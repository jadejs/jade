;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var process=require("__browserify_process");if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (typeof emitter._events[type] === 'function')
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

},{"__browserify_process":5}],2:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],3:[function(require,module,exports){
var process=require("__browserify_process");function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';

},{"__browserify_process":5}],4:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\u001b[' + styles[style][0] + 'm' + str +
             '\u001b[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && Object.prototype.toString.call(ar) === '[object Array]');
}


function isRegExp(re) {
  typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]';
}


function isDate(d) {
  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":1}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
module.exports = function(hljs){
  var IDENT_RE_RU = '[a-zA-Zа-яА-Я][a-zA-Z0-9_а-яА-Я]*';
  var OneS_KEYWORDS = 'возврат дата для если и или иначе иначеесли исключение конецесли ' +
    'конецпопытки конецпроцедуры конецфункции конеццикла константа не перейти перем ' +
    'перечисление по пока попытка прервать продолжить процедура строка тогда фс функция цикл ' +
    'число экспорт';
  var OneS_BUILT_IN = 'ansitooem oemtoansi ввестивидсубконто ввестидату ввестизначение ' +
    'ввестиперечисление ввестипериод ввестиплансчетов ввестистроку ввестичисло вопрос ' +
    'восстановитьзначение врег выбранныйплансчетов вызватьисключение датагод датамесяц ' +
    'датачисло добавитьмесяц завершитьработусистемы заголовоксистемы записьжурналарегистрации ' +
    'запуститьприложение зафиксироватьтранзакцию значениевстроку значениевстрокувнутр ' +
    'значениевфайл значениеизстроки значениеизстрокивнутр значениеизфайла имякомпьютера ' +
    'имяпользователя каталогвременныхфайлов каталогиб каталогпользователя каталогпрограммы ' +
    'кодсимв командасистемы конгода конецпериодаби конецрассчитанногопериодаби ' +
    'конецстандартногоинтервала конквартала конмесяца коннедели лев лог лог10 макс ' +
    'максимальноеколичествосубконто мин монопольныйрежим названиеинтерфейса названиенабораправ ' +
    'назначитьвид назначитьсчет найти найтипомеченныенаудаление найтиссылки началопериодаби ' +
    'началостандартногоинтервала начатьтранзакцию начгода начквартала начмесяца начнедели ' +
    'номерднягода номерднянедели номернеделигода нрег обработкаожидания окр описаниеошибки ' +
    'основнойжурналрасчетов основнойплансчетов основнойязык открытьформу открытьформумодально ' +
    'отменитьтранзакцию очиститьокносообщений периодстр полноеимяпользователя получитьвремята ' +
    'получитьдатута получитьдокументта получитьзначенияотбора получитьпозициюта ' +
    'получитьпустоезначение получитьта прав праводоступа предупреждение префиксавтонумерации ' +
    'пустаястрока пустоезначение рабочаядаттьпустоезначение рабочаядата разделительстраниц ' +
    'разделительстрок разм разобратьпозициюдокумента рассчитатьрегистрына ' +
    'рассчитатьрегистрыпо сигнал симв символтабуляции создатьобъект сокрл сокрлп сокрп ' +
    'сообщить состояние сохранитьзначение сред статусвозврата стрдлина стрзаменить ' +
    'стрколичествострок стрполучитьстроку  стрчисловхождений сформироватьпозициюдокумента ' +
    'счетпокоду текущаядата текущеевремя типзначения типзначениястр удалитьобъекты ' +
    'установитьтана установитьтапо фиксшаблон формат цел шаблон';
  var DQUOTE =  {className: 'dquote',  begin: '""'};
  var STR_START = {
      className: 'string',
      begin: '"', end: '"|$',
      contains: [DQUOTE],
      relevance: 0
    };
  var STR_CONT = {
    className: 'string',
    begin: '\\|', end: '"|$',
    contains: [DQUOTE]
  };

  return {
    case_insensitive: true,
    lexems: IDENT_RE_RU,
    keywords: {keyword: OneS_KEYWORDS, built_in: OneS_BUILT_IN},
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.NUMBER_MODE,
      STR_START, STR_CONT,
      {
        className: 'function',
        begin: '(процедура|функция)', end: '$',
        lexems: IDENT_RE_RU,
        keywords: 'процедура функция',
        contains: [
          {className: 'title', begin: IDENT_RE_RU},
          {
            className: 'tail',
            endsWithParent: true,
            contains: [
              {
                className: 'params',
                begin: '\\(', end: '\\)',
                lexems: IDENT_RE_RU,
                keywords: 'знач',
                contains: [STR_START, STR_CONT]
              },
              {
                className: 'export',
                begin: 'экспорт', endsWithParent: true,
                lexems: IDENT_RE_RU,
                keywords: 'экспорт',
                contains: [hljs.C_LINE_COMMENT_MODE]
              }
            ]
          },
          hljs.C_LINE_COMMENT_MODE
        ]
      },
      {className: 'preprocessor', begin: '#', end: '$'},
      {className: 'date', begin: '\'\\d{2}\\.\\d{2}\\.(\\d{2}|\\d{4})\''}
    ]
  };
};
},{}],7:[function(require,module,exports){
module.exports = function(hljs) {
  var IDENT_RE = '[a-zA-Z_$][a-zA-Z0-9_$]*';
  var IDENT_FUNC_RETURN_TYPE_RE = '([*]|[a-zA-Z_$][a-zA-Z0-9_$]*)';

  var AS3_REST_ARG_MODE = {
    className: 'rest_arg',
    begin: '[.]{3}', end: IDENT_RE,
    relevance: 10
  };
  var TITLE_MODE = {className: 'title', begin: IDENT_RE};

  return {
    keywords: {
      keyword: 'as break case catch class const continue default delete do dynamic each ' +
        'else extends final finally for function get if implements import in include ' +
        'instanceof interface internal is namespace native new override package private ' +
        'protected public return set static super switch this throw try typeof use var void ' +
        'while with',
      literal: 'true false null undefined'
    },
    contains: [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'package',
        beginWithKeyword: true, end: '{',
        keywords: 'package',
        contains: [TITLE_MODE]
      },
      {
        className: 'class',
        beginWithKeyword: true, end: '{',
        keywords: 'class interface',
        contains: [
          {
            beginWithKeyword: true,
            keywords: 'extends implements'
          },
          TITLE_MODE
        ]
      },
      {
        className: 'preprocessor',
        beginWithKeyword: true, end: ';',
        keywords: 'import include'
      },
      {
        className: 'function',
        beginWithKeyword: true, end: '[{;]',
        keywords: 'function',
        illegal: '\\S',
        contains: [
          TITLE_MODE,
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              AS3_REST_ARG_MODE
            ]
          },
          {
            className: 'type',
            begin: ':',
            end: IDENT_FUNC_RETURN_TYPE_RE,
            relevance: 10
          }
        ]
      }
    ]
  };
};
},{}],8:[function(require,module,exports){
module.exports = function(hljs) {
  var NUMBER = {className: 'number', begin: '[\\$%]\\d+'};
  return {
    case_insensitive: true,
    keywords: {
      keyword: 'acceptfilter acceptmutex acceptpathinfo accessfilename action addalt ' +
        'addaltbyencoding addaltbytype addcharset adddefaultcharset adddescription ' +
        'addencoding addhandler addicon addiconbyencoding addiconbytype addinputfilter ' +
        'addlanguage addmoduleinfo addoutputfilter addoutputfilterbytype addtype alias ' +
        'aliasmatch allow allowconnect allowencodedslashes allowoverride anonymous ' +
        'anonymous_logemail anonymous_mustgiveemail anonymous_nouserid anonymous_verifyemail ' +
        'authbasicauthoritative authbasicprovider authdbduserpwquery authdbduserrealmquery ' +
        'authdbmgroupfile authdbmtype authdbmuserfile authdefaultauthoritative ' +
        'authdigestalgorithm authdigestdomain authdigestnccheck authdigestnonceformat ' +
        'authdigestnoncelifetime authdigestprovider authdigestqop authdigestshmemsize ' +
        'authgroupfile authldapbinddn authldapbindpassword authldapcharsetconfig ' +
        'authldapcomparednonserver authldapdereferencealiases authldapgroupattribute ' +
        'authldapgroupattributeisdn authldapremoteuserattribute authldapremoteuserisdn ' +
        'authldapurl authname authnprovideralias authtype authuserfile authzdbmauthoritative ' +
        'authzdbmtype authzdefaultauthoritative authzgroupfileauthoritative ' +
        'authzldapauthoritative authzownerauthoritative authzuserauthoritative ' +
        'balancermember browsermatch browsermatchnocase bufferedlogs cachedefaultexpire ' +
        'cachedirlength cachedirlevels cachedisable cacheenable cachefile ' +
        'cacheignorecachecontrol cacheignoreheaders cacheignorenolastmod ' +
        'cacheignorequerystring cachelastmodifiedfactor cachemaxexpire cachemaxfilesize ' +
        'cacheminfilesize cachenegotiateddocs cacheroot cachestorenostore cachestoreprivate ' +
        'cgimapextension charsetdefault charsetoptions charsetsourceenc checkcaseonly ' +
        'checkspelling chrootdir contentdigest cookiedomain cookieexpires cookielog ' +
        'cookiename cookiestyle cookietracking coredumpdirectory customlog dav ' +
        'davdepthinfinity davgenericlockdb davlockdb davmintimeout dbdexptime dbdkeep ' +
        'dbdmax dbdmin dbdparams dbdpersist dbdpreparesql dbdriver defaulticon ' +
        'defaultlanguage defaulttype deflatebuffersize deflatecompressionlevel ' +
        'deflatefilternote deflatememlevel deflatewindowsize deny directoryindex ' +
        'directorymatch directoryslash documentroot dumpioinput dumpiologlevel dumpiooutput ' +
        'enableexceptionhook enablemmap enablesendfile errordocument errorlog example ' +
        'expiresactive expiresbytype expiresdefault extendedstatus extfilterdefine ' +
        'extfilteroptions fileetag filterchain filterdeclare filterprotocol filterprovider ' +
        'filtertrace forcelanguagepriority forcetype forensiclog gracefulshutdowntimeout ' +
        'group header headername hostnamelookups identitycheck identitychecktimeout ' +
        'imapbase imapdefault imapmenu include indexheadinsert indexignore indexoptions ' +
        'indexorderdefault indexstylesheet isapiappendlogtoerrors isapiappendlogtoquery ' +
        'isapicachefile isapifakeasync isapilognotsupported isapireadaheadbuffer keepalive ' +
        'keepalivetimeout languagepriority ldapcacheentries ldapcachettl ' +
        'ldapconnectiontimeout ldapopcacheentries ldapopcachettl ldapsharedcachefile ' +
        'ldapsharedcachesize ldaptrustedclientcert ldaptrustedglobalcert ldaptrustedmode ' +
        'ldapverifyservercert limitinternalrecursion limitrequestbody limitrequestfields ' +
        'limitrequestfieldsize limitrequestline limitxmlrequestbody listen listenbacklog ' +
        'loadfile loadmodule lockfile logformat loglevel maxclients maxkeepaliverequests ' +
        'maxmemfree maxrequestsperchild maxrequestsperthread maxspareservers maxsparethreads ' +
        'maxthreads mcachemaxobjectcount mcachemaxobjectsize mcachemaxstreamingbuffer ' +
        'mcacheminobjectsize mcacheremovalalgorithm mcachesize metadir metafiles metasuffix ' +
        'mimemagicfile minspareservers minsparethreads mmapfile mod_gzip_on ' +
        'mod_gzip_add_header_count mod_gzip_keep_workfiles mod_gzip_dechunk ' +
        'mod_gzip_min_http mod_gzip_minimum_file_size mod_gzip_maximum_file_size ' +
        'mod_gzip_maximum_inmem_size mod_gzip_temp_dir mod_gzip_item_include ' +
        'mod_gzip_item_exclude mod_gzip_command_version mod_gzip_can_negotiate ' +
        'mod_gzip_handle_methods mod_gzip_static_suffix mod_gzip_send_vary ' +
        'mod_gzip_update_static modmimeusepathinfo multiviewsmatch namevirtualhost noproxy ' +
        'nwssltrustedcerts nwsslupgradeable options order passenv pidfile protocolecho ' +
        'proxybadheader proxyblock proxydomain proxyerroroverride proxyftpdircharset ' +
        'proxyiobuffersize proxymaxforwards proxypass proxypassinterpolateenv ' +
        'proxypassmatch proxypassreverse proxypassreversecookiedomain ' +
        'proxypassreversecookiepath proxypreservehost proxyreceivebuffersize proxyremote ' +
        'proxyremotematch proxyrequests proxyset proxystatus proxytimeout proxyvia ' +
        'readmename receivebuffersize redirect redirectmatch redirectpermanent ' +
        'redirecttemp removecharset removeencoding removehandler removeinputfilter ' +
        'removelanguage removeoutputfilter removetype requestheader require rewritebase ' +
        'rewritecond rewriteengine rewritelock rewritelog rewriteloglevel rewritemap ' +
        'rewriteoptions rewriterule rlimitcpu rlimitmem rlimitnproc satisfy scoreboardfile ' +
        'script scriptalias scriptaliasmatch scriptinterpretersource scriptlog ' +
        'scriptlogbuffer scriptloglength scriptsock securelisten seerequesttail ' +
        'sendbuffersize serveradmin serveralias serverlimit servername serverpath ' +
        'serverroot serversignature servertokens setenv setenvif setenvifnocase sethandler ' +
        'setinputfilter setoutputfilter ssienableaccess ssiendtag ssierrormsg ssistarttag ' +
        'ssitimeformat ssiundefinedecho sslcacertificatefile sslcacertificatepath ' +
        'sslcadnrequestfile sslcadnrequestpath sslcarevocationfile sslcarevocationpath ' +
        'sslcertificatechainfile sslcertificatefile sslcertificatekeyfile sslciphersuite ' +
        'sslcryptodevice sslengine sslhonorciperorder sslmutex ssloptions ' +
        'sslpassphrasedialog sslprotocol sslproxycacertificatefile ' +
        'sslproxycacertificatepath sslproxycarevocationfile sslproxycarevocationpath ' +
        'sslproxyciphersuite sslproxyengine sslproxymachinecertificatefile ' +
        'sslproxymachinecertificatepath sslproxyprotocol sslproxyverify ' +
        'sslproxyverifydepth sslrandomseed sslrequire sslrequiressl sslsessioncache ' +
        'sslsessioncachetimeout sslusername sslverifyclient sslverifydepth startservers ' +
        'startthreads substitute suexecusergroup threadlimit threadsperchild ' +
        'threadstacksize timeout traceenable transferlog typesconfig unsetenv ' +
        'usecanonicalname usecanonicalphysicalport user userdir virtualdocumentroot ' +
        'virtualdocumentrootip virtualscriptalias virtualscriptaliasip ' +
        'win32disableacceptex xbithack',
      literal: 'on off'
    },
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        className: 'sqbracket',
        begin: '\\s\\[', end: '\\]$'
      },
      {
        className: 'cbracket',
        begin: '[\\$%]\\{', end: '\\}',
        contains: ['self', NUMBER]
      },
      NUMBER,
      {className: 'tag', begin: '</?', end: '>'},
      hljs.QUOTE_STRING_MODE
    ]
  };
};
},{}],9:[function(require,module,exports){
module.exports = function(hljs) {
  var STRING = hljs.inherit(hljs.QUOTE_STRING_MODE, {illegal: ''});
  var TITLE = {
    className: 'title', begin: hljs.UNDERSCORE_IDENT_RE
  };
  var PARAMS = {
    className: 'params',
    begin: '\\(', end: '\\)',
    contains: ['self', hljs.C_NUMBER_MODE, STRING]
  };
  var COMMENTS = [
    {
      className: 'comment',
      begin: '--', end: '$',
    },
    {
      className: 'comment',
      begin: '\\(\\*', end: '\\*\\)',
      contains: ['self', {begin: '--', end: '$'}] //allow nesting
    },
    hljs.HASH_COMMENT_MODE
  ];

  return {
    keywords: {
      keyword:
        'about above after against and around as at back before beginning ' +
        'behind below beneath beside between but by considering ' +
        'contain contains continue copy div does eighth else end equal ' +
        'equals error every exit fifth first for fourth from front ' +
        'get given global if ignoring in into is it its last local me ' +
        'middle mod my ninth not of on onto or over prop property put ref ' +
        'reference repeat returning script second set seventh since ' +
        'sixth some tell tenth that the then third through thru ' +
        'timeout times to transaction try until where while whose with ' +
        'without',
      constant:
        'AppleScript false linefeed return pi quote result space tab true',
      type:
        'alias application boolean class constant date file integer list ' +
        'number real record string text',
      command:
        'activate beep count delay launch log offset read round ' +
        'run say summarize write',
      property:
        'character characters contents day frontmost id item length ' +
        'month name paragraph paragraphs rest reverse running time version ' +
        'weekday word words year'
    },
    contains: [
      STRING,
      hljs.C_NUMBER_MODE,
      {
        className: 'type',
        begin: '\\bPOSIX file\\b'
      },
      {
        className: 'command',
        begin:
          '\\b(clipboard info|the clipboard|info for|list (disks|folder)|' +
          'mount volume|path to|(close|open for) access|(get|set) eof|' +
          'current date|do shell script|get volume settings|random number|' +
          'set volume|system attribute|system info|time to GMT|' +
          '(load|run|store) script|scripting components|' +
          'ASCII (character|number)|localized string|' +
          'choose (application|color|file|file name|' +
          'folder|from list|remote application|URL)|' +
          'display (alert|dialog))\\b|^\\s*return\\b'
      },
      {
        className: 'constant',
        begin:
          '\\b(text item delimiters|current application|missing value)\\b'
      },
      {
        className: 'keyword',
        begin:
          '\\b(apart from|aside from|instead of|out of|greater than|' +
          "isn't|(doesn't|does not) (equal|come before|come after|contain)|" +
          '(greater|less) than( or equal)?|(starts?|ends|begins?) with|' +
          'contained by|comes (before|after)|a (ref|reference))\\b'
      },
      {
        className: 'property',
        begin:
          '\\b(POSIX path|(date|time) string|quoted form)\\b'
      },
      {
        className: 'function_start',
        beginWithKeyword: true,
        keywords: 'on',
        illegal: '[${=;\\n]',
        contains: [TITLE, PARAMS]
      }
    ].concat(COMMENTS)
  };
};
},{}],10:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    keywords: {
      keyword:
        /* mnemonic */
        'adc add adiw and andi asr bclr bld brbc brbs brcc brcs break breq brge brhc brhs ' +
        'brid brie brlo brlt brmi brne brpl brsh brtc brts brvc brvs bset bst call cbi cbr ' +
        'clc clh cli cln clr cls clt clv clz com cp cpc cpi cpse dec eicall eijmp elpm eor ' +
        'fmul fmuls fmulsu icall ijmp in inc jmp ld ldd ldi lds lpm lsl lsr mov movw mul ' +
        'muls mulsu neg nop or ori out pop push rcall ret reti rjmp rol ror sbc sbr sbrc sbrs ' +
        'sec seh sbi sbci sbic sbis sbiw sei sen ser ses set sev sez sleep spm st std sts sub ' +
        'subi swap tst wdr',
      built_in:
        /* general purpose registers */
        'r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 ' +
        'r23 r24 r25 r26 r27 r28 r29 r30 r31 x|0 xh xl y|0 yh yl z|0 zh zl ' +
        /* IO Registers (ATMega128) */
        'ucsr1c udr1 ucsr1a ucsr1b ubrr1l ubrr1h ucsr0c ubrr0h tccr3c tccr3a tccr3b tcnt3h ' +
        'tcnt3l ocr3ah ocr3al ocr3bh ocr3bl ocr3ch ocr3cl icr3h icr3l etimsk etifr tccr1c ' +
        'ocr1ch ocr1cl twcr twdr twar twsr twbr osccal xmcra xmcrb eicra spmcsr spmcr portg ' +
        'ddrg ping portf ddrf sreg sph spl xdiv rampz eicrb eimsk gimsk gicr eifr gifr timsk ' +
        'tifr mcucr mcucsr tccr0 tcnt0 ocr0 assr tccr1a tccr1b tcnt1h tcnt1l ocr1ah ocr1al ' +
        'ocr1bh ocr1bl icr1h icr1l tccr2 tcnt2 ocr2 ocdr wdtcr sfior eearh eearl eedr eecr ' +
        'porta ddra pina portb ddrb pinb portc ddrc pinc portd ddrd pind spdr spsr spcr udr0 ' +
        'ucsr0a ucsr0b ubrr0l acsr admux adcsr adch adcl porte ddre pine pinf'
    },
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,
      {className: 'comment', begin: ';',  end: '$'},
      hljs.C_NUMBER_MODE, // 0x..., decimal, float
      hljs.BINARY_NUMBER_MODE, // 0b...
      {
        className: 'number',
        begin: '\\b(\\$[a-zA-Z0-9]+|0o[0-7]+)' // $..., 0o...
      },
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: '\'', end: '[^\\\\]\'',
        illegal: '[^\\\\][^\']'
      },
      {className: 'label',  begin: '^[A-Za-z0-9_.$]+:'},
      {className: 'preprocessor', begin: '#', end: '$'},
      {  // директивы «.include» «.macro» и т.д.
        className: 'preprocessor',
        begin: '\\.[a-zA-Z]+'
      },
      {  // подстановка в «.macro»
        className: 'localvars',
        begin: '@[0-9]+'
      }
    ]
  };
};
},{}],11:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: 'false int abstract private char interface boolean static null if for true ' +
      'while long throw finally protected extends final implements return void enum else ' +
      'break new catch byte super class case short default double public try this switch ' +
      'continue reverse firstfast firstonly forupdate nofetch sum avg minof maxof count ' +
      'order group by asc desc index hint like dispaly edit client server ttsbegin ' +
      'ttscommit str real date container anytype common div mod',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'preprocessor',
        begin: '#', end: '$'
      },
      {
        className: 'class',
        beginWithKeyword: true, end: '{',
        illegal: ':',
        keywords: 'class interface',
        contains: [
          {
            className: 'inheritance',
            beginWithKeyword: true,
            keywords: 'extends implements',
            relevance: 10
          },
          {
            className: 'title',
            begin: hljs.UNDERSCORE_IDENT_RE
          }
        ]
      }
    ]
  };
};
},{}],12:[function(require,module,exports){
module.exports = function(hljs) {
  var BASH_LITERAL = 'true false';
  var BASH_KEYWORD = 'if then else elif fi for break continue while in do done echo exit return set declare';
  var VAR1 = {
    className: 'variable', begin: '\\$[a-zA-Z0-9_#]+'
  };
  var VAR2 = {
    className: 'variable', begin: '\\${([^}]|\\\\})+}'
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE, VAR1, VAR2],
    relevance: 0
  };
  var APOS_STRING = {
    className: 'string',
    begin: '\'', end: '\'',
    contains: [{begin: '\'\''}],
    relevance: 0
  };
  var TEST_CONDITION = {
    className: 'test_condition',
    begin: '', end: '',
    contains: [QUOTE_STRING, APOS_STRING, VAR1, VAR2],
    keywords: {
      literal: BASH_LITERAL
    },
    relevance: 0
  };

  return {
    keywords: {
      keyword: BASH_KEYWORD,
      literal: BASH_LITERAL
    },
    contains: [
      {
        className: 'shebang',
        begin: '(#!\\/bin\\/bash)|(#!\\/bin\\/sh)',
        relevance: 10
      },
      VAR1,
      VAR2,
      hljs.HASH_COMMENT_MODE,
      QUOTE_STRING,
      APOS_STRING,
      hljs.inherit(TEST_CONDITION, {begin: '\\[ ', end: ' \\]', relevance: 0}),
      hljs.inherit(TEST_CONDITION, {begin: '\\[\\[ ', end: ' \\]\\]'})
    ]
  };
};
},{}],13:[function(require,module,exports){
module.exports = function(hljs){
  return {
    contains: [
      {
        className: 'comment',
        begin: '[^\\[\\]\\.,\\+\\-<> \r\n]',
        excludeEnd: true,
        end: '[\\[\\]\\.,\\+\\-<> \r\n]',
        relevance: 0
      },
      {
        className: 'title',
        begin: '[\\[\\]]',
        relevance: 0
      },
      {
        className: 'string',
        begin: '[\\.,]'
      },
      {
        className: 'literal',
        begin: '[\\+\\-]'
      }
    ]
  };
};
},{}],14:[function(require,module,exports){
module.exports = function(hljs) {
  var keywords = {
    built_in:
      // Clojure keywords
      'def cond apply if-not if-let if not not= = &lt; < > &lt;= <= >= == + / * - rem '+
      'quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? '+
      'set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? '+
      'class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? '+
      'string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . '+
      'inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last '+
      'drop-while while intern condp case reduced cycle split-at split-with repeat replicate '+
      'iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext '+
      'nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends '+
      'add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler '+
      'set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter '+
      'monitor-exit defmacro defn defn- macroexpand macroexpand-1 for doseq dosync dotimes and or '+
      'when when-not when-let comp juxt partial sequence memoize constantly complement identity assert '+
      'peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast '+
      'sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import '+
      'intern refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! '+
      'assoc! dissoc! pop! disj! import use class type num float double short byte boolean bigint biginteger '+
      'bigdec print-method print-dup throw-if throw printf format load compile get-in update-in pr pr-on newline '+
      'flush read slurp read-line subvec with-open memfn time ns assert re-find re-groups rand-int rand mod locking '+
      'assert-valid-fdecl alias namespace resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! '+
      'reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! '+
      'new next conj set! memfn to-array future future-call into-array aset gen-class reduce merge map filter find empty '+
      'hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list '+
      'disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer '+
      'chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate '+
      'unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta '+
      'lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize'
   };

  var CLJ_IDENT_RE = '[a-zA-Z_0-9\\!\\.\\?\\-\\+\\*\\/\\<\\=\\>\\&\\#\\$\';]+';
  var SIMPLE_NUMBER_RE = '[\\s:\\(\\{]+\\d+(\\.\\d+)?';

  var NUMBER = {
    className: 'number', begin: SIMPLE_NUMBER_RE,
    relevance: 0
  };
  var STRING = {
    className: 'string',
    begin: '"', end: '"',
    contains: [hljs.BACKSLASH_ESCAPE],
    relevance: 0
  };
  var COMMENT = {
    className: 'comment',
    begin: ';', end: '$',
    relevance: 0
  };
  var COLLECTION = {
    className: 'collection',
    begin: '[\\[\\{]', end: '[\\]\\}]'
  };
  var HINT = {
    className: 'comment',
    begin: '\\^' + CLJ_IDENT_RE
  };
  var HINT_COL = {
    className: 'comment',
    begin: '\\^\\{', end: '\\}'
  };
  var KEY = {
    className: 'attribute',
    begin: '[:]' + CLJ_IDENT_RE
  };
  var LIST = {
    className: 'list',
    begin: '\\(', end: '\\)',
    relevance: 0
  };
  var BODY = {
    endsWithParent: true, excludeEnd: true,
    keywords: {literal: 'true false nil'},
    relevance: 0
  };
  var TITLE = {
    keywords: keywords,
    lexems: CLJ_IDENT_RE,
    className: 'title', begin: CLJ_IDENT_RE,
    starts: BODY
  };

  LIST.contains = [{className: 'comment', begin: 'comment'}, TITLE];
  BODY.contains = [LIST, STRING, HINT, HINT_COL, COMMENT, KEY, COLLECTION, NUMBER];
  COLLECTION.contains = [LIST, STRING, HINT, COMMENT, KEY, COLLECTION, NUMBER];

  return {
    illegal: '\\S',
    contains: [
      COMMENT,
      LIST
    ]
  }
};
},{}],15:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    keywords: 'add_custom_command add_custom_target add_definitions add_dependencies ' +
      'add_executable add_library add_subdirectory add_test aux_source_directory ' +
      'break build_command cmake_minimum_required cmake_policy configure_file ' +
      'create_test_sourcelist define_property else elseif enable_language enable_testing ' +
      'endforeach endfunction endif endmacro endwhile execute_process export find_file ' +
      'find_library find_package find_path find_program fltk_wrap_ui foreach function ' +
      'get_cmake_property get_directory_property get_filename_component get_property ' +
      'get_source_file_property get_target_property get_test_property if include ' +
      'include_directories include_external_msproject include_regular_expression install ' +
      'link_directories load_cache load_command macro mark_as_advanced message option ' +
      'output_required_files project qt_wrap_cpp qt_wrap_ui remove_definitions return ' +
      'separate_arguments set set_directory_properties set_property ' +
      'set_source_files_properties set_target_properties set_tests_properties site_name ' +
      'source_group string target_link_libraries try_compile try_run unset variable_watch ' +
      'while build_name exec_program export_library_dependencies install_files ' +
      'install_programs install_targets link_libraries make_directory remove subdir_depends ' +
      'subdirs use_mangled_mesa utility_source variable_requires write_file',
    contains: [
      {
        className: 'envvar',
        begin: '\\${', end: '}'
      },
      hljs.HASH_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.NUMBER_MODE
    ]
  };
};
},{}],16:[function(require,module,exports){
module.exports = function(hljs) {
  var KEYWORDS = {
    keyword:
      // JS keywords
      'in if for while finally new do return else break catch instanceof throw try this ' +
      'switch continue typeof delete debugger super ' +
      // Coffee keywords
      'then unless until loop of by when and or is isnt not',
    literal:
      // JS literals
      'true false null undefined ' +
      // Coffee literals
      'yes no on off ',
    reserved: 'case default function var void with const let enum export import native ' +
      '__hasProp __extends __slice __bind __indexOf'
  };
  var JS_IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var TITLE = {className: 'title', begin: JS_IDENT_RE};
  var SUBST = {
    className: 'subst',
    begin: '#\\{', end: '}',
    keywords: KEYWORDS,
    contains: [hljs.BINARY_NUMBER_MODE, hljs.C_NUMBER_MODE]
  };

  return {
    keywords: KEYWORDS,
    contains: [
      // Numbers
      hljs.BINARY_NUMBER_MODE,
      hljs.C_NUMBER_MODE,
      // Strings
      hljs.APOS_STRING_MODE,
      {
        className: 'string',
        begin: '"""', end: '"""',
        contains: [hljs.BACKSLASH_ESCAPE, SUBST]
      },
      {
        className: 'string',
        begin: '"', end: '"',
        contains: [hljs.BACKSLASH_ESCAPE, SUBST],
        relevance: 0
      },
      // Comments
      {
        className: 'comment',
        begin: '###', end: '###'
      },
      hljs.HASH_COMMENT_MODE,
      {
        className: 'regexp',
        begin: '///', end: '///',
        contains: [hljs.HASH_COMMENT_MODE]
      },
      {
        className: 'regexp', begin: '//[gim]*'
      },
      {
        className: 'regexp',
        begin: '/\\S(\\\\.|[^\\n])*/[gim]*' // \S is required to parse x / 2 / 3 as two divisions
      },
      {
        begin: '`', end: '`',
        excludeBegin: true, excludeEnd: true,
        subLanguage: 'javascript'
      },
      {
        className: 'function',
        begin: JS_IDENT_RE + '\\s*=\\s*(\\(.+\\))?\\s*[-=]>',
        returnBegin: true,
        contains: [
          TITLE,
          {
            className: 'params',
            begin: '\\(', end: '\\)'
          }
        ]
      },
      {
        className: 'class',
        beginWithKeyword: true, keywords: 'class',
        end: '$',
        illegal: ':',
        contains: [
          {
            beginWithKeyword: true, keywords: 'extends',
            endsWithParent: true,
            illegal: ':',
            contains: [TITLE]
          },
          TITLE
        ]
      },
      {
        className: 'property',
        begin: '@' + JS_IDENT_RE
      }
    ]
  };
};
},{}],17:[function(require,module,exports){
module.exports = function(hljs) {
  var CPP_KEYWORDS = {
    keyword: 'false int float while private char catch export virtual operator sizeof ' +
      'dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace ' +
      'unsigned long throw volatile static protected bool template mutable if public friend ' +
      'do return goto auto void enum else break new extern using true class asm case typeid ' +
      'short reinterpret_cast|10 default double register explicit signed typename try this ' +
      'switch continue wchar_t inline delete alignof char16_t char32_t constexpr decltype ' +
      'noexcept nullptr static_assert thread_local restrict _Bool complex',
    built_in: 'std string cin cout cerr clog stringstream istringstream ostringstream ' +
      'auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set ' +
      'unordered_map unordered_multiset unordered_multimap array shared_ptr'
  };
  return {
    keywords: CPP_KEYWORDS,
    illegal: '</',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: '\'\\\\?.', end: '\'',
        illegal: '.'
      },
      {
        className: 'number',
        begin: '\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)'
      },
      hljs.C_NUMBER_MODE,
      {
        className: 'preprocessor',
        begin: '#', end: '$'
      },
      {
        className: 'stl_container',
        begin: '\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<', end: '>',
        keywords: CPP_KEYWORDS,
        relevance: 10,
        contains: ['self']
      }
    ]
  };
};
},{}],18:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords:
      // Normal keywords.
      'abstract as base bool break byte case catch char checked class const continue decimal ' +
      'default delegate do double else enum event explicit extern false finally fixed float ' +
      'for foreach goto if implicit in int interface internal is lock long namespace new null ' +
      'object operator out override params private protected public readonly ref return sbyte ' +
      'sealed short sizeof stackalloc static string struct switch this throw true try typeof ' +
      'uint ulong unchecked unsafe ushort using virtual volatile void while ' +
      // Contextual keywords.
      'ascending descending from get group into join let orderby partial select set value var '+
      'where yield',
    contains: [
      {
        className: 'comment',
        begin: '///', end: '$', returnBegin: true,
        contains: [
          {
            className: 'xmlDocTag',
            begin: '///|<!--|-->'
          },
          {
            className: 'xmlDocTag',
            begin: '</?', end: '>'
          }
        ]
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'preprocessor',
        begin: '#', end: '$',
        keywords: 'if else elif endif define undef warning error line region endregion pragma checksum'
      },
      {
        className: 'string',
        begin: '@"', end: '"',
        contains: [{begin: '""'}]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.C_NUMBER_MODE
    ]
  };
};
},{}],19:[function(require,module,exports){
module.exports = function(hljs) {
  var FUNCTION = {
    className: 'function',
    begin: hljs.IDENT_RE + '\\(', end: '\\)',
    contains: [hljs.NUMBER_MODE, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
  };
  return {
    case_insensitive: true,
    illegal: '[=/|\']',
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'id', begin: '\\#[A-Za-z0-9_-]+'
      },
      {
        className: 'class', begin: '\\.[A-Za-z0-9_-]+',
        relevance: 0
      },
      {
        className: 'attr_selector',
        begin: '\\[', end: '\\]',
        illegal: '$'
      },
      {
        className: 'pseudo',
        begin: ':(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\"\\\']+'
      },
      {
        className: 'at_rule',
        begin: '@(font-face|page)',
        lexems: '[a-z-]+',
        keywords: 'font-face page'
      },
      {
        className: 'at_rule',
        begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
                                 // because it doesn’t let it to be parsed as
                                 // a rule set but instead drops parser into
                                 // the default mode which is how it should be.
        excludeEnd: true,
        keywords: 'import page media charset',
        contains: [
          FUNCTION,
          hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE
        ]
      },
      {
        className: 'tag', begin: hljs.IDENT_RE,
        relevance: 0
      },
      {
        className: 'rules',
        begin: '{', end: '}',
        illegal: '[^\\s]',
        relevance: 0,
        contains: [
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: 'rule',
            begin: '[^\\s]', returnBegin: true, end: ';', endsWithParent: true,
            contains: [
              {
                className: 'attribute',
                begin: '[A-Z\\_\\.\\-]+', end: ':',
                excludeEnd: true,
                illegal: '[^\\s]',
                starts: {
                  className: 'value',
                  endsWithParent: true, excludeEnd: true,
                  contains: [
                    FUNCTION,
                    hljs.NUMBER_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.APOS_STRING_MODE,
                    hljs.C_BLOCK_COMMENT_MODE,
                    {
                      className: 'hexcolor', begin: '\\#[0-9A-F]+'
                    },
                    {
                      className: 'important', begin: '!important'
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    ]
  };
};
},{}],20:[function(require,module,exports){
module.exports = /**
 * Known issues:
 *
 * - invalid hex string literals will be recognized as a double quoted strings
 *   but 'x' at the beginning of string will not be matched
 *
 * - delimited string literals are not checked for matching end delimiter
 *   (not possible to do with js regexp)
 *
 * - content of token string is colored as a string (i.e. no keyword coloring inside a token string)
 *   also, content of token string is not validated to contain only valid D tokens
 *
 * - special token sequence rule is not strictly following D grammar (anything following #line
 *   up to the end of line is matched as special token sequence)
 */

function(hljs) {

	/**
	 * Language keywords
	 *
	 * @type {Object}
	 */
	var D_KEYWORDS = {
		keyword:
			'abstract alias align asm assert auto body break byte case cast catch class ' +
			'const continue debug default delete deprecated do else enum export extern final ' +
			'finally for foreach foreach_reverse|10 goto if immutable import in inout int ' +
			'interface invariant is lazy macro mixin module new nothrow out override package ' +
			'pragma private protected public pure ref return scope shared static struct ' +
			'super switch synchronized template this throw try typedef typeid typeof union ' +
			'unittest version void volatile while with __FILE__ __LINE__ __gshared|10 ' +
			'__thread __traits __DATE__ __EOF__ __TIME__ __TIMESTAMP__ __VENDOR__ __VERSION__',
		built_in:
			'bool cdouble cent cfloat char creal dchar delegate double dstring float function ' +
			'idouble ifloat ireal long real short string ubyte ucent uint ulong ushort wchar ' +
			'wstring',
		literal:
			'false null true'
	};

	/**
	 * Number literal regexps
	 *
	 * @type {String}
	 */
	var decimal_integer_re = '(0|[1-9][\\d_]*)',
		decimal_integer_nosus_re = '(0|[1-9][\\d_]*|\\d[\\d_]*|[\\d_]+?\\d)',
		binary_integer_re = '0[bB][01_]+',
		hexadecimal_digits_re = '([\\da-fA-F][\\da-fA-F_]*|_[\\da-fA-F][\\da-fA-F_]*)',
		hexadecimal_integer_re = '0[xX]' + hexadecimal_digits_re,

		decimal_exponent_re = '([eE][+-]?' + decimal_integer_nosus_re + ')',
		decimal_float_re = '(' + decimal_integer_nosus_re + '(\\.\\d*|' + decimal_exponent_re + ')|' +
								'\\d+\\.' + decimal_integer_nosus_re + decimal_integer_nosus_re + '|' +
								'\\.' + decimal_integer_re + decimal_exponent_re + '?' +
							')',
		hexadecimal_float_re = '(0[xX](' +
									hexadecimal_digits_re + '\\.' + hexadecimal_digits_re + '|'+
									'\\.?' + hexadecimal_digits_re +
							   ')[pP][+-]?' + decimal_integer_nosus_re + ')',

		integer_re = '(' +
			decimal_integer_re + '|' +
			binary_integer_re  + '|' +
		 	hexadecimal_integer_re   +
		')',

		float_re = '(' +
			hexadecimal_float_re + '|' +
			decimal_float_re  +
		')';

	/**
	 * Escape sequence supported in D string and character literals
	 *
	 * @type {String}
	 */
	var escape_sequence_re = '\\\\(' +
							'[\'"\\?\\\\abfnrtv]|' +	// common escapes
							'u[\\dA-Fa-f]{4}|' + 		// four hex digit unicode codepoint
							'[0-7]{1,3}|' + 			// one to three octal digit ascii char code
							'x[\\dA-Fa-f]{2}|' +		// two hex digit ascii char code
							'U[\\dA-Fa-f]{8}' +			// eight hex digit unicode codepoint
						  ')|' +
						  '&[a-zA-Z\\d]{2,};';			// named character entity


	/**
	 * D integer number literals
	 *
	 * @type {Object}
	 */
	var D_INTEGER_MODE = {
		className: 'number',
    	begin: '\\b' + integer_re + '(L|u|U|Lu|LU|uL|UL)?',
    	relevance: 0
	};

	/**
	 * [D_FLOAT_MODE description]
	 * @type {Object}
	 */
	var D_FLOAT_MODE = {
		className: 'number',
		begin: '\\b(' +
				float_re + '([fF]|L|i|[fF]i|Li)?|' +
				integer_re + '(i|[fF]i|Li)' +
			')',
		relevance: 0
	};

	/**
	 * D character literal
	 *
	 * @type {Object}
	 */
	var D_CHARACTER_MODE = {
		className: 'string',
		begin: '\'(' + escape_sequence_re + '|.)', end: '\'',
		illegal: '.'
	};

	/**
	 * D string escape sequence
	 *
	 * @type {Object}
	 */
	var D_ESCAPE_SEQUENCE = {
		begin: escape_sequence_re,
		relevance: 0
	}

	/**
	 * D double quoted string literal
	 *
	 * @type {Object}
	 */
	var D_STRING_MODE = {
		className: 'string',
		begin: '"',
		contains: [D_ESCAPE_SEQUENCE],
		end: '"[cwd]?',
		relevance: 0
	};

	/**
	 * D wysiwyg and delimited string literals
	 *
	 * @type {Object}
	 */
	var D_WYSIWYG_DELIMITED_STRING_MODE = {
		className: 'string',
		begin: '[rq]"',
		end: '"[cwd]?',
		relevance: 5
	};

	/**
	 * D alternate wysiwyg string literal
	 *
	 * @type {Object}
	 */
	var D_ALTERNATE_WYSIWYG_STRING_MODE = {
		className: 'string',
		begin: '`',
		end: '`[cwd]?'
	};

	/**
	 * D hexadecimal string literal
	 *
	 * @type {Object}
	 */
	var D_HEX_STRING_MODE = {
		className: 'string',
		begin: 'x"[\\da-fA-F\\s\\n\\r]*"[cwd]?',
		relevance: 10
	};

	/**
	 * D delimited string literal
	 *
	 * @type {Object}
	 */
	var D_TOKEN_STRING_MODE = {
		className: 'string',
		begin: 'q"\\{',
		end: '\\}"'
	};

	/**
	 * Hashbang support
	 *
	 * @type {Object}
	 */
	var D_HASHBANG_MODE = {
		className: 'shebang',
		begin: '^#!',
		end: '$',
		relevance: 5
	};

	/**
	 * D special token sequence
	 *
	 * @type {Object}
	 */
	var D_SPECIAL_TOKEN_SEQUENCE_MODE = {
		className: 'preprocessor',
		begin: '#(line)',
		end: '$',
		relevance: 5
	};

	/**
	 * D attributes
	 *
	 * @type {Object}
	 */
	var D_ATTRIBUTE_MODE = {
		className: 'keyword',
		begin: '@[a-zA-Z_][a-zA-Z_\\d]*'
	};

	/**
	 * D nesting comment
	 *
	 * @type {Object}
	 */
	var D_NESTING_COMMENT_MODE = {
		className: 'comment',
		begin: '\\/\\+',
		contains: ['self'],
		end: '\\+\\/',
		relevance: 10
	}

	return {
		lexems: hljs.UNDERSCORE_IDENT_RE,
		keywords: D_KEYWORDS,
		contains: [
			hljs.C_LINE_COMMENT_MODE,
  			hljs.C_BLOCK_COMMENT_MODE,
  			D_NESTING_COMMENT_MODE,
  			D_HEX_STRING_MODE,
  			D_STRING_MODE,
  			D_WYSIWYG_DELIMITED_STRING_MODE,
  			D_ALTERNATE_WYSIWYG_STRING_MODE,
  			D_TOKEN_STRING_MODE,
  			D_FLOAT_MODE,
  			D_INTEGER_MODE,
  			D_CHARACTER_MODE,
  			D_HASHBANG_MODE,
  			D_SPECIAL_TOKEN_SEQUENCE_MODE,
  			D_ATTRIBUTE_MODE
		]
	};
};
},{}],21:[function(require,module,exports){
module.exports = function(hljs) {
  var DELPHI_KEYWORDS = 'and safecall cdecl then string exports library not pascal set ' +
    'virtual file in array label packed end. index while const raise for to implementation ' +
    'with except overload destructor downto finally program exit unit inherited override if ' +
    'type until function do begin repeat goto nil far initialization object else var uses ' +
    'external resourcestring interface end finalization class asm mod case on shr shl of ' +
    'register xorwrite threadvar try record near stored constructor stdcall inline div out or ' +
    'procedure';
  var DELPHI_CLASS_KEYWORDS = 'safecall stdcall pascal stored const implementation ' +
    'finalization except to finally program inherited override then exports string read not ' +
    'mod shr try div shl set library message packed index for near overload label downto exit ' +
    'public goto interface asm on of constructor or private array unit raise destructor var ' +
    'type until function else external with case default record while protected property ' +
    'procedure published and cdecl do threadvar file in if end virtual write far out begin ' +
    'repeat nil initialization object uses resourcestring class register xorwrite inline static';
  var CURLY_COMMENT =  {
    className: 'comment',
    begin: '{', end: '}',
    relevance: 0
  };
  var PAREN_COMMENT = {
    className: 'comment',
    begin: '\\(\\*', end: '\\*\\)',
    relevance: 10
  };
  var STRING = {
    className: 'string',
    begin: '\'', end: '\'',
    contains: [{begin: '\'\''}],
    relevance: 0
  };
  var CHAR_STRING = {
    className: 'string', begin: '(#\\d+)+'
  };
  var FUNCTION = {
    className: 'function',
    beginWithKeyword: true, end: '[:;]',
    keywords: 'function constructor|10 destructor|10 procedure|10',
    contains: [
      {
        className: 'title', begin: hljs.IDENT_RE
      },
      {
        className: 'params',
        begin: '\\(', end: '\\)',
        keywords: DELPHI_KEYWORDS,
        contains: [STRING, CHAR_STRING]
      },
      CURLY_COMMENT, PAREN_COMMENT
    ]
  };
  return {
    case_insensitive: true,
    keywords: DELPHI_KEYWORDS,
    illegal: '("|\\$[G-Zg-z]|\\/\\*|</)',
    contains: [
      CURLY_COMMENT, PAREN_COMMENT, hljs.C_LINE_COMMENT_MODE,
      STRING, CHAR_STRING,
      hljs.NUMBER_MODE,
      FUNCTION,
      {
        className: 'class',
        begin: '=\\bclass\\b', end: 'end;',
        keywords: DELPHI_CLASS_KEYWORDS,
        contains: [
          STRING, CHAR_STRING,
          CURLY_COMMENT, PAREN_COMMENT, hljs.C_LINE_COMMENT_MODE,
          FUNCTION
        ]
      }
    ]
  };
};
},{}],22:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    contains: [
      {
        className: 'chunk',
        begin: '^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$',
        relevance: 10
      },
      {
        className: 'chunk',
        begin: '^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$',
        relevance: 10
      },
      {
        className: 'chunk',
        begin: '^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$',
        relevance: 10
      },
      {
        className: 'header',
        begin: 'Index: ', end: '$'
      },
      {
        className: 'header',
        begin: '=====', end: '=====$'
      },
      {
        className: 'header',
        begin: '^\\-\\-\\-', end: '$'
      },
      {
        className: 'header',
        begin: '^\\*{3} ', end: '$'
      },
      {
        className: 'header',
        begin: '^\\+\\+\\+', end: '$'
      },
      {
        className: 'header',
        begin: '\\*{5}', end: '\\*{5}$'
      },
      {
        className: 'addition',
        begin: '^\\+', end: '$'
      },
      {
        className: 'deletion',
        begin: '^\\-', end: '$'
      },
      {
        className: 'change',
        begin: '^\\!', end: '$'
      }
    ]
  };
};
},{}],23:[function(require,module,exports){
module.exports = function(hljs) {

  function allowsDjangoSyntax(mode, parent) {
    return (
      parent == undefined || // default mode
      (!mode.className && parent.className == 'tag') || // tag_internal
      mode.className == 'value' // value
    );
  }

  function copy(mode, parent) {
    var result = {};
    for (var key in mode) {
      if (key != 'contains') {
        result[key] = mode[key];
      }
      var contains = [];
      for (var i = 0; mode.contains && i < mode.contains.length; i++) {
        contains.push(copy(mode.contains[i], mode));
      }
      if (allowsDjangoSyntax(mode, parent)) {
        contains = DJANGO_CONTAINS.concat(contains);
      }
      if (contains.length) {
        result.contains = contains;
      }
    }
    return result;
  }

  var FILTER = {
    className: 'filter',
    begin: '\\|[A-Za-z]+\\:?', excludeEnd: true,
    keywords:
      'truncatewords removetags linebreaksbr yesno get_digit timesince random striptags ' +
      'filesizeformat escape linebreaks length_is ljust rjust cut urlize fix_ampersands ' +
      'title floatformat capfirst pprint divisibleby add make_list unordered_list urlencode ' +
      'timeuntil urlizetrunc wordcount stringformat linenumbers slice date dictsort ' +
      'dictsortreversed default_if_none pluralize lower join center default ' +
      'truncatewords_html upper length phone2numeric wordwrap time addslashes slugify first ' +
      'escapejs force_escape iriencode last safe safeseq truncatechars localize unlocalize ' +
      'localtime utc timezone',
    contains: [
      {className: 'argument', begin: '"', end: '"'}
    ]
  };

  var DJANGO_CONTAINS = [
    {
      className: 'template_comment',
      begin: '{%\\s*comment\\s*%}', end: '{%\\s*endcomment\\s*%}'
    },
    {
      className: 'template_comment',
      begin: '{#', end: '#}'
    },
    {
      className: 'template_tag',
      begin: '{%', end: '%}',
      keywords:
        'comment endcomment load templatetag ifchanged endifchanged if endif firstof for ' +
        'endfor in ifnotequal endifnotequal widthratio extends include spaceless ' +
        'endspaceless regroup by as ifequal endifequal ssi now with cycle url filter ' +
        'endfilter debug block endblock else autoescape endautoescape csrf_token empty elif ' +
        'endwith static trans blocktrans endblocktrans get_static_prefix get_media_prefix ' +
        'plural get_current_language language get_available_languages ' +
        'get_current_language_bidi get_language_info get_language_info_list localize ' +
        'endlocalize localtime endlocaltime timezone endtimezone get_current_timezone',
      contains: [FILTER]
    },
    {
      className: 'variable',
      begin: '{{', end: '}}',
      contains: [FILTER]
    }
  ];

  var result = copy(hljs.LANGUAGES.xml);
  result.case_insensitive = true;
  return result;
};
},{}],24:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    keywords: {
      flow: 'if else goto for in do call exit not exist errorlevel defined equ neq lss leq gtr geq',
      keyword: 'shift cd dir echo setlocal endlocal set pause copy',
      stream: 'prn nul lpt3 lpt2 lpt1 con com4 com3 com2 com1 aux',
      winutils: 'ping net ipconfig taskkill xcopy ren del'
    },
    contains: [
      {
        className: 'envvar', begin: '%%[^ ]'
      },
      {
        className: 'envvar', begin: '%[^ ]+?%'
      },
      {
        className: 'envvar', begin: '![^ ]+?!'
      },
      {
        className: 'number', begin: '\\b\\d+',
        relevance: 0
      },
      {
        className: 'comment',
        begin: '@?rem', end: '$'
      }
    ]
  };
};
},{}],25:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: {
      special_functions:
        'spawn spawn_link self',
      reserved:
        'after and andalso|10 band begin bnot bor bsl bsr bxor case catch cond div end fun if ' +
        'let not of or orelse|10 query receive rem try when xor'
    },
    contains: [
      {
        className: 'prompt', begin: '^[0-9]+> ',
        relevance: 10
      },
      {
        className: 'comment',
        begin: '%', end: '$'
      },
      {
        className: 'number',
        begin: '\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)',
        relevance: 0
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'constant', begin: '\\?(::)?([A-Z]\\w*(::)?)+'
      },
      {
        className: 'arrow', begin: '->'
      },
      {
        className: 'ok', begin: 'ok'
      },
      {
        className: 'exclamation_mark', begin: '!'
      },
      {
        className: 'function_or_atom',
        begin: '(\\b[a-z\'][a-zA-Z0-9_\']*:[a-z\'][a-zA-Z0-9_\']*)|(\\b[a-z\'][a-zA-Z0-9_\']*)',
        relevance: 0
      },
      {
        className: 'variable',
        begin: '[A-Z][a-zA-Z0-9_\']*',
        relevance: 0
      }
    ]
  };
};
},{}],26:[function(require,module,exports){
module.exports = function(hljs) {
  var BASIC_ATOM_RE = '[a-z\'][a-zA-Z0-9_\']*';
  var FUNCTION_NAME_RE = '(' + BASIC_ATOM_RE + ':' + BASIC_ATOM_RE + '|' + BASIC_ATOM_RE + ')';
  var ERLANG_RESERVED = {
    keyword:
      'after and andalso|10 band begin bnot bor bsl bzr bxor case catch cond div end fun let ' +
      'not of orelse|10 query receive rem try when xor',
    literal:
      'false true'
  };

  var COMMENT = {
    className: 'comment',
    begin: '%', end: '$',
    relevance: 0
  };
  var NUMBER = {
    className: 'number',
    begin: '\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)',
    relevance: 0
  };
  var NAMED_FUN = {
    begin: 'fun\\s+' + BASIC_ATOM_RE + '/\\d+'
  };
  var FUNCTION_CALL = {
    begin: FUNCTION_NAME_RE + '\\(', end: '\\)',
    returnBegin: true,
    relevance: 0,
    contains: [
      {
        className: 'function_name', begin: FUNCTION_NAME_RE,
        relevance: 0
      },
      {
        begin: '\\(', end: '\\)', endsWithParent: true,
        returnEnd: true,
        relevance: 0
        // "contains" defined later
      }
    ]
  };
  var TUPLE = {
    className: 'tuple',
    begin: '{', end: '}',
    relevance: 0
    // "contains" defined later
  };
  var VAR1 = {
    className: 'variable',
    begin: '\\b_([A-Z][A-Za-z0-9_]*)?',
    relevance: 0
  };
  var VAR2 = {
    className: 'variable',
    begin: '[A-Z][a-zA-Z0-9_]*',
    relevance: 0
  };
  var RECORD_ACCESS = {
    begin: '#', end: '}',
    illegal: '.',
    relevance: 0,
    returnBegin: true,
    contains: [
      {
        className: 'record_name',
        begin: '#' + hljs.UNDERSCORE_IDENT_RE,
        relevance: 0
      },
      {
        begin: '{', endsWithParent: true,
        relevance: 0
        // "contains" defined later
      }
    ]
  };

  var BLOCK_STATEMENTS = {
    keywords: ERLANG_RESERVED,
    begin: '(fun|receive|if|try|case)', end: 'end'
  };
  BLOCK_STATEMENTS.contains = [
    COMMENT,
    NAMED_FUN,
    hljs.inherit(hljs.APOS_STRING_MODE, {className: ''}),
    BLOCK_STATEMENTS,
    FUNCTION_CALL,
    hljs.QUOTE_STRING_MODE,
    NUMBER,
    TUPLE,
    VAR1, VAR2,
    RECORD_ACCESS
  ];

  var BASIC_MODES = [
    COMMENT,
    NAMED_FUN,
    BLOCK_STATEMENTS,
    FUNCTION_CALL,
    hljs.QUOTE_STRING_MODE,
    NUMBER,
    TUPLE,
    VAR1, VAR2,
    RECORD_ACCESS
  ];
  FUNCTION_CALL.contains[1].contains = BASIC_MODES;
  TUPLE.contains = BASIC_MODES;
  RECORD_ACCESS.contains[1].contains = BASIC_MODES;

  var PARAMS = {
    className: 'params',
    begin: '\\(', end: '\\)',
    contains: BASIC_MODES
  };
  return {
    keywords: ERLANG_RESERVED,
    illegal: '(</|\\*=|\\+=|-=|/=|/\\*|\\*/|\\(\\*|\\*\\))',
    contains: [
      {
        className: 'function',
        begin: '^' + BASIC_ATOM_RE + '\\s*\\(', end: '->',
        returnBegin: true,
        illegal: '\\(|#|//|/\\*|\\\\|:',
        contains: [
          PARAMS,
          {
            className: 'title', begin: BASIC_ATOM_RE
          }
        ],
        starts: {
          end: ';|\\.',
          keywords: ERLANG_RESERVED,
          contains: BASIC_MODES
        }
      },
      COMMENT,
      {
        className: 'pp',
        begin: '^-', end: '\\.',
        relevance: 0,
        excludeEnd: true,
        returnBegin: true,
        lexems: '-' + hljs.IDENT_RE,
        keywords:
          '-module -record -undef -export -ifdef -ifndef -author -copyright -doc -vsn ' +
          '-import -include -include_lib -compile -define -else -endif -file -behaviour ' +
          '-behavior',
        contains: [PARAMS]
      },
      NUMBER,
      hljs.QUOTE_STRING_MODE,
      RECORD_ACCESS,
      VAR1, VAR2,
      TUPLE
    ]
  };
};
},{}],27:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: {
      keyword:
        'atomic_uint attribute bool break bvec2 bvec3 bvec4 case centroid coherent const continue default ' +
        'discard dmat2 dmat2x2 dmat2x3 dmat2x4 dmat3 dmat3x2 dmat3x3 dmat3x4 dmat4 dmat4x2 dmat4x3 ' +
        'dmat4x4 do double dvec2 dvec3 dvec4 else flat float for highp if iimage1D iimage1DArray ' +
        'iimage2D iimage2DArray iimage2DMS iimage2DMSArray iimage2DRect iimage3D iimageBuffer iimageCube ' +
        'iimageCubeArray image1D image1DArray image2D image2DArray image2DMS image2DMSArray image2DRect ' +
        'image3D imageBuffer imageCube imageCubeArray in inout int invariant isampler1D isampler1DArray ' +
        'isampler2D isampler2DArray isampler2DMS isampler2DMSArray isampler2DRect isampler3D isamplerBuffer ' +
        'isamplerCube isamplerCubeArray ivec2 ivec3 ivec4 layout lowp mat2 mat2x2 mat2x3 mat2x4 mat3 mat3x2 ' +
        'mat3x3 mat3x4 mat4 mat4x2 mat4x3 mat4x4 mediump noperspective out patch precision readonly restrict ' +
        'return sample sampler1D sampler1DArray sampler1DArrayShadow sampler1DShadow sampler2D sampler2DArray ' +
        'sampler2DArrayShadow sampler2DMS sampler2DMSArray sampler2DRect sampler2DRectShadow sampler2DShadow ' +
        'sampler3D samplerBuffer samplerCube samplerCubeArray samplerCubeArrayShadow samplerCubeShadow smooth ' +
        'struct subroutine switch uimage1D uimage1DArray uimage2D uimage2DArray uimage2DMS uimage2DMSArray ' +
        'uimage2DRect uimage3D uimageBuffer uimageCube uimageCubeArray uint uniform usampler1D usampler1DArray ' +
        'usampler2D usampler2DArray usampler2DMS usampler2DMSArray usampler2DRect usampler3D usamplerBuffer ' +
        'usamplerCube usamplerCubeArray uvec2 uvec3 uvec4 varying vec2 vec3 vec4 void volatile while writeonly',
      built_in:
        'gl_BackColor gl_BackLightModelProduct gl_BackLightProduct gl_BackMaterial ' +
        'gl_BackSecondaryColor gl_ClipDistance gl_ClipPlane gl_ClipVertex gl_Color ' +
        'gl_DepthRange gl_EyePlaneQ gl_EyePlaneR gl_EyePlaneS gl_EyePlaneT gl_Fog gl_FogCoord ' +
        'gl_FogFragCoord gl_FragColor gl_FragCoord gl_FragData gl_FragDepth gl_FrontColor ' +
        'gl_FrontFacing gl_FrontLightModelProduct gl_FrontLightProduct gl_FrontMaterial ' +
        'gl_FrontSecondaryColor gl_InstanceID gl_InvocationID gl_Layer gl_LightModel ' +
        'gl_LightSource gl_MaxAtomicCounterBindings gl_MaxAtomicCounterBufferSize ' +
        'gl_MaxClipDistances gl_MaxClipPlanes gl_MaxCombinedAtomicCounterBuffers ' +
        'gl_MaxCombinedAtomicCounters gl_MaxCombinedImageUniforms gl_MaxCombinedImageUnitsAndFragmentOutputs ' +
        'gl_MaxCombinedTextureImageUnits gl_MaxDrawBuffers gl_MaxFragmentAtomicCounterBuffers ' +
        'gl_MaxFragmentAtomicCounters gl_MaxFragmentImageUniforms gl_MaxFragmentInputComponents ' +
        'gl_MaxFragmentUniformComponents gl_MaxFragmentUniformVectors gl_MaxGeometryAtomicCounterBuffers ' +
        'gl_MaxGeometryAtomicCounters gl_MaxGeometryImageUniforms gl_MaxGeometryInputComponents ' +
        'gl_MaxGeometryOutputComponents gl_MaxGeometryOutputVertices gl_MaxGeometryTextureImageUnits ' +
        'gl_MaxGeometryTotalOutputComponents gl_MaxGeometryUniformComponents gl_MaxGeometryVaryingComponents ' +
        'gl_MaxImageSamples gl_MaxImageUnits gl_MaxLights gl_MaxPatchVertices gl_MaxProgramTexelOffset ' +
        'gl_MaxTessControlAtomicCounterBuffers gl_MaxTessControlAtomicCounters gl_MaxTessControlImageUniforms ' +
        'gl_MaxTessControlInputComponents gl_MaxTessControlOutputComponents gl_MaxTessControlTextureImageUnits ' +
        'gl_MaxTessControlTotalOutputComponents gl_MaxTessControlUniformComponents ' +
        'gl_MaxTessEvaluationAtomicCounterBuffers gl_MaxTessEvaluationAtomicCounters ' +
        'gl_MaxTessEvaluationImageUniforms gl_MaxTessEvaluationInputComponents gl_MaxTessEvaluationOutputComponents ' +
        'gl_MaxTessEvaluationTextureImageUnits gl_MaxTessEvaluationUniformComponents ' +
        'gl_MaxTessGenLevel gl_MaxTessPatchComponents gl_MaxTextureCoords gl_MaxTextureImageUnits ' +
        'gl_MaxTextureUnits gl_MaxVaryingComponents gl_MaxVaryingFloats gl_MaxVaryingVectors ' +
        'gl_MaxVertexAtomicCounterBuffers gl_MaxVertexAtomicCounters gl_MaxVertexAttribs ' +
        'gl_MaxVertexImageUniforms gl_MaxVertexOutputComponents gl_MaxVertexTextureImageUnits ' +
        'gl_MaxVertexUniformComponents gl_MaxVertexUniformVectors gl_MaxViewports gl_MinProgramTexelOffset'+
        'gl_ModelViewMatrix gl_ModelViewMatrixInverse gl_ModelViewMatrixInverseTranspose ' +
        'gl_ModelViewMatrixTranspose gl_ModelViewProjectionMatrix gl_ModelViewProjectionMatrixInverse ' +
        'gl_ModelViewProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixTranspose ' +
        'gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 ' +
        'gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_Normal gl_NormalMatrix ' +
        'gl_NormalScale gl_ObjectPlaneQ gl_ObjectPlaneR gl_ObjectPlaneS gl_ObjectPlaneT gl_PatchVerticesIn ' +
        'gl_PerVertex gl_Point gl_PointCoord gl_PointSize gl_Position gl_PrimitiveID gl_PrimitiveIDIn ' +
        'gl_ProjectionMatrix gl_ProjectionMatrixInverse gl_ProjectionMatrixInverseTranspose ' +
        'gl_ProjectionMatrixTranspose gl_SampleID gl_SampleMask gl_SampleMaskIn gl_SamplePosition ' +
        'gl_SecondaryColor gl_TessCoord gl_TessLevelInner gl_TessLevelOuter gl_TexCoord gl_TextureEnvColor ' +
        'gl_TextureMatrixInverseTranspose gl_TextureMatrixTranspose gl_Vertex gl_VertexID ' +
        'gl_ViewportIndex gl_in gl_out EmitStreamVertex EmitVertex EndPrimitive EndStreamPrimitive ' +
        'abs acos acosh all any asin asinh atan atanh atomicCounter atomicCounterDecrement ' +
        'atomicCounterIncrement barrier bitCount bitfieldExtract bitfieldInsert bitfieldReverse ' +
        'ceil clamp cos cosh cross dFdx dFdy degrees determinant distance dot equal exp exp2 faceforward ' +
        'findLSB findMSB floatBitsToInt floatBitsToUint floor fma fract frexp ftransform fwidth greaterThan ' +
        'greaterThanEqual imageAtomicAdd imageAtomicAnd imageAtomicCompSwap imageAtomicExchange ' +
        'imageAtomicMax imageAtomicMin imageAtomicOr imageAtomicXor imageLoad imageStore imulExtended ' +
        'intBitsToFloat interpolateAtCentroid interpolateAtOffset interpolateAtSample inverse inversesqrt ' +
        'isinf isnan ldexp length lessThan lessThanEqual log log2 matrixCompMult max memoryBarrier ' +
        'min mix mod modf noise1 noise2 noise3 noise4 normalize not notEqual outerProduct packDouble2x32 ' +
        'packHalf2x16 packSnorm2x16 packSnorm4x8 packUnorm2x16 packUnorm4x8 pow radians reflect refract ' +
        'round roundEven shadow1D shadow1DLod shadow1DProj shadow1DProjLod shadow2D shadow2DLod shadow2DProj ' +
        'shadow2DProjLod sign sin sinh smoothstep sqrt step tan tanh texelFetch texelFetchOffset texture ' +
        'texture1D texture1DLod texture1DProj texture1DProjLod texture2D texture2DLod texture2DProj ' +
        'texture2DProjLod texture3D texture3DLod texture3DProj texture3DProjLod textureCube textureCubeLod ' +
        'textureGather textureGatherOffset textureGatherOffsets textureGrad textureGradOffset textureLod ' +
        'textureLodOffset textureOffset textureProj textureProjGrad textureProjGradOffset textureProjLod ' +
        'textureProjLodOffset textureProjOffset textureQueryLod textureSize transpose trunc uaddCarry ' +
        'uintBitsToFloat umulExtended unpackDouble2x32 unpackHalf2x16 unpackSnorm2x16 unpackSnorm4x8 ' +
        'unpackUnorm2x16 unpackUnorm4x8 usubBorrow gl_TextureMatrix gl_TextureMatrixInverse',
      literal: 'true false'
    },
    illegal: '"',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'preprocessor',
        begin: '#', end: '$'
      }
    ]
  };
};
},{}],28:[function(require,module,exports){
module.exports = function(hljs) {
  var GO_KEYWORDS = {
    keyword:
      'break default func interface select case map struct chan else goto package switch ' +
      'const fallthrough if range type continue for import return var go defer',
    constant:
       'true false iota nil',
    typename:
      'bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 ' +
      'uint16 uint32 uint64 int uint uintptr rune',
    built_in:
      'append cap close complex copy imag len make new panic print println real recover delete'
  };
  return {
    keywords: GO_KEYWORDS,
    illegal: '</',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: '\'', end: '[^\\\\]\'',
        relevance: 0
      },
      {
        className: 'string',
        begin: '`', end: '`'
      },
      {
        className: 'number',
        begin: '[^a-zA-Z_0-9](\\-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s)(\\+|\\-)?\\d+)?',
        relevance: 0
      },
      hljs.C_NUMBER_MODE
    ]
  };
};
},{}],29:[function(require,module,exports){
module.exports = function(hljs) {
  var TYPE = {
    className: 'type',
    begin: '\\b[A-Z][\\w\']*',
    relevance: 0
  };
  var CONTAINER = {
    className: 'container',
    begin: '\\(', end: '\\)',
    contains: [
      {className: 'type', begin: '\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?'},
      {className: 'title', begin: '[_a-z][\\w\']*'}
    ]
  };
  var CONTAINER2 = {
    className: 'container',
    begin: '{', end: '}',
    contains: CONTAINER.contains
  }

  return {
    keywords:
      'let in if then else case of where do module import hiding qualified type data ' +
      'newtype deriving class instance not as foreign ccall safe unsafe',
    contains: [
      {
        className: 'comment',
        begin: '--', end: '$'
      },
      {
        className: 'preprocessor',
        begin: '{-#', end: '#-}'
      },
      {
        className: 'comment',
        contains: ['self'],
        begin: '{-', end: '-}'
      },
      {
        className: 'string',
        begin: '\\s+\'', end: '\'',
        contains: [hljs.BACKSLASH_ESCAPE],
        relevance: 0
      },
      hljs.QUOTE_STRING_MODE,
      {
        className: 'import',
        begin: '\\bimport', end: '$',
        keywords: 'import qualified as hiding',
        contains: [CONTAINER],
        illegal: '\\W\\.|;'
      },
      {
        className: 'module',
        begin: '\\bmodule', end: 'where',
        keywords: 'module where',
        contains: [CONTAINER],
        illegal: '\\W\\.|;'
      },
      {
        className: 'class',
        begin: '\\b(class|instance)', end: 'where',
        keywords: 'class where instance',
        contains: [TYPE]
      },
      {
        className: 'typedef',
        begin: '\\b(data|(new)?type)', end: '$',
        keywords: 'data type newtype deriving',
        contains: [TYPE, CONTAINER, CONTAINER2]
      },
      hljs.C_NUMBER_MODE,
      {
        className: 'shebang',
        begin: '#!\\/usr\\/bin\\/env\ runhaskell', end: '$'
      },
      TYPE,
      {
        className: 'title', begin: '^[_a-z][\\w\']*'
      }
    ]
  };
};
},{}],30:[function(require,module,exports){
var hljs = new function() {

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/gm, '&amp;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;');
  }

  function findCode(pre) {
    for (var node = pre.firstChild; node; node = node.nextSibling) {
      if (node.nodeName == 'CODE')
        return node;
      if (!(node.nodeType == 3 && node.nodeValue.match(/\s+/)))
        break;
    }
  }

  function blockText(block, ignoreNewLines) {
    return Array.prototype.map.call(block.childNodes, function(node) {
      if (node.nodeType == 3) {
        return ignoreNewLines ? node.nodeValue.replace(/\n/g, '') : node.nodeValue;
      }
      if (node.nodeName == 'BR') {
        return '\n';
      }
      return blockText(node, ignoreNewLines);
    }).join('');
  }

  function blockLanguage(block) {
    var classes = (block.className + ' ' + block.parentNode.className).split(/\s+/);
    classes = classes.map(function(c) {return c.replace(/^language-/, '')});
    for (var i = 0; i < classes.length; i++) {
      if (languages[classes[i]] || classes[i] == 'no-highlight') {
        return classes[i];
      }
    }
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType == 3)
          offset += child.nodeValue.length;
        else if (child.nodeName == 'BR')
          offset += 1;
        else if (child.nodeType == 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          result.push({
            event: 'stop',
            offset: offset,
            node: child
          });
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(stream1, stream2, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (stream1.length && stream2.length) {
        if (stream1[0].offset != stream2[0].offset)
          return (stream1[0].offset < stream2[0].offset) ? stream1 : stream2;
        else {
          /*
          To avoid starting the stream just before it should stop the order is
          ensured that stream1 always starts first and closes last:

          if (event1 == 'start' && event2 == 'start')
            return stream1;
          if (event1 == 'start' && event2 == 'stop')
            return stream2;
          if (event1 == 'stop' && event2 == 'start')
            return stream1;
          if (event1 == 'stop' && event2 == 'stop')
            return stream2;

          ... which is collapsed to:
          */
          return stream2[0].event == 'start' ? stream1 : stream2;
        }
      } else {
        return stream1.length ? stream1 : stream2;
      }
    }

    function open(node) {
      function attr_str(a) {return ' ' + a.nodeName + '="' + escape(a.value) + '"'};
      return '<' + node.nodeName + Array.prototype.map.call(node.attributes, attr_str).join('') + '>';
    }

    while (stream1.length || stream2.length) {
      var current = selectStream().splice(0, 1)[0];
      result += escape(value.substr(processed, current.offset - processed));
      processed = current.offset;
      if ( current.event == 'start') {
        result += open(current.node);
        nodeStack.push(current.node);
      } else if (current.event == 'stop') {
        var node, i = nodeStack.length;
        do {
          i--;
          node = nodeStack[i];
          result += ('</' + node.nodeName.toLowerCase() + '>');
        } while (node != current.node);
        nodeStack.splice(i, 1);
        while (i < nodeStack.length) {
          result += open(nodeStack[i]);
          i++;
        }
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function compileLanguage(language) {

    function langRe(value, global) {
      return RegExp(
        value,
        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
      );
    }

    function compileMode(mode, parent) {
      if (mode.compiled)
        return;
      mode.compiled = true;

      var keywords = []; // used later with beginWithKeyword but filled as a side-effect of keywords compilation
      if (mode.keywords) {
        var compiled_keywords = {};

        function flatten(className, str) {
          str.split(' ').forEach(function(kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
            keywords.push(pair[0]);
          });
        }

        mode.lexemsRe = langRe(mode.lexems || hljs.IDENT_RE, true);
        if (typeof mode.keywords == 'string') { // string
          flatten('keyword', mode.keywords)
        } else {
          for (var className in mode.keywords) {
            if (!mode.keywords.hasOwnProperty(className))
              continue;
            flatten(className, mode.keywords[className]);
          }
        }
        mode.keywords = compiled_keywords;
      }
      if (parent) {
        if (mode.beginWithKeyword) {
          mode.begin = '\\b(' + keywords.join('|') + ')\\s';
        }
        mode.beginRe = langRe(mode.begin ? mode.begin : '\\B|\\b');
        if (!mode.end && !mode.endsWithParent)
          mode.end = '\\B|\\b';
        if (mode.end)
          mode.endRe = langRe(mode.end);
        mode.terminator_end = mode.end || '';
        if (mode.endsWithParent && parent.terminator_end)
          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal)
        mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance === undefined)
        mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      for (var i = 0; i < mode.contains.length; i++) {
        if (mode.contains[i] == 'self') {
          mode.contains[i] = mode;
        }
        compileMode(mode.contains[i], mode);
      }
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = [];
      for (var i = 0; i < mode.contains.length; i++) {
        terminators.push(mode.contains[i].begin);
      }
      if (mode.terminator_end) {
        terminators.push(mode.terminator_end);
      }
      if (mode.illegal) {
        terminators.push(mode.illegal);
      }
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(s) {return null;}};
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name and a string with the
  code to highlight. Returns an object with the following properties:

  - relevance (int)
  - keyword_count (int)
  - value (an HTML string with highlighting markup)

  */
  function highlight(language_name, value) {

    function subMode(lexem, mode) {
      for (var i = 0; i < mode.contains.length; i++) {
        var match = mode.contains[i].beginRe.exec(lexem);
        if (match && match.index == 0) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexem) {
      if (mode.end && mode.endRe.test(lexem)) {
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexem);
      }
    }

    function isIllegal(lexem, mode) {
      return mode.illegal && mode.illegalRe.test(lexem);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function processKeywords() {
      var buffer = escape(mode_buffer);
      if (!top.keywords)
        return buffer;
      var result = '';
      var last_index = 0;
      top.lexemsRe.lastIndex = 0;
      var match = top.lexemsRe.exec(buffer);
      while (match) {
        result += buffer.substr(last_index, match.index - last_index);
        var keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          keyword_count += keyword_match[1];
          result += '<span class="'+ keyword_match[0] +'">' + match[0] + '</span>';
        } else {
          result += match[0];
        }
        last_index = top.lexemsRe.lastIndex;
        match = top.lexemsRe.exec(buffer);
      }
      return result + buffer.substr(last_index);
    }

    function processSubLanguage() {
      if (top.subLanguage && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }
      var result = top.subLanguage ? highlight(top.subLanguage, mode_buffer) : highlightAuto(mode_buffer);
      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        keyword_count += result.keyword_count;
        relevance += result.relevance;
      }
      return '<span class="' + result.language  + '">' + result.value + '</span>';
    }

    function processBuffer() {
      return top.subLanguage !== undefined ? processSubLanguage() : processKeywords();
    }

    function startNewMode(mode, lexem) {
      var markup = mode.className? '<span class="' + mode.className + '">': '';
      if (mode.returnBegin) {
        result += markup;
        mode_buffer = '';
      } else if (mode.excludeBegin) {
        result += escape(lexem) + markup;
        mode_buffer = '';
      } else {
        result += markup;
        mode_buffer = lexem;
      }
      top = Object.create(mode, {parent: {value: top}});
      relevance += mode.relevance;
    }

    function processLexem(buffer, lexem) {
      mode_buffer += buffer;
      if (lexem === undefined) {
        result += processBuffer();
        return 0;
      }

      var new_mode = subMode(lexem, top);
      if (new_mode) {
        result += processBuffer();
        startNewMode(new_mode, lexem);
        return new_mode.returnBegin ? 0 : lexem.length;
      }

      var end_mode = endOfMode(top, lexem);
      if (end_mode) {
        if (!(end_mode.returnEnd || end_mode.excludeEnd)) {
          mode_buffer += lexem;
        }
        result += processBuffer();
        do {
          if (top.className) {
            result += '</span>';
          }
          top = top.parent;
        } while (top != end_mode.parent);
        if (end_mode.excludeEnd) {
          result += escape(lexem);
        }
        mode_buffer = '';
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return end_mode.returnEnd ? 0 : lexem.length;
      }

      if (isIllegal(lexem, top))
        throw 'Illegal';

      /*
      Parser should not reach this point as all types of lexems should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexem;
      return lexem.length || 1;
    }

    var language = languages[language_name];
    compileLanguage(language);
    var top = language;
    var mode_buffer = '';
    var relevance = 0;
    var keyword_count = 0;
    var result = '';
    try {
      var match, count, index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match)
          break;
        count = processLexem(value.substr(index, match.index - index), match[0]);
        index = match.index + count;
      }
      processLexem(value.substr(index))
      return {
        relevance: relevance,
        keyword_count: keyword_count,
        value: result,
        language: language_name
      };
    } catch (e) {
      if (e == 'Illegal') {
        return {
          relevance: 0,
          keyword_count: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - keyword_count (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

  */
  function highlightAuto(text) {
    var result = {
      keyword_count: 0,
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    for (var key in languages) {
      if (!languages.hasOwnProperty(key))
        continue;
      var current = highlight(key, text);
      current.language = key;
      if (current.keyword_count + current.relevance > second_best.keyword_count + second_best.relevance) {
        second_best = current;
      }
      if (current.keyword_count + current.relevance > result.keyword_count + result.relevance) {
        second_best = result;
        result = current;
      }
    }
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers

  */
  function fixMarkup(value, tabReplace, useBR) {
    if (tabReplace) {
      value = value.replace(/^((<[^>]+>|\t)+)/gm, function(match, p1, offset, s) {
        return p1.replace(/\t/g, tabReplace);
      });
    }
    if (useBR) {
      value = value.replace(/\n/g, '<br>');
    }
    return value;
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block, tabReplace, useBR) {
    var text = blockText(block, useBR);
    var language = blockLanguage(block);
    if (language == 'no-highlight')
        return;
    var result = language ? highlight(language, text) : highlightAuto(text);
    language = result.language;
    var original = nodeStream(block);
    if (original.length) {
      var pre = document.createElement('pre');
      pre.innerHTML = result.value;
      result.value = mergeStreams(original, nodeStream(pre), text);
    }
    result.value = fixMarkup(result.value, tabReplace, useBR);

    var class_name = block.className;
    if (!class_name.match('(\\s|^)(language-)?' + language + '(\\s|$)')) {
      class_name = class_name ? (class_name + ' ' + language) : language;
    }
    block.innerHTML = result.value;
    block.className = class_name;
    block.result = {
      language: language,
      kw: result.keyword_count,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        kw: result.second_best.keyword_count,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called)
      return;
    initHighlighting.called = true;
    Array.prototype.map.call(document.getElementsByTagName('pre'), findCode).
      filter(Boolean).
      forEach(function(code){highlightBlock(code, hljs.tabReplace)});
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    window.addEventListener('DOMContentLoaded', initHighlighting, false);
    window.addEventListener('load', initHighlighting, false);
  }

  var languages = {}; // a shortcut to avoid writing "this." everywhere

  /* Interface definition */

  this.LANGUAGES = languages;
  this.highlight = highlight;
  this.highlightAuto = highlightAuto;
  this.fixMarkup = fixMarkup;
  this.highlightBlock = highlightBlock;
  this.initHighlighting = initHighlighting;
  this.initHighlightingOnLoad = initHighlightingOnLoad;

  // Common regexps
  this.IDENT_RE = '[a-zA-Z][a-zA-Z0-9_]*';
  this.UNDERSCORE_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*';
  this.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  this.C_NUMBER_RE = '(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  this.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  this.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  this.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  this.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [this.BACKSLASH_ESCAPE],
    relevance: 0
  };
  this.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [this.BACKSLASH_ESCAPE],
    relevance: 0
  };
  this.C_LINE_COMMENT_MODE = {
    className: 'comment',
    begin: '//', end: '$'
  };
  this.C_BLOCK_COMMENT_MODE = {
    className: 'comment',
    begin: '/\\*', end: '\\*/'
  };
  this.HASH_COMMENT_MODE = {
    className: 'comment',
    begin: '#', end: '$'
  };
  this.NUMBER_MODE = {
    className: 'number',
    begin: this.NUMBER_RE,
    relevance: 0
  };
  this.C_NUMBER_MODE = {
    className: 'number',
    begin: this.C_NUMBER_RE,
    relevance: 0
  };
  this.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: this.BINARY_NUMBER_RE,
    relevance: 0
  };

  // Utility functions
  this.inherit = function(parent, obj) {
    var result = {}
    for (var key in parent)
      result[key] = parent[key];
    if (obj)
      for (var key in obj)
        result[key] = obj[key];
    return result;
  }
}();
hljs.LANGUAGES['bash'] = require('./bash.js')(hljs);
hljs.LANGUAGES['erlang'] = require('./erlang.js')(hljs);
hljs.LANGUAGES['cs'] = require('./cs.js')(hljs);
hljs.LANGUAGES['brainfuck'] = require('./brainfuck.js')(hljs);
hljs.LANGUAGES['ruby'] = require('./ruby.js')(hljs);
hljs.LANGUAGES['rust'] = require('./rust.js')(hljs);
hljs.LANGUAGES['rib'] = require('./rib.js')(hljs);
hljs.LANGUAGES['diff'] = require('./diff.js')(hljs);
hljs.LANGUAGES['javascript'] = require('./javascript.js')(hljs);
hljs.LANGUAGES['glsl'] = require('./glsl.js')(hljs);
hljs.LANGUAGES['rsl'] = require('./rsl.js')(hljs);
hljs.LANGUAGES['lua'] = require('./lua.js')(hljs);
hljs.LANGUAGES['xml'] = require('./xml.js')(hljs);
hljs.LANGUAGES['markdown'] = require('./markdown.js')(hljs);
hljs.LANGUAGES['css'] = require('./css.js')(hljs);
hljs.LANGUAGES['lisp'] = require('./lisp.js')(hljs);
hljs.LANGUAGES['profile'] = require('./profile.js')(hljs);
hljs.LANGUAGES['http'] = require('./http.js')(hljs);
hljs.LANGUAGES['java'] = require('./java.js')(hljs);
hljs.LANGUAGES['php'] = require('./php.js')(hljs);
hljs.LANGUAGES['haskell'] = require('./haskell.js')(hljs);
hljs.LANGUAGES['1c'] = require('./1c.js')(hljs);
hljs.LANGUAGES['python'] = require('./python.js')(hljs);
hljs.LANGUAGES['smalltalk'] = require('./smalltalk.js')(hljs);
hljs.LANGUAGES['tex'] = require('./tex.js')(hljs);
hljs.LANGUAGES['actionscript'] = require('./actionscript.js')(hljs);
hljs.LANGUAGES['sql'] = require('./sql.js')(hljs);
hljs.LANGUAGES['vala'] = require('./vala.js')(hljs);
hljs.LANGUAGES['ini'] = require('./ini.js')(hljs);
hljs.LANGUAGES['d'] = require('./d.js')(hljs);
hljs.LANGUAGES['axapta'] = require('./axapta.js')(hljs);
hljs.LANGUAGES['perl'] = require('./perl.js')(hljs);
hljs.LANGUAGES['scala'] = require('./scala.js')(hljs);
hljs.LANGUAGES['cmake'] = require('./cmake.js')(hljs);
hljs.LANGUAGES['objectivec'] = require('./objectivec.js')(hljs);
hljs.LANGUAGES['avrasm'] = require('./avrasm.js')(hljs);
hljs.LANGUAGES['vhdl'] = require('./vhdl.js')(hljs);
hljs.LANGUAGES['coffeescript'] = require('./coffeescript.js')(hljs);
hljs.LANGUAGES['nginx'] = require('./nginx.js')(hljs);
hljs.LANGUAGES['erlang-repl'] = require('./erlang-repl.js')(hljs);
hljs.LANGUAGES['r'] = require('./r.js')(hljs);
hljs.LANGUAGES['json'] = require('./json.js')(hljs);
hljs.LANGUAGES['django'] = require('./django.js')(hljs);
hljs.LANGUAGES['delphi'] = require('./delphi.js')(hljs);
hljs.LANGUAGES['vbscript'] = require('./vbscript.js')(hljs);
hljs.LANGUAGES['mel'] = require('./mel.js')(hljs);
hljs.LANGUAGES['dos'] = require('./dos.js')(hljs);
hljs.LANGUAGES['apache'] = require('./apache.js')(hljs);
hljs.LANGUAGES['applescript'] = require('./applescript.js')(hljs);
hljs.LANGUAGES['cpp'] = require('./cpp.js')(hljs);
hljs.LANGUAGES['matlab'] = require('./matlab.js')(hljs);
hljs.LANGUAGES['parser3'] = require('./parser3.js')(hljs);
hljs.LANGUAGES['clojure'] = require('./clojure.js')(hljs);
hljs.LANGUAGES['go'] = require('./go.js')(hljs);
module.exports = hljs;
},{"./1c.js":6,"./actionscript.js":7,"./apache.js":8,"./applescript.js":9,"./avrasm.js":10,"./axapta.js":11,"./bash.js":12,"./brainfuck.js":13,"./clojure.js":14,"./cmake.js":15,"./coffeescript.js":16,"./cpp.js":17,"./cs.js":18,"./css.js":19,"./d.js":20,"./delphi.js":21,"./diff.js":22,"./django.js":23,"./dos.js":24,"./erlang-repl.js":25,"./erlang.js":26,"./glsl.js":27,"./go.js":28,"./haskell.js":29,"./http.js":31,"./ini.js":32,"./java.js":33,"./javascript.js":34,"./json.js":35,"./lisp.js":36,"./lua.js":37,"./markdown.js":38,"./matlab.js":39,"./mel.js":40,"./nginx.js":41,"./objectivec.js":42,"./parser3.js":43,"./perl.js":44,"./php.js":45,"./profile.js":46,"./python.js":47,"./r.js":48,"./rib.js":49,"./rsl.js":50,"./ruby.js":51,"./rust.js":52,"./scala.js":53,"./smalltalk.js":54,"./sql.js":55,"./tex.js":56,"./vala.js":57,"./vbscript.js":58,"./vhdl.js":59,"./xml.js":60}],31:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    illegal: '\\S',
    contains: [
      {
        className: 'status',
        begin: '^HTTP/[0-9\\.]+', end: '$',
        contains: [{className: 'number', begin: '\\b\\d{3}\\b'}]
      },
      {
        className: 'request',
        begin: '^[A-Z]+ (.*?) HTTP/[0-9\\.]+$', returnBegin: true, end: '$',
        contains: [
          {
            className: 'string',
            begin: ' ', end: ' ',
            excludeBegin: true, excludeEnd: true
          }
        ]
      },
      {
        className: 'attribute',
        begin: '^\\w', end: ': ', excludeEnd: true,
        illegal: '\\n|\\s|=',
        starts: {className: 'string', end: '$'}
      },
      {
        begin: '\\n\\n',
        starts: {subLanguage: '', endsWithParent: true}
      }
    ]
  };
};
},{}],32:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    illegal: '[^\\s]',
    contains: [
      {
        className: 'comment',
        begin: ';', end: '$'
      },
      {
        className: 'title',
        begin: '^\\[', end: '\\]'
      },
      {
        className: 'setting',
        begin: '^[a-z0-9\\[\\]_-]+[ \\t]*=[ \\t]*', end: '$',
        contains: [
          {
            className: 'value',
            endsWithParent: true,
            keywords: 'on off true false yes no',
            contains: [hljs.QUOTE_STRING_MODE, hljs.NUMBER_MODE]
          }
        ]
      }
    ]
  };
};
},{}],33:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords:
      'false synchronized int abstract float private char boolean static null if const ' +
      'for true while long throw strictfp finally protected import native final return void ' +
      'enum else break transient new catch instanceof byte super volatile case assert short ' +
      'package default double public try this switch continue throws',
    contains: [
      {
        className: 'javadoc',
        begin: '/\\*\\*', end: '\\*/',
        contains: [{
          className: 'javadoctag', begin: '@[A-Za-z]+'
        }],
        relevance: 10
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'class',
        beginWithKeyword: true, end: '{',
        keywords: 'class interface',
        illegal: ':',
        contains: [
          {
            beginWithKeyword: true,
            keywords: 'extends implements',
            relevance: 10
          },
          {
            className: 'title',
            begin: hljs.UNDERSCORE_IDENT_RE
          }
        ]
      },
      hljs.C_NUMBER_MODE,
      {
        className: 'annotation', begin: '@[A-Za-z]+'
      }
    ]
  };
};
},{}],34:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: {
      keyword:
        'in if for while finally var new function do return void else break catch ' +
        'instanceof with throw case default try this switch continue typeof delete ' +
        'let yield const',
      literal:
        'true false null undefined NaN Infinity'
    },
    contains: [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      { // "value" container
        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: 'regexp',
            begin: '/', end: '/[gim]*',
            illegal: '\\n',
            contains: [{begin: '\\\\/'}]
          },
          { // E4X
            begin: '<', end: '>;',
            subLanguage: 'xml'
          }
        ],
        relevance: 0
      },
      {
        className: 'function',
        beginWithKeyword: true, end: '{',
        keywords: 'function',
        contains: [
          {
            className: 'title', begin: '[A-Za-z$_][0-9A-Za-z$_]*'
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ],
            illegal: '["\'\\(]'
          }
        ],
        illegal: '\\[|%'
      }
    ]
  };
};
},{}],35:[function(require,module,exports){
module.exports = function(hljs) {
  var LITERALS = {literal: 'true false null'};
  var TYPES = [
    hljs.QUOTE_STRING_MODE,
    hljs.C_NUMBER_MODE
  ];
  var VALUE_CONTAINER = {
    className: 'value',
    end: ',', endsWithParent: true, excludeEnd: true,
    contains: TYPES,
    keywords: LITERALS
  };
  var OBJECT = {
    begin: '{', end: '}',
    contains: [
      {
        className: 'attribute',
        begin: '\\s*"', end: '"\\s*:\\s*', excludeBegin: true, excludeEnd: true,
        contains: [hljs.BACKSLASH_ESCAPE],
        illegal: '\\n',
        starts: VALUE_CONTAINER
      }
    ],
    illegal: '\\S'
  };
  var ARRAY = {
    begin: '\\[', end: '\\]',
    contains: [hljs.inherit(VALUE_CONTAINER, {className: null})], // inherit is also a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents
    illegal: '\\S'
  };
  TYPES.splice(TYPES.length, 0, OBJECT, ARRAY);
  return {
    contains: TYPES,
    keywords: LITERALS,
    illegal: '\\S'
  };
};
},{}],36:[function(require,module,exports){
module.exports = function(hljs) {
  var LISP_IDENT_RE = '[a-zA-Z_\\-\\+\\*\\/\\<\\=\\>\\&\\#][a-zA-Z0-9_\\-\\+\\*\\/\\<\\=\\>\\&\\#]*';
  var LISP_SIMPLE_NUMBER_RE = '(\\-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s)(\\+|\\-)?\\d+)?';
  var LITERAL = {
    className: 'literal',
    begin: '\\b(t{1}|nil)\\b'
  };
  var NUMBERS = [
    {
      className: 'number', begin: LISP_SIMPLE_NUMBER_RE
    },
    {
      className: 'number', begin: '#b[0-1]+(/[0-1]+)?'
    },
    {
      className: 'number', begin: '#o[0-7]+(/[0-7]+)?'
    },
    {
      className: 'number', begin: '#x[0-9a-f]+(/[0-9a-f]+)?'
    },
    {
      className: 'number', begin: '#c\\(' + LISP_SIMPLE_NUMBER_RE + ' +' + LISP_SIMPLE_NUMBER_RE, end: '\\)'
    }
  ]
  var STRING = {
    className: 'string',
    begin: '"', end: '"',
    contains: [hljs.BACKSLASH_ESCAPE],
    relevance: 0
  };
  var COMMENT = {
    className: 'comment',
    begin: ';', end: '$'
  };
  var VARIABLE = {
    className: 'variable',
    begin: '\\*', end: '\\*'
  };
  var KEYWORD = {
    className: 'keyword',
    begin: '[:&]' + LISP_IDENT_RE
  };
  var QUOTED_LIST = {
    begin: '\\(', end: '\\)',
    contains: ['self', LITERAL, STRING].concat(NUMBERS)
  };
  var QUOTED1 = {
    className: 'quoted',
    begin: '[\'`]\\(', end: '\\)',
    contains: NUMBERS.concat([STRING, VARIABLE, KEYWORD, QUOTED_LIST])
  };
  var QUOTED2 = {
    className: 'quoted',
    begin: '\\(quote ', end: '\\)',
    keywords: {title: 'quote'},
    contains: NUMBERS.concat([STRING, VARIABLE, KEYWORD, QUOTED_LIST])
  };
  var LIST = {
    className: 'list',
    begin: '\\(', end: '\\)'
  };
  var BODY = {
    className: 'body',
    endsWithParent: true, excludeEnd: true
  };
  LIST.contains = [{className: 'title', begin: LISP_IDENT_RE}, BODY];
  BODY.contains = [QUOTED1, QUOTED2, LIST, LITERAL].concat(NUMBERS).concat([STRING, COMMENT, VARIABLE, KEYWORD]);

  return {
    illegal: '[^\\s]',
    contains: NUMBERS.concat([
      LITERAL,
      STRING,
      COMMENT,
      QUOTED1, QUOTED2,
      LIST
    ])
  };
};
},{}],37:[function(require,module,exports){
module.exports = function(hljs) {
  var OPENING_LONG_BRACKET = '\\[=*\\[';
  var CLOSING_LONG_BRACKET = '\\]=*\\]';
  var LONG_BRACKETS = {
    begin: OPENING_LONG_BRACKET, end: CLOSING_LONG_BRACKET,
    contains: ['self']
  };
  var COMMENTS = [
    {
      className: 'comment',
      begin: '--(?!' + OPENING_LONG_BRACKET + ')', end: '$'
    },
    {
      className: 'comment',
      begin: '--' + OPENING_LONG_BRACKET, end: CLOSING_LONG_BRACKET,
      contains: [LONG_BRACKETS],
      relevance: 10
    }
  ]
  return {
    lexems: hljs.UNDERSCORE_IDENT_RE,
    keywords: {
      keyword:
        'and break do else elseif end false for if in local nil not or repeat return then ' +
        'true until while',
      built_in:
        '_G _VERSION assert collectgarbage dofile error getfenv getmetatable ipairs load ' +
        'loadfile loadstring module next pairs pcall print rawequal rawget rawset require ' +
        'select setfenv setmetatable tonumber tostring type unpack xpcall coroutine debug ' +
        'io math os package string table'
    },
    contains: COMMENTS.concat([
      {
        className: 'function',
        beginWithKeyword: true, end: '\\)',
        keywords: 'function',
        contains: [
          {
            className: 'title',
            begin: '([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*'
          },
          {
            className: 'params',
            begin: '\\(', endsWithParent: true,
            contains: COMMENTS
          }
        ].concat(COMMENTS)
      },
      hljs.C_NUMBER_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: OPENING_LONG_BRACKET, end: CLOSING_LONG_BRACKET,
        contains: [LONG_BRACKETS],
        relevance: 10
      }
    ])
  };
};
},{}],38:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    contains: [
      // highlight headers
      {
        className: 'header',
        begin: '^#{1,3}', end: '$'
      },
      {
        className: 'header',
        begin: '^.+?\\n[=-]{2,}$'
      },
      // inline html
      {
        begin: '<', end: '>',
        subLanguage: 'xml',
        relevance: 0
      },
      // lists (indicators only)
      {
        className: 'bullet',
        begin: '^([*+-]|(\\d+\\.))\\s+'
      },
      // strong segments
      {
        className: 'strong',
        begin: '[*_]{2}.+?[*_]{2}'
      },
      // emphasis segments
      {
        className: 'emphasis',
        begin: '\\*.+?\\*'
      },
      {
        className: 'emphasis',
        begin: '_.+?_',
        relevance: 0
      },
      // blockquotes
      {
        className: 'blockquote',
        begin: '^>\\s+', end: '$'
      },
      // code snippets
      {
        className: 'code',
        begin: '`.+?`'
      },
      {
        className: 'code',
        begin: '^    ', end: '$',
        relevance: 0
      },
      // horizontal rules
      {
        className: 'horizontal_rule',
        begin: '^-{3,}', end: '$'
      },
      // using links - title and link
      {
        begin: '\\[.+?\\]\\(.+?\\)',
        returnBegin: true,
        contains: [
          {
            className: 'link_label',
            begin: '\\[.+\\]'
          },
          {
            className: 'link_url',
            begin: '\\(', end: '\\)',
            excludeBegin: true, excludeEnd: true
          }
        ]
      }
    ]
  };
};
},{}],39:[function(require,module,exports){
module.exports = function(hljs) {

  var COMMON_CONTAINS = [
    hljs.C_NUMBER_MODE,
    {
      className: 'string',
      begin: '\'', end: '\'',
      contains: [hljs.BACKSLASH_ESCAPE, {begin: '\'\''}],
      relevance: 0
    }
  ];

  return {
    keywords: {
      keyword:
        'break case catch classdef continue else elseif end enumerated events for function ' +
        'global if methods otherwise parfor persistent properties return spmd switch try while',
      built_in:
        'sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan ' +
        'atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot ' +
        'cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog ' +
        'realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal ' +
        'cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli ' +
        'besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma ' +
        'gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms ' +
        'nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones ' +
        'eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ' +
        'ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril ' +
        'triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute ' +
        'shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i inf nan ' +
        'isnan isinf isfinite j why compan gallery hadamard hankel hilb invhilb magic pascal ' +
        'rosser toeplitz vander wilkinson'
    },
    illegal: '(//|"|#|/\\*|\\s+/\\w+)',
    contains: [
      {
        className: 'function',
        beginWithKeyword: true, end: '$',
        keywords: 'function',
        contains: [
          {
              className: 'title',
              begin: hljs.UNDERSCORE_IDENT_RE
          },
          {
              className: 'params',
              begin: '\\(', end: '\\)'
          },
          {
              className: 'params',
              begin: '\\[', end: '\\]'
          }
        ]
      },
      {
        className: 'transposed_variable',
        begin: '[a-zA-Z_][a-zA-Z_0-9]*(\'+[\\.\']*|[\\.\']+)', end: ''
      },
      {
        className: 'matrix',
        begin: '\\[', end: '\\]\'*[\\.\']*',
        contains: COMMON_CONTAINS
      },
      {
        className: 'cell',
        begin: '\\{', end: '\\}\'*[\\.\']*',
        contains: COMMON_CONTAINS
      },
      {
        className: 'comment',
        begin: '\\%', end: '$'
      }
    ].concat(COMMON_CONTAINS)
  };
};
},{}],40:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords:
      'int float string vector matrix if else switch case default while do for in break ' +
      'continue global proc return about abs addAttr addAttributeEditorNodeHelp addDynamic ' +
      'addNewShelfTab addPP addPanelCategory addPrefixToName advanceToNextDrivenKey ' +
      'affectedNet affects aimConstraint air alias aliasAttr align alignCtx alignCurve ' +
      'alignSurface allViewFit ambientLight angle angleBetween animCone animCurveEditor ' +
      'animDisplay animView annotate appendStringArray applicationName applyAttrPreset ' +
      'applyTake arcLenDimContext arcLengthDimension arclen arrayMapper art3dPaintCtx ' +
      'artAttrCtx artAttrPaintVertexCtx artAttrSkinPaintCtx artAttrTool artBuildPaintMenu ' +
      'artFluidAttrCtx artPuttyCtx artSelectCtx artSetPaintCtx artUserPaintCtx assignCommand ' +
      'assignInputDevice assignViewportFactories attachCurve attachDeviceAttr attachSurface ' +
      'attrColorSliderGrp attrCompatibility attrControlGrp attrEnumOptionMenu ' +
      'attrEnumOptionMenuGrp attrFieldGrp attrFieldSliderGrp attrNavigationControlGrp ' +
      'attrPresetEditWin attributeExists attributeInfo attributeMenu attributeQuery ' +
      'autoKeyframe autoPlace bakeClip bakeFluidShading bakePartialHistory bakeResults ' +
      'bakeSimulation basename basenameEx batchRender bessel bevel bevelPlus binMembership ' +
      'bindSkin blend2 blendShape blendShapeEditor blendShapePanel blendTwoAttr blindDataType ' +
      'boneLattice boundary boxDollyCtx boxZoomCtx bufferCurve buildBookmarkMenu ' +
      'buildKeyframeMenu button buttonManip CBG cacheFile cacheFileCombine cacheFileMerge ' +
      'cacheFileTrack camera cameraView canCreateManip canvas capitalizeString catch ' +
      'catchQuiet ceil changeSubdivComponentDisplayLevel changeSubdivRegion channelBox ' +
      'character characterMap characterOutlineEditor characterize chdir checkBox checkBoxGrp ' +
      'checkDefaultRenderGlobals choice circle circularFillet clamp clear clearCache clip ' +
      'clipEditor clipEditorCurrentTimeCtx clipSchedule clipSchedulerOutliner clipTrimBefore ' +
      'closeCurve closeSurface cluster cmdFileOutput cmdScrollFieldExecuter ' +
      'cmdScrollFieldReporter cmdShell coarsenSubdivSelectionList collision color ' +
      'colorAtPoint colorEditor colorIndex colorIndexSliderGrp colorSliderButtonGrp ' +
      'colorSliderGrp columnLayout commandEcho commandLine commandPort compactHairSystem ' +
      'componentEditor compositingInterop computePolysetVolume condition cone confirmDialog ' +
      'connectAttr connectControl connectDynamic connectJoint connectionInfo constrain ' +
      'constrainValue constructionHistory container containsMultibyte contextInfo control ' +
      'convertFromOldLayers convertIffToPsd convertLightmap convertSolidTx convertTessellation ' +
      'convertUnit copyArray copyFlexor copyKey copySkinWeights cos cpButton cpCache ' +
      'cpClothSet cpCollision cpConstraint cpConvClothToMesh cpForces cpGetSolverAttr cpPanel ' +
      'cpProperty cpRigidCollisionFilter cpSeam cpSetEdit cpSetSolverAttr cpSolver ' +
      'cpSolverTypes cpTool cpUpdateClothUVs createDisplayLayer createDrawCtx createEditor ' +
      'createLayeredPsdFile createMotionField createNewShelf createNode createRenderLayer ' +
      'createSubdivRegion cross crossProduct ctxAbort ctxCompletion ctxEditMode ctxTraverse ' +
      'currentCtx currentTime currentTimeCtx currentUnit currentUnit curve curveAddPtCtx ' +
      'curveCVCtx curveEPCtx curveEditorCtx curveIntersect curveMoveEPCtx curveOnSurface ' +
      'curveSketchCtx cutKey cycleCheck cylinder dagPose date defaultLightListCheckBox ' +
      'defaultNavigation defineDataServer defineVirtualDevice deformer deg_to_rad delete ' +
      'deleteAttr deleteShadingGroupsAndMaterials deleteShelfTab deleteUI deleteUnusedBrushes ' +
      'delrandstr detachCurve detachDeviceAttr detachSurface deviceEditor devicePanel dgInfo ' +
      'dgdirty dgeval dgtimer dimWhen directKeyCtx directionalLight dirmap dirname disable ' +
      'disconnectAttr disconnectJoint diskCache displacementToPoly displayAffected ' +
      'displayColor displayCull displayLevelOfDetail displayPref displayRGBColor ' +
      'displaySmoothness displayStats displayString displaySurface distanceDimContext ' +
      'distanceDimension doBlur dolly dollyCtx dopeSheetEditor dot dotProduct ' +
      'doubleProfileBirailSurface drag dragAttrContext draggerContext dropoffLocator ' +
      'duplicate duplicateCurve duplicateSurface dynCache dynControl dynExport dynExpression ' +
      'dynGlobals dynPaintEditor dynParticleCtx dynPref dynRelEdPanel dynRelEditor ' +
      'dynamicLoad editAttrLimits editDisplayLayerGlobals editDisplayLayerMembers ' +
      'editRenderLayerAdjustment editRenderLayerGlobals editRenderLayerMembers editor ' +
      'editorTemplate effector emit emitter enableDevice encodeString endString endsWith env ' +
      'equivalent equivalentTol erf error eval eval evalDeferred evalEcho event ' +
      'exactWorldBoundingBox exclusiveLightCheckBox exec executeForEachObject exists exp ' +
      'expression expressionEditorListen extendCurve extendSurface extrude fcheck fclose feof ' +
      'fflush fgetline fgetword file fileBrowserDialog fileDialog fileExtension fileInfo ' +
      'filetest filletCurve filter filterCurve filterExpand filterStudioImport ' +
      'findAllIntersections findAnimCurves findKeyframe findMenuItem findRelatedSkinCluster ' +
      'finder firstParentOf fitBspline flexor floatEq floatField floatFieldGrp floatScrollBar ' +
      'floatSlider floatSlider2 floatSliderButtonGrp floatSliderGrp floor flow fluidCacheInfo ' +
      'fluidEmitter fluidVoxelInfo flushUndo fmod fontDialog fopen formLayout format fprint ' +
      'frameLayout fread freeFormFillet frewind fromNativePath fwrite gamma gauss ' +
      'geometryConstraint getApplicationVersionAsFloat getAttr getClassification ' +
      'getDefaultBrush getFileList getFluidAttr getInputDeviceRange getMayaPanelTypes ' +
      'getModifiers getPanel getParticleAttr getPluginResource getenv getpid glRender ' +
      'glRenderEditor globalStitch gmatch goal gotoBindPose grabColor gradientControl ' +
      'gradientControlNoAttr graphDollyCtx graphSelectContext graphTrackCtx gravity grid ' +
      'gridLayout group groupObjectsByName HfAddAttractorToAS HfAssignAS HfBuildEqualMap ' +
      'HfBuildFurFiles HfBuildFurImages HfCancelAFR HfConnectASToHF HfCreateAttractor ' +
      'HfDeleteAS HfEditAS HfPerformCreateAS HfRemoveAttractorFromAS HfSelectAttached ' +
      'HfSelectAttractors HfUnAssignAS hardenPointCurve hardware hardwareRenderPanel ' +
      'headsUpDisplay headsUpMessage help helpLine hermite hide hilite hitTest hotBox hotkey ' +
      'hotkeyCheck hsv_to_rgb hudButton hudSlider hudSliderButton hwReflectionMap hwRender ' +
      'hwRenderLoad hyperGraph hyperPanel hyperShade hypot iconTextButton iconTextCheckBox ' +
      'iconTextRadioButton iconTextRadioCollection iconTextScrollList iconTextStaticLabel ' +
      'ikHandle ikHandleCtx ikHandleDisplayScale ikSolver ikSplineHandleCtx ikSystem ' +
      'ikSystemInfo ikfkDisplayMethod illustratorCurves image imfPlugins inheritTransform ' +
      'insertJoint insertJointCtx insertKeyCtx insertKnotCurve insertKnotSurface instance ' +
      'instanceable instancer intField intFieldGrp intScrollBar intSlider intSliderGrp ' +
      'interToUI internalVar intersect iprEngine isAnimCurve isConnected isDirty isParentOf ' +
      'isSameObject isTrue isValidObjectName isValidString isValidUiName isolateSelect ' +
      'itemFilter itemFilterAttr itemFilterRender itemFilterType joint jointCluster jointCtx ' +
      'jointDisplayScale jointLattice keyTangent keyframe keyframeOutliner ' +
      'keyframeRegionCurrentTimeCtx keyframeRegionDirectKeyCtx keyframeRegionDollyCtx ' +
      'keyframeRegionInsertKeyCtx keyframeRegionMoveKeyCtx keyframeRegionScaleKeyCtx ' +
      'keyframeRegionSelectKeyCtx keyframeRegionSetKeyCtx keyframeRegionTrackCtx ' +
      'keyframeStats lassoContext lattice latticeDeformKeyCtx launch launchImageEditor ' +
      'layerButton layeredShaderPort layeredTexturePort layout layoutDialog lightList ' +
      'lightListEditor lightListPanel lightlink lineIntersection linearPrecision linstep ' +
      'listAnimatable listAttr listCameras listConnections listDeviceAttachments listHistory ' +
      'listInputDeviceAxes listInputDeviceButtons listInputDevices listMenuAnnotation ' +
      'listNodeTypes listPanelCategories listRelatives listSets listTransforms ' +
      'listUnselected listerEditor loadFluid loadNewShelf loadPlugin ' +
      'loadPluginLanguageResources loadPrefObjects localizedPanelLabel lockNode loft log ' +
      'longNameOf lookThru ls lsThroughFilter lsType lsUI Mayatomr mag makeIdentity makeLive ' +
      'makePaintable makeRoll makeSingleSurface makeTubeOn makebot manipMoveContext ' +
      'manipMoveLimitsCtx manipOptions manipRotateContext manipRotateLimitsCtx ' +
      'manipScaleContext manipScaleLimitsCtx marker match max memory menu menuBarLayout ' +
      'menuEditor menuItem menuItemToShelf menuSet menuSetPref messageLine min minimizeApp ' +
      'mirrorJoint modelCurrentTimeCtx modelEditor modelPanel mouse movIn movOut move ' +
      'moveIKtoFK moveKeyCtx moveVertexAlongDirection multiProfileBirailSurface mute ' +
      'nParticle nameCommand nameField namespace namespaceInfo newPanelItems newton nodeCast ' +
      'nodeIconButton nodeOutliner nodePreset nodeType noise nonLinear normalConstraint ' +
      'normalize nurbsBoolean nurbsCopyUVSet nurbsCube nurbsEditUV nurbsPlane nurbsSelect ' +
      'nurbsSquare nurbsToPoly nurbsToPolygonsPref nurbsToSubdiv nurbsToSubdivPref ' +
      'nurbsUVSet nurbsViewDirectionVector objExists objectCenter objectLayer objectType ' +
      'objectTypeUI obsoleteProc oceanNurbsPreviewPlane offsetCurve offsetCurveOnSurface ' +
      'offsetSurface openGLExtension openMayaPref optionMenu optionMenuGrp optionVar orbit ' +
      'orbitCtx orientConstraint outlinerEditor outlinerPanel overrideModifier ' +
      'paintEffectsDisplay pairBlend palettePort paneLayout panel panelConfiguration ' +
      'panelHistory paramDimContext paramDimension paramLocator parent parentConstraint ' +
      'particle particleExists particleInstancer particleRenderInfo partition pasteKey ' +
      'pathAnimation pause pclose percent performanceOptions pfxstrokes pickWalk picture ' +
      'pixelMove planarSrf plane play playbackOptions playblast plugAttr plugNode pluginInfo ' +
      'pluginResourceUtil pointConstraint pointCurveConstraint pointLight pointMatrixMult ' +
      'pointOnCurve pointOnSurface pointPosition poleVectorConstraint polyAppend ' +
      'polyAppendFacetCtx polyAppendVertex polyAutoProjection polyAverageNormal ' +
      'polyAverageVertex polyBevel polyBlendColor polyBlindData polyBoolOp polyBridgeEdge ' +
      'polyCacheMonitor polyCheck polyChipOff polyClipboard polyCloseBorder polyCollapseEdge ' +
      'polyCollapseFacet polyColorBlindData polyColorDel polyColorPerVertex polyColorSet ' +
      'polyCompare polyCone polyCopyUV polyCrease polyCreaseCtx polyCreateFacet ' +
      'polyCreateFacetCtx polyCube polyCut polyCutCtx polyCylinder polyCylindricalProjection ' +
      'polyDelEdge polyDelFacet polyDelVertex polyDuplicateAndConnect polyDuplicateEdge ' +
      'polyEditUV polyEditUVShell polyEvaluate polyExtrudeEdge polyExtrudeFacet ' +
      'polyExtrudeVertex polyFlipEdge polyFlipUV polyForceUV polyGeoSampler polyHelix ' +
      'polyInfo polyInstallAction polyLayoutUV polyListComponentConversion polyMapCut ' +
      'polyMapDel polyMapSew polyMapSewMove polyMergeEdge polyMergeEdgeCtx polyMergeFacet ' +
      'polyMergeFacetCtx polyMergeUV polyMergeVertex polyMirrorFace polyMoveEdge ' +
      'polyMoveFacet polyMoveFacetUV polyMoveUV polyMoveVertex polyNormal polyNormalPerVertex ' +
      'polyNormalizeUV polyOptUvs polyOptions polyOutput polyPipe polyPlanarProjection ' +
      'polyPlane polyPlatonicSolid polyPoke polyPrimitive polyPrism polyProjection ' +
      'polyPyramid polyQuad polyQueryBlindData polyReduce polySelect polySelectConstraint ' +
      'polySelectConstraintMonitor polySelectCtx polySelectEditCtx polySeparate ' +
      'polySetToFaceNormal polySewEdge polyShortestPathCtx polySmooth polySoftEdge ' +
      'polySphere polySphericalProjection polySplit polySplitCtx polySplitEdge polySplitRing ' +
      'polySplitVertex polyStraightenUVBorder polySubdivideEdge polySubdivideFacet ' +
      'polyToSubdiv polyTorus polyTransfer polyTriangulate polyUVSet polyUnite polyWedgeFace ' +
      'popen popupMenu pose pow preloadRefEd print progressBar progressWindow projFileViewer ' +
      'projectCurve projectTangent projectionContext projectionManip promptDialog propModCtx ' +
      'propMove psdChannelOutliner psdEditTextureFile psdExport psdTextureFile putenv pwd ' +
      'python querySubdiv quit rad_to_deg radial radioButton radioButtonGrp radioCollection ' +
      'radioMenuItemCollection rampColorPort rand randomizeFollicles randstate rangeControl ' +
      'readTake rebuildCurve rebuildSurface recordAttr recordDevice redo reference ' +
      'referenceEdit referenceQuery refineSubdivSelectionList refresh refreshAE ' +
      'registerPluginResource rehash reloadImage removeJoint removeMultiInstance ' +
      'removePanelCategory rename renameAttr renameSelectionList renameUI render ' +
      'renderGlobalsNode renderInfo renderLayerButton renderLayerParent ' +
      'renderLayerPostProcess renderLayerUnparent renderManip renderPartition ' +
      'renderQualityNode renderSettings renderThumbnailUpdate renderWindowEditor ' +
      'renderWindowSelectContext renderer reorder reorderDeformers requires reroot ' +
      'resampleFluid resetAE resetPfxToPolyCamera resetTool resolutionNode retarget ' +
      'reverseCurve reverseSurface revolve rgb_to_hsv rigidBody rigidSolver roll rollCtx ' +
      'rootOf rot rotate rotationInterpolation roundConstantRadius rowColumnLayout rowLayout ' +
      'runTimeCommand runup sampleImage saveAllShelves saveAttrPreset saveFluid saveImage ' +
      'saveInitialState saveMenu savePrefObjects savePrefs saveShelf saveToolSettings scale ' +
      'scaleBrushBrightness scaleComponents scaleConstraint scaleKey scaleKeyCtx sceneEditor ' +
      'sceneUIReplacement scmh scriptCtx scriptEditorInfo scriptJob scriptNode scriptTable ' +
      'scriptToShelf scriptedPanel scriptedPanelType scrollField scrollLayout sculpt ' +
      'searchPathArray seed selLoadSettings select selectContext selectCurveCV selectKey ' +
      'selectKeyCtx selectKeyframeRegionCtx selectMode selectPref selectPriority selectType ' +
      'selectedNodes selectionConnection separator setAttr setAttrEnumResource ' +
      'setAttrMapping setAttrNiceNameResource setConstraintRestPosition ' +
      'setDefaultShadingGroup setDrivenKeyframe setDynamic setEditCtx setEditor setFluidAttr ' +
      'setFocus setInfinity setInputDeviceMapping setKeyCtx setKeyPath setKeyframe ' +
      'setKeyframeBlendshapeTargetWts setMenuMode setNodeNiceNameResource setNodeTypeFlag ' +
      'setParent setParticleAttr setPfxToPolyCamera setPluginResource setProject ' +
      'setStampDensity setStartupMessage setState setToolTo setUITemplate setXformManip sets ' +
      'shadingConnection shadingGeometryRelCtx shadingLightRelCtx shadingNetworkCompare ' +
      'shadingNode shapeCompare shelfButton shelfLayout shelfTabLayout shellField ' +
      'shortNameOf showHelp showHidden showManipCtx showSelectionInTitle ' +
      'showShadingGroupAttrEditor showWindow sign simplify sin singleProfileBirailSurface ' +
      'size sizeBytes skinCluster skinPercent smoothCurve smoothTangentSurface smoothstep ' +
      'snap2to2 snapKey snapMode snapTogetherCtx snapshot soft softMod softModCtx sort sound ' +
      'soundControl source spaceLocator sphere sphrand spotLight spotLightPreviewPort ' +
      'spreadSheetEditor spring sqrt squareSurface srtContext stackTrace startString ' +
      'startsWith stitchAndExplodeShell stitchSurface stitchSurfacePoints strcmp ' +
      'stringArrayCatenate stringArrayContains stringArrayCount stringArrayInsertAtIndex ' +
      'stringArrayIntersector stringArrayRemove stringArrayRemoveAtIndex ' +
      'stringArrayRemoveDuplicates stringArrayRemoveExact stringArrayToString ' +
      'stringToStringArray strip stripPrefixFromName stroke subdAutoProjection ' +
      'subdCleanTopology subdCollapse subdDuplicateAndConnect subdEditUV ' +
      'subdListComponentConversion subdMapCut subdMapSewMove subdMatchTopology subdMirror ' +
      'subdToBlind subdToPoly subdTransferUVsToCache subdiv subdivCrease ' +
      'subdivDisplaySmoothness substitute substituteAllString substituteGeometry substring ' +
      'surface surfaceSampler surfaceShaderList swatchDisplayPort switchTable symbolButton ' +
      'symbolCheckBox sysFile system tabLayout tan tangentConstraint texLatticeDeformContext ' +
      'texManipContext texMoveContext texMoveUVShellContext texRotateContext texScaleContext ' +
      'texSelectContext texSelectShortestPathCtx texSmudgeUVContext texWinToolCtx text ' +
      'textCurves textField textFieldButtonGrp textFieldGrp textManip textScrollList ' +
      'textToShelf textureDisplacePlane textureHairColor texturePlacementContext ' +
      'textureWindow threadCount threePointArcCtx timeControl timePort timerX toNativePath ' +
      'toggle toggleAxis toggleWindowVisibility tokenize tokenizeList tolerance tolower ' +
      'toolButton toolCollection toolDropped toolHasOptions toolPropertyWindow torus toupper ' +
      'trace track trackCtx transferAttributes transformCompare transformLimits translator ' +
      'trim trunc truncateFluidCache truncateHairCache tumble tumbleCtx turbulence ' +
      'twoPointArcCtx uiRes uiTemplate unassignInputDevice undo undoInfo ungroup uniform unit ' +
      'unloadPlugin untangleUV untitledFileName untrim upAxis updateAE userCtx uvLink ' +
      'uvSnapshot validateShelfName vectorize view2dToolCtx viewCamera viewClipPlane ' +
      'viewFit viewHeadOn viewLookAt viewManip viewPlace viewSet visor volumeAxis vortex ' +
      'waitCursor warning webBrowser webBrowserPrefs whatIs window windowPref wire ' +
      'wireContext workspace wrinkle wrinkleContext writeTake xbmLangPathList xform',
    illegal: '</',
    contains: [
      hljs.C_NUMBER_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: '`', end: '`',
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        className: 'variable',
        begin: '\\$\\d',
        relevance: 5
      },
      {
        className: 'variable',
        begin: '[\\$\\%\\@\\*](\\^\\w\\b|#\\w+|[^\\s\\w{]|{\\w+}|\\w+)'
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE
    ]
  };
};
},{}],41:[function(require,module,exports){
module.exports = function(hljs) {
  var VARS = [
    {
      className: 'variable', begin: '\\$\\d+'
    },
    {
      className: 'variable', begin: '\\${', end: '}'
    },
    {
      className: 'variable', begin: '[\\$\\@]' + hljs.UNDERSCORE_IDENT_RE
    }
  ];
  var DEFAULT = {
    endsWithParent: true,
    lexems: '[a-z/_]+',
    keywords: {
      built_in:
        'on off yes no true false none blocked debug info notice warn error crit ' +
        'select break last permanent redirect kqueue rtsig epoll poll /dev/poll'
    },
    relevance: 0,
    illegal: '=>',
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        className: 'string',
        begin: '"', end: '"',
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS),
        relevance: 0
      },
      {
        className: 'string',
        begin: "'", end: "'",
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS),
        relevance: 0
      },
      {
        className: 'url',
        begin: '([a-z]+):/', end: '\\s', endsWithParent: true, excludeEnd: true
      },
      {
        className: 'regexp',
        begin: "\\s\\^", end: "\\s|{|;", returnEnd: true,
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS)
      },
      // regexp locations (~, ~*)
      {
        className: 'regexp',
        begin: "~\\*?\\s+", end: "\\s|{|;", returnEnd: true,
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS)
      },
      // *.example.com
      {
        className: 'regexp',
        begin: "\\*(\\.[a-z\\-]+)+",
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS)
      },
      // sub.example.*
      {
        className: 'regexp',
        begin: "([a-z\\-]+\\.)+\\*",
        contains: [hljs.BACKSLASH_ESCAPE].concat(VARS)
      },
      // IP
      {
        className: 'number',
        begin: '\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b'
      },
      // units
      {
        className: 'number',
        begin: '\\b\\d+[kKmMgGdshdwy]*\\b',
        relevance: 0
      }
    ].concat(VARS)
  };

  return {
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        begin: hljs.UNDERSCORE_IDENT_RE + '\\s', end: ';|{', returnBegin: true,
        contains: [
          {
            className: 'title',
            begin: hljs.UNDERSCORE_IDENT_RE,
            starts: DEFAULT
          }
        ]
      }
    ],
    illegal: '[^\\s\\}]'
  };
};
},{}],42:[function(require,module,exports){
module.exports = function(hljs) {
  var OBJC_KEYWORDS = {
    keyword:
      'int float while private char catch export sizeof typedef const struct for union ' +
      'unsigned long volatile static protected bool mutable if public do return goto void ' +
      'enum else break extern class asm case short default double throw register explicit ' +
      'signed typename try this switch continue wchar_t inline readonly assign property ' +
      'protocol self synchronized end synthesize id optional required implementation ' +
      'nonatomic interface super unichar finally dynamic IBOutlet IBAction selector strong ' +
      'weak readonly',
    literal:
    	'false true FALSE TRUE nil YES NO NULL',
    built_in:
      'NSString NSDictionary CGRect CGPoint UIButton UILabel UITextView UIWebView MKMapView ' +
      'UISegmentedControl NSObject UITableViewDelegate UITableViewDataSource NSThread ' +
      'UIActivityIndicator UITabbar UIToolBar UIBarButtonItem UIImageView NSAutoreleasePool ' +
      'UITableView BOOL NSInteger CGFloat NSException NSLog NSMutableString NSMutableArray ' +
      'NSMutableDictionary NSURL NSIndexPath CGSize UITableViewCell UIView UIViewController ' +
      'UINavigationBar UINavigationController UITabBarController UIPopoverController ' +
      'UIPopoverControllerDelegate UIImage NSNumber UISearchBar NSFetchedResultsController ' +
      'NSFetchedResultsChangeType UIScrollView UIScrollViewDelegate UIEdgeInsets UIColor ' +
      'UIFont UIApplication NSNotFound NSNotificationCenter NSNotification ' +
      'UILocalNotification NSBundle NSFileManager NSTimeInterval NSDate NSCalendar ' +
      'NSUserDefaults UIWindow NSRange NSArray NSError NSURLRequest NSURLConnection class ' +
      'UIInterfaceOrientation MPMoviePlayerController dispatch_once_t ' +
      'dispatch_queue_t dispatch_sync dispatch_async dispatch_once'
  };
  return {
    keywords: OBJC_KEYWORDS,
    illegal: '</',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'string',
        begin: '\'',
        end: '[^\\\\]\'',
        illegal: '[^\\\\][^\']'
      },

      {
        className: 'preprocessor',
        begin: '#import',
        end: '$',
        contains: [
        {
          className: 'title',
          begin: '\"',
          end: '\"'
        },
        {
          className: 'title',
          begin: '<',
          end: '>'
        }
        ]
      },
      {
        className: 'preprocessor',
        begin: '#',
        end: '$'
      },
      {
        className: 'class',
        beginWithKeyword: true,
        end: '({|$)',
        keywords: 'interface class protocol implementation',
        contains: [{
          className: 'id',
          begin: hljs.UNDERSCORE_IDENT_RE
        }
        ]
      },
      {
        className: 'variable',
        begin: '\\.'+hljs.UNDERSCORE_IDENT_RE
      }
    ]
  };
};
},{}],43:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    subLanguage: 'xml',
    contains: [
      {
        className: 'comment',
        begin: '^#', end: '$'
      },
      {
        className: 'comment',
        begin: '\\^rem{', end: '}',
        relevance: 10,
        contains: [
          {
            begin: '{', end: '}',
            contains: ['self']
          }
        ]
      },
      {
        className: 'preprocessor',
        begin: '^@(?:BASE|USE|CLASS|OPTIONS)$',
        relevance: 10
      },
      {
        className: 'title',
        begin: '@[\\w\\-]+\\[[\\w^;\\-]*\\](?:\\[[\\w^;\\-]*\\])?(?:.*)$'
      },
      {
        className: 'variable',
        begin: '\\$\\{?[\\w\\-\\.\\:]+\\}?'
      },
      {
        className: 'keyword',
        begin: '\\^[\\w\\-\\.\\:]+'
      },
      {
        className: 'number',
        begin: '\\^#[0-9a-fA-F]+'
      },
      hljs.C_NUMBER_MODE
    ]
  };
};
},{}],44:[function(require,module,exports){
module.exports = function(hljs) {
  var PERL_KEYWORDS = 'getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ' +
    'ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime ' +
    'readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qq' +
    'fileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent ' +
    'shutdown dump chomp connect getsockname die socketpair close flock exists index shmget' +
    'sub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr ' +
    'unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 ' +
    'getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline ' +
    'endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand ' +
    'mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink ' +
    'getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr ' +
    'untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link ' +
    'getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller ' +
    'lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and ' +
    'sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 ' +
    'chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach ' +
    'tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedir' +
    'ioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe ' +
    'atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when';
  var SUBST = {
    className: 'subst',
    begin: '[$@]\\{', end: '\\}',
    keywords: PERL_KEYWORDS,
    relevance: 10
  };
  var VAR1 = {
    className: 'variable',
    begin: '\\$\\d'
  };
  var VAR2 = {
    className: 'variable',
    begin: '[\\$\\%\\@\\*](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|[^\\s\\w{]|{\\w+}|\\w+(\\:\\:\\w*)*)'
  };
  var STRING_CONTAINS = [hljs.BACKSLASH_ESCAPE, SUBST, VAR1, VAR2];
  var METHOD = {
    begin: '->',
    contains: [
      {begin: hljs.IDENT_RE},
      {begin: '{', end: '}'}
    ]
  };
  var COMMENT = {
    className: 'comment',
    begin: '^(__END__|__DATA__)', end: '\\n$',
    relevance: 5
  }
  var PERL_DEFAULT_CONTAINS = [
    VAR1, VAR2,
    hljs.HASH_COMMENT_MODE,
    COMMENT,
    {
      className: 'comment',
      begin: '^\\=\\w', end: '\\=cut', endsWithParent: true
    },
    METHOD,
    {
      className: 'string',
      begin: 'q[qwxr]?\\s*\\(', end: '\\)',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: 'q[qwxr]?\\s*\\[', end: '\\]',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: 'q[qwxr]?\\s*\\{', end: '\\}',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: 'q[qwxr]?\\s*\\|', end: '\\|',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: 'q[qwxr]?\\s*\\<', end: '\\>',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: 'qw\\s+q', end: 'q',
      contains: STRING_CONTAINS,
      relevance: 5
    },
    {
      className: 'string',
      begin: '\'', end: '\'',
      contains: [hljs.BACKSLASH_ESCAPE],
      relevance: 0
    },
    {
      className: 'string',
      begin: '"', end: '"',
      contains: STRING_CONTAINS,
      relevance: 0
    },
    {
      className: 'string',
      begin: '`', end: '`',
      contains: [hljs.BACKSLASH_ESCAPE]
    },
    {
      className: 'string',
      begin: '{\\w+}',
      relevance: 0
    },
    {
      className: 'string',
      begin: '\-?\\w+\\s*\\=\\>',
      relevance: 0
    },
    {
      className: 'number',
      begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
      relevance: 0
    },
    { // regexp container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
      keywords: 'split return print reverse grep',
      relevance: 0,
      contains: [
        hljs.HASH_COMMENT_MODE,
        COMMENT,
        {
          className: 'regexp',
          begin: '(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*',
          relevance: 10
        },
        {
          className: 'regexp',
          begin: '(m|qr)?/', end: '/[a-z]*',
          contains: [hljs.BACKSLASH_ESCAPE],
          relevance: 0 // allows empty "//" which is a common comment delimiter in other languages
        }
      ]
    },
    {
      className: 'sub',
      beginWithKeyword: true, end: '(\\s*\\(.*?\\))?[;{]',
      keywords: 'sub',
      relevance: 5
    },
    {
      className: 'operator',
      begin: '-\\w\\b',
      relevance: 0
    }
  ];
  SUBST.contains = PERL_DEFAULT_CONTAINS;
  METHOD.contains[1].contains = PERL_DEFAULT_CONTAINS;

  return {
    keywords: PERL_KEYWORDS,
    contains: PERL_DEFAULT_CONTAINS
  };
};
},{}],45:[function(require,module,exports){
module.exports = function(hljs) {
  var VARIABLE = {
    className: 'variable', begin: '\\$+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
  };
  var STRINGS = [
    hljs.inherit(hljs.APOS_STRING_MODE, {illegal: null}),
    hljs.inherit(hljs.QUOTE_STRING_MODE, {illegal: null}),
    {
      className: 'string',
      begin: 'b"', end: '"',
      contains: [hljs.BACKSLASH_ESCAPE]
    },
    {
      className: 'string',
      begin: 'b\'', end: '\'',
      contains: [hljs.BACKSLASH_ESCAPE]
    }
  ];
  var NUMBERS = [hljs.BINARY_NUMBER_MODE, hljs.C_NUMBER_MODE];
  var TITLE = {
    className: 'title', begin: hljs.UNDERSCORE_IDENT_RE
  };
  return {
    case_insensitive: true,
    keywords:
      'and include_once list abstract global private echo interface as static endswitch ' +
      'array null if endwhile or const for endforeach self var while isset public ' +
      'protected exit foreach throw elseif include __FILE__ empty require_once do xor ' +
      'return implements parent clone use __CLASS__ __LINE__ else break print eval new ' +
      'catch __METHOD__ case exception php_user_filter default die require __FUNCTION__ ' +
      'enddeclare final try this switch continue endfor endif declare unset true false ' +
      'namespace trait goto instanceof insteadof __DIR__ __NAMESPACE__ __halt_compiler',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.HASH_COMMENT_MODE,
      {
        className: 'comment',
        begin: '/\\*', end: '\\*/',
        contains: [{
            className: 'phpdoc',
            begin: '\\s@[A-Za-z]+'
        }]
      },
      {
          className: 'comment',
          excludeBegin: true,
          begin: '__halt_compiler.+?;', endsWithParent: true
      },
      {
        className: 'string',
        begin: '<<<[\'"]?\\w+[\'"]?$', end: '^\\w+;',
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        className: 'preprocessor',
        begin: '<\\?php',
        relevance: 10
      },
      {
        className: 'preprocessor',
        begin: '\\?>'
      },
      VARIABLE,
      {
        className: 'function',
        beginWithKeyword: true, end: '{',
        keywords: 'function',
        illegal: '\\$|\\[|%',
        contains: [
          TITLE,
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [
              'self',
              VARIABLE,
              hljs.C_BLOCK_COMMENT_MODE
            ].concat(STRINGS).concat(NUMBERS)
          }
        ]
      },
      {
        className: 'class',
        beginWithKeyword: true, end: '{',
        keywords: 'class',
        illegal: '[:\\(\\$]',
        contains: [
          {
            beginWithKeyword: true, endsWithParent: true,
            keywords: 'extends',
            contains: [TITLE]
          },
          TITLE
        ]
      },
      {
        begin: '=>' // No markup, just a relevance booster
      }
    ].concat(STRINGS).concat(NUMBERS)
  };
};
},{}],46:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    contains: [
      hljs.C_NUMBER_MODE,
      {
        className: 'builtin',
        begin: '{', end: '}$',
        excludeBegin: true, excludeEnd: true,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE],
        relevance: 0
      },
      {
        className: 'filename',
        begin: '[a-zA-Z_][\\da-zA-Z_]+\\.[\\da-zA-Z_]{1,3}', end: ':',
        excludeEnd: true
      },
      {
        className: 'header',
        begin: '(ncalls|tottime|cumtime)', end: '$',
        keywords: 'ncalls tottime|10 cumtime|10 filename',
        relevance: 10
      },
      {
        className: 'summary',
        begin: 'function calls', end: '$',
        contains: [hljs.C_NUMBER_MODE],
        relevance: 10
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'function',
        begin: '\\(', end: '\\)$',
        contains: [{
          className: 'title',
          begin: hljs.UNDERSCORE_IDENT_RE,
          relevance: 0
        }],
        relevance: 0
      }
    ]
  };
};
},{}],47:[function(require,module,exports){
module.exports = function(hljs) {
  var PROMPT = {
    className: 'prompt',  begin: '^(>>>|\\.\\.\\.) '
  }
  var STRINGS = [
    {
      className: 'string',
      begin: '(u|b)?r?\'\'\'', end: '\'\'\'',
      contains: [PROMPT],
      relevance: 10
    },
    {
      className: 'string',
      begin: '(u|b)?r?"""', end: '"""',
      contains: [PROMPT],
      relevance: 10
    },
    {
      className: 'string',
      begin: '(u|r|ur)\'', end: '\'',
      contains: [hljs.BACKSLASH_ESCAPE],
      relevance: 10
    },
    {
      className: 'string',
      begin: '(u|r|ur)"', end: '"',
      contains: [hljs.BACKSLASH_ESCAPE],
      relevance: 10
    },
    {
      className: 'string',
      begin: '(b|br)\'', end: '\'',
      contains: [hljs.BACKSLASH_ESCAPE]
    },
    {
      className: 'string',
      begin: '(b|br)"', end: '"',
      contains: [hljs.BACKSLASH_ESCAPE]
    }
  ].concat([
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ]);
  var TITLE = {
    className: 'title', begin: hljs.UNDERSCORE_IDENT_RE
  };
  var PARAMS = {
    className: 'params',
    begin: '\\(', end: '\\)',
    contains: ['self', hljs.C_NUMBER_MODE, PROMPT].concat(STRINGS)
  };
  var FUNC_CLASS_PROTO = {
    beginWithKeyword: true, end: ':',
    illegal: '[${=;\\n]',
    contains: [TITLE, PARAMS],
    relevance: 10
  };

  return {
    keywords: {
      keyword:
        'and elif is global as in if from raise for except finally print import pass return ' +
        'exec else break not with class assert yield try while continue del or def lambda ' +
        'nonlocal|10',
      built_in:
        'None True False Ellipsis NotImplemented'
    },
    illegal: '(</|->|\\?)',
    contains: STRINGS.concat([
      PROMPT,
      hljs.HASH_COMMENT_MODE,
      hljs.inherit(FUNC_CLASS_PROTO, {className: 'function', keywords: 'def'}),
      hljs.inherit(FUNC_CLASS_PROTO, {className: 'class', keywords: 'class'}),
      hljs.C_NUMBER_MODE,
      {
        className: 'decorator',
        begin: '@', end: '$'
      },
      {
        begin: '\\b(print|exec)\\(' // don’t highlight keywords-turned-functions in Python 3
      }
    ])
  };
};
},{}],48:[function(require,module,exports){
module.exports = function(hljs) {
  var IDENT_RE = '([a-zA-Z]|\\.[a-zA-Z.])[a-zA-Z0-9._]*';

  return {
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        begin: IDENT_RE,
        lexems: IDENT_RE,
        keywords: {
          keyword:
            'function if in break next repeat else for return switch while try tryCatch|10 ' +
            'stop warning require library attach detach source setMethod setGeneric ' +
            'setGroupGeneric setClass ...|10',
          literal:
            'NULL NA TRUE FALSE T F Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 ' +
            'NA_complex_|10'
        },
        relevance: 0
      },
      {
        // hex value
        className: 'number',
        begin: "0[xX][0-9a-fA-F]+[Li]?\\b",
        relevance: 0
      },
      {
        // explicit integer
        className: 'number',
        begin: "\\d+(?:[eE][+\\-]?\\d*)?L\\b",
        relevance: 0
      },
      {
        // number with trailing decimal
        className: 'number',
        begin: "\\d+\\.(?!\\d)(?:i\\b)?",
        relevance: 0
      },
      {
        // number
        className: 'number',
        begin: "\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",
        relevance: 0
      },
      {
        // number with leading decimal
        className: 'number',
        begin: "\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",
        relevance: 0
      },

      {
        // escaped identifier
        begin: '`',
        end: '`',
        relevance: 0
      },

      {
        className: 'string',
        begin: '"',
        end: '"',
        contains: [hljs.BACKSLASH_ESCAPE],
        relevance: 0
      },
      {
        className: 'string',
        begin: "'",
        end: "'",
        contains: [hljs.BACKSLASH_ESCAPE],
        relevance: 0
      }
    ]
  };
};
},{}],49:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords:
      'ArchiveRecord AreaLightSource Atmosphere Attribute AttributeBegin AttributeEnd Basis ' +
      'Begin Blobby Bound Clipping ClippingPlane Color ColorSamples ConcatTransform Cone ' +
      'CoordinateSystem CoordSysTransform CropWindow Curves Cylinder DepthOfField Detail ' +
      'DetailRange Disk Displacement Display End ErrorHandler Exposure Exterior Format ' +
      'FrameAspectRatio FrameBegin FrameEnd GeneralPolygon GeometricApproximation Geometry ' +
      'Hider Hyperboloid Identity Illuminate Imager Interior LightSource ' +
      'MakeCubeFaceEnvironment MakeLatLongEnvironment MakeShadow MakeTexture Matte ' +
      'MotionBegin MotionEnd NuPatch ObjectBegin ObjectEnd ObjectInstance Opacity Option ' +
      'Orientation Paraboloid Patch PatchMesh Perspective PixelFilter PixelSamples ' +
      'PixelVariance Points PointsGeneralPolygons PointsPolygons Polygon Procedural Projection ' +
      'Quantize ReadArchive RelativeDetail ReverseOrientation Rotate Scale ScreenWindow ' +
      'ShadingInterpolation ShadingRate Shutter Sides Skew SolidBegin SolidEnd Sphere ' +
      'SubdivisionMesh Surface TextureCoordinates Torus Transform TransformBegin TransformEnd ' +
      'TransformPoints Translate TrimCurve WorldBegin WorldEnd',
    illegal: '</',
    contains: [
      hljs.HASH_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };
};
},{}],50:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: {
      keyword:
        'float color point normal vector matrix while for if do return else break extern continue',
      built_in:
        'abs acos ambient area asin atan atmosphere attribute calculatenormal ceil cellnoise ' +
        'clamp comp concat cos degrees depth Deriv diffuse distance Du Dv environment exp ' +
        'faceforward filterstep floor format fresnel incident length lightsource log match ' +
        'max min mod noise normalize ntransform opposite option phong pnoise pow printf ' +
        'ptlined radians random reflect refract renderinfo round setcomp setxcomp setycomp ' +
        'setzcomp shadow sign sin smoothstep specular specularbrdf spline sqrt step tan ' +
        'texture textureinfo trace transform vtransform xcomp ycomp zcomp'
    },
    illegal: '</',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'preprocessor',
        begin: '#', end: '$'
      },
      {
        className: 'shader',
        beginWithKeyword: true, end: '\\(',
        keywords: 'surface displacement light volume imager'
      },
      {
        className: 'shading',
        beginWithKeyword: true, end: '\\(',
        keywords: 'illuminate illuminance gather'
      }
    ]
  };
};
},{}],51:[function(require,module,exports){
module.exports = function(hljs) {
  var RUBY_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*(\\!|\\?)?';
  var RUBY_METHOD_RE = '[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?';
  var RUBY_KEYWORDS = {
    keyword:
      'and false then defined module in return redo if BEGIN retry end for true self when ' +
      'next until do begin unless END rescue nil else break undef not super class case ' +
      'require yield alias while ensure elsif or include'
  };
  var YARDOCTAG = {
    className: 'yardoctag',
    begin: '@[A-Za-z]+'
  };
  var COMMENTS = [
    {
      className: 'comment',
      begin: '#', end: '$',
      contains: [YARDOCTAG]
    },
    {
      className: 'comment',
      begin: '^\\=begin', end: '^\\=end',
      contains: [YARDOCTAG],
      relevance: 10
    },
    {
      className: 'comment',
      begin: '^__END__', end: '\\n$'
    }
  ];
  var SUBST = {
    className: 'subst',
    begin: '#\\{', end: '}',
    lexems: RUBY_IDENT_RE,
    keywords: RUBY_KEYWORDS
  };
  var STR_CONTAINS = [hljs.BACKSLASH_ESCAPE, SUBST];
  var STRINGS = [
    {
      className: 'string',
      begin: '\'', end: '\'',
      contains: STR_CONTAINS,
      relevance: 0
    },
    {
      className: 'string',
      begin: '"', end: '"',
      contains: STR_CONTAINS,
      relevance: 0
    },
    {
      className: 'string',
      begin: '%[qw]?\\(', end: '\\)',
      contains: STR_CONTAINS
    },
    {
      className: 'string',
      begin: '%[qw]?\\[', end: '\\]',
      contains: STR_CONTAINS
    },
    {
      className: 'string',
      begin: '%[qw]?{', end: '}',
      contains: STR_CONTAINS
    },
    {
      className: 'string',
      begin: '%[qw]?<', end: '>',
      contains: STR_CONTAINS,
      relevance: 10
    },
    {
      className: 'string',
      begin: '%[qw]?/', end: '/',
      contains: STR_CONTAINS,
      relevance: 10
    },
    {
      className: 'string',
      begin: '%[qw]?%', end: '%',
      contains: STR_CONTAINS,
      relevance: 10
    },
    {
      className: 'string',
      begin: '%[qw]?-', end: '-',
      contains: STR_CONTAINS,
      relevance: 10
    },
    {
      className: 'string',
      begin: '%[qw]?\\|', end: '\\|',
      contains: STR_CONTAINS,
      relevance: 10
    }
  ];
  var FUNCTION = {
    className: 'function',
    beginWithKeyword: true, end: ' |$|;',
    keywords: 'def',
    contains: [
      {
        className: 'title',
        begin: RUBY_METHOD_RE,
        lexems: RUBY_IDENT_RE,
        keywords: RUBY_KEYWORDS
      },
      {
        className: 'params',
        begin: '\\(', end: '\\)',
        lexems: RUBY_IDENT_RE,
        keywords: RUBY_KEYWORDS
      }
    ].concat(COMMENTS)
  };

  var RUBY_DEFAULT_CONTAINS = COMMENTS.concat(STRINGS.concat([
    {
      className: 'class',
      beginWithKeyword: true, end: '$|;',
      keywords: 'class module',
      contains: [
        {
          className: 'title',
          begin: '[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?',
          relevance: 0
        },
        {
          className: 'inheritance',
          begin: '<\\s*',
          contains: [{
            className: 'parent',
            begin: '(' + hljs.IDENT_RE + '::)?' + hljs.IDENT_RE
          }]
        }
      ].concat(COMMENTS)
    },
    FUNCTION,
    {
      className: 'constant',
      begin: '(::)?(\\b[A-Z]\\w*(::)?)+',
      relevance: 0
    },
    {
      className: 'symbol',
      begin: ':',
      contains: STRINGS.concat([{begin: RUBY_METHOD_RE}]),
      relevance: 0
    },
    {
      className: 'symbol',
      begin: RUBY_IDENT_RE + ':',
      relevance: 0
    },
    {
      className: 'number',
      begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
      relevance: 0
    },
    {
      className: 'number',
      begin: '\\?\\w'
    },
    {
      className: 'variable',
      begin: '(\\$\\W)|((\\$|\\@\\@?)(\\w+))'
    },
    { // regexp container
      begin: '(' + hljs.RE_STARTERS_RE + ')\\s*',
      contains: COMMENTS.concat([
        {
          className: 'regexp',
          begin: '/', end: '/[a-z]*',
          illegal: '\\n',
          contains: [hljs.BACKSLASH_ESCAPE, SUBST]
        }
      ]),
      relevance: 0
    }
  ]));
  SUBST.contains = RUBY_DEFAULT_CONTAINS;
  FUNCTION.contains[1].contains = RUBY_DEFAULT_CONTAINS;

  return {
    lexems: RUBY_IDENT_RE,
    keywords: RUBY_KEYWORDS,
    contains: RUBY_DEFAULT_CONTAINS
  };
};
},{}],52:[function(require,module,exports){
module.exports = function(hljs) {
  var TITLE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE
  };
  var NUMBER = {
    className: 'number',
    begin: '\\b(0[xb][A-Za-z0-9_]+|[0-9_]+(\\.[0-9_]+)?([uif](8|16|32|64)?)?)',
    relevance: 0
  };
  var KEYWORDS =
    'alt any as assert be bind block bool break char check claim const cont dir do else enum ' +
    'export f32 f64 fail false float fn for i16 i32 i64 i8 if iface impl import in int let ' +
    'log mod mutable native note of prove pure resource ret self str syntax true type u16 u32 ' +
    'u64 u8 uint unchecked unsafe use vec while';
  return {
    keywords: KEYWORDS,
    illegal: '</',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.inherit(hljs.QUOTE_STRING_MODE, {illegal: null}),
      hljs.APOS_STRING_MODE,
      NUMBER,
      {
        className: 'function',
        beginWithKeyword: true, end: '(\\(|<)',
        keywords: 'fn',
        contains: [TITLE]
      },
      {
        className: 'preprocessor',
        begin: '#\\[', end: '\\]'
      },
      {
        beginWithKeyword: true, end: '(=|<)',
        keywords: 'type',
        contains: [TITLE],
        illegal: '\\S'
      },
      {
        beginWithKeyword: true, end: '({|<)',
        keywords: 'iface enum',
        contains: [TITLE],
        illegal: '\\S'
      }
    ]
  };
};
},{}],53:[function(require,module,exports){
module.exports = function(hljs) {
  var ANNOTATION = {
    className: 'annotation', begin: '@[A-Za-z]+'
  };
  var STRING = {
    className: 'string',
    begin: 'u?r?"""', end: '"""',
    relevance: 10
  };
  return {
    keywords:
      'type yield lazy override def with val var false true sealed abstract private trait ' +
      'object null if for while throw finally protected extends import final return else ' +
      'break new catch super class case package default try this match continue throws',
    contains: [
      {
        className: 'javadoc',
        begin: '/\\*\\*', end: '\\*/',
        contains: [{
          className: 'javadoctag',
          begin: '@[A-Za-z]+'
        }],
        relevance: 10
      },
      hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE,
      hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, STRING,
      {
        className: 'class',
        begin: '((case )?class |object |trait )', end: '({|$)', // beginWithKeyword won't work because a single "case" shouldn't start this mode
        illegal: ':',
        keywords: 'case class trait object',
        contains: [
          {
            beginWithKeyword: true,
            keywords: 'extends with',
            relevance: 10
          },
          {
            className: 'title',
            begin: hljs.UNDERSCORE_IDENT_RE
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [
              hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, STRING,
              ANNOTATION
            ]
          }
        ]
      },
      hljs.C_NUMBER_MODE,
      ANNOTATION
    ]
  };
};
},{}],54:[function(require,module,exports){
module.exports = function(hljs) {
  var VAR_IDENT_RE = '[a-z][a-zA-Z0-9_]*';
  var CHAR = {
    className: 'char',
    begin: '\\$.{1}'
  };
  var SYMBOL = {
    className: 'symbol',
    begin: '#' + hljs.UNDERSCORE_IDENT_RE
  };
  return {
    keywords: 'self super nil true false thisContext', // only 6
    contains: [
      {
        className: 'comment',
        begin: '"', end: '"',
        relevance: 0
      },
      hljs.APOS_STRING_MODE,
      {
        className: 'class',
        begin: '\\b[A-Z][A-Za-z0-9_]*',
        relevance: 0
      },
      {
        className: 'method',
        begin: VAR_IDENT_RE + ':'
      },
      hljs.C_NUMBER_MODE,
      SYMBOL,
      CHAR,
      {
        className: 'localvars',
        begin: '\\|\\s*((' + VAR_IDENT_RE + ')\\s*)+\\|'
      },
      {
        className: 'array',
        begin: '\\#\\(', end: '\\)',
        contains: [
          hljs.APOS_STRING_MODE,
          CHAR,
          hljs.C_NUMBER_MODE,
          SYMBOL
        ]
      }
    ]
  };
};
},{}],55:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    contains: [
      {
        className: 'operator',
        begin: '(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma|grant)\\b(?!:)', // negative look-ahead here is specifically to prevent stomping on SmallTalk
        end: ';', endsWithParent: true,
        keywords: {
          keyword: 'all partial global month current_timestamp using go revoke smallint ' +
            'indicator end-exec disconnect zone with character assertion to add current_user ' +
            'usage input local alter match collate real then rollback get read timestamp ' +
            'session_user not integer bit unique day minute desc insert execute like ilike|2 ' +
            'level decimal drop continue isolation found where constraints domain right ' +
            'national some module transaction relative second connect escape close system_user ' +
            'for deferred section cast current sqlstate allocate intersect deallocate numeric ' +
            'public preserve full goto initially asc no key output collation group by union ' +
            'session both last language constraint column of space foreign deferrable prior ' +
            'connection unknown action commit view or first into float year primary cascaded ' +
            'except restrict set references names table outer open select size are rows from ' +
            'prepare distinct leading create only next inner authorization schema ' +
            'corresponding option declare precision immediate else timezone_minute external ' +
            'varying translation true case exception join hour default double scroll value ' +
            'cursor descriptor values dec fetch procedure delete and false int is describe ' +
            'char as at in varchar null trailing any absolute current_time end grant ' +
            'privileges when cross check write current_date pad begin temporary exec time ' +
            'update catalog user sql date on identity timezone_hour natural whenever interval ' +
            'work order cascade diagnostics nchar having left call do handler load replace ' +
            'truncate start lock show pragma exists number',
          aggregate: 'count sum min max avg'
        },
        contains: [
          {
            className: 'string',
            begin: '\'', end: '\'',
            contains: [hljs.BACKSLASH_ESCAPE, {begin: '\'\''}],
            relevance: 0
          },
          {
            className: 'string',
            begin: '"', end: '"',
            contains: [hljs.BACKSLASH_ESCAPE, {begin: '""'}],
            relevance: 0
          },
          {
            className: 'string',
            begin: '`', end: '`',
            contains: [hljs.BACKSLASH_ESCAPE]
          },
          hljs.C_NUMBER_MODE
        ]
      },
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'comment',
        begin: '--', end: '$'
      }
    ]
  };
};
},{}],56:[function(require,module,exports){
module.exports = function(hljs) {
  var COMMAND1 = {
    className: 'command',
    begin: '\\\\[a-zA-Zа-яА-я]+[\\*]?'
  };
  var COMMAND2 = {
    className: 'command',
    begin: '\\\\[^a-zA-Zа-яА-я0-9]'
  };
  var SPECIAL = {
    className: 'special',
    begin: '[{}\\[\\]\\&#~]',
    relevance: 0
  };

  return {
    contains: [
      { // parameter
        begin: '\\\\[a-zA-Zа-яА-я]+[\\*]? *= *-?\\d*\\.?\\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?',
        returnBegin: true,
        contains: [
          COMMAND1, COMMAND2,
          {
            className: 'number',
            begin: ' *=', end: '-?\\d*\\.?\\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?',
            excludeBegin: true
          }
        ],
        relevance: 10
      },
      COMMAND1, COMMAND2,
      SPECIAL,
      {
        className: 'formula',
        begin: '\\$\\$', end: '\\$\\$',
        contains: [COMMAND1, COMMAND2, SPECIAL],
        relevance: 0
      },
      {
        className: 'formula',
        begin: '\\$', end: '\\$',
        contains: [COMMAND1, COMMAND2, SPECIAL],
        relevance: 0
      },
      {
        className: 'comment',
        begin: '%', end: '$',
        relevance: 0
      }
    ]
  };
};
},{}],57:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    keywords: {
      keyword:
        // Value types
        'char uchar unichar int uint long ulong short ushort int8 int16 int32 int64 uint8 ' +
        'uint16 uint32 uint64 float double bool struct enum string void ' +
        // Reference types
        'weak unowned owned ' +
        // Modifiers
        'async signal static abstract interface override ' +
        // Control Structures
        'while do for foreach else switch case break default return try catch ' +
        // Visibility
        'public private protected internal ' +
        // Other
        'using new this get set const stdout stdin stderr var',
      built_in:
        'DBus GLib CCode Gee Object',
      literal:
        'false true null'
    },
    contains: [
      {
        className: 'class',
        beginWithKeyword: true, end: '{',
        keywords: 'class interface delegate namespace',
        contains: [
          {
            beginWithKeyword: true,
            keywords: 'extends implements'
          },
          {
            className: 'title',
            begin: hljs.UNDERSCORE_IDENT_RE
          }
        ]
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'string',
        begin: '"""', end: '"""',
        relevance: 5
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'preprocessor',
        begin: '^#', end: '$',
        relevance: 2
      },
      {
        className: 'constant',
        begin: ' [A-Z_]+ ',
        relevance: 0
      }
    ]
  };
};
},{}],58:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    keywords: {
      keyword:
        'call class const dim do loop erase execute executeglobal exit for each next function ' +
        'if then else on error option explicit new private property let get public randomize ' +
        'redim rem select case set stop sub while wend with end to elseif is or xor and not ' +
        'class_initialize class_terminate default preserve in me byval byref step resume goto',
      built_in:
        'lcase month vartype instrrev ubound setlocale getobject rgb getref string ' +
        'weekdayname rnd dateadd monthname now day minute isarray cbool round formatcurrency ' +
        'conversions csng timevalue second year space abs clng timeserial fixs len asc ' +
        'isempty maths dateserial atn timer isobject filter weekday datevalue ccur isdate ' +
        'instr datediff formatdatetime replace isnull right sgn array snumeric log cdbl hex ' +
        'chr lbound msgbox ucase getlocale cos cdate cbyte rtrim join hour oct typename trim ' +
        'strcomp int createobject loadpicture tan formatnumber mid scriptenginebuildversion ' +
        'scriptengine split scriptengineminorversion cint sin datepart ltrim sqr ' +
        'scriptenginemajorversion time derived eval date formatpercent exp inputbox left ascw ' +
        'chrw regexp server response request cstr err',
      literal:
        'true false null nothing empty'
    },
    illegal: '//',
    contains: [
      hljs.inherit(hljs.QUOTE_STRING_MODE, {contains: [{begin: '""'}]}),
      {
        className: 'comment',
        begin: '\'', end: '$'
      },
      hljs.C_NUMBER_MODE
    ]
  };
};
},{}],59:[function(require,module,exports){
module.exports = function(hljs) {
  return {
    case_insensitive: true,
    keywords: {
      keyword:
        'abs access after alias all and architecture array assert attribute begin block ' +
        'body buffer bus case component configuration constant context cover disconnect ' +
        'downto default else elsif end entity exit fairness file for force function generate ' +
        'generic group guarded if impure in inertial inout is label library linkage literal ' +
        'loop map mod nand new next nor not null of on open or others out package port ' +
        'postponed procedure process property protected pure range record register reject ' +
        'release rem report restrict restrict_guarantee return rol ror select sequence ' +
        'severity shared signal sla sll sra srl strong subtype then to transport type ' +
        'unaffected units until use variable vmode vprop vunit wait when while with xnor xor',
      typename:
        'boolean bit character severity_level integer time delay_length natural positive ' +
        'string bit_vector file_open_kind file_open_status std_ulogic std_ulogic_vector ' +
        'std_logic std_logic_vector unsigned signed boolean_vector integer_vector ' +
        'real_vector time_vector'
    },
    illegal: '{',
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,        // VHDL-2008 block commenting.
      {
        className: 'comment',
        begin: '--', end: '$'
      },
      hljs.QUOTE_STRING_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'literal',
        begin: '\'(U|X|0|1|Z|W|L|H|-)\'',
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        className: 'attribute',
        begin: '\'[A-Za-z](_?[A-Za-z0-9])*',
        contains: [hljs.BACKSLASH_ESCAPE]
      }
    ]
  }; // return
};
},{}],60:[function(require,module,exports){
module.exports = function(hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    contains: [
      {
        className: 'attribute',
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: '="', returnBegin: true, end: '"',
        contains: [{
            className: 'value',
            begin: '"', endsWithParent: true
        }]
      },
      {
        begin: '=\'', returnBegin: true, end: '\'',
        contains: [{
          className: 'value',
          begin: '\'', endsWithParent: true
        }]
      },
      {
        begin: '=',
        contains: [{
          className: 'value',
          begin: '[^\\s/>]+'
        }]
      }
    ]
  };
  return {
    case_insensitive: true,
    contains: [
      {
        className: 'pi',
        begin: '<\\?', end: '\\?>',
        relevance: 10
      },
      {
        className: 'doctype',
        begin: '<!DOCTYPE', end: '>',
        relevance: 10,
        contains: [{begin: '\\[', end: '\\]'}]
      },
      {
        className: 'comment',
        begin: '<!--', end: '-->',
        relevance: 10
      },
      {
        className: 'cdata',
        begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
        relevance: 10
      },
      {
        className: 'tag',
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending braket. The '$' is needed for the lexem to be recognized
        by hljs.subMode() that tests lexems outside the stream.
        */
        begin: '<style(?=\\s|>|$)', end: '>',
        keywords: {title: 'style'},
        contains: [TAG_INTERNALS],
        starts: {
          end: '</style>', returnEnd: true,
          subLanguage: 'css'
        }
      },
      {
        className: 'tag',
        // See the comment in the <style tag about the lookahead pattern
        begin: '<script(?=\\s|>|$)', end: '>',
        keywords: {title: 'script'},
        contains: [TAG_INTERNALS],
        starts: {
          end: '</script>', returnEnd: true,
          subLanguage: 'javascript'
        }
      },
      {
        begin: '<%', end: '%>',
        subLanguage: 'vbscript'
      },
      {
        className: 'tag',
        begin: '</?', end: '/?>',
        contains: [
          {
            className: 'title', begin: '[^ />]+'
          },
          TAG_INTERNALS
        ]
      }
    ]
  };
};
},{}],61:[function(require,module,exports){
/*!
 * Jade - Compiler
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var nodes = require('./nodes')
  , filters = require('./filters')
  , doctypes = require('./doctypes')
  , selfClosing = require('./self-closing')
  , runtime = require('./runtime')
  , utils = require('./utils')
  , parseJSExpression = require('character-parser').parseMax
  , isConstant = require('constantinople')
  , toConstant = require('constantinople').toConstant


/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */

var Compiler = module.exports = function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  if (options.doctype) this.setDoctype(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {

  /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */

  compile: function(){
    this.buf = [];
    if (this.pp) this.buf.push("jade.indent = [];");
    this.lastBufferedIdx = -1;
    this.visit(this.node);
    return this.buf.join('\n');
  },

  /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */

  setDoctype: function(name){
    name = name || 'default';
    this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
    this.terse = this.doctype.toLowerCase() == '<!doctype html>';
    this.xml = 0 == this.doctype.indexOf('<?xml');
  },

  /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */

  buffer: function (str, interpolate) {
    var self = this;
    if (interpolate) {
      var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
      if (match) {
        this.buffer(str.substr(0, match.index), false);
        if (match[1]) { // escape
          this.buffer(match[2] + '{', false);
          this.buffer(match[3], true);
          return;
        } else {
          try {
            var rest = match[3];
            var range = parseJSExpression(rest);
            var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade.interp = " + range.src + ") == null ? '' : jade.interp)";
          } catch (ex) {
            throw ex;
            //didn't match, just as if escaped
            this.buffer(match[2] + '{', false);
            this.buffer(match[3], true);
            return;
          }
          this.bufferExpression(code);
          this.buffer(rest.substr(range.end + 1), true);
          return;
        }
      }
    }

    str = JSON.stringify(str);
    str = str.substr(1, str.length - 2);

    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
      this.lastBufferedType = 'text';
      this.lastBuffered += str;
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
    } else {
      this.buf.push('buf.push("' + str + '");');
      this.lastBufferedType = 'text';
      this.bufferStartChar = '"';
      this.lastBuffered = str;
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */

  bufferExpression: function (src) {
    if (isConstant(src)) {
      return this.buffer(toConstant(src), false)
    }
    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'text') this.lastBuffered += '"';
      this.lastBufferedType = 'code';
      this.lastBuffered += ' + (' + src + ')';
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
    } else {
      this.buf.push('buf.push(' + src + ');');
      this.lastBufferedType = 'code';
      this.bufferStartChar = '';
      this.lastBuffered = '(' + src + ')';
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */

  prettyIndent: function(offset, newline){
    offset = offset || 0;
    newline = newline ? '\n' : '';
    this.buffer(newline + Array(this.indents + offset).join('  '));
    if (this.parentIndents)
      this.buf.push("buf.push.apply(buf, jade.indent);");
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visit: function(node){
    var debug = this.debug;

    if (debug) {
      this.buf.push('jade.debug.unshift({ lineno: ' + node.line
        + ', filename: ' + (node.filename
          ? JSON.stringify(node.filename)
          : 'jade.debug[0].filename')
        + ' });');
    }

    // Massive hack to fix our context
    // stack for - else[ if] etc
    if (false === node.debug && this.debug) {
      this.buf.pop();
      this.buf.pop();
    }

    this.visitNode(node);

    if (debug) this.buf.push('jade.debug.shift();');
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visitNode: function(node){
    var name = node.constructor.name
      || node.constructor.toString().match(/function ([^(\s]+)()/)[1];
    return this['visit' + name](node);
  },

  /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitCase: function(node){
    var _ = this.withinCase;
    this.withinCase = true;
    this.buf.push('switch (' + node.expr + '){');
    this.visit(node.block);
    this.buf.push('}');
    this.withinCase = _;
  },

  /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitWhen: function(node){
    if ('default' == node.expr) {
      this.buf.push('default:');
    } else {
      this.buf.push('case ' + node.expr + ':');
    }
    this.visit(node.block);
    this.buf.push('  break;');
  },

  /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitLiteral: function(node){
    this.buffer(node.str);
  },

  /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */

  visitBlock: function(block){
    var len = block.nodes.length
      , escape = this.escape
      , pp = this.pp

    // Block keyword has a special meaning in mixins
    if (this.parentIndents && block.mode) {
      if (pp) this.buf.push("jade.indent.push('" + Array(this.indents + 1).join('  ') + "');")
      this.buf.push('block && block();');
      if (pp) this.buf.push("jade.indent.pop();")
      return;
    }

    // Pretty print multi-line text
    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
      this.prettyIndent(1, true);

    for (var i = 0; i < len; ++i) {
      // Pretty print text
      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
        this.prettyIndent(1, false);

      this.visit(block.nodes[i]);
      // Multiple text nodes are separated by newlines
      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
        this.buffer('\n');
    }
  },

  /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */

  visitDoctype: function(doctype){
    if (doctype && (doctype.val || !this.doctype)) {
      this.setDoctype(doctype.val || 'default');
    }

    if (this.doctype) this.buffer(this.doctype);
    this.hasCompiledDoctype = true;
  },

  /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */

  visitMixin: function(mixin){
    var name = mixin.name.replace(/-/g, '_') + '_mixin'
      , args = mixin.args || ''
      , block = mixin.block
      , attrs = mixin.attrs
      , pp = this.pp;

    if (mixin.call) {
      if (pp) this.buf.push("jade.indent.push('" + Array(this.indents + 1).join('  ') + "');")
      if (block || attrs.length) {

        this.buf.push(name + '.call({');

        if (block) {
          this.buf.push('block: function(){');

          // Render block with no indents, dynamically added when rendered
          this.parentIndents++;
          var _indents = this.indents;
          this.indents = 0;
          this.visit(mixin.block);
          this.indents = _indents;
          this.parentIndents--;

          if (attrs.length) {
            this.buf.push('},');
          } else {
            this.buf.push('}');
          }
        }

        if (attrs.length) {
          var val = this.attrs(attrs);
          if (val.inherits) {
            this.buf.push('attributes: jade.merge({' + val.buf
                + '}, attributes), escaped: jade.merge(' + val.escaped + ', escaped, true)');
          } else {
            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);
          }
        }

        if (args) {
          this.buf.push('}, ' + args + ');');
        } else {
          this.buf.push('});');
        }

      } else {
        this.buf.push(name + '(' + args + ');');
      }
      if (pp) this.buf.push("jade.indent.pop();")
    } else {
      this.buf.push('var ' + name + ' = function(' + args + '){');
      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');
      this.parentIndents++;
      this.visit(block);
      this.parentIndents--;
      this.buf.push('};');
    }
  },

  /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @api public
   */

  visitTag: function(tag){
    this.indents++;
    var name = tag.name
      , pp = this.pp
      , self = this;

    function bufferName() {
      if (tag.buffer) self.bufferExpression(name);
      else self.buffer(name);
    }

    if (!this.hasCompiledTag) {
      if (!this.hasCompiledDoctype && 'html' == name) {
        this.visitDoctype();
      }
      this.hasCompiledTag = true;
    }

    // pretty print
    if (pp && !tag.isInline())
      this.prettyIndent(0, true);

    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {
      this.buffer('<');
      bufferName();
      this.visitAttributes(tag.attrs);
      this.terse
        ? this.buffer('>')
        : this.buffer('/>');
    } else {
      // Optimize attributes buffering
      if (tag.attrs.length) {
        this.buffer('<');
        bufferName();
        if (tag.attrs.length) this.visitAttributes(tag.attrs);
        this.buffer('>');
      } else {
        this.buffer('<');
        bufferName();
        this.buffer('>');
      }
      if (tag.code) this.visitCode(tag.code);
      this.escape = 'pre' == tag.name;
      this.visit(tag.block);

      // pretty print
      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
        this.prettyIndent(0, true);

      this.buffer('</');
      bufferName();
      this.buffer('>');
    }
    this.indents--;
  },

  /**
   * Visit `filter`, throwing when the filter does not exist.
   *
   * @param {Filter} filter
   * @api public
   */

  visitFilter: function(filter){
    var text = filter.block.nodes.map(
      function(node){ return node.val; }
    ).join('\n');
    filter.attrs = filter.attrs || {};
    filter.attrs.filename = this.options.filename;
    this.buffer(filters(filter.name, text, filter.attrs), true);
  },

  /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */

  visitText: function(text){
    this.buffer(text.val, true);
  },

  /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */

  visitComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    this.buffer('<!--' + comment.val + '-->');
  },

  /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */

  visitBlockComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    if (0 == comment.val.trim().indexOf('if')) {
      this.buffer('<!--[' + comment.val.trim() + ']>');
      this.visit(comment.block);
      if (this.pp) this.prettyIndent(1, true);
      this.buffer('<![endif]-->');
    } else {
      this.buffer('<!--' + comment.val);
      this.visit(comment.block);
      if (this.pp) this.prettyIndent(1, true);
      this.buffer('-->');
    }
  },

  /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */

  visitCode: function(code){
    // Wrap code blocks with {}.
    // we only wrap unbuffered code blocks ATM
    // since they are usually flow control

    // Buffer code
    if (code.buffer) {
      var val = code.val.trimLeft();
      val = 'null == (jade.interp = '+val+') ? "" : jade.interp';
      if (code.escape) val = 'jade.escape(' + val + ')';
      this.bufferExpression(val);
    } else {
      this.buf.push(code.val);
    }

    // Block support
    if (code.block) {
      if (!code.buffer) this.buf.push('{');
      this.visit(code.block);
      if (!code.buffer) this.buf.push('}');
    }
  },

  /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */

  visitEach: function(each){
    this.buf.push(''
      + '// iterate ' + each.obj + '\n'
      + ';(function(){\n'
      + '  var $$obj = ' + each.obj + ';\n'
      + '  if (\'number\' == typeof $$obj.length) {\n');

    if (each.alternative) {
      this.buf.push('  if ($$obj.length) {');
    }

    this.buf.push(''
      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('    }\n');

    if (each.alternative) {
      this.buf.push('  } else {');
      this.visit(each.alternative);
      this.buf.push('  }');
    }

    this.buf.push(''
      + '  } else {\n'
      + '    var $$l = 0;\n'
      + '    for (var ' + each.key + ' in $$obj) {\n'
      + '      $$l++;'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('    }\n');
    if (each.alternative) {
      this.buf.push('    if ($$l === 0) {');
      this.visit(each.alternative);
      this.buf.push('    }');
    }
    this.buf.push('  }\n}).call(this);\n');
  },

  /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */

  visitAttributes: function(attrs){
    var val = this.attrs(attrs);
    if (val.inherits) {
      this.bufferExpression("jade.attrs(jade.merge({ " + val.buf +
          " }, attributes), jade.merge(" + val.escaped + ", escaped, true))");
    } else if (val.constant) {
      this.buffer(runtime.attrs(toConstant('{' + val.buf + '}'), JSON.parse(val.escaped)));
    } else {
      this.bufferExpression("jade.attrs({ " + val.buf + " }, " + val.escaped + ")");
    }
  },

  /**
   * Compile attributes.
   */

  attrs: function(attrs){
    var buf = []
      , classes = []
      , escaped = {}
      , constant = attrs.every(function(attr){ return isConstant(attr.val) })
      , inherits = false;

    if (this.terse) buf.push('terse: true');

    attrs.forEach(function(attr){
      if (attr.name == 'attributes') return inherits = true;
      escaped[attr.name] = attr.escaped;
      if (attr.name == 'class') {
        classes.push('(' + attr.val + ')');
      } else {
        var pair = "'" + attr.name + "':(" + attr.val + ')';
        buf.push(pair);
      }
    });

    if (classes.length) {
      buf.push('"class": [' + classes.join(',') + ']');
    }

    return {
      buf: buf.join(', '),
      escaped: JSON.stringify(escaped),
      inherits: inherits,
      constant: constant
    };
  }
};
},{"./doctypes":62,"./filters":63,"./nodes":76,"./runtime":83,"./self-closing":84,"./utils":85,"character-parser":86,"constantinople":87}],62:[function(require,module,exports){

/*!
 * Jade - doctypes
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = {
    '5': '<!DOCTYPE html>'
  , 'default': '<!DOCTYPE html>'
  , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
  , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
  , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
  , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
  , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
  , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
  , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
};
},{}],63:[function(require,module,exports){
/*!
 * Jade - filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = filter;
function filter(name, str, options) {
  if (typeof filter[name] === 'function') {
    var res = filter[name](str, options);
  } else {
    throw new Error('unknown filter ":' + name + '"');
  }
  return res;
}
filter.exists = function (name, str, options) {
  return typeof filter[name] === 'function';
};

},{}],64:[function(require,module,exports){

/*!
 * Jade - inline tags
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = [
    'a'
  , 'abbr'
  , 'acronym'
  , 'b'
  , 'br'
  , 'code'
  , 'em'
  , 'font'
  , 'i'
  , 'img'
  , 'ins'
  , 'kbd'
  , 'map'
  , 'samp'
  , 'small'
  , 'span'
  , 'strong'
  , 'sub'
  , 'sup'
];
},{}],65:[function(require,module,exports){
/*!
 * Jade
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = require('./parser')
  , Lexer = require('./lexer')
  , Compiler = require('./compiler')
  , runtime = require('./runtime')
  , addWith = require('with')
  , fs = require('fs');

/**
 * Expose self closing tags.
 */

exports.selfClosing = require('./self-closing');

/**
 * Default supported doctypes.
 */

exports.doctypes = require('./doctypes');

/**
 * Text filters.
 */

exports.filters = require('./filters');

/**
 * Utilities.
 */

exports.utils = require('./utils');

/**
 * Expose `Compiler`.
 */

exports.Compiler = Compiler;

/**
 * Expose `Parser`.
 */

exports.Parser = Parser;

/**
 * Expose `Lexer`.
 */

exports.Lexer = Lexer;

/**
 * Nodes.
 */

exports.nodes = require('./nodes');

/**
 * Jade runtime helpers.
 */

exports.runtime = runtime;

/**
 * Template function cache.
 */

exports.cache = {};

/**
 * Parse the given `str` of jade and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api private
 */

function parse(str, options){
  try {
    // Parse
    var parser = new (options.parser || Parser)(str, options.filename, options);

    // Compile
    var compiler = new (options.compiler || Compiler)(parser.parse(), options)
      , js = compiler.compile();

    // Debug compiler
    if (options.debug) {
      console.error('\nCompiled Function:\n\n\033[90m%s\033[0m', js.replace(/^/gm, '  '));
    }

    return ''
      + 'var buf = [];\n'
      + (options.self
        ? 'var self = locals || {};\n' + js
        : addWith('locals || {}', js, ['jade', 'buf'])) + ';'
      + 'return buf.join("");';
  } catch (err) {
    parser = parser.context();
    runtime.rethrow(err, parser.filename, parser.lexer.lineno, str);
  }
}

/**
 * Strip any UTF-8 BOM off of the start of `str`, if it exists.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function stripBOM(str){
  return 0xFEFF == str.charCodeAt(0)
    ? str.substring(1)
    : str;
}

/**
 * Compile a `Function` representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *   - `filename` used to improve errors when `compileDebug` is not `false`
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
  var options = options || {}
    , filename = options.filename
      ? JSON.stringify(options.filename)
      : 'undefined'
    , fn;

  str = stripBOM(String(str));

  if (options.compileDebug !== false) {
    fn = [
        'jade.debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parse(str, options)
      , '} catch (err) {'
      , '  jade.rethrow(err, jade.debug[0].filename, jade.debug[0].lineno' + (options.compileDebug === true ? ',' + JSON.stringify(str) : '') + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parse(str, options);
  }

  if (options.client) return new Function('locals', fn)
  fn = new Function('locals, jade', fn)
  return function(locals){ return fn(locals, Object.create(runtime)) }
};

/**
 * Render the given `str` of jade.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.render = function(str, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache && !options.filename) {
    throw new Error('the "filename" option is required for caching');
  }

  var path = options.filename;
  var tmpl = options.cache
    ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
    : exports.compile(str, options);
  return tmpl(options);
};

/**
 * Render a Jade file at the given `path`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.renderFile = function(path, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  var key = path + ':string';

  options.filename = path;
  var str = options.cache
    ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
    : fs.readFileSync(path, 'utf8');
  return exports.render(str, options);
};

/**
 * Express support.
 */

exports.__express = exports.renderFile;

},{"./compiler":61,"./doctypes":62,"./filters":63,"./lexer":66,"./nodes":76,"./parser":82,"./runtime":83,"./self-closing":84,"./utils":85,"fs":2,"with":99}],66:[function(require,module,exports){
/*!
 * Jade - Lexer
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var utils = require('./utils');
var parseJSExpression = require('character-parser').parseMax;

/**
 * Initialize `Lexer` with the given `str`.
 *
 * Options:
 *
 *   - `colons` allow colons for attr delimiters
 *
 * @param {String} str
 * @param {Object} options
 * @api private
 */

var Lexer = module.exports = function Lexer(str, options) {
  options = options || {};
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.colons = options.colons;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
};

/**
 * Lexer prototype.
 */

Lexer.prototype = {
  
  /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */
  
  tok: function(type, val){
    return {
        type: type
      , line: this.lineno
      , val: val
    }
  },
  
  /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */
  
  consume: function(len){
    this.input = this.input.substr(len);
  },
  
  /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */
  
  scan: function(regexp, type){
    var captures;
    if (captures = regexp.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(type, captures[1]);
    }
  },
  
  /**
   * Defer the given `tok`.
   *
   * @param {Object} tok
   * @api private
   */
  
  defer: function(tok){
    this.deferredTokens.push(tok);
  },
  
  /**
   * Lookahead `n` tokens.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */
  
  lookahead: function(n){
    var fetch = n - this.stash.length;
    while (fetch-- > 0) this.stash.push(this.next());
    return this.stash[--n];
  },
  
  /**
   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * @return {Number}
   * @api private
   */
  
  bracketExpression: function(skip){
    skip = skip || 0;
    var start = this.input[skip];
    if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
    var end = ({'(': ')', '{': '}', '[': ']'})[start];
    var range = parseJSExpression(this.input, {start: skip + 1});
    if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
    return range;
  },
  
  /**
   * Stashed token.
   */
  
  stashed: function() {
    return this.stash.length
      && this.stash.shift();
  },
  
  /**
   * Deferred token.
   */
  
  deferred: function() {
    return this.deferredTokens.length 
      && this.deferredTokens.shift();
  },
  
  /**
   * end-of-source.
   */
  
  eos: function() {
    if (this.input.length) return;
    if (this.indentStack.length) {
      this.indentStack.shift();
      return this.tok('outdent');
    } else {
      return this.tok('eos');
    }
  },

  /**
   * Blank line.
   */
  
  blank: function() {
    var captures;
    if (captures = /^\n *\n/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      ++this.lineno;
      if (this.pipeless) return this.tok('text', '');
      return this.next();
    }
  },

  /**
   * Comment.
   */
  
  comment: function() {
    var captures;
    if (captures = /^ *\/\/(-)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('comment', captures[2]);
      tok.buffer = '-' != captures[1];
      return tok;
    }
  },

  /**
   * Interpolated tag.
   */

  interpolation: function() {
    if (/^#\{/.test(this.input)) {
      var match;
      try {
        match = this.bracketExpression(1);
      } catch (ex) {
        return;//not an interpolation expression, just an unmatched open interpolation
      }

      this.consume(match.end + 1);
      return this.tok('interpolation', match.src);
    }
  },

  /**
   * Tag.
   */
  
  tag: function() {
    var captures;
    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok, name = captures[1];
      if (':' == name[name.length - 1]) {
        name = name.slice(0, -1);
        tok = this.tok('tag', name);
        this.defer(this.tok(':'));
        while (' ' == this.input[0]) this.input = this.input.substr(1);
      } else {
        tok = this.tok('tag', name);
      }
      tok.selfClosing = !! captures[2];
      return tok;
    }
  },
  
  /**
   * Filter.
   */
  
  filter: function() {
    return this.scan(/^:(\w+)/, 'filter');
  },
  
  /**
   * Doctype.
   */
  
  doctype: function() {
    return this.scan(/^(?:!!!|doctype) *([^\n]+)?/, 'doctype');
  },

  /**
   * Id.
   */
  
  id: function() {
    return this.scan(/^#([\w-]+)/, 'id');
  },
  
  /**
   * Class.
   */
  
  className: function() {
    return this.scan(/^\.([\w-]+)/, 'class');
  },
  
  /**
   * Text.
   */
  
  text: function() {
    return this.scan(/^(?:\| ?| ?)?([^\n]+)/, 'text');
  },

  /**
   * Extends.
   */
  
  "extends": function() {
    return this.scan(/^extends? +([^\n]+)/, 'extends');
  },

  /**
   * Block prepend.
   */
  
  prepend: function() {
    var captures;
    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'prepend'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },
  
  /**
   * Block append.
   */
  
  append: function() {
    var captures;
    if (captures = /^append +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'append'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Block.
   */
  
  block: function() {
    var captures;
    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = captures[1] || 'replace'
        , name = captures[2]
        , tok = this.tok('block', name);

      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Yield.
   */
  
  yield: function() {
    return this.scan(/^yield */, 'yield');
  },

  /**
   * Include.
   */
  
  include: function() {
    return this.scan(/^include +([^\n]+)/, 'include');
  },

  /**
   * Case.
   */
  
  "case": function() {
    return this.scan(/^case +([^\n]+)/, 'case');
  },

  /**
   * When.
   */
  
  when: function() {
    return this.scan(/^when +([^:\n]+)/, 'when');
  },

  /**
   * Default.
   */
  
  "default": function() {
    return this.scan(/^default */, 'default');
  },

  /**
   * Assignment.
   */
  
  assignment: function() {
    var captures;
    if (captures = /^(\w+) += *([^;\n]+)( *;? *)/.exec(this.input)) {
      this.consume(captures[0].length);
      var name = captures[1]
        , val = captures[2];
      return this.tok('code', 'var ' + name + ' = (' + val + ');');
    }
  },

  /**
   * Call mixin.
   */
  
  call: function(){
    var captures;
    if (captures = /^\+([-\w]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('call', captures[1]);

      // Check for args (not attributes)
      if (captures = /^ *\(/.exec(this.input)) {
        try {
          var range = this.bracketExpression(captures[0].length - 1);
          if (!/^ *[-\w]+ *=/.test(range.src)) { // not attributes
            this.consume(range.end + 1);
            tok.args = range.src;
          }
        } catch (ex) {
          //not a bracket expcetion, just unmatched open parens
        }
      }
      
      return tok;
    }
  },

  /**
   * Mixin.
   */

  mixin: function(){
    var captures;
    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))?/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('mixin', captures[1]);
      tok.args = captures[2];
      return tok;
    }
  },

  /**
   * Conditional.
   */
  
  conditional: function() {
    var captures;
    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var type = captures[1]
        , js = captures[2];

      switch (type) {
        case 'if': js = 'if (' + js + ')'; break;
        case 'unless': js = 'if (!(' + js + '))'; break;
        case 'else if': js = 'else if (' + js + ')'; break;
        case 'else': js = 'else'; break;
      }

      return this.tok('code', js);
    }
  },

  /**
   * While.
   */
  
  "while": function() {
    var captures;
    if (captures = /^while +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok('code', 'while (' + captures[1] + ')');
    }
  },

  /**
   * Each.
   */
  
  each: function() {
    var captures;
    if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('each', captures[1]);
      tok.key = captures[2] || '$index';
      tok.code = captures[3];
      return tok;
    }
  },
  
  /**
   * Code.
   */
  
  code: function() {
    var captures;
    if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var flags = captures[1];
      captures[1] = captures[2];
      var tok = this.tok('code', captures[1]);
      tok.escape = flags.charAt(0) === '=';
      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
      return tok;
    }
  },
  
  /**
   * Attributes.
   */
  
  attrs: function() {
    if ('(' == this.input.charAt(0)) {
      var index = this.bracketExpression().end
        , str = this.input.substr(1, index-1)
        , tok = this.tok('attrs')
        , len = str.length
        , colons = this.colons
        , states = ['key']
        , escapedAttr
        , key = ''
        , val = ''
        , quote
        , c
        , p;

      function state(){
        return states[states.length - 1];
      }

      function interpolate(attr) {
        return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
          if (escape) return _;
          try {
            var range = parseJSExpression(expr);
            if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
            return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
          } catch (ex) {
            return _.substr(0, 2) + interpolate(_.substr(2));
          }
        });
      }

      this.consume(index + 1);
      tok.attrs = {};
      tok.escaped = {};

      function parse(c) {
        var real = c;
        // TODO: remove when people fix ":"
        if (colons && ':' == c) c = '=';
        switch (c) {
          case ',':
          case '\n':
            switch (state()) {
              case 'expr':
              case 'array':
              case 'string':
              case 'object':
                val += c;
                break;
              default:
                states.push('key');
                val = val.trim();
                key = key.trim();
                if ('' == key) return;
                key = key.replace(/^['"]|['"]$/g, '').replace('!', '');
                tok.escaped[key] = escapedAttr;
                tok.attrs[key] = '' == val
                  ? true
                  : interpolate(val);
                key = val = '';
            }
            break;
          case '=':
            switch (state()) {
              case 'key char':
                key += real;
                break;
              case 'val':
              case 'expr':
              case 'array':
              case 'string':
              case 'object':
                val += real;
                break;
              default:
                escapedAttr = '!' != p;
                states.push('val');
            }
            break;
          case '(':
            if ('val' == state()
              || 'expr' == state()) states.push('expr');
            val += c;
            break;
          case ')':
            if ('expr' == state()
              || 'val' == state()) states.pop();
            val += c;
            break;
          case '{':
            if ('val' == state()) states.push('object');
            val += c;
            break;
          case '}':
            if ('object' == state()) states.pop();
            val += c;
            break;
          case '[':
            if ('val' == state()) states.push('array');
            val += c;
            break;
          case ']':
            if ('array' == state()) states.pop();
            val += c;
            break;
          case '"':
          case "'":
            switch (state()) {
              case 'key':
                states.push('key char');
                break;
              case 'key char':
                states.pop();
                break;
              case 'string':
                if (c == quote) states.pop();
                val += c;
                break;
              default:
                states.push('string');
                val += c;
                quote = c;
            }
            break;
          case '':
            break;
          default:
            switch (state()) {
              case 'key':
              case 'key char':
                key += c;
                break;
              default:
                val += c;
            }
        }
        p = c;
      }

      for (var i = 0; i < len; ++i) {
        parse(str.charAt(i));
      }

      parse(',');

      if ('/' == this.input.charAt(0)) {
        this.consume(1);
        tok.selfClosing = true;
      }

      return tok;
    }
  },
  
  /**
   * Indent | Outdent | Newline.
   */
  
  indent: function() {
    var captures, re;

    // established regexp
    if (this.indentRe) {
      captures = this.indentRe.exec(this.input);
    // determine regexp
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.exec(this.input);

      // spaces
      if (captures && !captures[1].length) {
        re = /^\n( *)/;
        captures = re.exec(this.input);
      }

      // established
      if (captures && captures[1].length) this.indentRe = re;
    }

    if (captures) {
      var tok
        , indents = captures[1].length;

      ++this.lineno;
      this.consume(indents + 1);

      if (' ' == this.input[0] || '\t' == this.input[0]) {
        throw new Error('Invalid indentation, you can use tabs or spaces but not both');
      }

      // blank line
      if ('\n' == this.input[0]) return this.tok('newline');

      // outdent
      if (this.indentStack.length && indents < this.indentStack[0]) {
        while (this.indentStack.length && this.indentStack[0] > indents) {
          this.stash.push(this.tok('outdent'));
          this.indentStack.shift();
        }
        tok = this.stash.pop();
      // indent
      } else if (indents && indents != this.indentStack[0]) {
        this.indentStack.unshift(indents);
        tok = this.tok('indent', indents);
      // newline
      } else {
        tok = this.tok('newline');
      }

      return tok;
    }
  },

  /**
   * Pipe-less text consumed only when 
   * pipeless is true;
   */

  pipelessText: function() {
    if (this.pipeless) {
      if ('\n' == this.input[0]) return;
      var i = this.input.indexOf('\n');
      if (-1 == i) i = this.input.length;
      var str = this.input.substr(0, i);
      this.consume(str.length);
      return this.tok('text', str);
    }
  },

  /**
   * ':'
   */

  colon: function() {
    return this.scan(/^: */, ':');
  },

  /**
   * Return the next token object, or those
   * previously stashed by lookahead.
   *
   * @return {Object}
   * @api private
   */
  
  advance: function(){
    return this.stashed()
      || this.next();
  },
  
  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */
  
  next: function() {
    return this.deferred()
      || this.blank()
      || this.eos()
      || this.pipelessText()
      || this.yield()
      || this.doctype()
      || this.interpolation()
      || this["case"]()
      || this.when()
      || this["default"]()
      || this["extends"]()
      || this.append()
      || this.prepend()
      || this.block()
      || this.include()
      || this.mixin()
      || this.call()
      || this.conditional()
      || this.each()
      || this["while"]()
      || this.assignment()
      || this.tag()
      || this.filter()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.indent()
      || this.comment()
      || this.colon()
      || this.text();
  }
};

},{"./utils":85,"character-parser":86}],67:[function(require,module,exports){

/*!
 * Jade - nodes - Attrs
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node'),
    Block = require('./block');

/**
 * Initialize a `Attrs` node.
 *
 * @api public
 */

var Attrs = module.exports = function Attrs() {
  this.attrs = [];
};

/**
 * Inherit from `Node`.
 */

Attrs.prototype.__proto__ = Node.prototype;

/**
 * Set attribute `name` to `val`, keep in mind these become
 * part of a raw js object literal, so to quote a value you must
 * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
 *
 * @param {String} name
 * @param {String} val
 * @param {Boolean} escaped
 * @return {Tag} for chaining
 * @api public
 */

Attrs.prototype.setAttribute = function(name, val, escaped){
  this.attrs.push({ name: name, val: val, escaped: escaped });
  return this;
};

/**
 * Remove attribute `name` when present.
 *
 * @param {String} name
 * @api public
 */

Attrs.prototype.removeAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      delete this.attrs[i];
    }
  }
};

/**
 * Get attribute value by `name`.
 *
 * @param {String} name
 * @return {String}
 * @api public
 */

Attrs.prototype.getAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      return this.attrs[i].val;
    }
  }
};

},{"./block":69,"./node":79}],68:[function(require,module,exports){

/*!
 * Jade - nodes - BlockComment
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `BlockComment` with the given `block`.
 *
 * @param {String} val
 * @param {Block} block
 * @param {Boolean} buffer
 * @api public
 */

var BlockComment = module.exports = function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from `Node`.
 */

BlockComment.prototype.__proto__ = Node.prototype;
},{"./node":79}],69:[function(require,module,exports){

/*!
 * Jade - nodes - Block
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a new `Block` with an optional `node`.
 *
 * @param {Node} node
 * @api public
 */

var Block = module.exports = function Block(node){
  this.nodes = [];
  if (node) this.push(node);
};

/**
 * Inherit from `Node`.
 */

Block.prototype.__proto__ = Node.prototype;

/**
 * Block flag.
 */

Block.prototype.isBlock = true;

/**
 * Replace the nodes in `other` with the nodes
 * in `this` block.
 *
 * @param {Block} other
 * @api private
 */

Block.prototype.replace = function(other){
  other.nodes = this.nodes;
};

/**
 * Pust the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.push = function(node){
  return this.nodes.push(node);
};

/**
 * Check if this block is empty.
 *
 * @return {Boolean}
 * @api public
 */

Block.prototype.isEmpty = function(){
  return 0 == this.nodes.length;
};

/**
 * Unshift the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.unshift = function(node){
  return this.nodes.unshift(node);
};

/**
 * Return the "last" block, or the first `yield` node.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.includeBlock = function(){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
};

/**
 * Return a clone of this block.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.clone = function(){
  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
};


},{"./node":79}],70:[function(require,module,exports){

/*!
 * Jade - nodes - Case
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a new `Case` with `expr`.
 *
 * @param {String} expr
 * @api public
 */

var Case = exports = module.exports = function Case(expr, block){
  this.expr = expr;
  this.block = block;
};

/**
 * Inherit from `Node`.
 */

Case.prototype.__proto__ = Node.prototype;

var When = exports.When = function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
};

/**
 * Inherit from `Node`.
 */

When.prototype.__proto__ = Node.prototype;


},{"./node":79}],71:[function(require,module,exports){

/*!
 * Jade - nodes - Code
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `Code` node with the given code `val`.
 * Code may also be optionally buffered and escaped.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @param {Boolean} escape
 * @api public
 */

var Code = module.exports = function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
};

/**
 * Inherit from `Node`.
 */

Code.prototype.__proto__ = Node.prototype;
},{"./node":79}],72:[function(require,module,exports){

/*!
 * Jade - nodes - Comment
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `Comment` with the given `val`, optionally `buffer`,
 * otherwise the comment may render in the output.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @api public
 */

var Comment = module.exports = function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from `Node`.
 */

Comment.prototype.__proto__ = Node.prototype;
},{"./node":79}],73:[function(require,module,exports){

/*!
 * Jade - nodes - Doctype
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `Doctype` with the given `val`. 
 *
 * @param {String} val
 * @api public
 */

var Doctype = module.exports = function Doctype(val) {
  this.val = val;
};

/**
 * Inherit from `Node`.
 */

Doctype.prototype.__proto__ = Node.prototype;
},{"./node":79}],74:[function(require,module,exports){

/*!
 * Jade - nodes - Each
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize an `Each` node, representing iteration
 *
 * @param {String} obj
 * @param {String} val
 * @param {String} key
 * @param {Block} block
 * @api public
 */

var Each = module.exports = function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
};

/**
 * Inherit from `Node`.
 */

Each.prototype.__proto__ = Node.prototype;
},{"./node":79}],75:[function(require,module,exports){

/*!
 * Jade - nodes - Filter
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node')
  , Block = require('./block');

/**
 * Initialize a `Filter` node with the given
 * filter `name` and `block`.
 *
 * @param {String} name
 * @param {Block|Node} block
 * @api public
 */

var Filter = module.exports = function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
};

/**
 * Inherit from `Node`.
 */

Filter.prototype.__proto__ = Node.prototype;
},{"./block":69,"./node":79}],76:[function(require,module,exports){

/*!
 * Jade - nodes
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

exports.Node = require('./node');
exports.Tag = require('./tag');
exports.Code = require('./code');
exports.Each = require('./each');
exports.Case = require('./case');
exports.Text = require('./text');
exports.Block = require('./block');
exports.Mixin = require('./mixin');
exports.Filter = require('./filter');
exports.Comment = require('./comment');
exports.Literal = require('./literal');
exports.BlockComment = require('./block-comment');
exports.Doctype = require('./doctype');

},{"./block":69,"./block-comment":68,"./case":70,"./code":71,"./comment":72,"./doctype":73,"./each":74,"./filter":75,"./literal":77,"./mixin":78,"./node":79,"./tag":80,"./text":81}],77:[function(require,module,exports){

/*!
 * Jade - nodes - Literal
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `Literal` node with the given `str.
 *
 * @param {String} str
 * @api public
 */

var Literal = module.exports = function Literal(str) {
  this.str = str;
};

/**
 * Inherit from `Node`.
 */

Literal.prototype.__proto__ = Node.prototype;

},{"./node":79}],78:[function(require,module,exports){

/*!
 * Jade - nodes - Mixin
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = require('./attrs');

/**
 * Initialize a new `Mixin` with `name` and `block`.
 *
 * @param {String} name
 * @param {String} args
 * @param {Block} block
 * @api public
 */

var Mixin = module.exports = function Mixin(name, args, block, call){
  this.name = name;
  this.args = args;
  this.block = block;
  this.attrs = [];
  this.call = call;
};

/**
 * Inherit from `Attrs`.
 */

Mixin.prototype.__proto__ = Attrs.prototype;


},{"./attrs":67}],79:[function(require,module,exports){

/*!
 * Jade - nodes - Node
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Initialize a `Node`.
 *
 * @api public
 */

var Node = module.exports = function Node(){};

/**
 * Clone this node (return itself)
 *
 * @return {Node}
 * @api private
 */

Node.prototype.clone = function(){
  return this;
};

},{}],80:[function(require,module,exports){

/*!
 * Jade - nodes - Tag
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = require('./attrs'),
    Block = require('./block'),
    inlineTags = require('../inline-tags');

/**
 * Initialize a `Tag` node with the given tag `name` and optional `block`.
 *
 * @param {String} name
 * @param {Block} block
 * @api public
 */

var Tag = module.exports = function Tag(name, block) {
  this.name = name;
  this.attrs = [];
  this.block = block || new Block;
};

/**
 * Inherit from `Attrs`.
 */

Tag.prototype.__proto__ = Attrs.prototype;

/**
 * Clone this tag.
 *
 * @return {Tag}
 * @api private
 */

Tag.prototype.clone = function(){
  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
};

/**
 * Check if this tag is an inline tag.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.isInline = function(){
  return ~inlineTags.indexOf(this.name);
};

/**
 * Check if this tag's contents can be inlined.  Used for pretty printing.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.canInline = function(){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline && node.isInline());
  }
  
  // Empty tag
  if (!nodes.length) return true;
  
  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);
  
  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i < len; ++i) {
      if (nodes[i-1].isText && nodes[i].isText)
        return false;
    }
    return true;
  }
  
  // Mixed tag
  return false;
};
},{"../inline-tags":64,"./attrs":67,"./block":69}],81:[function(require,module,exports){

/*!
 * Jade - nodes - Text
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node');

/**
 * Initialize a `Text` node with optional `line`.
 *
 * @param {String} line
 * @api public
 */

var Text = module.exports = function Text(line) {
  this.val = '';
  if ('string' == typeof line) this.val = line;
};

/**
 * Inherit from `Node`.
 */

Text.prototype.__proto__ = Node.prototype;

/**
 * Flag as text.
 */

Text.prototype.isText = true;
},{"./node":79}],82:[function(require,module,exports){
/*!
 * Jade - Parser
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Lexer = require('./lexer')
  , nodes = require('./nodes')
  , utils = require('./utils')
  , filters = require('./filters')
  , path = require('path')
  , extname = path.extname;

/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

var Parser = exports = module.exports = function Parser(str, filename, options){
  this.input = str;
  this.lexer = new Lexer(str, options);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
};

/**
 * Tags that may not contain tags.
 */

var textOnly = exports.textOnly = ['script', 'style'];

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Push `parser` onto the context stack,
   * or pop and return a `Parser`.
   */

  context: function(parser){
    if (parser) {
      this.contexts.push(parser);
    } else {
      return this.contexts.pop();
    }
  },

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function(){
    return this.lexer.advance();
  },

  /**
   * Skip `n` tokens.
   *
   * @param {Number} n
   * @api private
   */

  skip: function(n){
    while (n--) this.advance();
  },

  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */

  peek: function() {
    return this.lookahead(1);
  },

  /**
   * Return lexer lineno.
   *
   * @return {Number}
   * @api private
   */

  line: function() {
    return this.lexer.lineno;
  },

  /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n){
    return this.lexer.lookahead(n);
  },

  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */

  parse: function(){
    var block = new nodes.Block, parser;
    block.line = this.line();

    while ('eos' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }

    if (parser = this.extending) {
      this.context(parser);
      var ast = parser.parse();
      this.context();

      // hoist mixins
      for (var name in this.mixins)
        ast.unshift(this.mixins[name]);
      return ast;
    }

    return block;
  },

  /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */

  expect: function(type){
    if (this.peek().type === type) {
      return this.advance();
    } else {
      throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
    }
  },

  /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */

  accept: function(type){
    if (this.peek().type === type) {
      return this.advance();
    }
  },

  /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */

  parseExpr: function(){
    switch (this.peek().type) {
      case 'tag':
        return this.parseTag();
      case 'mixin':
        return this.parseMixin();
      case 'block':
        return this.parseBlock();
      case 'case':
        return this.parseCase();
      case 'when':
        return this.parseWhen();
      case 'default':
        return this.parseDefault();
      case 'extends':
        return this.parseExtends();
      case 'include':
        return this.parseInclude();
      case 'doctype':
        return this.parseDoctype();
      case 'filter':
        return this.parseFilter();
      case 'comment':
        return this.parseComment();
      case 'text':
        return this.parseText();
      case 'each':
        return this.parseEach();
      case 'code':
        return this.parseCode();
      case 'call':
        return this.parseCall();
      case 'interpolation':
        return this.parseInterpolation();
      case 'yield':
        this.advance();
        var block = new nodes.Block;
        block.yield = true;
        return block;
      case 'id':
      case 'class':
        var tok = this.advance();
        this.lexer.defer(this.lexer.tok('tag', 'div'));
        this.lexer.defer(tok);
        return this.parseExpr();
      default:
        throw new Error('unexpected token "' + this.peek().type + '"');
    }
  },

  /**
   * Text
   */

  parseText: function(){
    var tok = this.expect('text');
    var node = new nodes.Text(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   *   ':' expr
   * | block
   */

  parseBlockExpansion: function(){
    if (':' == this.peek().type) {
      this.advance();
      return new nodes.Block(this.parseExpr());
    } else {
      return this.block();
    }
  },

  /**
   * case
   */

  parseCase: function(){
    var val = this.expect('case').val;
    var node = new nodes.Case(val);
    node.line = this.line();
    node.block = this.block();
    return node;
  },

  /**
   * when
   */

  parseWhen: function(){
    var val = this.expect('when').val
    return new nodes.Case.When(val, this.parseBlockExpansion());
  },

  /**
   * default
   */

  parseDefault: function(){
    this.expect('default');
    return new nodes.Case.When('default', this.parseBlockExpansion());
  },

  /**
   * code
   */

  parseCode: function(){
    var tok = this.expect('code');
    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
    var block;
    var i = 1;
    node.line = this.line();
    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;
    block = 'indent' == this.lookahead(i).type;
    if (block) {
      this.skip(i-1);
      node.block = this.block();
    }
    return node;
  },

  /**
   * comment
   */

  parseComment: function(){
    var tok = this.expect('comment');
    var node;

    if ('indent' == this.peek().type) {
      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);
    } else {
      node = new nodes.Comment(tok.val, tok.buffer);
    }

    node.line = this.line();
    return node;
  },

  /**
   * doctype
   */

  parseDoctype: function(){
    var tok = this.expect('doctype');
    var node = new nodes.Doctype(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   * filter attrs? text-block
   */

  parseFilter: function(){
    var tok = this.expect('filter');
    var attrs = this.accept('attrs');
    var block;

    if ('indent' == this.peek().type) {
      this.lexer.pipeless = true;
      block = this.parseTextBlock();
      this.lexer.pipeless = false;
    } else block = new nodes.Block;

    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);
    node.line = this.line();
    return node;
  },

  /**
   * each block
   */

  parseEach: function(){
    var tok = this.expect('each');
    var node = new nodes.Each(tok.code, tok.val, tok.key);
    node.line = this.line();
    node.block = this.block();
    if (this.peek().type == 'code' && this.peek().val == 'else') {
      this.advance();
      node.alternative = this.block();
    }
    return node;
  },

  /**
   * Resolves a path relative to the template for use in
   * includes and extends
   *
   * @param {String}  path
   * @param {String}  purpose  Used in error messages.
   * @return {String}
   * @api private
   */

  resolvePath: function (path, purpose) {
    var p = require('path');
    var dirname = p.dirname;
    var basename = p.basename;
    var join = p.join;

    if (path[0] !== '/' && !this.filename)
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');

    if (path[0] === '/' && !this.options.basedir)
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');

    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);

    if (basename(path).indexOf('.') === -1) path += '.jade';

    return path;
  },

  /**
   * 'extends' name
   */

  parseExtends: function(){
    var fs = require('fs');

    var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
    if ('.jade' != path.substr(-5)) path += '.jade';

    var str = fs.readFileSync(path, 'utf8');
    var parser = new Parser(str, path, this.options);

    parser.blocks = this.blocks;
    parser.contexts = this.contexts;
    this.extending = parser;

    // TODO: null node
    return new nodes.Literal('');
  },

  /**
   * 'block' name block
   */

  parseBlock: function(){
    var block = this.expect('block');
    var mode = block.mode;
    var name = block.val.trim();

    block = 'indent' == this.peek().type
      ? this.block()
      : new nodes.Block(new nodes.Literal(''));

    var prev = this.blocks[name] || {prepended: [], appended: []}
    if (prev.mode === 'replace') return this.blocks[name] = prev;

    var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);

    switch (mode) {
      case 'append':
        prev.appended = prev.parser === this ?
                        prev.appended.concat(block.nodes) :
                        block.nodes.concat(prev.appended);
        break;
      case 'prepend':
        prev.prepended = prev.parser === this ?
                         block.nodes.concat(prev.prepended) :
                         prev.prepended.concat(block.nodes);
        break;
    }
    block.nodes = allNodes;
    block.appended = prev.appended;
    block.prepended = prev.prepended;
    block.mode = mode;
    block.parser = this;

    return this.blocks[name] = block;
  },

  /**
   * include block?
   */

  parseInclude: function(){
    var fs = require('fs');

    var path = this.resolvePath(this.expect('include').val.trim(), 'include');

    // non-jade
    if ('.jade' != path.substr(-5)) {
      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
      var ext = extname(path).slice(1);
      if (filters.exists(ext)) str = filters(ext, str, { filename: path });
      return new nodes.Literal(str);
    }

    var str = fs.readFileSync(path, 'utf8');
    var parser = new Parser(str, path, this.options);
    parser.blocks = utils.merge({}, this.blocks);

    parser.mixins = this.mixins;

    this.context(parser);
    var ast = parser.parse();
    this.context();
    ast.filename = path;

    if ('indent' == this.peek().type) {
      ast.includeBlock().push(this.block());
    }

    return ast;
  },

  /**
   * call ident block
   */

  parseCall: function(){
    var tok = this.expect('call');
    var name = tok.val;
    var args = tok.args;
    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

    this.tag(mixin);
    if (mixin.code) {
      mixin.block.push(mixin.code);
      mixin.code = null;
    }
    if (mixin.block.isEmpty()) mixin.block = null;
    return mixin;
  },

  /**
   * mixin block
   */

  parseMixin: function(){
    var tok = this.expect('mixin');
    var name = tok.val;
    var args = tok.args;
    var mixin;

    // definition
    if ('indent' == this.peek().type) {
      mixin = new nodes.Mixin(name, args, this.block(), false);
      this.mixins[name] = mixin;
      return mixin;
    // call
    } else {
      return new nodes.Mixin(name, args, null, true);
    }
  },

  /**
   * indent (text | newline)* outdent
   */

  parseTextBlock: function(){
    var block = new nodes.Block;
    block.line = this.line();
    var spaces = this.expect('indent').val;
    if (null == this._spaces) this._spaces = spaces;
    var indent = Array(spaces - this._spaces + 1).join(' ');
    while ('outdent' != this.peek().type) {
      switch (this.peek().type) {
        case 'newline':
          this.advance();
          break;
        case 'indent':
          this.parseTextBlock().nodes.forEach(function(node){
            block.push(node);
          });
          break;
        default:
          var text = new nodes.Text(indent + this.advance().val);
          text.line = this.line();
          block.push(text);
      }
    }

    if (spaces == this._spaces) this._spaces = null;
    this.expect('outdent');
    return block;
  },

  /**
   * indent expr* outdent
   */

  block: function(){
    var block = new nodes.Block;
    block.line = this.line();
    this.expect('indent');
    while ('outdent' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }
    this.expect('outdent');
    return block;
  },

  /**
   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseInterpolation: function(){
    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);
    tag.buffer = true;
    return this.tag(tag);
  },

  /**
   * tag (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseTag: function(){
    // ast-filter look-ahead
    var i = 2;
    if ('attrs' == this.lookahead(i).type) ++i;

    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);

    tag.selfClosing = tok.selfClosing;

    return this.tag(tag);
  },

  /**
   * Parse tag.
   */

  tag: function(tag){
    var dot;

    tag.line = this.line();

    var seenAttrs = false;
    // (attrs | class | id)*
    out:
      while (true) {
        switch (this.peek().type) {
          case 'id':
          case 'class':
            var tok = this.advance();
            tag.setAttribute(tok.type, "'" + tok.val + "'");
            continue;
          case 'attrs':
            if (seenAttrs) {
              console.warn('You should not have jade tags with multiple attributes.');
            }
            seenAttrs = true;
            var tok = this.advance()
              , obj = tok.attrs
              , escaped = tok.escaped
              , names = Object.keys(obj);

            if (tok.selfClosing) tag.selfClosing = true;

            for (var i = 0, len = names.length; i < len; ++i) {
              var name = names[i]
                , val = obj[name];
              tag.setAttribute(name, val, escaped[name]);
            }
            continue;
          default:
            break out;
        }
      }

    // check immediate '.'
    if ('.' == this.peek().val) {
      dot = tag.textOnly = true;
      this.advance();
    }

    // (text | code | ':')?
    switch (this.peek().type) {
      case 'text':
        tag.block.push(this.parseText());
        break;
      case 'code':
        tag.code = this.parseCode();
        break;
      case ':':
        this.advance();
        tag.block = new nodes.Block;
        tag.block.push(this.parseExpr());
        break;
      case 'newline':
      case 'indent':
      case 'outdent':
      case 'eos':
        break;
      default:
        throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
    }

    // newline*
    while ('newline' == this.peek().type) this.advance();

    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);

    // script special-case
    if ('script' == tag.name) {
      var type = tag.getAttribute('type');
      if (!dot && type && 'text/javascript' != type.replace(/^['"]|['"]$/g, '')) {
        tag.textOnly = false;
      }
    }

    // block?
    if ('indent' == this.peek().type) {
      if (tag.textOnly) {
        if (!dot) {
          console.warn(this.filename + ', line ' + this.peek().line + ':')
          console.warn('Implicit textOnly for `script` and `style` is deprecated.  Use `script.` or `style.` instead.');
        }
        this.lexer.pipeless = true;
        tag.block = this.parseTextBlock();
        this.lexer.pipeless = false;
      } else {
        var block = this.block();
        if (tag.block) {
          for (var i = 0, len = block.nodes.length; i < len; ++i) {
            tag.block.push(block.nodes[i]);
          }
        } else {
          tag.block = block;
        }
      }
    }

    return tag;
  }
};

},{"./filters":63,"./lexer":66,"./nodes":76,"./utils":85,"fs":2,"path":3}],83:[function(require,module,exports){

/*!
 * Jade - runtime
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Lame Array.isArray() polyfill for now.
 */

if (!Array.isArray) {
  Array.isArray = function(arr){
    return '[object Array]' == Object.prototype.toString.call(arr);
  };
}

/**
 * Lame Object.keys() polyfill for now.
 */

if (!Object.keys) {
  Object.keys = function(obj){
    var arr = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        arr.push(key);
      }
    }
    return arr;
  }
}

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */

function nulls(val) {
  return val != null && val !== '';
}

/**
 * join array as classes.
 *
 * @param {*} val
 * @return {String}
 * @api private
 */

function joinClasses(val) {
  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;
}

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 * @api private
 */

exports.attrs = function attrs(obj, escaped){
  var buf = []
    , terse = obj.terse;

  delete obj.terse;
  var keys = Object.keys(obj)
    , len = keys.length;

  if (len) {
    buf.push('');
    for (var i = 0; i < len; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('boolean' == typeof val || null == val) {
        if (val) {
          terse
            ? buf.push(key)
            : buf.push(key + '="' + key + '"');
        }
      } else if (0 == key.indexOf('data') && 'string' != typeof val) {
        buf.push(key + "='" + JSON.stringify(val) + "'");
      } else if ('class' == key) {
        if (escaped && escaped[key]){
          if (val = exports.escape(joinClasses(val))) {
            buf.push(key + '="' + val + '"');
          }
        } else {
          if (val = joinClasses(val)) {
            buf.push(key + '="' + val + '"');
          }
        }
      } else if (escaped && escaped[key]) {
        buf.push(key + '="' + exports.escape(val) + '"');
      } else {
        buf.push(key + '="' + val + '"');
      }
    }
  }

  return buf.join(' ');
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function escape(html){
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) && !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str =  str || require('fs').readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};

},{"fs":2}],84:[function(require,module,exports){

/*!
 * Jade - self closing tags
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = [
    'meta'
  , 'img'
  , 'link'
  , 'input'
  , 'source'
  , 'area'
  , 'base'
  , 'col'
  , 'br'
  , 'hr'
];
},{}],85:[function(require,module,exports){

/*!
 * Jade - utils
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports.merge = function(a, b) {
  for (var key in b) a[key] = b[key];
  return a;
};


},{}],86:[function(require,module,exports){
exports = (module.exports = parse);
exports.parse = parse;
function parse(src, state, options) {
  options = options || {};
  state = state || exports.defaultState();
  var start = options.start || 0;
  var end = options.end || src.length;
  var index = start;
  while (index < end) {
    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
    }
    exports.parseChar(src[index++], state);
  }
  return state;
}

exports.parseMax = parseMax;
function parseMax(src, options) {
  options = options || {};
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
    if (index >= src.length) {
      throw new Error('The end of the string was reached with no closing bracket found.');
    }
    exports.parseChar(src[index++], state);
  }
  var end = index - 1;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}

exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options) {
  options = options || {};
  var includeLineComment = options.includeLineComment || false;
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.singleQuote || state.doubleQuote || state.regexp || state.blockComment ||
         (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
    exports.parseChar(src[index++], state);
  }
  var end = index;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}


exports.parseChar = parseChar;
function parseChar(character, state) {
  if (character.length !== 1) throw new Error('Character must be a string of length 1');
  state = state || defaultState();
  var wasComment = state.blockComment || state.lineComment;
  var lastChar = state.history ? state.history[0] : '';
  if (state.lineComment) {
    if (character === '\n') {
      state.lineComment = false;
    }
  } else if (state.blockComment) {
    if (state.lastChar === '*' && character === '/') {
      state.blockComment = false;
    }
  } else if (state.singleQuote) {
    if (character === '\'' && !state.escaped) {
      state.singleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.doubleQuote) {
    if (character === '"' && !state.escaped) {
      state.doubleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.regexp) {
    if (character === '/' && !state.escaped) {
      state.regexp = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (lastChar === '/' && character === '/') {
    history = history.substr(1);
    state.lineComment = true;
  } else if (lastChar === '/' && character === '*') {
    history = history.substr(1);
    state.blockComment = true;
  } else if (character === '/') {
    //could be start of regexp or divide sign
    var history = state.history.replace(/^\s*/, '');
    if (history[0] === ')') {
      //unless its an `if`, `while`, `for` or `with` it's a divide
      //this is probably best left though
    } else if (history[0] === '}') {
      //unless it's a function expression, it's a regexp
      //this is probably best left though
    } else if (isPunctuator(history[0])) {
      state.regexp = true;
    } else if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0])) {
      state.regexp = true;
    } else {
      // assume it's divide
    }
  } else if (character === '\'') {
    state.singleQuote = true;
  } else if (character === '"') {
    state.doubleQuote = true;
  } else if (character === '(') {
    state.roundDepth++;
  } else if (character === ')') {
    state.roundDepth--;
  } else if (character === '{') {
    state.curlyDepth++;
  } else if (character === '}') {
    state.curlyDepth--;
  } else if (character === '[') {
    state.squareDepth++;
  } else if (character === ']') {
    state.squareDepth--;
  }
  if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
  return state;
}

exports.defaultState = defaultState;
function defaultState() {
  return {
    lineComment: false,
    blockComment: false,

    singleQuote: false,
    doubleQuote: false,
    regexp: false,
    escaped: false,

    roundDepth: 0,
    curlyDepth: 0,
    squareDepth: 0,

    history: ''
  };
}

function startsWith(str, start, i) {
  return str.substr(i || 0, start.length) === start;
}

function isPunctuator(c) {
  var code = c.charCodeAt(0)

  switch (code) {
    case 46:   // . dot
    case 40:   // ( open bracket
    case 41:   // ) close bracket
    case 59:   // ; semicolon
    case 44:   // , comma
    case 123:  // { open curly brace
    case 125:  // } close curly brace
    case 91:   // [
    case 93:   // ]
    case 58:   // :
    case 63:   // ?
    case 126:  // ~
    case 37:   // %
    case 38:   // &
    case 42:   // *:
    case 43:   // +
    case 45:   // -
    case 47:   // /
    case 60:   // <
    case 62:   // >
    case 94:   // ^
    case 124:  // |
    case 33:   // !
    case 61:   // =
      return true;
    default:
      return false;
    }
}
function isKeyword(id) {
    return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
          (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
          (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
          (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
          (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
          (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
          (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
          (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||
          (id === 'yield') || (id === 'let');
}

},{}],87:[function(require,module,exports){
'use strict'

var uglify = require('uglify-js')

var lastSRC = '(null)'
var lastRes = true

module.exports = isConstant
function isConstant(src) {
  src = '(' + src + ')'
  if (lastSRC === src) return lastRes
  lastSRC = src
  try {
    return lastRes = (detect(src).length === 0)
  } catch (ex) {
    return lastRes = false
  }
}
isConstant.isConstant = isConstant

isConstant.toConstant = toConstant
function toConstant(src) {
  if (!isConstant(src)) throw new Error(JSON.stringify(src) + ' is not constant.')
  return Function('return (' + src + ')')()
}

function detect(src) {
  var ast = uglify.parse(src.toString())
  ast.figure_out_scope()
  var globals = ast.globals
    .map(function (node, name) {
      return name
    })
  return globals
}
},{"uglify-js":98}],88:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":93,"./source-map/source-map-generator":94,"./source-map/source-node":95}],89:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":96,"amdefine":97}],90:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":91,"amdefine":97}],91:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":97}],92:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":97}],93:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":89,"./base64-vlq":90,"./binary-search":92,"./util":96,"amdefine":97}],94:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":89,"./base64-vlq":90,"./util":96,"amdefine":97}],95:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":94,"./util":96,"amdefine":97}],96:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":97}],97:[function(require,module,exports){
var process=require("__browserify_process"),__filename="/../../node_modules/jade/node_modules/constantinople/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js";/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

},{"__browserify_process":5,"path":3}],98:[function(require,module,exports){
var sys = require("util");
var MOZ_SourceMap = require("source-map");
var UglifyJS = exports;
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function array_to_hash(a) {
    var ret = Object.create(null);
    for (var i = 0; i < a.length; ++i)
        ret[a[i]] = true;
    return ret;
};

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
    return str.split("");
};

function member(name, array) {
    for (var i = array.length; --i >= 0;)
        if (array[i] == name)
            return true;
    return false;
};

function find_if(func, array) {
    for (var i = 0, n = array.length; i < n; ++i) {
        if (func(array[i]))
            return array[i];
    }
};

function repeat_string(str, i) {
    if (i <= 0) return "";
    if (i == 1) return str;
    var d = repeat_string(str, i >> 1);
    d += d;
    if (i & 1) d += str;
    return d;
};

function DefaultsError(msg, defs) {
    this.msg = msg;
    this.defs = defs;
};

function defaults(args, defs, croak) {
    if (args === true)
        args = {};
    var ret = args || {};
    if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))
        throw new DefaultsError("`" + i + "` is not a supported option", defs);
    for (var i in defs) if (defs.hasOwnProperty(i)) {
        ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];
    }
    return ret;
};

function merge(obj, ext) {
    for (var i in ext) if (ext.hasOwnProperty(i)) {
        obj[i] = ext[i];
    }
    return obj;
};

function noop() {};

var MAP = (function(){
    function MAP(a, f, backwards) {
        var ret = [], top = [], i;
        function doit() {
            var val = f(a[i], i);
            var is_last = val instanceof Last;
            if (is_last) val = val.v;
            if (val instanceof AtTop) {
                val = val.v;
                if (val instanceof Splice) {
                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    top.push(val);
                }
            }
            else if (val !== skip) {
                if (val instanceof Splice) {
                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    ret.push(val);
                }
            }
            return is_last;
        };
        if (a instanceof Array) {
            if (backwards) {
                for (i = a.length; --i >= 0;) if (doit()) break;
                ret.reverse();
                top.reverse();
            } else {
                for (i = 0; i < a.length; ++i) if (doit()) break;
            }
        }
        else {
            for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
        }
        return top.concat(ret);
    };
    MAP.at_top = function(val) { return new AtTop(val) };
    MAP.splice = function(val) { return new Splice(val) };
    MAP.last = function(val) { return new Last(val) };
    var skip = MAP.skip = {};
    function AtTop(val) { this.v = val };
    function Splice(val) { this.v = val };
    function Last(val) { this.v = val };
    return MAP;
})();

function push_uniq(array, el) {
    if (array.indexOf(el) < 0)
        array.push(el);
};

function string_template(text, props) {
    return text.replace(/\{(.+?)\}/g, function(str, p){
        return props[p];
    });
};

function remove(array, el) {
    for (var i = array.length; --i >= 0;) {
        if (array[i] === el) array.splice(i, 1);
    }
};

function mergeSort(array, cmp) {
    if (array.length < 2) return array.slice();
    function merge(a, b) {
        var r = [], ai = 0, bi = 0, i = 0;
        while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0
                ? r[i++] = a[ai++]
                : r[i++] = b[bi++];
        }
        if (ai < a.length) r.push.apply(r, a.slice(ai));
        if (bi < b.length) r.push.apply(r, b.slice(bi));
        return r;
    };
    function _ms(a) {
        if (a.length <= 1)
            return a;
        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
        left = _ms(left);
        right = _ms(right);
        return merge(left, right);
    };
    return _ms(array);
};

function set_difference(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) < 0;
    });
};

function set_intersection(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) >= 0;
    });
};

// this function is taken from Acorn [1], written by Marijn Haverbeke
// [1] https://github.com/marijnh/acorn
function makePredicate(words) {
    if (!(words instanceof Array)) words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
            }
        cats.push([words[i]]);
    }
    function compareTo(arr) {
        if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
        f += "return true}return false;";
    }
    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.
    if (cats.length > 3) {
        cats.sort(function(a, b) {return b.length - a.length;});
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
        }
        f += "}";
        // Otherwise, simply generate a flat `switch` statement.
    } else {
        compareTo(words);
    }
    return new Function("str", f);
};

function all(array, predicate) {
    for (var i = array.length; --i >= 0;)
        if (!predicate(array[i]))
            return false;
    return true;
};

function Dictionary() {
    this._values = Object.create(null);
    this._size = 0;
};
Dictionary.prototype = {
    set: function(key, val) {
        if (!this.has(key)) ++this._size;
        this._values["$" + key] = val;
        return this;
    },
    add: function(key, val) {
        if (this.has(key)) {
            this.get(key).push(val);
        } else {
            this.set(key, [ val ]);
        }
        return this;
    },
    get: function(key) { return this._values["$" + key] },
    del: function(key) {
        if (this.has(key)) {
            --this._size;
            delete this._values["$" + key];
        }
        return this;
    },
    has: function(key) { return ("$" + key) in this._values },
    each: function(f) {
        for (var i in this._values)
            f(this._values[i], i.substr(1));
    },
    size: function() {
        return this._size;
    },
    map: function(f) {
        var ret = [];
        for (var i in this._values)
            ret.push(f(this._values[i], i.substr(1)));
        return ret;
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function DEFNODE(type, props, methods, base) {
    if (arguments.length < 4) base = AST_Node;
    if (!props) props = [];
    else props = props.split(/\s+/);
    var self_props = props;
    if (base && base.PROPS)
        props = props.concat(base.PROPS);
    var code = "return function AST_" + type + "(props){ if (props) { ";
    for (var i = props.length; --i >= 0;) {
        code += "this." + props[i] + " = props." + props[i] + ";";
    }
    var proto = base && new base;
    if (proto && proto.initialize || (methods && methods.initialize))
        code += "this.initialize();";
    code += "}}";
    var ctor = new Function(code)();
    if (proto) {
        ctor.prototype = proto;
        ctor.BASE = base;
    }
    if (base) base.SUBCLASSES.push(ctor);
    ctor.prototype.CTOR = ctor;
    ctor.PROPS = props || null;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    if (type) {
        ctor.prototype.TYPE = ctor.TYPE = type;
    }
    if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
        if (/^\$/.test(i)) {
            ctor[i.substr(1)] = methods[i];
        } else {
            ctor.prototype[i] = methods[i];
        }
    }
    ctor.DEFMETHOD = function(name, method) {
        this.prototype[name] = method;
    };
    return ctor;
};

var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {
}, null);

var AST_Node = DEFNODE("Node", "start end", {
    clone: function() {
        return new this.CTOR(this);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
        start: "[AST_Token] The first token of this node",
        end: "[AST_Token] The last token of this node"
    },
    _walk: function(visitor) {
        return visitor._visit(this);
    },
    walk: function(visitor) {
        return this._walk(visitor); // not sure the indirection will be any help
    }
}, null);

AST_Node.warn_function = null;
AST_Node.warn = function(txt, props) {
    if (AST_Node.warn_function)
        AST_Node.warn_function(string_template(txt, props));
};

/* -----[ statements ]----- */

var AST_Statement = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
});

var AST_Debugger = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement",
}, AST_Statement);

var AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
        scope: "[AST_Scope/S] The scope that this directive affects"
    },
}, AST_Statement);

var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

function walk_body(node, visitor) {
    if (node.body instanceof AST_Statement) {
        node.body._walk(visitor);
    }
    else node.body.forEach(function(stat){
        stat._walk(visitor);
    });
};

var AST_Block = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually bracketed)",
    $propdoc: {
        body: "[AST_Statement*] an array of statements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
        });
    }
}, AST_Statement);

var AST_BlockStatement = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement",
}, AST_Block);

var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _walk: function(visitor) {
        return visitor._visit(this);
    }
}, AST_Statement);

var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
        label: "[AST_Label] a label definition"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.label._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_IterationStatement = DEFNODE("IterationStatement", null, {
    $documentation: "Internal class.  All loops inherit from it."
}, AST_StatementWithBody);

var AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_Do = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
}, AST_DWLoop);

var AST_While = DEFNODE("While", null, {
    $documentation: "A `while` statement",
}, AST_DWLoop);

var AST_For = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
        init: "[AST_Node?] the `for` initialization code, or null if empty",
        condition: "[AST_Node?] the `for` termination clause, or null if empty",
        step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.init) this.init._walk(visitor);
            if (this.condition) this.condition._walk(visitor);
            if (this.step) this.step._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        init: "[AST_Node] the `for/in` initialization code",
        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        object: "[AST_Node] the object that we're looping through"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_With = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
        expression: "[AST_Node] the `with` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ scope and functions ]----- */

var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
        directives: "[string*/S] an array of directives declared in this scope",
        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
    },
}, AST_Block);

var AST_Toplevel = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
    },
    wrap_enclose: function(arg_parameter_pairs) {
        var self = this;
        var args = [];
        var parameters = [];

        arg_parameter_pairs.forEach(function(pair) {
            var split = pair.split(":");

            args.push(split[0]);
            parameters.push(split[1]);
        });

        var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_Directive && node.value == "$ORIG") {
                return MAP.splice(self.body);
            }
        }));
        return wrapped_tl;
    },
    wrap_commonjs: function(name, export_all) {
        var self = this;
        var to_export = [];
        if (export_all) {
            self.figure_out_scope();
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                    if (!find_if(function(n){ return n.name == node.name }, to_export))
                        to_export.push(node);
                }
            }));
        }
        var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_SimpleStatement) {
                node = node.body;
                if (node instanceof AST_String) switch (node.getValue()) {
                  case "$ORIG":
                    return MAP.splice(self.body);
                  case "$EXPORTS":
                    var body = [];
                    to_export.forEach(function(sym){
                        body.push(new AST_SimpleStatement({
                            body: new AST_Assign({
                                left: new AST_Sub({
                                    expression: new AST_SymbolRef({ name: "exports" }),
                                    property: new AST_String({ value: sym.name }),
                                }),
                                operator: "=",
                                right: new AST_SymbolRef(sym),
                            }),
                        }));
                    });
                    return MAP.splice(body);
                }
            }
        }));
        return wrapped_tl;
    }
}, AST_Scope);

var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function",
        argnames: "[AST_SymbolFunarg*] array of function arguments",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.name) this.name._walk(visitor);
            this.argnames.forEach(function(arg){
                arg._walk(visitor);
            });
            walk_body(this, visitor);
        });
    }
}, AST_Scope);

var AST_Accessor = DEFNODE("Accessor", null, {
    $documentation: "A setter/getter function.  The `name` property is always null."
}, AST_Lambda);

var AST_Function = DEFNODE("Function", null, {
    $documentation: "A function expression"
}, AST_Lambda);

var AST_Defun = DEFNODE("Defun", null, {
    $documentation: "A function definition"
}, AST_Lambda);

/* -----[ JUMPS ]----- */

var AST_Jump = DEFNODE("Jump", null, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement);

var AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.value && function(){
            this.value._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Return = DEFNODE("Return", null, {
    $documentation: "A `return` statement"
}, AST_Exit);

var AST_Throw = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement"
}, AST_Exit);

var AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none",
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.label && function(){
            this.label._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Break = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
}, AST_LoopControl);

var AST_Continue = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
}, AST_LoopControl);

/* -----[ IF ]----- */

var AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative) this.alternative._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ SWITCH ]----- */

var AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
}, AST_Block);

var AST_Default = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch",
}, AST_SwitchBranch);

var AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_SwitchBranch);

/* -----[ EXCEPTIONS ]----- */

var AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
            if (this.bcatch) this.bcatch._walk(visitor);
            if (this.bfinally) this.bfinally._walk(visitor);
        });
    }
}, AST_Block);

// XXX: this is wrong according to ECMA-262 (12.4).  the catch block
// should introduce another scope, as the argname should be visible
// only inside the catch block.  However, doing it this way because of
// IE which simply introduces the name in the surrounding scope.  If
// we ever want to fix this then AST_Catch should inherit from
// AST_Scope.
var AST_Catch = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.argname._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_Finally = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block);

/* -----[ VAR/CONST ]----- */

var AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.definitions.forEach(function(def){
                def._walk(visitor);
            });
        });
    }
}, AST_Statement);

var AST_Var = DEFNODE("Var", null, {
    $documentation: "A `var` statement"
}, AST_Definitions);

var AST_Const = DEFNODE("Const", null, {
    $documentation: "A `const` statement"
}, AST_Definitions);

var AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.name._walk(visitor);
            if (this.value) this.value._walk(visitor);
        });
    }
});

/* -----[ OTHER ]----- */

var AST_Call = DEFNODE("Call", "expression args", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.args.forEach(function(arg){
                arg._walk(visitor);
            });
        });
    }
});

var AST_New = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
}, AST_Call);

var AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "A sequence expression (two comma-separated expressions)",
    $propdoc: {
        car: "[AST_Node] first element in sequence",
        cdr: "[AST_Node] second element in sequence"
    },
    $cons: function(x, y) {
        var seq = new AST_Seq(x);
        seq.car = x;
        seq.cdr = y;
        return seq;
    },
    $from_array: function(array) {
        if (array.length == 0) return null;
        if (array.length == 1) return array[0].clone();
        var list = null;
        for (var i = array.length; --i >= 0;) {
            list = AST_Seq.cons(array[i], list);
        }
        var p = list;
        while (p) {
            if (p.cdr && !p.cdr.cdr) {
                p.cdr = p.cdr.car;
                break;
            }
            p = p.cdr;
        }
        return list;
    },
    to_array: function() {
        var p = this, a = [];
        while (p) {
            a.push(p.car);
            if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                a.push(p.cdr);
                break;
            }
            p = p.cdr;
        }
        return a;
    },
    add: function(node) {
        var p = this;
        while (p) {
            if (!(p.cdr instanceof AST_Seq)) {
                var cell = AST_Seq.cons(p.cdr, node);
                return p.cdr = cell;
            }
            p = p.cdr;
        }
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.car._walk(visitor);
            if (this.cdr) this.cdr._walk(visitor);
        });
    }
});

var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
        expression: "[AST_Node] the “container” expression",
        property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
});

var AST_Dot = DEFNODE("Dot", null, {
    $documentation: "A dotted property access expression",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Sub = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.property._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
});

var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary);

var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary);

var AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.left._walk(visitor);
            this.right._walk(visitor);
        });
    }
});

var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
        });
    }
});

var AST_Assign = DEFNODE("Assign", null, {
    $documentation: "An assignment expression — `a = b + 5`",
}, AST_Binary);

/* -----[ LITERALS ]----- */

var AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.elements.forEach(function(el){
                el._walk(visitor);
            });
        });
    }
});

var AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.properties.forEach(function(prop){
                prop._walk(visitor);
            });
        });
    }
});

var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
        key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",
        value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.value._walk(visitor);
        });
    }
});

var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
}, AST_ObjectProperty);

var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
}, AST_ObjectProperty);

var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
}, AST_ObjectProperty);

var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols",
});

var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol);

var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol);

var AST_SymbolVar = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable",
}, AST_SymbolDeclaration);

var AST_SymbolConst = DEFNODE("SymbolConst", null, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration);

var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument",
}, AST_SymbolVar);

var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function",
}, AST_SymbolDeclaration);

var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression",
}, AST_SymbolDeclaration);

var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch",
}, AST_SymbolDeclaration);

var AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function() {
        this.references = [];
        this.thedef = this;
    }
}, AST_Symbol);

var AST_SymbolRef = DEFNODE("SymbolRef", null, {
    $documentation: "Reference to some symbol (not definition/declaration)",
}, AST_Symbol);

var AST_LabelRef = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol",
}, AST_Symbol);

var AST_This = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
}, AST_Symbol);

var AST_Constant = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    getValue: function() {
        return this.value;
    }
});

var AST_String = DEFNODE("String", "value", {
    $documentation: "A string literal",
    $propdoc: {
        value: "[string] the contents of this string"
    }
}, AST_Constant);

var AST_Number = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
        value: "[number] the numeric value"
    }
}, AST_Constant);

var AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
        value: "[RegExp] the actual regexp"
    }
}, AST_Constant);

var AST_Atom = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
}, AST_Constant);

var AST_Null = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
}, AST_Atom);

var AST_NaN = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0/0
}, AST_Atom);

var AST_Undefined = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: (function(){}())
}, AST_Atom);

var AST_Hole = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: (function(){}())
}, AST_Atom);

var AST_Infinity = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1/0
}, AST_Atom);

var AST_Boolean = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
}, AST_Atom);

var AST_False = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
}, AST_Boolean);

var AST_True = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
}, AST_Boolean);

/* -----[ TreeWalker ]----- */

function TreeWalker(callback) {
    this.visit = callback;
    this.stack = [];
};
TreeWalker.prototype = {
    _visit: function(node, descend) {
        this.stack.push(node);
        var ret = this.visit(node, descend ? function(){
            descend.call(node);
        } : noop);
        if (!ret && descend) {
            descend.call(node);
        }
        this.stack.pop();
        return ret;
    },
    parent: function(n) {
        return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function (node) {
        this.stack.push(node);
    },
    pop: function() {
        return this.stack.pop();
    },
    self: function() {
        return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
        var stack = this.stack;
        for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof type) return x;
        }
    },
    has_directive: function(type) {
        return this.find_parent(AST_Scope).has_directive(type);
    },
    in_boolean_context: function() {
        var stack = this.stack;
        var i = stack.length, self = stack[--i];
        while (i > 0) {
            var p = stack[--i];
            if ((p instanceof AST_If           && p.condition === self) ||
                (p instanceof AST_Conditional  && p.condition === self) ||
                (p instanceof AST_DWLoop       && p.condition === self) ||
                (p instanceof AST_For          && p.condition === self) ||
                (p instanceof AST_UnaryPrefix  && p.operator == "!" && p.expression === self))
            {
                return true;
            }
            if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")))
                return false;
            self = p;
        }
    },
    loopcontrol_target: function(label) {
        var stack = this.stack;
        if (label) for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                return x.body;
            }
        } else for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_Switch || x instanceof AST_IterationStatement)
                return x;
        }
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';
var KEYWORDS_ATOM = 'false null true';
var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile'
    + " " + KEYWORDS_ATOM + " " + KEYWORDS;
var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';

KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);

var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));

var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

// regexps adapted from http://xregexp.com/plugins/#unicode
var UNICODE = {
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};

function is_letter(code) {
    return (code >= 97 && code <= 122)
        || (code >= 65 && code <= 90)
        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));
};

function is_digit(code) {
    return code >= 48 && code <= 57; //XXX: find out if "UnicodeDigit" means something else than 0..9
};

function is_alphanumeric_char(code) {
    return is_digit(code) || is_letter(code);
};

function is_unicode_combining_mark(ch) {
    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
};

function is_identifier(name) {
    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
};

function is_identifier_start(code) {
    return code == 36 || code == 95 || is_letter(code);
};

function is_identifier_char(ch) {
    var code = ch.charCodeAt(0);
    return is_identifier_start(code)
        || is_digit(code)
        || code == 8204 // \u200c: zero-width non-joiner <ZWNJ>
        || code == 8205 // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        || is_unicode_combining_mark(ch)
        || is_unicode_connector_punctuation(ch)
    ;
};

function is_identifier_string(str){
    var i = str.length;
    if (i == 0) return false;
    if (!is_identifier_start(str.charCodeAt(0))) return false;
    while (--i >= 0) {
        if (!is_identifier_char(str.charAt(i)))
            return false;
    }
    return true;
};

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    } else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    } else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
};

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, filename, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT, filename, html5_comments) {

    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ''),
        filename        : filename,
        pos             : 0,
        tokpos          : 0,
        line            : 1,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };

    function peek() { return S.text.charAt(S.pos); };

    function next(signal_eof, in_string) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch)
            throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
        } else {
            ++S.col;
        }
        return ch;
    };

    function forward(i) {
        while (i-- > 0) next();
    };

    function looking_at(str) {
        return S.text.substr(S.pos, str.length) == str;
    };

    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    };

    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    };

    var prev_was_dot = false;
    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX(value)) ||
                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value)) ||
                           (type == "punc" && PUNC_BEFORE_EXPRESSION(value)));
        prev_was_dot = (type == "punc" && value == ".");
        var ret = {
            type   : type,
            value  : value,
            line   : S.tokline,
            col    : S.tokcol,
            pos    : S.tokpos,
            endpos : S.pos,
            nlb    : S.newline_before,
            file   : filename
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
            // make note of any newlines in the comments that came before
            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
            }
        }
        S.newline_before = false;
        return new AST_Token(ret);
    };

    function skip_whitespace() {
        while (WHITESPACE_CHARS(peek()))
            next();
    };

    function read_while(pred) {
        var ret = "", ch, i = 0;
        while ((ch = peek()) && pred(ch, i++))
            ret += next();
        return ret;
    };

    function parse_error(err) {
        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
    };

    function read_num(prefix) {
        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
        var num = read_while(function(ch, i){
            var code = ch.charCodeAt(0);
            switch (code) {
              case 120: case 88: // xX
                return has_x ? false : (has_x = true);
              case 101: case 69: // eE
                return has_x ? true : has_e ? false : (has_e = after_e = true);
              case 45: // -
                return after_e || (i == 0 && !prefix);
              case 43: // +
                return after_e;
              case (after_e = false, 46): // .
                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
            }
            return is_alphanumeric_char(code);
        });
        if (prefix) num = prefix + num;
        var valid = parse_js_number(num);
        if (!isNaN(valid)) {
            return token("num", valid);
        } else {
            parse_error("Invalid syntax: " + num);
        }
    };

    function read_escaped_char(in_string) {
        var ch = next(true, in_string);
        switch (ch.charCodeAt(0)) {
          case 110 : return "\n";
          case 114 : return "\r";
          case 116 : return "\t";
          case 98  : return "\b";
          case 118 : return "\u000b"; // \v
          case 102 : return "\f";
          case 48  : return "\0";
          case 120 : return String.fromCharCode(hex_bytes(2)); // \x
          case 117 : return String.fromCharCode(hex_bytes(4)); // \u
          case 10  : return ""; // newline
          default  : return ch;
        }
    };

    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit))
                parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    };

    var read_string = with_eof_error("Unterminated string constant", function(){
        var quote = next(), ret = "";
        for (;;) {
            var ch = next(true);
            if (ch == "\\") {
                // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                // https://github.com/mishoo/UglifyJS/issues/178
                var octal_len = 0, first = null;
                ch = read_while(function(ch){
                    if (ch >= "0" && ch <= "7") {
                        if (!first) {
                            first = ch;
                            return ++octal_len;
                        }
                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                    }
                    return false;
                });
                if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                else ch = read_escaped_char(true);
            }
            else if (ch == quote) break;
            ret += ch;
        }
        return token("string", ret);
    });

    function skip_line_comment(type) {
        var regex_allowed = S.regex_allowed;
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        S.comments_before.push(token(type, ret, true));
        S.regex_allowed = regex_allowed;
        return next_token();
    };

    var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function(){
        var regex_allowed = S.regex_allowed;
        var i = find("*/", true);
        var text = S.text.substring(S.pos, i);
        var a = text.split("\n"), n = a.length;
        // update stream position
        S.pos = i + 2;
        S.line += n - 1;
        if (n > 1) S.col = a[n - 1].length;
        else S.col += a[n - 1].length;
        S.col += 2;
        var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
        S.comments_before.push(token("comment2", text, true));
        S.regex_allowed = regex_allowed;
        S.newline_before = nlb;
        return next_token();
    });

    function read_name() {
        var backslash = false, name = "", ch, escaped = false, hex;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") escaped = backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        if (KEYWORDS(name) && escaped) {
            hex = name.charCodeAt(0).toString(16).toUpperCase();
            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
        }
        return name;
    };

    var read_regexp = with_eof_error("Unterminated regular expression", function(regexp){
        var prev_backslash = false, ch, in_class = false;
        while ((ch = next(true))) if (prev_backslash) {
            regexp += "\\" + ch;
            prev_backslash = false;
        } else if (ch == "[") {
            in_class = true;
            regexp += ch;
        } else if (ch == "]" && in_class) {
            in_class = false;
            regexp += ch;
        } else if (ch == "/" && !in_class) {
            break;
        } else if (ch == "\\") {
            prev_backslash = true;
        } else {
            regexp += ch;
        }
        var mods = read_name();
        return token("regexp", new RegExp(regexp, mods));
    });

    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (OPERATORS(bigger)) {
                next();
                return grow(bigger);
            } else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    };

    function handle_slash() {
        next();
        switch (peek()) {
          case "/":
            next();
            return skip_line_comment("comment1");
          case "*":
            next();
            return skip_multiline_comment();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    };

    function handle_dot() {
        next();
        return is_digit(peek().charCodeAt(0))
            ? read_num(".")
            : token("punc", ".");
    };

    function read_word() {
        var word = read_name();
        if (prev_was_dot) return token("name", word);
        return KEYWORDS_ATOM(word) ? token("atom", word)
            : !KEYWORDS(word) ? token("name", word)
            : OPERATORS(word) ? token("operator", word)
            : token("keyword", word);
    };

    function with_eof_error(eof_error, cont) {
        return function(x) {
            try {
                return cont(x);
            } catch(ex) {
                if (ex === EX_EOF) parse_error(eof_error);
                else throw ex;
            }
        };
    };

    function next_token(force_regexp) {
        if (force_regexp != null)
            return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        if (html5_comments) {
            if (looking_at("<!--")) {
                forward(4);
                return skip_line_comment("comment3");
            }
            if (looking_at("-->") && S.newline_before) {
                forward(3);
                return skip_line_comment("comment4");
            }
        }
        var ch = peek();
        if (!ch) return token("eof");
        var code = ch.charCodeAt(0);
        switch (code) {
          case 34: case 39: return read_string();
          case 46: return handle_dot();
          case 47: return handle_slash();
        }
        if (is_digit(code)) return read_num();
        if (PUNC_CHARS(ch)) return token("punc", next());
        if (OPERATOR_CHARS(ch)) return read_operator();
        if (code == 92 || is_identifier_start(code)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    };

    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };

    return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
]);

var UNARY_POSTFIX = makePredicate([ "--", "++" ]);

var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);

var PRECEDENCE = (function(a, ret){
    for (var i = 0; i < a.length; ++i) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = i + 1;
        }
    }
    return ret;
})(
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ],
    {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function parse($TEXT, options) {

    options = defaults(options, {
        strict         : false,
        filename       : null,
        toplevel       : null,
        expression     : false,
        html5_comments : true,
    });

    var S = {
        input         : (typeof $TEXT == "string"
                         ? tokenizer($TEXT, options.filename,
                                     options.html5_comments)
                         : $TEXT),
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    };

    function peek() { return S.peeked || (S.peeked = S.input()); };

    function next() {
        S.prev = S.token;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        } else {
            S.token = S.input();
        }
        S.in_directives = S.in_directives && (
            S.token.type == "string" || is("punc", ";")
        );
        return S.token;
    };

    function prev() {
        return S.prev;
    };

    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 ctx.filename,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    };

    function token_error(token, msg) {
        croak(msg, token.line, token.col);
    };

    function unexpected(token) {
        if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
    };

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
    };

    function expect(punc) { return expect_token("punc", punc); };

    function can_insert_semicolon() {
        return !options.strict && (
            S.token.nlb || is("eof") || is("punc", "}")
        );
    };

    function semicolon() {
        if (is("punc", ";")) next();
        else if (!can_insert_semicolon()) unexpected();
    };

    function parenthesised() {
        expect("(");
        var exp = expression(true);
        expect(")");
        return exp;
    };

    function embed_tokens(parser) {
        return function() {
            var start = S.token;
            var expr = parser();
            var end = prev();
            expr.start = start;
            expr.end = end;
            return expr;
        };
    };

    function handle_regexp() {
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
    };

    var statement = embed_tokens(function() {
        var tmp;
        handle_regexp();
        switch (S.token.type) {
          case "string":
            var dir = S.in_directives, stat = simple_statement();
            // XXXv2: decide how to fix directives
            if (dir && stat.body instanceof AST_String && !is("punc", ","))
                return new AST_Directive({ value: stat.body.value });
            return stat;
          case "num":
          case "regexp":
          case "operator":
          case "atom":
            return simple_statement();

          case "name":
            return is_token(peek(), "punc", ":")
                ? labeled_statement()
                : simple_statement();

          case "punc":
            switch (S.token.value) {
              case "{":
                return new AST_BlockStatement({
                    start : S.token,
                    body  : block_(),
                    end   : prev()
                });
              case "[":
              case "(":
                return simple_statement();
              case ";":
                next();
                return new AST_EmptyStatement();
              default:
                unexpected();
            }

          case "keyword":
            switch (tmp = S.token.value, next(), tmp) {
              case "break":
                return break_cont(AST_Break);

              case "continue":
                return break_cont(AST_Continue);

              case "debugger":
                semicolon();
                return new AST_Debugger();

              case "do":
                return new AST_Do({
                    body      : in_loop(statement),
                    condition : (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), tmp)
                });

              case "while":
                return new AST_While({
                    condition : parenthesised(),
                    body      : in_loop(statement)
                });

              case "for":
                return for_();

              case "function":
                return function_(AST_Defun);

              case "if":
                return if_();

              case "return":
                if (S.in_function == 0)
                    croak("'return' outside of function");
                return new AST_Return({
                    value: ( is("punc", ";")
                             ? (next(), null)
                             : can_insert_semicolon()
                             ? null
                             : (tmp = expression(true), semicolon(), tmp) )
                });

              case "switch":
                return new AST_Switch({
                    expression : parenthesised(),
                    body       : in_loop(switch_body_)
                });

              case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return new AST_Throw({
                    value: (tmp = expression(true), semicolon(), tmp)
                });

              case "try":
                return try_();

              case "var":
                return tmp = var_(), semicolon(), tmp;

              case "const":
                return tmp = const_(), semicolon(), tmp;

              case "with":
                return new AST_With({
                    expression : parenthesised(),
                    body       : statement()
                });

              default:
                unexpected();
            }
        }
    });

    function labeled_statement() {
        var label = as_symbol(AST_Label);
        if (find_if(function(l){ return l.name == label.name }, S.labels)) {
            // ECMA-262, 12.12: An ECMAScript program is considered
            // syntactically incorrect if it contains a
            // LabelledStatement that is enclosed by a
            // LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice");
        }
        expect(":");
        S.labels.push(label);
        var stat = statement();
        S.labels.pop();
        if (!(stat instanceof AST_IterationStatement)) {
            // check for `continue` that refers to this label.
            // those should be reported as syntax errors.
            // https://github.com/mishoo/UglifyJS2/issues/287
            label.references.forEach(function(ref){
                if (ref instanceof AST_Continue) {
                    ref = ref.label.start;
                    croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
                          ref.line, ref.col, ref.pos);
                }
            });
        }
        return new AST_LabeledStatement({ body: stat, label: label });
    };

    function simple_statement(tmp) {
        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
    };

    function break_cont(type) {
        var label = null, ldef;
        if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
        }
        if (label != null) {
            ldef = find_if(function(l){ return l.name == label.name }, S.labels);
            if (!ldef)
                croak("Undefined label " + label.name);
            label.thedef = ldef;
        }
        else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
        semicolon();
        var stat = new type({ label: label });
        if (ldef) ldef.references.push(stat);
        return stat;
    };

    function for_() {
        expect("(");
        var init = null;
        if (!is("punc", ";")) {
            init = is("keyword", "var")
                ? (next(), var_(true))
                : expression(true, true);
            if (is("operator", "in")) {
                if (init instanceof AST_Var && init.definitions.length > 1)
                    croak("Only one variable declaration allowed in for..in loop");
                next();
                return for_in(init);
            }
        }
        return regular_for(init);
    };

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression(true);
        expect(";");
        var step = is("punc", ")") ? null : expression(true);
        expect(")");
        return new AST_For({
            init      : init,
            condition : test,
            step      : step,
            body      : in_loop(statement)
        });
    };

    function for_in(init) {
        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
        var obj = expression(true);
        expect(")");
        return new AST_ForIn({
            init   : init,
            name   : lhs,
            object : obj,
            body   : in_loop(statement)
        });
    };

    var function_ = function(ctor) {
        var in_statement = ctor === AST_Defun;
        var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
        if (in_statement && !name)
            unexpected();
        expect("(");
        return new ctor({
            name: name,
            argnames: (function(first, a){
                while (!is("punc", ")")) {
                    if (first) first = false; else expect(",");
                    a.push(as_symbol(AST_SymbolFunarg));
                }
                next();
                return a;
            })(true, []),
            body: (function(loop, labels){
                ++S.in_function;
                S.in_directives = true;
                S.in_loop = 0;
                S.labels = [];
                var a = block_();
                --S.in_function;
                S.in_loop = loop;
                S.labels = labels;
                return a;
            })(S.in_loop, S.labels)
        });
    };

    function if_() {
        var cond = parenthesised(), body = statement(), belse = null;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return new AST_If({
            condition   : cond,
            body        : body,
            alternative : belse
        });
    };

    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            a.push(statement());
        }
        next();
        return a;
    };

    function switch_body_() {
        expect("{");
        var a = [], cur = null, branch = null, tmp;
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            if (is("keyword", "case")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Case({
                    start      : (tmp = S.token, next(), tmp),
                    expression : expression(true),
                    body       : cur
                });
                a.push(branch);
                expect(":");
            }
            else if (is("keyword", "default")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Default({
                    start : (tmp = S.token, next(), expect(":"), tmp),
                    body  : cur
                });
                a.push(branch);
            }
            else {
                if (!cur) unexpected();
                cur.push(statement());
            }
        }
        if (branch) branch.end = prev();
        next();
        return a;
    };

    function try_() {
        var body = block_(), bcatch = null, bfinally = null;
        if (is("keyword", "catch")) {
            var start = S.token;
            next();
            expect("(");
            var name = as_symbol(AST_SymbolCatch);
            expect(")");
            bcatch = new AST_Catch({
                start   : start,
                argname : name,
                body    : block_(),
                end     : prev()
            });
        }
        if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
                start : start,
                body  : block_(),
                end   : prev()
            });
        }
        if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
        return new AST_Try({
            body     : body,
            bcatch   : bcatch,
            bfinally : bfinally
        });
    };

    function vardefs(no_in, in_const) {
        var a = [];
        for (;;) {
            a.push(new AST_VarDef({
                start : S.token,
                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                value : is("operator", "=") ? (next(), expression(false, no_in)) : null,
                end   : prev()
            }));
            if (!is("punc", ","))
                break;
            next();
        }
        return a;
    };

    var var_ = function(no_in) {
        return new AST_Var({
            start       : prev(),
            definitions : vardefs(no_in, false),
            end         : prev()
        });
    };

    var const_ = function() {
        return new AST_Const({
            start       : prev(),
            definitions : vardefs(false, true),
            end         : prev()
        });
    };

    var new_ = function() {
        var start = S.token;
        expect_token("operator", "new");
        var newexp = expr_atom(false), args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        } else {
            args = [];
        }
        return subscripts(new AST_New({
            start      : start,
            expression : newexp,
            args       : args,
            end        : prev()
        }), true);
    };

    function as_atom_node() {
        var tok = S.token, ret;
        switch (tok.type) {
          case "name":
          case "keyword":
            ret = _make_symbol(AST_SymbolRef);
            break;
          case "num":
            ret = new AST_Number({ start: tok, end: tok, value: tok.value });
            break;
          case "string":
            ret = new AST_String({ start: tok, end: tok, value: tok.value });
            break;
          case "regexp":
            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });
            break;
          case "atom":
            switch (tok.value) {
              case "false":
                ret = new AST_False({ start: tok, end: tok });
                break;
              case "true":
                ret = new AST_True({ start: tok, end: tok });
                break;
              case "null":
                ret = new AST_Null({ start: tok, end: tok });
                break;
            }
            break;
        }
        next();
        return ret;
    };

    var expr_atom = function(allow_calls) {
        if (is("operator", "new")) {
            return new_();
        }
        var start = S.token;
        if (is("punc")) {
            switch (start.value) {
              case "(":
                next();
                var ex = expression(true);
                ex.start = start;
                ex.end = S.token;
                expect(")");
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_(), allow_calls);
            }
            unexpected();
        }
        if (is("keyword", "function")) {
            next();
            var func = function_(AST_Function);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
        }
        if (ATOMIC_START_TOKEN[S.token.type]) {
            return subscripts(as_atom_node(), allow_calls);
        }
        unexpected();
    };

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true, a = [];
        while (!is("punc", closing)) {
            if (first) first = false; else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    };

    var array_ = embed_tokens(function() {
        expect("[");
        return new AST_Array({
            elements: expr_list("]", !options.strict, true)
        });
    });

    var object_ = embed_tokens(function() {
        expect("{");
        var first = true, a = [];
        while (!is("punc", "}")) {
            if (first) first = false; else expect(",");
            if (!options.strict && is("punc", "}"))
                // allow trailing comma
                break;
            var start = S.token;
            var type = start.type;
            var name = as_property_name();
            if (type == "name" && !is("punc", ":")) {
                if (name == "get") {
                    a.push(new AST_ObjectGetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
                if (name == "set") {
                    a.push(new AST_ObjectSetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
            }
            expect(":");
            a.push(new AST_ObjectKeyVal({
                start : start,
                key   : name,
                value : expression(false),
                end   : prev()
            }));
        }
        next();
        return new AST_Object({ properties: a });
    });

    function as_property_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "num":
          case "string":
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function as_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function _make_symbol(type) {
        var name = S.token.value;
        return new (name == "this" ? AST_This : type)({
            name  : String(name),
            start : S.token,
            end   : S.token
        });
    };

    function as_symbol(type, noerror) {
        if (!is("name")) {
            if (!noerror) croak("Name expected");
            return null;
        }
        var sym = _make_symbol(type);
        next();
        return sym;
    };

    var subscripts = function(expr, allow_calls) {
        var start = expr.start;
        if (is("punc", ".")) {
            next();
            return subscripts(new AST_Dot({
                start      : start,
                expression : expr,
                property   : as_name(),
                end        : prev()
            }), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return subscripts(new AST_Sub({
                start      : start,
                expression : expr,
                property   : prop,
                end        : prev()
            }), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(new AST_Call({
                start      : start,
                expression : expr,
                args       : expr_list(")"),
                end        : prev()
            }), true);
        }
        return expr;
    };

    var maybe_unary = function(allow_calls) {
        var start = S.token;
        if (is("operator") && UNARY_PREFIX(start.value)) {
            next();
            handle_regexp();
            var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
            val = make_unary(AST_UnaryPostfix, S.token.value, val);
            val.start = start;
            val.end = S.token;
            next();
        }
        return val;
    };

    function make_unary(ctor, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr))
            croak("Invalid use of " + op + " operator");
        return new ctor({ operator: op, expression: expr });
    };

    var expr_op = function(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(new AST_Binary({
                start    : left.start,
                left     : left,
                operator : op,
                right    : right,
                end      : right.end
            }), min_prec, no_in);
        }
        return left;
    };

    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    };

    var maybe_conditional = function(no_in) {
        var start = S.token;
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
                start       : start,
                condition   : expr,
                consequent  : yes,
                alternative : expression(false, no_in),
                end         : peek()
            });
        }
        return expr;
    };

    function is_assignable(expr) {
        if (!options.strict) return true;
        if (expr instanceof AST_This) return false;
        return (expr instanceof AST_PropAccess || expr instanceof AST_Symbol);
    };

    var maybe_assign = function(no_in) {
        var start = S.token;
        var left = maybe_conditional(no_in), val = S.token.value;
        if (is("operator") && ASSIGNMENT(val)) {
            if (is_assignable(left)) {
                next();
                return new AST_Assign({
                    start    : start,
                    left     : left,
                    operator : val,
                    right    : maybe_assign(no_in),
                    end      : prev()
                });
            }
            croak("Invalid assignment");
        }
        return left;
    };

    var expression = function(commas, no_in) {
        var start = S.token;
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return new AST_Seq({
                start  : start,
                car    : expr,
                cdr    : expression(true, no_in),
                end    : peek()
            });
        }
        return expr;
    };

    function in_loop(cont) {
        ++S.in_loop;
        var ret = cont();
        --S.in_loop;
        return ret;
    };

    if (options.expression) {
        return expression(true);
    }

    return (function(){
        var start = S.token;
        var body = [];
        while (!is("eof"))
            body.push(statement());
        var end = prev();
        var toplevel = options.toplevel;
        if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
        } else {
            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
        }
        return toplevel;
    })();

};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// Tree transformer helpers.

function TreeTransformer(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
}
TreeTransformer.prototype = new TreeWalker;

(function(undefined){

    function _(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list){
            var x, y;
            tw.push(this);
            if (tw.before) x = tw.before(this, descend, in_list);
            if (x === undefined) {
                if (!tw.after) {
                    x = this;
                    descend(x, tw);
                } else {
                    tw.stack[tw.stack.length - 1] = x = this.clone();
                    descend(x, tw);
                    y = tw.after(x, in_list);
                    if (y !== undefined) x = y;
                }
            }
            tw.pop();
            return x;
        });
    };

    function do_list(list, tw) {
        return MAP(list, function(node){
            return node.transform(tw, true);
        });
    };

    _(AST_Node, noop);

    _(AST_LabeledStatement, function(self, tw){
        self.label = self.label.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_SimpleStatement, function(self, tw){
        self.body = self.body.transform(tw);
    });

    _(AST_Block, function(self, tw){
        self.body = do_list(self.body, tw);
    });

    _(AST_DWLoop, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_For, function(self, tw){
        if (self.init) self.init = self.init.transform(tw);
        if (self.condition) self.condition = self.condition.transform(tw);
        if (self.step) self.step = self.step.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_ForIn, function(self, tw){
        self.init = self.init.transform(tw);
        self.object = self.object.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_With, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_Exit, function(self, tw){
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_LoopControl, function(self, tw){
        if (self.label) self.label = self.label.transform(tw);
    });

    _(AST_If, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
        if (self.alternative) self.alternative = self.alternative.transform(tw);
    });

    _(AST_Switch, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Case, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Try, function(self, tw){
        self.body = do_list(self.body, tw);
        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
    });

    _(AST_Catch, function(self, tw){
        self.argname = self.argname.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Definitions, function(self, tw){
        self.definitions = do_list(self.definitions, tw);
    });

    _(AST_VarDef, function(self, tw){
        self.name = self.name.transform(tw);
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_Lambda, function(self, tw){
        if (self.name) self.name = self.name.transform(tw);
        self.argnames = do_list(self.argnames, tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Call, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.args = do_list(self.args, tw);
    });

    _(AST_Seq, function(self, tw){
        self.car = self.car.transform(tw);
        self.cdr = self.cdr.transform(tw);
    });

    _(AST_Dot, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Sub, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.property = self.property.transform(tw);
    });

    _(AST_Unary, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Binary, function(self, tw){
        self.left = self.left.transform(tw);
        self.right = self.right.transform(tw);
    });

    _(AST_Conditional, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.consequent = self.consequent.transform(tw);
        self.alternative = self.alternative.transform(tw);
    });

    _(AST_Array, function(self, tw){
        self.elements = do_list(self.elements, tw);
    });

    _(AST_Object, function(self, tw){
        self.properties = do_list(self.properties, tw);
    });

    _(AST_ObjectProperty, function(self, tw){
        self.value = self.value.transform(tw);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function SymbolDef(scope, index, orig) {
    this.name = orig.name;
    this.orig = [ orig ];
    this.scope = scope;
    this.references = [];
    this.global = false;
    this.mangled_name = null;
    this.undeclared = false;
    this.constant = false;
    this.index = index;
};

SymbolDef.prototype = {
    unmangleable: function(options) {
        return (this.global && !(options && options.toplevel))
            || this.undeclared
            || (!(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with));
    },
    mangle: function(options) {
        if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            if (!options.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda)
                s = s.parent_scope;
            this.mangled_name = s.next_mangled(options, this);
        }
    }
};

AST_Toplevel.DEFMETHOD("figure_out_scope", function(){
    // This does what ast_add_scope did in UglifyJS v1.
    //
    // Part of it could be done at parse time, but it would complicate
    // the parser (and it's already kinda complex).  It's also worth
    // having it separated because we might need to call it multiple
    // times on the same tree.

    // pass 1: setup scope chaining and handle definitions
    var self = this;
    var scope = self.parent_scope = null;
    var nesting = 0;
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Scope) {
            node.init_scope_vars(nesting);
            var save_scope = node.parent_scope = scope;
            ++nesting;
            scope = node;
            descend();
            scope = save_scope;
            --nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Directive) {
            node.scope = scope;
            push_uniq(scope.directives, node.value);
            return true;
        }
        if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
                s.uses_with = true;
            return;
        }
        if (node instanceof AST_Symbol) {
            node.scope = scope;
        }
        if (node instanceof AST_SymbolLambda) {
            scope.def_function(node);
        }
        else if (node instanceof AST_SymbolDefun) {
            // Careful here, the scope where this should be defined is
            // the parent scope.  The reason is that we enter a new
            // scope when we encounter the AST_Defun node (which is
            // instanceof AST_Scope) but we get to the symbol a bit
            // later.
            (node.scope = scope.parent_scope).def_function(node);
        }
        else if (node instanceof AST_SymbolVar
                 || node instanceof AST_SymbolConst) {
            var def = scope.def_variable(node);
            def.constant = node instanceof AST_SymbolConst;
            def.init = tw.parent().value;
        }
        else if (node instanceof AST_SymbolCatch) {
            // XXX: this is wrong according to ECMA-262 (12.4).  the
            // `catch` argument name should be visible only inside the
            // catch block.  For a quick fix AST_Catch should inherit
            // from AST_Scope.  Keeping it this way because of IE,
            // which doesn't obey the standard. (it introduces the
            // identifier in the enclosing scope)
            scope.def_variable(node);
        }
    });
    self.walk(tw);

    // pass 2: find back references and eval
    var func = null;
    var globals = self.globals = new Dictionary();
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Lambda) {
            var prev_func = func;
            func = node;
            descend();
            func = prev_func;
            return true;
        }
        if (node instanceof AST_SymbolRef) {
            var name = node.name;
            var sym = node.scope.find_variable(name);
            if (!sym) {
                var g;
                if (globals.has(name)) {
                    g = globals.get(name);
                } else {
                    g = new SymbolDef(self, globals.size(), node);
                    g.undeclared = true;
                    g.global = true;
                    globals.set(name, g);
                }
                node.thedef = g;
                if (name == "eval" && tw.parent() instanceof AST_Call) {
                    for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope)
                        s.uses_eval = true;
                }
                if (func && name == "arguments") {
                    func.uses_arguments = true;
                }
            } else {
                node.thedef = sym;
            }
            node.reference();
            return true;
        }
    });
    self.walk(tw);
});

AST_Scope.DEFMETHOD("init_scope_vars", function(nesting){
    this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
    this.variables = new Dictionary(); // map name to AST_SymbolVar (variables defined in this scope; includes functions)
    this.functions = new Dictionary(); // map name to AST_SymbolDefun (functions defined in this scope)
    this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
    this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
    this.parent_scope = null; // the parent scope
    this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
    this.cname = -1;          // the current index for mangling functions/variables
    this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
});

AST_Scope.DEFMETHOD("strict", function(){
    return this.has_directive("use strict");
});

AST_Lambda.DEFMETHOD("init_scope_vars", function(){
    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
    this.uses_arguments = false;
});

AST_SymbolRef.DEFMETHOD("reference", function() {
    var def = this.definition();
    def.references.push(this);
    var s = this.scope;
    while (s) {
        push_uniq(s.enclosed, def);
        if (s === def.scope) break;
        s = s.parent_scope;
    }
    this.frame = this.scope.nesting - def.scope.nesting;
});

AST_Scope.DEFMETHOD("find_variable", function(name){
    if (name instanceof AST_Symbol) name = name.name;
    return this.variables.get(name)
        || (this.parent_scope && this.parent_scope.find_variable(name));
});

AST_Scope.DEFMETHOD("has_directive", function(value){
    return this.parent_scope && this.parent_scope.has_directive(value)
        || (this.directives.indexOf(value) >= 0 ? this : null);
});

AST_Scope.DEFMETHOD("def_function", function(symbol){
    this.functions.set(symbol.name, this.def_variable(symbol));
});

AST_Scope.DEFMETHOD("def_variable", function(symbol){
    var def;
    if (!this.variables.has(symbol.name)) {
        def = new SymbolDef(this, this.variables.size(), symbol);
        this.variables.set(symbol.name, def);
        def.global = !this.parent_scope;
    } else {
        def = this.variables.get(symbol.name);
        def.orig.push(symbol);
    }
    return symbol.thedef = def;
});

AST_Scope.DEFMETHOD("next_mangled", function(options){
    var ext = this.enclosed;
    out: while (true) {
        var m = base54(++this.cname);
        if (!is_identifier(m)) continue; // skip over "do"
        // we must ensure that the mangled name does not shadow a name
        // from some parent scope that is referenced in this or in
        // inner scopes.
        for (var i = ext.length; --i >= 0;) {
            var sym = ext[i];
            var name = sym.mangled_name || (sym.unmangleable(options) && sym.name);
            if (m == name) continue out;
        }
        return m;
    }
});

AST_Function.DEFMETHOD("next_mangled", function(options, def){
    // #179, #326
    // in Safari strict mode, something like (function x(x){...}) is a syntax error;
    // a function expression's argument cannot shadow the function expression's name

    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
    while (true) {
        var name = AST_Lambda.prototype.next_mangled.call(this, options, def);
        if (!(tricky_def && tricky_def.mangled_name == name))
            return name;
    }
});

AST_Scope.DEFMETHOD("references", function(sym){
    if (sym instanceof AST_Symbol) sym = sym.definition();
    return this.enclosed.indexOf(sym) < 0 ? null : sym;
});

AST_Symbol.DEFMETHOD("unmangleable", function(options){
    return this.definition().unmangleable(options);
});

// property accessors are not mangleable
AST_SymbolAccessor.DEFMETHOD("unmangleable", function(){
    return true;
});

// labels are always mangleable
AST_Label.DEFMETHOD("unmangleable", function(){
    return false;
});

AST_Symbol.DEFMETHOD("unreferenced", function(){
    return this.definition().references.length == 0
        && !(this.scope.uses_eval || this.scope.uses_with);
});

AST_Symbol.DEFMETHOD("undeclared", function(){
    return this.definition().undeclared;
});

AST_LabelRef.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Label.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Symbol.DEFMETHOD("definition", function(){
    return this.thedef;
});

AST_Symbol.DEFMETHOD("global", function(){
    return this.definition().global;
});

AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options){
    return defaults(options, {
        except   : [],
        eval     : false,
        sort     : false,
        toplevel : false,
        screw_ie8 : false
    });
});

AST_Toplevel.DEFMETHOD("mangle_names", function(options){
    options = this._default_mangler_options(options);
    // We only need to mangle declaration nodes.  Special logic wired
    // into the code generator will display the mangled name if it's
    // present (and for AST_SymbolRef-s it'll use the mangled name of
    // the AST_SymbolDeclaration that it points to).
    var lname = -1;
    var to_mangle = [];
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_LabeledStatement) {
            // lname is incremented when we get to the AST_Label
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Scope) {
            var p = tw.parent(), a = [];
            node.variables.each(function(symbol){
                if (options.except.indexOf(symbol.name) < 0) {
                    a.push(symbol);
                }
            });
            if (options.sort) a.sort(function(a, b){
                return b.references.length - a.references.length;
            });
            to_mangle.push.apply(to_mangle, a);
            return;
        }
        if (node instanceof AST_Label) {
            var name;
            do name = base54(++lname); while (!is_identifier(name));
            node.mangled_name = name;
            return true;
        }
    });
    this.walk(tw);
    to_mangle.forEach(function(def){ def.mangle(options) });
});

AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options){
    options = this._default_mangler_options(options);
    var tw = new TreeWalker(function(node){
        if (node instanceof AST_Constant)
            base54.consider(node.print_to_string());
        else if (node instanceof AST_Return)
            base54.consider("return");
        else if (node instanceof AST_Throw)
            base54.consider("throw");
        else if (node instanceof AST_Continue)
            base54.consider("continue");
        else if (node instanceof AST_Break)
            base54.consider("break");
        else if (node instanceof AST_Debugger)
            base54.consider("debugger");
        else if (node instanceof AST_Directive)
            base54.consider(node.value);
        else if (node instanceof AST_While)
            base54.consider("while");
        else if (node instanceof AST_Do)
            base54.consider("do while");
        else if (node instanceof AST_If) {
            base54.consider("if");
            if (node.alternative) base54.consider("else");
        }
        else if (node instanceof AST_Var)
            base54.consider("var");
        else if (node instanceof AST_Const)
            base54.consider("const");
        else if (node instanceof AST_Lambda)
            base54.consider("function");
        else if (node instanceof AST_For)
            base54.consider("for");
        else if (node instanceof AST_ForIn)
            base54.consider("for in");
        else if (node instanceof AST_Switch)
            base54.consider("switch");
        else if (node instanceof AST_Case)
            base54.consider("case");
        else if (node instanceof AST_Default)
            base54.consider("default");
        else if (node instanceof AST_With)
            base54.consider("with");
        else if (node instanceof AST_ObjectSetter)
            base54.consider("set" + node.key);
        else if (node instanceof AST_ObjectGetter)
            base54.consider("get" + node.key);
        else if (node instanceof AST_ObjectKeyVal)
            base54.consider(node.key);
        else if (node instanceof AST_New)
            base54.consider("new");
        else if (node instanceof AST_This)
            base54.consider("this");
        else if (node instanceof AST_Try)
            base54.consider("try");
        else if (node instanceof AST_Catch)
            base54.consider("catch");
        else if (node instanceof AST_Finally)
            base54.consider("finally");
        else if (node instanceof AST_Symbol && node.unmangleable(options))
            base54.consider(node.name);
        else if (node instanceof AST_Unary || node instanceof AST_Binary)
            base54.consider(node.operator);
        else if (node instanceof AST_Dot)
            base54.consider(node.property);
    });
    this.walk(tw);
    base54.sort();
});

var base54 = (function() {
    var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
    var chars, frequency;
    function reset() {
        frequency = Object.create(null);
        chars = string.split("").map(function(ch){ return ch.charCodeAt(0) });
        chars.forEach(function(ch){ frequency[ch] = 0 });
    }
    base54.consider = function(str){
        for (var i = str.length; --i >= 0;) {
            var code = str.charCodeAt(i);
            if (code in frequency) ++frequency[code];
        }
    };
    base54.sort = function() {
        chars = mergeSort(chars, function(a, b){
            if (is_digit(a) && !is_digit(b)) return 1;
            if (is_digit(b) && !is_digit(a)) return -1;
            return frequency[b] - frequency[a];
        });
    };
    base54.reset = reset;
    reset();
    base54.get = function(){ return chars };
    base54.freq = function(){ return frequency };
    function base54(num) {
        var ret = "", base = 54;
        do {
            ret += String.fromCharCode(chars[num % base]);
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    };
    return base54;
})();

AST_Toplevel.DEFMETHOD("scope_warnings", function(options){
    options = defaults(options, {
        undeclared       : false, // this makes a lot of noise
        unreferenced     : true,
        assign_to_global : true,
        func_arguments   : true,
        nested_defuns    : true,
        eval             : true
    });
    var tw = new TreeWalker(function(node){
        if (options.undeclared
            && node instanceof AST_SymbolRef
            && node.undeclared())
        {
            // XXX: this also warns about JS standard names,
            // i.e. Object, Array, parseInt etc.  Should add a list of
            // exceptions.
            AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.assign_to_global)
        {
            var sym = null;
            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)
                sym = node.left;
            else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)
                sym = node.init;
            if (sym
                && (sym.undeclared()
                    || (sym.global() && sym.scope !== sym.definition().scope))) {
                AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                    msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                    name: sym.name,
                    file: sym.start.file,
                    line: sym.start.line,
                    col: sym.start.col
                });
            }
        }
        if (options.eval
            && node instanceof AST_SymbolRef
            && node.undeclared()
            && node.name == "eval") {
            AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
        }
        if (options.unreferenced
            && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label)
            && node.unreferenced()) {
            AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                type: node instanceof AST_Label ? "Label" : "Symbol",
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.func_arguments
            && node instanceof AST_Lambda
            && node.uses_arguments) {
            AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                name: node.name ? node.name.name : "anonymous",
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.nested_defuns
            && node instanceof AST_Defun
            && !(tw.parent() instanceof AST_Scope)) {
            AST_Node.warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                name: node.name.name,
                type: tw.parent().TYPE,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
    });
    this.walk(tw);
});

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function OutputStream(options) {

    options = defaults(options, {
        indent_start  : 0,
        indent_level  : 4,
        quote_keys    : false,
        space_colon   : true,
        ascii_only    : false,
        inline_script : false,
        width         : 80,
        max_line_len  : 32000,
        beautify      : false,
        source_map    : null,
        bracketize    : false,
        semicolons    : true,
        comments      : false,
        preserve_line : false,
        screw_ie8     : false,
        preamble      : null,
    }, true);

    var indentation = 0;
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var OUTPUT = "";

    function to_ascii(str, identifier) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
                while (code.length < 2) code = "0" + code;
                return "\\x" + code;
            } else {
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
            }
        });
    };

    function make_string(str) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
            switch (s) {
              case "\\": return "\\\\";
              case "\b": return "\\b";
              case "\f": return "\\f";
              case "\n": return "\\n";
              case "\r": return "\\r";
              case "\u2028": return "\\u2028";
              case "\u2029": return "\\u2029";
              case '"': ++dq; return '"';
              case "'": ++sq; return "'";
              case "\0": return "\\x00";
            }
            return s;
        });
        if (options.ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
    };

    function encode_string(str) {
        var ret = make_string(str);
        if (options.inline_script)
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
        return ret;
    };

    function make_name(name) {
        name = name.toString();
        if (options.ascii_only)
            name = to_ascii(name, true);
        return name;
    };

    function make_indent(back) {
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
    };

    /* -----[ beautification/minification ]----- */

    var might_need_space = false;
    var might_need_semicolon = false;
    var last = null;

    function last_char() {
        return last.charAt(last.length - 1);
    };

    function maybe_newline() {
        if (options.max_line_len && current_col > options.max_line_len)
            print("\n");
    };

    var requireSemicolonChars = makePredicate("( [ + * / - , .");

    function print(str) {
        str = String(str);
        var ch = str.charAt(0);
        if (might_need_semicolon) {
            if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                if (options.semicolons || requireSemicolonChars(ch)) {
                    OUTPUT += ";";
                    current_col++;
                    current_pos++;
                } else {
                    OUTPUT += "\n";
                    current_pos++;
                    current_line++;
                    current_col = 0;
                }
                if (!options.beautify)
                    might_need_space = false;
            }
            might_need_semicolon = false;
            maybe_newline();
        }

        if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
            var target_line = stack[stack.length - 1].start.line;
            while (current_line < target_line) {
                OUTPUT += "\n";
                current_pos++;
                current_line++;
                current_col = 0;
                might_need_space = false;
            }
        }

        if (might_need_space) {
            var prev = last_char();
            if ((is_identifier_char(prev)
                 && (is_identifier_char(ch) || ch == "\\"))
                || (/^[\+\-\/]$/.test(ch) && ch == prev))
            {
                OUTPUT += " ";
                current_col++;
                current_pos++;
            }
            might_need_space = false;
        }
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        if (n == 0) {
            current_col += a[n].length;
        } else {
            current_col = a[n].length;
        }
        current_pos += str.length;
        last = str;
        OUTPUT += str;
    };

    var space = options.beautify ? function() {
        print(" ");
    } : function() {
        might_need_space = true;
    };

    var indent = options.beautify ? function(half) {
        if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
        }
    } : noop;

    var with_indent = options.beautify ? function(col, cont) {
        if (col === true) col = next_indent();
        var save_indentation = indentation;
        indentation = col;
        var ret = cont();
        indentation = save_indentation;
        return ret;
    } : function(col, cont) { return cont() };

    var newline = options.beautify ? function() {
        print("\n");
    } : noop;

    var semicolon = options.beautify ? function() {
        print(";");
    } : function() {
        might_need_semicolon = true;
    };

    function force_semicolon() {
        might_need_semicolon = false;
        print(";");
    };

    function next_indent() {
        return indentation + options.indent_level;
    };

    function with_block(cont) {
        var ret;
        print("{");
        newline();
        with_indent(next_indent(), function(){
            ret = cont();
        });
        indent();
        print("}");
        return ret;
    };

    function with_parens(cont) {
        print("(");
        //XXX: still nice to have that for argument lists
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print(")");
        return ret;
    };

    function with_square(cont) {
        print("[");
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print("]");
        return ret;
    };

    function comma() {
        print(",");
        space();
    };

    function colon() {
        print(":");
        if (options.space_colon) space();
    };

    var add_mapping = options.source_map ? function(token, name) {
        try {
            if (token) options.source_map.add(
                token.file || "?",
                current_line, current_col,
                token.line, token.col,
                (!name && token.type == "name") ? token.value : name
            );
        } catch(ex) {
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                file: token.file,
                line: token.line,
                col: token.col,
                cline: current_line,
                ccol: current_col,
                name: name || ""
            })
        }
    } : noop;

    function get() {
        return OUTPUT;
    };

    if (options.preamble) {
        print(options.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
    }

    var stack = [];
    return {
        get             : get,
        toString        : get,
        indent          : indent,
        indentation     : function() { return indentation },
        current_width   : function() { return current_col - indentation },
        should_break    : function() { return options.width && this.current_width() >= options.width },
        newline         : newline,
        print           : print,
        space           : space,
        comma           : comma,
        colon           : colon,
        last            : function() { return last },
        semicolon       : semicolon,
        force_semicolon : force_semicolon,
        to_ascii        : to_ascii,
        print_name      : function(name) { print(make_name(name)) },
        print_string    : function(str) { print(encode_string(str)) },
        next_indent     : next_indent,
        with_indent     : with_indent,
        with_block      : with_block,
        with_parens     : with_parens,
        with_square     : with_square,
        add_mapping     : add_mapping,
        option          : function(opt) { return options[opt] },
        line            : function() { return current_line },
        col             : function() { return current_col },
        pos             : function() { return current_pos },
        push_node       : function(node) { stack.push(node) },
        pop_node        : function() { return stack.pop() },
        stack           : function() { return stack },
        parent          : function(n) {
            return stack[stack.length - 2 - (n || 0)];
        }
    };

};

/* -----[ code generators ]----- */

(function(){

    /* -----[ utils ]----- */

    function DEFPRINT(nodetype, generator) {
        nodetype.DEFMETHOD("_codegen", generator);
    };

    AST_Node.DEFMETHOD("print", function(stream, force_parens){
        var self = this, generator = self._codegen;
        function doit() {
            self.add_comments(stream);
            self.add_source_map(stream);
            generator(self, stream);
        }
        stream.push_node(self);
        if (force_parens || self.needs_parens(stream)) {
            stream.with_parens(doit);
        } else {
            doit();
        }
        stream.pop_node();
    });

    AST_Node.DEFMETHOD("print_to_string", function(options){
        var s = OutputStream(options);
        this.print(s);
        return s.get();
    });

    /* -----[ comments ]----- */

    AST_Node.DEFMETHOD("add_comments", function(output){
        var c = output.option("comments"), self = this;
        if (c) {
            var start = self.start;
            if (start && !start._comments_dumped) {
                start._comments_dumped = true;
                var comments = start.comments_before || [];

                // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                //      if this node is `return` or `throw`, we cannot allow comments before
                //      the returned or thrown value.
                if (self instanceof AST_Exit && self.value
                    && self.value.start.comments_before
                    && self.value.start.comments_before.length > 0) {
                    comments = comments.concat(self.value.start.comments_before);
                    self.value.start.comments_before = [];
                }

                if (c.test) {
                    comments = comments.filter(function(comment){
                        return c.test(comment.value);
                    });
                } else if (typeof c == "function") {
                    comments = comments.filter(function(comment){
                        return c(self, comment);
                    });
                }
                comments.forEach(function(c){
                    if (/comment[134]/.test(c.type)) {
                        output.print("//" + c.value + "\n");
                        output.indent();
                    }
                    else if (c.type == "comment2") {
                        output.print("/*" + c.value + "*/");
                        if (start.nlb) {
                            output.print("\n");
                            output.indent();
                        } else {
                            output.space();
                        }
                    }
                });
            }
        }
    });

    /* -----[ PARENTHESES ]----- */

    function PARENS(nodetype, func) {
        nodetype.DEFMETHOD("needs_parens", func);
    };

    PARENS(AST_Node, function(){
        return false;
    });

    // a function expression needs parens around it when it's provably
    // the first token to appear in a statement.
    PARENS(AST_Function, function(output){
        return first_in_statement(output);
    });

    // same goes for an object literal, because otherwise it would be
    // interpreted as a block of code.
    PARENS(AST_Object, function(output){
        return first_in_statement(output);
    });

    PARENS(AST_Unary, function(output){
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this;
    });

    PARENS(AST_Seq, function(output){
        var p = output.parent();
        return p instanceof AST_Call             // (foo, bar)() or foo(1, (2, 3), 4)
            || p instanceof AST_Unary            // !(foo, bar, baz)
            || p instanceof AST_Binary           // 1 + (2, 3) + 4 ==> 8
            || p instanceof AST_VarDef           // var a = (1, 2), b = a + a; ==> b == 4
            || p instanceof AST_Dot              // (1, {foo:2}).foo ==> 2
            || p instanceof AST_Array            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
            || p instanceof AST_ObjectProperty   // { foo: (1, 2) }.foo ==> 2
            || p instanceof AST_Conditional      /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                  * ==> 20 (side effect, set a := 10 and b := 20) */
        ;
    });

    PARENS(AST_Binary, function(output){
        var p = output.parent();
        // (foo && bar)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // typeof (foo && bar)
        if (p instanceof AST_Unary)
            return true;
        // (foo && bar)["prop"], (foo && bar).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // this deals with precedence: 3 * (2 + 1)
        if (p instanceof AST_Binary) {
            var po = p.operator, pp = PRECEDENCE[po];
            var so = this.operator, sp = PRECEDENCE[so];
            if (pp > sp
                || (pp == sp
                    && this === p.right)) {
                return true;
            }
        }
    });

    PARENS(AST_PropAccess, function(output){
        var p = output.parent();
        if (p instanceof AST_New && p.expression === this) {
            // i.e. new (foo.bar().baz)
            //
            // if there's one call into this subtree, then we need
            // parens around it too, otherwise the call will be
            // interpreted as passing the arguments to the upper New
            // expression.
            try {
                this.walk(new TreeWalker(function(node){
                    if (node instanceof AST_Call) throw p;
                }));
            } catch(ex) {
                if (ex !== p) throw ex;
                return true;
            }
        }
    });

    PARENS(AST_Call, function(output){
        var p = output.parent(), p1;
        if (p instanceof AST_New && p.expression === this)
            return true;

        // workaround for Safari bug.
        // https://bugs.webkit.org/show_bug.cgi?id=123506
        return this.expression instanceof AST_Function
            && p instanceof AST_PropAccess
            && p.expression === this
            && (p1 = output.parent(1)) instanceof AST_Assign
            && p1.left === p;
    });

    PARENS(AST_New, function(output){
        var p = output.parent();
        if (no_constructor_parens(this, output)
            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
            return true;
    });

    PARENS(AST_Number, function(output){
        var p = output.parent();
        if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    PARENS(AST_NaN, function(output){
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    function assign_and_conditional_paren_rules(output) {
        var p = output.parent();
        // !(a = false) → true
        if (p instanceof AST_Unary)
            return true;
        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
        // (a = func)() —or— new (a = Object)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (a = foo) ? bar : baz
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // (a = foo)["prop"] —or— (a = foo).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    };

    PARENS(AST_Assign, assign_and_conditional_paren_rules);
    PARENS(AST_Conditional, assign_and_conditional_paren_rules);

    /* -----[ PRINTERS ]----- */

    DEFPRINT(AST_Directive, function(self, output){
        output.print_string(self.value);
        output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(self, output){
        output.print("debugger");
        output.semicolon();
    });

    /* -----[ statements ]----- */

    function display_body(body, is_toplevel, output) {
        var last = body.length - 1;
        body.forEach(function(stmt, i){
            if (!(stmt instanceof AST_EmptyStatement)) {
                output.indent();
                stmt.print(output);
                if (!(i == last && is_toplevel)) {
                    output.newline();
                    if (is_toplevel) output.newline();
                }
            }
        });
    };

    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output){
        force_statement(this.body, output);
    });

    DEFPRINT(AST_Statement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    DEFPRINT(AST_Toplevel, function(self, output){
        display_body(self.body, true, output);
        output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(self, output){
        self.label.print(output);
        output.colon();
        self.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    function print_bracketed(body, output) {
        if (body.length > 0) output.with_block(function(){
            display_body(body, false, output);
        });
        else output.print("{}");
    };
    DEFPRINT(AST_BlockStatement, function(self, output){
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_EmptyStatement, function(self, output){
        output.semicolon();
    });
    DEFPRINT(AST_Do, function(self, output){
        output.print("do");
        output.space();
        self._do_print_body(output);
        output.space();
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.semicolon();
    });
    DEFPRINT(AST_While, function(self, output){
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_For, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            if (self.init) {
                if (self.init instanceof AST_Definitions) {
                    self.init.print(output);
                } else {
                    parenthesize_for_noin(self.init, output, true);
                }
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.condition) {
                self.condition.print(output);
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.step) {
                self.step.print(output);
            }
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_ForIn, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            self.init.print(output);
            output.space();
            output.print("in");
            output.space();
            self.object.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_With, function(self, output){
        output.print("with");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        self._do_print_body(output);
    });

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword){
        var self = this;
        if (!nokeyword) {
            output.print("function");
        }
        if (self.name) {
            output.space();
            self.name.print(output);
        }
        output.with_parens(function(){
            self.argnames.forEach(function(arg, i){
                if (i) output.comma();
                arg.print(output);
            });
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Lambda, function(self, output){
        self._do_print(output);
    });

    /* -----[ exits ]----- */
    AST_Exit.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.value) {
            output.space();
            this.value.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Return, function(self, output){
        self._do_print(output, "return");
    });
    DEFPRINT(AST_Throw, function(self, output){
        self._do_print(output, "throw");
    });

    /* -----[ loop control ]----- */
    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.label) {
            output.space();
            this.label.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Break, function(self, output){
        self._do_print(output, "break");
    });
    DEFPRINT(AST_Continue, function(self, output){
        self._do_print(output, "continue");
    });

    /* -----[ if ]----- */
    function make_then(self, output) {
        if (output.option("bracketize")) {
            make_block(self.body, output);
            return;
        }
        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        if (!self.body)
            return output.force_semicolon();
        if (self.body instanceof AST_Do
            && !output.option("screw_ie8")) {
            // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
            // croaks with "syntax error" on code like this: if (foo)
            // do ... while(cond); else ...  we need block brackets
            // around do/while
            make_block(self.body, output);
            return;
        }
        var b = self.body;
        while (true) {
            if (b instanceof AST_If) {
                if (!b.alternative) {
                    make_block(self.body, output);
                    return;
                }
                b = b.alternative;
            }
            else if (b instanceof AST_StatementWithBody) {
                b = b.body;
            }
            else break;
        }
        force_statement(self.body, output);
    };
    DEFPRINT(AST_If, function(self, output){
        output.print("if");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        if (self.alternative) {
            make_then(self, output);
            output.space();
            output.print("else");
            output.space();
            force_statement(self.alternative, output);
        } else {
            self._do_print_body(output);
        }
    });

    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output){
        output.print("switch");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        if (self.body.length > 0) output.with_block(function(){
            self.body.forEach(function(stmt, i){
                if (i) output.newline();
                output.indent(true);
                stmt.print(output);
            });
        });
        else output.print("{}");
    });
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output){
        if (this.body.length > 0) {
            output.newline();
            this.body.forEach(function(stmt){
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
    });
    DEFPRINT(AST_Default, function(self, output){
        output.print("default:");
        self._do_print_body(output);
    });
    DEFPRINT(AST_Case, function(self, output){
        output.print("case");
        output.space();
        self.expression.print(output);
        output.print(":");
        self._do_print_body(output);
    });

    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output){
        output.print("try");
        output.space();
        print_bracketed(self.body, output);
        if (self.bcatch) {
            output.space();
            self.bcatch.print(output);
        }
        if (self.bfinally) {
            output.space();
            self.bfinally.print(output);
        }
    });
    DEFPRINT(AST_Catch, function(self, output){
        output.print("catch");
        output.space();
        output.with_parens(function(){
            self.argname.print(output);
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Finally, function(self, output){
        output.print("finally");
        output.space();
        print_bracketed(self.body, output);
    });

    /* -----[ var/const ]----- */
    AST_Definitions.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        output.space();
        this.definitions.forEach(function(def, i){
            if (i) output.comma();
            def.print(output);
        });
        var p = output.parent();
        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
        var avoid_semicolon = in_for && p.init === this;
        if (!avoid_semicolon)
            output.semicolon();
    });
    DEFPRINT(AST_Var, function(self, output){
        self._do_print(output, "var");
    });
    DEFPRINT(AST_Const, function(self, output){
        self._do_print(output, "const");
    });

    function parenthesize_for_noin(node, output, noin) {
        if (!noin) node.print(output);
        else try {
            // need to take some precautions here:
            //    https://github.com/mishoo/UglifyJS2/issues/60
            node.walk(new TreeWalker(function(node){
                if (node instanceof AST_Binary && node.operator == "in")
                    throw output;
            }));
            node.print(output);
        } catch(ex) {
            if (ex !== output) throw ex;
            node.print(output, true);
        }
    };

    DEFPRINT(AST_VarDef, function(self, output){
        self.name.print(output);
        if (self.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self.value, output, noin);
        }
    });

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output){
        self.expression.print(output);
        if (self instanceof AST_New && no_constructor_parens(self, output))
            return;
        output.with_parens(function(){
            self.args.forEach(function(expr, i){
                if (i) output.comma();
                expr.print(output);
            });
        });
    });
    DEFPRINT(AST_New, function(self, output){
        output.print("new");
        output.space();
        AST_Call.prototype._codegen(self, output);
    });

    AST_Seq.DEFMETHOD("_do_print", function(output){
        this.car.print(output);
        if (this.cdr) {
            output.comma();
            if (output.should_break()) {
                output.newline();
                output.indent();
            }
            this.cdr.print(output);
        }
    });
    DEFPRINT(AST_Seq, function(self, output){
        self._do_print(output);
        // var p = output.parent();
        // if (p instanceof AST_Statement) {
        //     output.with_indent(output.next_indent(), function(){
        //         self._do_print(output);
        //     });
        // } else {
        //     self._do_print(output);
        // }
    });
    DEFPRINT(AST_Dot, function(self, output){
        var expr = self.expression;
        expr.print(output);
        if (expr instanceof AST_Number && expr.getValue() >= 0) {
            if (!/[xa-f.]/i.test(output.last())) {
                output.print(".");
            }
        }
        output.print(".");
        // the name after dot would be mapped about here.
        output.add_mapping(self.end);
        output.print_name(self.property);
    });
    DEFPRINT(AST_Sub, function(self, output){
        self.expression.print(output);
        output.print("[");
        self.property.print(output);
        output.print("]");
    });
    DEFPRINT(AST_UnaryPrefix, function(self, output){
        var op = self.operator;
        output.print(op);
        if (/^[a-z]/i.test(op))
            output.space();
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(self, output){
        self.expression.print(output);
        output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(self, output){
        self.left.print(output);
        output.space();
        output.print(self.operator);
        if (self.operator == "<"
            && self.right instanceof AST_UnaryPrefix
            && self.right.operator == "!"
            && self.right.expression instanceof AST_UnaryPrefix
            && self.right.expression.operator == "--") {
            // space is mandatory to avoid outputting <!--
            // http://javascript.spec.whatwg.org/#comment-syntax
            output.print(" ");
        } else {
            // the space is optional depending on "beautify"
            output.space();
        }
        self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(self, output){
        self.condition.print(output);
        output.space();
        output.print("?");
        output.space();
        self.consequent.print(output);
        output.space();
        output.colon();
        self.alternative.print(output);
    });

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output){
        output.with_square(function(){
            var a = self.elements, len = a.length;
            if (len > 0) output.space();
            a.forEach(function(exp, i){
                if (i) output.comma();
                exp.print(output);
                // If the final element is a hole, we need to make sure it
                // doesn't look like a trailing comma, by inserting an actual
                // trailing comma.
                if (i === len - 1 && exp instanceof AST_Hole)
                  output.comma();
            });
            if (len > 0) output.space();
        });
    });
    DEFPRINT(AST_Object, function(self, output){
        if (self.properties.length > 0) output.with_block(function(){
            self.properties.forEach(function(prop, i){
                if (i) {
                    output.print(",");
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else output.print("{}");
    });
    DEFPRINT(AST_ObjectKeyVal, function(self, output){
        var key = self.key;
        if (output.option("quote_keys")) {
            output.print_string(key + "");
        } else if ((typeof key == "number"
                    || !output.option("beautify")
                    && +key + "" == key)
                   && parseFloat(key) >= 0) {
            output.print(make_num(key));
        } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
            output.print_name(key);
        } else {
            output.print_string(key);
        }
        output.colon();
        self.value.print(output);
    });
    DEFPRINT(AST_ObjectSetter, function(self, output){
        output.print("set");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_ObjectGetter, function(self, output){
        output.print("get");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_Symbol, function(self, output){
        var def = self.definition();
        output.print_name(def ? def.mangled_name || def.name : self.name);
    });
    DEFPRINT(AST_Undefined, function(self, output){
        output.print("void 0");
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Infinity, function(self, output){
        output.print("1/0");
    });
    DEFPRINT(AST_NaN, function(self, output){
        output.print("0/0");
    });
    DEFPRINT(AST_This, function(self, output){
        output.print("this");
    });
    DEFPRINT(AST_Constant, function(self, output){
        output.print(self.getValue());
    });
    DEFPRINT(AST_String, function(self, output){
        output.print_string(self.getValue());
    });
    DEFPRINT(AST_Number, function(self, output){
        output.print(make_num(self.getValue()));
    });
    DEFPRINT(AST_RegExp, function(self, output){
        var str = self.getValue().toString();
        if (output.option("ascii_only"))
            str = output.to_ascii(str);
        output.print(str);
        var p = output.parent();
        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)
            output.print(" ");
    });

    function force_statement(stat, output) {
        if (output.option("bracketize")) {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.print("{}");
            else if (stat instanceof AST_BlockStatement)
                stat.print(output);
            else output.with_block(function(){
                output.indent();
                stat.print(output);
                output.newline();
            });
        } else {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.force_semicolon();
            else
                stat.print(output);
        }
    };

    // return true if the node at the top of the stack (that means the
    // innermost node in the current output) is lexically the first in
    // a statement.
    function first_in_statement(output) {
        var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
        while (i > 0) {
            if (p instanceof AST_Statement && p.body === node)
                return true;
            if ((p instanceof AST_Seq           && p.car === node        ) ||
                (p instanceof AST_Call          && p.expression === node && !(p instanceof AST_New) ) ||
                (p instanceof AST_Dot           && p.expression === node ) ||
                (p instanceof AST_Sub           && p.expression === node ) ||
                (p instanceof AST_Conditional   && p.condition === node  ) ||
                (p instanceof AST_Binary        && p.left === node       ) ||
                (p instanceof AST_UnaryPostfix  && p.expression === node ))
            {
                node = p;
                p = a[--i];
            } else {
                return false;
            }
        }
    };

    // self should be AST_New.  decide if we want to show parens or not.
    function no_constructor_parens(self, output) {
        return self.args.length == 0 && !output.option("beautify");
    };

    function best_of(a) {
        var best = a[0], len = best.length;
        for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
                best = a[i];
                len = best.length;
            }
        }
        return best;
    };

    function make_num(num) {
        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
        if (Math.floor(num) === num) {
            if (num >= 0) {
                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                       "0" + num.toString(8)); // same.
            } else {
                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                       "-0" + (-num).toString(8)); // same.
            }
            if ((m = /^(.*?)(0+)$/.exec(num))) {
                a.push(m[1] + "e" + m[2].length);
            }
        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
            a.push(m[2] + "e-" + (m[1].length + m[2].length),
                   str.substr(str.indexOf(".")));
        }
        return best_of(a);
    };

    function make_block(stmt, output) {
        if (stmt instanceof AST_BlockStatement) {
            stmt.print(output);
            return;
        }
        output.with_block(function(){
            output.indent();
            stmt.print(output);
            output.newline();
        });
    };

    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) {
        nodetype.DEFMETHOD("add_source_map", function(stream){
            generator(this, stream);
        });
    };

    // We could easily add info for ALL nodes, but it seems to me that
    // would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop);

    function basic_sourcemap_gen(self, output) {
        output.add_mapping(self.start);
    };

    // XXX: I'm not exactly sure if we need it for all of these nodes,
    // or if we should add even more.

    DEFMAP(AST_Directive, basic_sourcemap_gen);
    DEFMAP(AST_Debugger, basic_sourcemap_gen);
    DEFMAP(AST_Symbol, basic_sourcemap_gen);
    DEFMAP(AST_Jump, basic_sourcemap_gen);
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
    DEFMAP(AST_LabeledStatement, noop); // since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen);
    DEFMAP(AST_Switch, basic_sourcemap_gen);
    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
    DEFMAP(AST_Toplevel, noop);
    DEFMAP(AST_New, basic_sourcemap_gen);
    DEFMAP(AST_Try, basic_sourcemap_gen);
    DEFMAP(AST_Catch, basic_sourcemap_gen);
    DEFMAP(AST_Finally, basic_sourcemap_gen);
    DEFMAP(AST_Definitions, basic_sourcemap_gen);
    DEFMAP(AST_Constant, basic_sourcemap_gen);
    DEFMAP(AST_ObjectProperty, function(self, output){
        output.add_mapping(self.start, self.key);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function Compressor(options, false_by_default) {
    if (!(this instanceof Compressor))
        return new Compressor(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
        sequences     : !false_by_default,
        properties    : !false_by_default,
        dead_code     : !false_by_default,
        drop_debugger : !false_by_default,
        unsafe        : false,
        unsafe_comps  : false,
        conditionals  : !false_by_default,
        comparisons   : !false_by_default,
        evaluate      : !false_by_default,
        booleans      : !false_by_default,
        loops         : !false_by_default,
        unused        : !false_by_default,
        hoist_funs    : !false_by_default,
        hoist_vars    : false,
        if_return     : !false_by_default,
        join_vars     : !false_by_default,
        cascade       : !false_by_default,
        side_effects  : !false_by_default,
        pure_getters  : false,
        pure_funcs    : null,
        negate_iife   : !false_by_default,
        screw_ie8     : false,

        warnings      : true,
        global_defs   : {}
    }, true);
};

Compressor.prototype = new TreeTransformer;
merge(Compressor.prototype, {
    option: function(key) { return this.options[key] },
    warn: function() {
        if (this.options.warnings)
            AST_Node.warn.apply(AST_Node, arguments);
    },
    before: function(node, descend, in_list) {
        if (node._squeezed) return node;
        if (node instanceof AST_Scope) {
            //node.drop_unused(this);
            node = node.hoist_declarations(this);
        }
        descend(node, this);
        node = node.optimize(this);
        if (node instanceof AST_Scope) {
            node.drop_unused(this);
            descend(node, this);
        }
        node._squeezed = true;
        return node;
    }
});

(function(){

    function OPT(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor){
            var self = this;
            if (self._optimized) return self;
            var opt = optimizer(self, compressor);
            opt._optimized = true;
            if (opt === self) return opt;
            return opt.transform(compressor);
        });
    };

    OPT(AST_Node, function(self, compressor){
        return self;
    });

    AST_Node.DEFMETHOD("equivalent_to", function(node){
        // XXX: this is a rather expensive way to test two node's equivalence:
        return this.print_to_string() == node.print_to_string();
    });

    function make_node(ctor, orig, props) {
        if (!props) props = {};
        if (orig) {
            if (!props.start) props.start = orig.start;
            if (!props.end) props.end = orig.end;
        }
        return new ctor(props);
    };

    function make_node_from_constant(compressor, val, orig) {
        // XXX: WIP.
        // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
        //     if (node instanceof AST_SymbolRef) {
        //         var scope = compressor.find_parent(AST_Scope);
        //         var def = scope.find_variable(node);
        //         node.thedef = def;
        //         return node;
        //     }
        // })).transform(compressor);

        if (val instanceof AST_Node) return val.transform(compressor);
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
                value: val
            }).optimize(compressor);
          case "number":
            return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                value: val
            }).optimize(compressor);
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
          case "undefined":
            return make_node(AST_Undefined, orig).optimize(compressor);
          default:
            if (val === null) {
                return make_node(AST_Null, orig).optimize(compressor);
            }
            if (val instanceof RegExp) {
                return make_node(AST_RegExp, orig).optimize(compressor);
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
                type: typeof val
            }));
        }
    };

    function as_statement_array(thing) {
        if (thing === null) return [];
        if (thing instanceof AST_BlockStatement) return thing.body;
        if (thing instanceof AST_EmptyStatement) return [];
        if (thing instanceof AST_Statement) return [ thing ];
        throw new Error("Can't convert thing to statement array");
    };

    function is_empty(thing) {
        if (thing === null) return true;
        if (thing instanceof AST_EmptyStatement) return true;
        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
        return false;
    };

    function loop_body(x) {
        if (x instanceof AST_Switch) return x;
        if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
            return (x.body instanceof AST_BlockStatement ? x.body : x);
        }
        return x;
    };

    function tighten_body(statements, compressor) {
        var CHANGED;
        do {
            CHANGED = false;
            statements = eliminate_spurious_blocks(statements);
            if (compressor.option("dead_code")) {
                statements = eliminate_dead_code(statements, compressor);
            }
            if (compressor.option("if_return")) {
                statements = handle_if_return(statements, compressor);
            }
            if (compressor.option("sequences")) {
                statements = sequencesize(statements, compressor);
            }
            if (compressor.option("join_vars")) {
                statements = join_consecutive_vars(statements, compressor);
            }
        } while (CHANGED);

        if (compressor.option("negate_iife")) {
            negate_iifes(statements, compressor);
        }

        return statements;

        function eliminate_spurious_blocks(statements) {
            var seen_dirs = [];
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_BlockStatement) {
                    CHANGED = true;
                    a.push.apply(a, eliminate_spurious_blocks(stat.body));
                } else if (stat instanceof AST_EmptyStatement) {
                    CHANGED = true;
                } else if (stat instanceof AST_Directive) {
                    if (seen_dirs.indexOf(stat.value) < 0) {
                        a.push(stat);
                        seen_dirs.push(stat.value);
                    } else {
                        CHANGED = true;
                    }
                } else {
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function handle_if_return(statements, compressor) {
            var self = compressor.self();
            var in_lambda = self instanceof AST_Lambda;
            var ret = [];
            loop: for (var i = statements.length; --i >= 0;) {
                var stat = statements[i];
                switch (true) {
                  case (in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0):
                    CHANGED = true;
                    // note, ret.length is probably always zero
                    // because we drop unreachable code before this
                    // step.  nevertheless, it's good to check.
                    continue loop;
                  case stat instanceof AST_If:
                    if (stat.body instanceof AST_Return) {
                        //---
                        // pretty silly case, but:
                        // if (foo()) return; return; ==> foo(); return;
                        if (((in_lambda && ret.length == 0)
                             || (ret[0] instanceof AST_Return && !ret[0].value))
                            && !stat.body.value && !stat.alternative) {
                            CHANGED = true;
                            var cond = make_node(AST_SimpleStatement, stat.condition, {
                                body: stat.condition
                            });
                            ret.unshift(cond);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; return y; ==> return foo() ? x : y;
                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0];
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                        if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                value: make_node(AST_Undefined, stat)
                            });
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                        if (!stat.body.value && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.condition = stat.condition.negate(compressor);
                            stat.body = make_node(AST_BlockStatement, stat, {
                                body: as_statement_array(stat.alternative).concat(ret)
                            });
                            stat.alternative = null;
                            ret = [ stat.transform(compressor) ];
                            continue loop;
                        }
                        //---
                        if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement
                            && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                            CHANGED = true;
                            ret.push(make_node(AST_Return, ret[0], {
                                value: make_node(AST_Undefined, ret[0])
                            }).transform(compressor));
                            ret = as_statement_array(stat.alternative).concat(ret);
                            ret.unshift(stat);
                            continue loop;
                        }
                    }

                    var ab = aborts(stat.body);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        var body = as_statement_array(stat.body).slice(0, -1);
                        stat = stat.clone();
                        stat.condition = stat.condition.negate(compressor);
                        stat.body = make_node(AST_BlockStatement, stat, {
                            body: ret
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat, {
                            body: body
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    var ab = aborts(stat.alternative);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        stat = stat.clone();
                        stat.body = make_node(AST_BlockStatement, stat.body, {
                            body: as_statement_array(stat.body).concat(ret)
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                            body: as_statement_array(stat.alternative).slice(0, -1)
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    ret.unshift(stat);
                    break;
                  default:
                    ret.unshift(stat);
                    break;
                }
            }
            return ret;
        };

        function eliminate_dead_code(statements, compressor) {
            var has_quit = false;
            var orig = statements.length;
            var self = compressor.self();
            statements = statements.reduce(function(a, stat){
                if (has_quit) {
                    extract_declarations_from_unreachable_code(compressor, stat, a);
                } else {
                    if (stat instanceof AST_LoopControl) {
                        var lct = compressor.loopcontrol_target(stat.label);
                        if ((stat instanceof AST_Break
                             && lct instanceof AST_BlockStatement
                             && loop_body(lct) === self) || (stat instanceof AST_Continue
                                                             && loop_body(lct) === self)) {
                            if (stat.label) {
                                remove(stat.label.thedef.references, stat);
                            }
                        } else {
                            a.push(stat);
                        }
                    } else {
                        a.push(stat);
                    }
                    if (aborts(stat)) has_quit = true;
                }
                return a;
            }, []);
            CHANGED = statements.length != orig;
            return statements;
        };

        function sequencesize(statements, compressor) {
            if (statements.length < 2) return statements;
            var seq = [], ret = [];
            function push_seq() {
                seq = AST_Seq.from_array(seq);
                if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                    body: seq
                }));
                seq = [];
            };
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) seq.push(stat.body);
                else push_seq(), ret.push(stat);
            });
            push_seq();
            ret = sequencesize_2(ret, compressor);
            CHANGED = ret.length != statements.length;
            return ret;
        };

        function sequencesize_2(statements, compressor) {
            function cons_seq(right) {
                ret.pop();
                var left = prev.body;
                if (left instanceof AST_Seq) {
                    left.add(right);
                } else {
                    left = AST_Seq.cons(left, right);
                }
                return left.transform(compressor);
            };
            var ret = [], prev = null;
            statements.forEach(function(stat){
                if (prev) {
                    if (stat instanceof AST_For) {
                        var opera = {};
                        try {
                            prev.body.walk(new TreeWalker(function(node){
                                if (node instanceof AST_Binary && node.operator == "in")
                                    throw opera;
                            }));
                            if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                stat.init = cons_seq(stat.init);
                            }
                            else if (!stat.init) {
                                stat.init = prev.body;
                                ret.pop();
                            }
                        } catch(ex) {
                            if (ex !== opera) throw ex;
                        }
                    }
                    else if (stat instanceof AST_If) {
                        stat.condition = cons_seq(stat.condition);
                    }
                    else if (stat instanceof AST_With) {
                        stat.expression = cons_seq(stat.expression);
                    }
                    else if (stat instanceof AST_Exit && stat.value) {
                        stat.value = cons_seq(stat.value);
                    }
                    else if (stat instanceof AST_Exit) {
                        stat.value = cons_seq(make_node(AST_Undefined, stat));
                    }
                    else if (stat instanceof AST_Switch) {
                        stat.expression = cons_seq(stat.expression);
                    }
                }
                ret.push(stat);
                prev = stat instanceof AST_SimpleStatement ? stat : null;
            });
            return ret;
        };

        function join_consecutive_vars(statements, compressor) {
            var prev = null;
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                    prev.definitions = prev.definitions.concat(stat.definitions);
                    CHANGED = true;
                }
                else if (stat instanceof AST_For
                         && prev instanceof AST_Definitions
                         && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                    CHANGED = true;
                    a.pop();
                    if (stat.init) {
                        stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                    } else {
                        stat.init = prev;
                    }
                    a.push(stat);
                    prev = stat;
                }
                else {
                    prev = stat;
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function negate_iifes(statements, compressor) {
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) {
                    stat.body = (function transform(thing) {
                        return thing.transform(new TreeTransformer(function(node){
                            if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                return make_node(AST_UnaryPrefix, node, {
                                    operator: "!",
                                    expression: node
                                });
                            }
                            else if (node instanceof AST_Call) {
                                node.expression = transform(node.expression);
                            }
                            else if (node instanceof AST_Seq) {
                                node.car = transform(node.car);
                            }
                            else if (node instanceof AST_Conditional) {
                                var expr = transform(node.condition);
                                if (expr !== node.condition) {
                                    // it has been negated, reverse
                                    node.condition = expr;
                                    var tmp = node.consequent;
                                    node.consequent = node.alternative;
                                    node.alternative = tmp;
                                }
                            }
                            return node;
                        }));
                    })(stat.body);
                }
            });
        };

    };

    function extract_declarations_from_unreachable_code(compressor, stat, target) {
        compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
        stat.walk(new TreeWalker(function(node){
            if (node instanceof AST_Definitions) {
                compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                node.remove_initializers();
                target.push(node);
                return true;
            }
            if (node instanceof AST_Defun) {
                target.push(node);
                return true;
            }
            if (node instanceof AST_Scope) {
                return true;
            }
        }));
    };

    /* -----[ boolean/negation helpers ]----- */

    // methods to determine whether an expression has a boolean result type
    (function (def){
        var unary_bool = [ "!", "delete" ];
        var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
        def(AST_Node, function(){ return false });
        def(AST_UnaryPrefix, function(){
            return member(this.operator, unary_bool);
        });
        def(AST_Binary, function(){
            return member(this.operator, binary_bool) ||
                ( (this.operator == "&&" || this.operator == "||") &&
                  this.left.is_boolean() && this.right.is_boolean() );
        });
        def(AST_Conditional, function(){
            return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def(AST_Assign, function(){
            return this.operator == "=" && this.right.is_boolean();
        });
        def(AST_Seq, function(){
            return this.cdr.is_boolean();
        });
        def(AST_True, function(){ return true });
        def(AST_False, function(){ return true });
    })(function(node, func){
        node.DEFMETHOD("is_boolean", func);
    });

    // methods to determine if an expression has a string result type
    (function (def){
        def(AST_Node, function(){ return false });
        def(AST_String, function(){ return true });
        def(AST_UnaryPrefix, function(){
            return this.operator == "typeof";
        });
        def(AST_Binary, function(compressor){
            return this.operator == "+" &&
                (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def(AST_Assign, function(compressor){
            return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def(AST_Seq, function(compressor){
            return this.cdr.is_string(compressor);
        });
        def(AST_Conditional, function(compressor){
            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
        def(AST_Call, function(compressor){
            return compressor.option("unsafe")
                && this.expression instanceof AST_SymbolRef
                && this.expression.name == "String"
                && this.expression.undeclared();
        });
    })(function(node, func){
        node.DEFMETHOD("is_string", func);
    });

    function best_of(ast1, ast2) {
        return ast1.print_to_string().length >
            ast2.print_to_string().length
            ? ast2 : ast1;
    };

    // methods to evaluate a constant expression
    (function (def){
        // The evaluate method returns an array with one or two
        // elements.  If the node has been successfully reduced to a
        // constant, then the second element tells us the value;
        // otherwise the second element is missing.  The first element
        // of the array is always an AST_Node descendant; if
        // evaluation was successful it's a node that represents the
        // constant; otherwise it's the original or a replacement node.
        AST_Node.DEFMETHOD("evaluate", function(compressor){
            if (!compressor.option("evaluate")) return [ this ];
            try {
                var val = this._eval(compressor);
                return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
            } catch(ex) {
                if (ex !== def) throw ex;
                return [ this ];
            }
        });
        def(AST_Statement, function(){
            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
        });
        def(AST_Function, function(){
            // XXX: AST_Function inherits from AST_Scope, which itself
            // inherits from AST_Statement; however, an AST_Function
            // isn't really a statement.  This could byte in other
            // places too. :-( Wish JS had multiple inheritance.
            throw def;
        });
        function ev(node, compressor) {
            if (!compressor) throw new Error("Compressor must be passed");

            return node._eval(compressor);
        };
        def(AST_Node, function(){
            throw def;          // not constant
        });
        def(AST_Constant, function(){
            return this.getValue();
        });
        def(AST_UnaryPrefix, function(compressor){
            var e = this.expression;
            switch (this.operator) {
              case "!": return !ev(e, compressor);
              case "typeof":
                // Function would be evaluated to an array and so typeof would
                // incorrectly return 'object'. Hence making is a special case.
                if (e instanceof AST_Function) return typeof function(){};

                e = ev(e, compressor);

                // typeof <RegExp> returns "object" or "function" on different platforms
                // so cannot evaluate reliably
                if (e instanceof RegExp) throw def;

                return typeof e;
              case "void": return void ev(e, compressor);
              case "~": return ~ev(e, compressor);
              case "-":
                e = ev(e, compressor);
                if (e === 0) throw def;
                return -e;
              case "+": return +ev(e, compressor);
            }
            throw def;
        });
        def(AST_Binary, function(c){
            var left = this.left, right = this.right;
            switch (this.operator) {
              case "&&"         : return ev(left, c) &&         ev(right, c);
              case "||"         : return ev(left, c) ||         ev(right, c);
              case "|"          : return ev(left, c) |          ev(right, c);
              case "&"          : return ev(left, c) &          ev(right, c);
              case "^"          : return ev(left, c) ^          ev(right, c);
              case "+"          : return ev(left, c) +          ev(right, c);
              case "*"          : return ev(left, c) *          ev(right, c);
              case "/"          : return ev(left, c) /          ev(right, c);
              case "%"          : return ev(left, c) %          ev(right, c);
              case "-"          : return ev(left, c) -          ev(right, c);
              case "<<"         : return ev(left, c) <<         ev(right, c);
              case ">>"         : return ev(left, c) >>         ev(right, c);
              case ">>>"        : return ev(left, c) >>>        ev(right, c);
              case "=="         : return ev(left, c) ==         ev(right, c);
              case "==="        : return ev(left, c) ===        ev(right, c);
              case "!="         : return ev(left, c) !=         ev(right, c);
              case "!=="        : return ev(left, c) !==        ev(right, c);
              case "<"          : return ev(left, c) <          ev(right, c);
              case "<="         : return ev(left, c) <=         ev(right, c);
              case ">"          : return ev(left, c) >          ev(right, c);
              case ">="         : return ev(left, c) >=         ev(right, c);
              case "in"         : return ev(left, c) in         ev(right, c);
              case "instanceof" : return ev(left, c) instanceof ev(right, c);
            }
            throw def;
        });
        def(AST_Conditional, function(compressor){
            return ev(this.condition, compressor)
                ? ev(this.consequent, compressor)
                : ev(this.alternative, compressor);
        });
        def(AST_SymbolRef, function(compressor){
            var d = this.definition();
            if (d && d.constant && d.init) return ev(d.init, compressor);
            throw def;
        });
    })(function(node, func){
        node.DEFMETHOD("_eval", func);
    });

    // method to negate an expression
    (function(def){
        function basic_negation(exp) {
            return make_node(AST_UnaryPrefix, exp, {
                operator: "!",
                expression: exp
            });
        };
        def(AST_Node, function(){
            return basic_negation(this);
        });
        def(AST_Statement, function(){
            throw new Error("Cannot negate a statement");
        });
        def(AST_Function, function(){
            return basic_negation(this);
        });
        def(AST_UnaryPrefix, function(){
            if (this.operator == "!")
                return this.expression;
            return basic_negation(this);
        });
        def(AST_Seq, function(compressor){
            var self = this.clone();
            self.cdr = self.cdr.negate(compressor);
            return self;
        });
        def(AST_Conditional, function(compressor){
            var self = this.clone();
            self.consequent = self.consequent.negate(compressor);
            self.alternative = self.alternative.negate(compressor);
            return best_of(basic_negation(this), self);
        });
        def(AST_Binary, function(compressor){
            var self = this.clone(), op = this.operator;
            if (compressor.option("unsafe_comps")) {
                switch (op) {
                  case "<=" : self.operator = ">"  ; return self;
                  case "<"  : self.operator = ">=" ; return self;
                  case ">=" : self.operator = "<"  ; return self;
                  case ">"  : self.operator = "<=" ; return self;
                }
            }
            switch (op) {
              case "==" : self.operator = "!="; return self;
              case "!=" : self.operator = "=="; return self;
              case "===": self.operator = "!=="; return self;
              case "!==": self.operator = "==="; return self;
              case "&&":
                self.operator = "||";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
              case "||":
                self.operator = "&&";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
            }
            return basic_negation(this);
        });
    })(function(node, func){
        node.DEFMETHOD("negate", function(compressor){
            return func.call(this, compressor);
        });
    });

    // determine if expression has side effects
    (function(def){
        def(AST_Node, function(compressor){ return true });

        def(AST_EmptyStatement, function(compressor){ return false });
        def(AST_Constant, function(compressor){ return false });
        def(AST_This, function(compressor){ return false });

        def(AST_Call, function(compressor){
            var pure = compressor.option("pure_funcs");
            if (!pure) return true;
            return pure.indexOf(this.expression.print_to_string()) < 0;
        });

        def(AST_Block, function(compressor){
            for (var i = this.body.length; --i >= 0;) {
                if (this.body[i].has_side_effects(compressor))
                    return true;
            }
            return false;
        });

        def(AST_SimpleStatement, function(compressor){
            return this.body.has_side_effects(compressor);
        });
        def(AST_Defun, function(compressor){ return true });
        def(AST_Function, function(compressor){ return false });
        def(AST_Binary, function(compressor){
            return this.left.has_side_effects(compressor)
                || this.right.has_side_effects(compressor);
        });
        def(AST_Assign, function(compressor){ return true });
        def(AST_Conditional, function(compressor){
            return this.condition.has_side_effects(compressor)
                || this.consequent.has_side_effects(compressor)
                || this.alternative.has_side_effects(compressor);
        });
        def(AST_Unary, function(compressor){
            return this.operator == "delete"
                || this.operator == "++"
                || this.operator == "--"
                || this.expression.has_side_effects(compressor);
        });
        def(AST_SymbolRef, function(compressor){ return false });
        def(AST_Object, function(compressor){
            for (var i = this.properties.length; --i >= 0;)
                if (this.properties[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_ObjectProperty, function(compressor){
            return this.value.has_side_effects(compressor);
        });
        def(AST_Array, function(compressor){
            for (var i = this.elements.length; --i >= 0;)
                if (this.elements[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_Dot, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor);
        });
        def(AST_Sub, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor)
                || this.property.has_side_effects(compressor);
        });
        def(AST_PropAccess, function(compressor){
            return !compressor.option("pure_getters");
        });
        def(AST_Seq, function(compressor){
            return this.car.has_side_effects(compressor)
                || this.cdr.has_side_effects(compressor);
        });
    })(function(node, func){
        node.DEFMETHOD("has_side_effects", func);
    });

    // tell me if a statement aborts
    function aborts(thing) {
        return thing && thing.aborts();
    };
    (function(def){
        def(AST_Statement, function(){ return null });
        def(AST_Jump, function(){ return this });
        function block_aborts(){
            var n = this.body.length;
            return n > 0 && aborts(this.body[n - 1]);
        };
        def(AST_BlockStatement, block_aborts);
        def(AST_SwitchBranch, block_aborts);
        def(AST_If, function(){
            return this.alternative && aborts(this.body) && aborts(this.alternative);
        });
    })(function(node, func){
        node.DEFMETHOD("aborts", func);
    });

    /* -----[ optimizers ]----- */

    OPT(AST_Directive, function(self, compressor){
        if (self.scope.has_directive(self.value) !== self.scope) {
            return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    OPT(AST_Debugger, function(self, compressor){
        if (compressor.option("drop_debugger"))
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_LabeledStatement, function(self, compressor){
        if (self.body instanceof AST_Break
            && compressor.loopcontrol_target(self.body.label) === self.body) {
            return make_node(AST_EmptyStatement, self);
        }
        return self.label.references.length == 0 ? self.body : self;
    });

    OPT(AST_Block, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_BlockStatement, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        switch (self.body.length) {
          case 1: return self.body[0];
          case 0: return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    AST_Scope.DEFMETHOD("drop_unused", function(compressor){
        var self = this;
        if (compressor.option("unused")
            && !(self instanceof AST_Toplevel)
            && !self.uses_eval
           ) {
            var in_use = [];
            var initializations = new Dictionary();
            // pass 1: find out which symbols are directly used in
            // this scope (not in nested scopes).
            var scope = this;
            var tw = new TreeWalker(function(node, descend){
                if (node !== self) {
                    if (node instanceof AST_Defun) {
                        initializations.add(node.name.name, node);
                        return true; // don't go in nested scopes
                    }
                    if (node instanceof AST_Definitions && scope === self) {
                        node.definitions.forEach(function(def){
                            if (def.value) {
                                initializations.add(def.name.name, def.value);
                                if (def.value.has_side_effects(compressor)) {
                                    def.value.walk(tw);
                                }
                            }
                        });
                        return true;
                    }
                    if (node instanceof AST_SymbolRef) {
                        push_uniq(in_use, node.definition());
                        return true;
                    }
                    if (node instanceof AST_Scope) {
                        var save_scope = scope;
                        scope = node;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                }
            });
            self.walk(tw);
            // pass 2: for every used symbol we need to walk its
            // initialization code to figure out if it uses other
            // symbols (that may not be in_use).
            for (var i = 0; i < in_use.length; ++i) {
                in_use[i].orig.forEach(function(decl){
                    // undeclared globals will be instanceof AST_SymbolRef
                    var init = initializations.get(decl.name);
                    if (init) init.forEach(function(init){
                        var tw = new TreeWalker(function(node){
                            if (node instanceof AST_SymbolRef) {
                                push_uniq(in_use, node.definition());
                            }
                        });
                        init.walk(tw);
                    });
                });
            }
            // pass 3: we should drop declarations not in_use
            var tt = new TreeTransformer(
                function before(node, descend, in_list) {
                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                        for (var a = node.argnames, i = a.length; --i >= 0;) {
                            var sym = a[i];
                            if (sym.unreferenced()) {
                                a.pop();
                                compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                    name : sym.name,
                                    file : sym.start.file,
                                    line : sym.start.line,
                                    col  : sym.start.col
                                });
                            }
                            else break;
                        }
                    }
                    if (node instanceof AST_Defun && node !== self) {
                        if (!member(node.name.definition(), in_use)) {
                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                name : node.name.name,
                                file : node.name.start.file,
                                line : node.name.start.line,
                                col  : node.name.start.col
                            });
                            return make_node(AST_EmptyStatement, node);
                        }
                        return node;
                    }
                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                        var def = node.definitions.filter(function(def){
                            if (member(def.name.definition(), in_use)) return true;
                            var w = {
                                name : def.name.name,
                                file : def.name.start.file,
                                line : def.name.start.line,
                                col  : def.name.start.col
                            };
                            if (def.value && def.value.has_side_effects(compressor)) {
                                def._unused_side_effects = true;
                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                return true;
                            }
                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                            return false;
                        });
                        // place uninitialized names at the start
                        def = mergeSort(def, function(a, b){
                            if (!a.value && b.value) return -1;
                            if (!b.value && a.value) return 1;
                            return 0;
                        });
                        // for unused names whose initialization has
                        // side effects, we can cascade the init. code
                        // into the next one, or next statement.
                        var side_effects = [];
                        for (var i = 0; i < def.length;) {
                            var x = def[i];
                            if (x._unused_side_effects) {
                                side_effects.push(x.value);
                                def.splice(i, 1);
                            } else {
                                if (side_effects.length > 0) {
                                    side_effects.push(x.value);
                                    x.value = AST_Seq.from_array(side_effects);
                                    side_effects = [];
                                }
                                ++i;
                            }
                        }
                        if (side_effects.length > 0) {
                            side_effects = make_node(AST_BlockStatement, node, {
                                body: [ make_node(AST_SimpleStatement, node, {
                                    body: AST_Seq.from_array(side_effects)
                                }) ]
                            });
                        } else {
                            side_effects = null;
                        }
                        if (def.length == 0 && !side_effects) {
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (def.length == 0) {
                            return side_effects;
                        }
                        node.definitions = def;
                        if (side_effects) {
                            side_effects.body.unshift(node);
                            node = side_effects;
                        }
                        return node;
                    }
                    if (node instanceof AST_For) {
                        descend(node, this);

                        if (node.init instanceof AST_BlockStatement) {
                            // certain combination of unused name + side effect leads to:
                            //    https://github.com/mishoo/UglifyJS2/issues/44
                            // that's an invalid AST.
                            // We fix it at this stage by moving the `var` outside the `for`.

                            var body = node.init.body.slice(0, -1);
                            node.init = node.init.body.slice(-1)[0].body;
                            body.push(node);

                            return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                                body: body
                            });
                        }
                    }
                    if (node instanceof AST_Scope && node !== self)
                        return node;
                }
            );
            self.transform(tt);
        }
    });

    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        var self = this;
        if (hoist_funs || hoist_vars) {
            var dirs = [];
            var hoisted = [];
            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
            // let's count var_decl first, we seem to waste a lot of
            // space if we hoist `var` when there's only one.
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }));
            hoist_vars = hoist_vars && var_decl > 1;
            var tt = new TreeTransformer(
                function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def){
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments();
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === node) {
                                if (seq == null) return node.definitions[0].name;
                                return seq;
                            }
                            if (p instanceof AST_For && p.init === node) {
                                return seq;
                            }
                            if (!seq) return make_node(AST_EmptyStatement, node);
                            return make_node(AST_SimpleStatement, node, {
                                body: seq
                            });
                        }
                        if (node instanceof AST_Scope)
                            return node; // to avoid descending in nested scopes
                    }
                }
            );
            self = self.transform(tt);
            if (vars_found > 0) {
                // collect only vars which don't show up in self's arguments list
                var defs = [];
                vars.each(function(def, name){
                    if (self instanceof AST_Lambda
                        && find_if(function(x){ return x.name == def.name.name },
                                   self.argnames)) {
                        vars.del(name);
                    } else {
                        def = def.clone();
                        def.value = null;
                        defs.push(def);
                        vars.set(name, def);
                    }
                });
                if (defs.length > 0) {
                    // try to merge in assignments
                    for (var i = 0; i < self.body.length;) {
                        if (self.body[i] instanceof AST_SimpleStatement) {
                            var expr = self.body[i].body, sym, assign;
                            if (expr instanceof AST_Assign
                                && expr.operator == "="
                                && (sym = expr.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = expr.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body.splice(i, 1);
                                continue;
                            }
                            if (expr instanceof AST_Seq
                                && (assign = expr.car) instanceof AST_Assign
                                && assign.operator == "="
                                && (sym = assign.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = assign.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body[i].body = expr.cdr;
                                continue;
                            }
                        }
                        if (self.body[i] instanceof AST_EmptyStatement) {
                            self.body.splice(i, 1);
                            continue;
                        }
                        if (self.body[i] instanceof AST_BlockStatement) {
                            var tmp = [ i, 1 ].concat(self.body[i].body);
                            self.body.splice.apply(self.body, tmp);
                            continue;
                        }
                        break;
                    }
                    defs = make_node(AST_Var, self, {
                        definitions: defs
                    });
                    hoisted.push(defs);
                };
            }
            self.body = dirs.concat(hoisted, self.body);
        }
        return self;
    });

    OPT(AST_SimpleStatement, function(self, compressor){
        if (compressor.option("side_effects")) {
            if (!self.body.has_side_effects(compressor)) {
                compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                return make_node(AST_EmptyStatement, self);
            }
        }
        return self;
    });

    OPT(AST_DWLoop, function(self, compressor){
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (!compressor.option("loops")) return self;
        if (cond.length > 1) {
            if (cond[1]) {
                return make_node(AST_For, self, {
                    body: self.body
                });
            } else if (self instanceof AST_While) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        return self;
    });

    function if_break_in_loop(self, compressor) {
        function drop_it(rest) {
            rest = as_statement_array(rest);
            if (self.body instanceof AST_BlockStatement) {
                self.body = self.body.clone();
                self.body.body = rest.concat(self.body.body.slice(1));
                self.body = self.body.transform(compressor);
            } else {
                self.body = make_node(AST_BlockStatement, self.body, {
                    body: rest
                }).transform(compressor);
            }
            if_break_in_loop(self, compressor);
        }
        var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
        if (first instanceof AST_If) {
            if (first.body instanceof AST_Break
                && compressor.loopcontrol_target(first.body.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition.negate(compressor),
                    });
                } else {
                    self.condition = first.condition.negate(compressor);
                }
                drop_it(first.alternative);
            }
            else if (first.alternative instanceof AST_Break
                     && compressor.loopcontrol_target(first.alternative.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition,
                    });
                } else {
                    self.condition = first.condition;
                }
                drop_it(first.body);
            }
        }
    };

    OPT(AST_While, function(self, compressor) {
        if (!compressor.option("loops")) return self;
        self = AST_DWLoop.prototype.optimize.call(self, compressor);
        if (self instanceof AST_While) {
            if_break_in_loop(self, compressor);
            self = make_node(AST_For, self, self).transform(compressor);
        }
        return self;
    });

    OPT(AST_For, function(self, compressor){
        var cond = self.condition;
        if (cond) {
            cond = cond.evaluate(compressor);
            self.condition = cond[0];
        }
        if (!compressor.option("loops")) return self;
        if (cond) {
            if (cond.length > 1 && !cond[1]) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.init instanceof AST_Statement) {
                        a.push(self.init);
                    }
                    else if (self.init) {
                        a.push(make_node(AST_SimpleStatement, self.init, {
                            body: self.init
                        }));
                    }
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        if_break_in_loop(self, compressor);
        return self;
    });

    OPT(AST_If, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        // if condition can be statically determined, warn and drop
        // one of the blocks.  note, statically determined implies
        // “has no side effects”; also it doesn't work for cases like
        // `x && true`, though it probably should.
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.alternative) {
                        extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                    }
                    a.push(self.body);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    if (self.alternative) a.push(self.alternative);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            }
        }
        if (is_empty(self.alternative)) self.alternative = null;
        var negated = self.condition.negate(compressor);
        var negated_is_best = best_of(self.condition, negated) === negated;
        if (self.alternative && negated_is_best) {
            negated_is_best = false; // because we already do the switch here.
            self.condition = negated;
            var tmp = self.body;
            self.body = self.alternative || make_node(AST_EmptyStatement);
            self.alternative = tmp;
        }
        if (is_empty(self.body) && is_empty(self.alternative)) {
            return make_node(AST_SimpleStatement, self.condition, {
                body: self.condition
            }).transform(compressor);
        }
        if (self.body instanceof AST_SimpleStatement
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.body,
                    alternative : self.alternative.body
                })
            }).transform(compressor);
        }
        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
            if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : negated,
                    right    : self.body.body
                })
            }).transform(compressor);
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "&&",
                    left     : self.condition,
                    right    : self.body.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_EmptyStatement
            && self.alternative
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : self.condition,
                    right    : self.alternative.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_Exit
            && self.alternative instanceof AST_Exit
            && self.body.TYPE == self.alternative.TYPE) {
            return make_node(self.body.CTOR, self, {
                value: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_If
            && !self.body.alternative
            && !self.alternative) {
            self.condition = make_node(AST_Binary, self.condition, {
                operator: "&&",
                left: self.condition,
                right: self.body.condition
            }).transform(compressor);
            self.body = self.body.body;
        }
        if (aborts(self.body)) {
            if (self.alternative) {
                var alt = self.alternative;
                self.alternative = null;
                return make_node(AST_BlockStatement, self, {
                    body: [ self, alt ]
                }).transform(compressor);
            }
        }
        if (aborts(self.alternative)) {
            var body = self.body;
            self.body = self.alternative;
            self.condition = negated_is_best ? negated : self.condition.negate(compressor);
            self.alternative = null;
            return make_node(AST_BlockStatement, self, {
                body: [ self, body ]
            }).transform(compressor);
        }
        return self;
    });

    OPT(AST_Switch, function(self, compressor){
        if (self.body.length == 0 && compressor.option("conditionals")) {
            return make_node(AST_SimpleStatement, self, {
                body: self.expression
            }).transform(compressor);
        }
        for(;;) {
            var last_branch = self.body[self.body.length - 1];
            if (last_branch) {
                var stat = last_branch.body[last_branch.body.length - 1]; // last statement
                if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self)
                    last_branch.body.pop();
                if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                    self.body.pop();
                    continue;
                }
            }
            break;
        }
        var exp = self.expression.evaluate(compressor);
        out: if (exp.length == 2) try {
            // constant expression
            self.expression = exp[0];
            if (!compressor.option("dead_code")) break out;
            var value = exp[1];
            var in_if = false;
            var in_block = false;
            var started = false;
            var stopped = false;
            var ruined = false;
            var tt = new TreeTransformer(function(node, descend, in_list){
                if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                    // no need to descend these node types
                    return node;
                }
                else if (node instanceof AST_Switch && node === self) {
                    node = node.clone();
                    descend(node, this);
                    return ruined ? node : make_node(AST_BlockStatement, node, {
                        body: node.body.reduce(function(a, branch){
                            return a.concat(branch.body);
                        }, [])
                    }).transform(compressor);
                }
                else if (node instanceof AST_If || node instanceof AST_Try) {
                    var save = in_if;
                    in_if = !in_block;
                    descend(node, this);
                    in_if = save;
                    return node;
                }
                else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                    var save = in_block;
                    in_block = true;
                    descend(node, this);
                    in_block = save;
                    return node;
                }
                else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                    if (in_if) {
                        ruined = true;
                        return node;
                    }
                    if (in_block) return node;
                    stopped = true;
                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                }
                else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                    if (stopped) return MAP.skip;
                    if (node instanceof AST_Case) {
                        var exp = node.expression.evaluate(compressor);
                        if (exp.length < 2) {
                            // got a case with non-constant expression, baling out
                            throw self;
                        }
                        if (exp[1] === value || started) {
                            started = true;
                            if (aborts(node)) stopped = true;
                            descend(node, this);
                            return node;
                        }
                        return MAP.skip;
                    }
                    descend(node, this);
                    return node;
                }
            });
            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
            self = self.transform(tt);
        } catch(ex) {
            if (ex !== self) throw ex;
        }
        return self;
    });

    OPT(AST_Case, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_Try, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    AST_Definitions.DEFMETHOD("remove_initializers", function(){
        this.definitions.forEach(function(def){ def.value = null });
    });

    AST_Definitions.DEFMETHOD("to_assignments", function(){
        var assignments = this.definitions.reduce(function(a, def){
            if (def.value) {
                var name = make_node(AST_SymbolRef, def.name, def.name);
                a.push(make_node(AST_Assign, def, {
                    operator : "=",
                    left     : name,
                    right    : def.value
                }));
            }
            return a;
        }, []);
        if (assignments.length == 0) return null;
        return AST_Seq.from_array(assignments);
    });

    OPT(AST_Definitions, function(self, compressor){
        if (self.definitions.length == 0)
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_Function, function(self, compressor){
        self = AST_Lambda.prototype.optimize.call(self, compressor);
        if (compressor.option("unused")) {
            if (self.name && self.name.unreferenced()) {
                self.name = null;
            }
        }
        return self;
    });

    OPT(AST_Call, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Array":
                    if (self.args.length != 1) {
                        return make_node(AST_Array, self, {
                            elements: self.args
                        }).transform(compressor);
                    }
                    break;
                  case "Object":
                    if (self.args.length == 0) {
                        return make_node(AST_Object, self, {
                            properties: []
                        });
                    }
                    break;
                  case "String":
                    if (self.args.length == 0) return make_node(AST_String, self, {
                        value: ""
                    });
                    if (self.args.length <= 1) return make_node(AST_Binary, self, {
                        left: self.args[0],
                        operator: "+",
                        right: make_node(AST_String, self, { value: "" })
                    }).transform(compressor);
                    break;
                  case "Number":
                    if (self.args.length == 0) return make_node(AST_Number, self, {
                        value: 0
                    });
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: self.args[0],
                        operator: "+"
                    }).transform(compressor);
                  case "Boolean":
                    if (self.args.length == 0) return make_node(AST_False, self);
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: make_node(AST_UnaryPrefix, null, {
                            expression: self.args[0],
                            operator: "!"
                        }),
                        operator: "!"
                    }).transform(compressor);
                    break;
                  case "Function":
                    if (all(self.args, function(x){ return x instanceof AST_String })) {
                        // quite a corner-case, but we can handle it:
                        //   https://github.com/mishoo/UglifyJS2/issues/203
                        // if the code argument is a constant, then we can minify it.
                        try {
                            var code = "(function(" + self.args.slice(0, -1).map(function(arg){
                                return arg.value;
                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                            var ast = parse(code);
                            ast.figure_out_scope();
                            var comp = new Compressor(compressor.options);
                            ast = ast.transform(comp);
                            ast.figure_out_scope();
                            ast.mangle_names();
                            var fun;
                            try {
                                ast.walk(new TreeWalker(function(node){
                                    if (node instanceof AST_Lambda) {
                                        fun = node;
                                        throw ast;
                                    }
                                }));
                            } catch(ex) {
                                if (ex !== ast) throw ex;
                            };
                            var args = fun.argnames.map(function(arg, i){
                                return make_node(AST_String, self.args[i], {
                                    value: arg.print_to_string()
                                });
                            });
                            var code = OutputStream();
                            AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                            code = code.toString().replace(/^\{|\}$/g, "");
                            args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                value: code
                            }));
                            self.args = args;
                            return self;
                        } catch(ex) {
                            if (ex instanceof JS_Parse_Error) {
                                compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                compressor.warn(ex.toString());
                            } else {
                                console.log(ex);
                                throw ex;
                            }
                        }
                    }
                    break;
                }
            }
            else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                return make_node(AST_Binary, self, {
                    left: make_node(AST_String, self, { value: "" }),
                    operator: "+",
                    right: exp.expression
                }).transform(compressor);
            }
            else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
                var separator = self.args.length == 0 ? "," : self.args[0].evaluate(compressor)[1];
                if (separator == null) break EXIT; // not a constant
                var elements = exp.expression.elements.reduce(function(a, el){
                    el = el.evaluate(compressor);
                    if (a.length == 0 || el.length == 1) {
                        a.push(el);
                    } else {
                        var last = a[a.length - 1];
                        if (last.length == 2) {
                            // it's a constant
                            var val = "" + last[1] + separator + el[1];
                            a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                        } else {
                            a.push(el);
                        }
                    }
                    return a;
                }, []);
                if (elements.length == 0) return make_node(AST_String, self, { value: "" });
                if (elements.length == 1) return elements[0][0];
                if (separator == "") {
                    var first;
                    if (elements[0][0] instanceof AST_String
                        || elements[1][0] instanceof AST_String) {
                        first = elements.shift()[0];
                    } else {
                        first = make_node(AST_String, self, { value: "" });
                    }
                    return elements.reduce(function(prev, el){
                        return make_node(AST_Binary, el[0], {
                            operator : "+",
                            left     : prev,
                            right    : el[0],
                        });
                    }, first).transform(compressor);
                }
                // need this awkward cloning to not affect original element
                // best_of will decide which one to get through.
                var node = self.clone();
                node.expression = node.expression.clone();
                node.expression.expression = node.expression.expression.clone();
                node.expression.expression.elements = elements.map(function(el){
                    return el[0];
                });
                return best_of(self, node);
            }
        }
        if (compressor.option("side_effects")) {
            if (self.expression instanceof AST_Function
                && self.args.length == 0
                && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {
                return make_node(AST_Undefined, self).transform(compressor);
            }
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_New, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Object":
                  case "RegExp":
                  case "Function":
                  case "Error":
                  case "Array":
                    return make_node(AST_Call, self, self).transform(compressor);
                }
            }
        }
        return self;
    });

    OPT(AST_Seq, function(self, compressor){
        if (!compressor.option("side_effects"))
            return self;
        if (!self.car.has_side_effects(compressor)) {
            // we shouldn't compress (1,eval)(something) to
            // eval(something) because that changes the meaning of
            // eval (becomes lexical instead of global).
            var p;
            if (!(self.cdr instanceof AST_SymbolRef
                  && self.cdr.name == "eval"
                  && self.cdr.undeclared()
                  && (p = compressor.parent()) instanceof AST_Call
                  && p.expression === self)) {
                return self.cdr;
            }
        }
        if (compressor.option("cascade")) {
            if (self.car instanceof AST_Assign
                && !self.car.left.has_side_effects(compressor)
                && self.car.left.equivalent_to(self.cdr)) {
                return self.car;
            }
            if (!self.car.has_side_effects(compressor)
                && !self.cdr.has_side_effects(compressor)
                && self.car.equivalent_to(self.cdr)) {
                return self.car;
            }
        }
        return self;
    });

    AST_Unary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.expression instanceof AST_Seq) {
                var seq = this.expression;
                var x = seq.to_array();
                this.expression = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    OPT(AST_UnaryPostfix, function(self, compressor){
        return self.lift_sequences(compressor);
    });

    OPT(AST_UnaryPrefix, function(self, compressor){
        self = self.lift_sequences(compressor);
        var e = self.expression;
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            switch (self.operator) {
              case "!":
                if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                    // !!foo ==> foo, if we're in boolean context
                    return e.expression;
                }
                break;
              case "typeof":
                // typeof always returns a non-empty string, thus it's
                // always true in booleans
                compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (e instanceof AST_Binary && self.operator == "!") {
                self = best_of(self, e.negate(compressor));
            }
        }
        return self.evaluate(compressor)[0];
    });

    function has_side_effects_or_prop_access(node, compressor) {
        var save_pure_getters = compressor.option("pure_getters");
        compressor.options.pure_getters = false;
        var ret = node.has_side_effects(compressor);
        compressor.options.pure_getters = save_pure_getters;
        return ret;
    }

    AST_Binary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.left instanceof AST_Seq) {
                var seq = this.left;
                var x = seq.to_array();
                this.left = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
            if (this.right instanceof AST_Seq
                && this instanceof AST_Assign
                && !has_side_effects_or_prop_access(this.left, compressor)) {
                var seq = this.right;
                var x = seq.to_array();
                this.right = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    var commutativeOperators = makePredicate("== === != !== * & | ^");

    OPT(AST_Binary, function(self, compressor){
        var reverse = compressor.has_directive("use asm") ? noop
            : function(op, force) {
                if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {
                    if (op) self.operator = op;
                    var tmp = self.left;
                    self.left = self.right;
                    self.right = tmp;
                }
            };
        if (commutativeOperators(self.operator)) {
            if (self.right instanceof AST_Constant
                && !(self.left instanceof AST_Constant)) {
                // if right is a constant, whatever side effects the
                // left side might have could not influence the
                // result.  hence, force switch.

                if (!(self.left instanceof AST_Binary
                      && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
                    reverse(null, true);
                }
            }
            if (/^[!=]==?$/.test(self.operator)) {
                if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                    if (self.right.consequent instanceof AST_SymbolRef
                        && self.right.consequent.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition;
                        if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor);
                    }
                    if (self.right.alternative instanceof AST_SymbolRef
                        && self.right.alternative.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.right.condition;
                    }
                }
                if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                    if (self.left.consequent instanceof AST_SymbolRef
                        && self.left.consequent.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition;
                        if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor);
                    }
                    if (self.left.alternative instanceof AST_SymbolRef
                        && self.left.alternative.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.left.condition;
                    }
                }
            }
        }
        self = self.lift_sequences(compressor);
        if (compressor.option("comparisons")) switch (self.operator) {
          case "===":
          case "!==":
            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                (self.left.is_boolean() && self.right.is_boolean())) {
                self.operator = self.operator.substr(0, 2);
            }
            // XXX: intentionally falling down to the next case
          case "==":
          case "!=":
            if (self.left instanceof AST_String
                && self.left.value == "undefined"
                && self.right instanceof AST_UnaryPrefix
                && self.right.operator == "typeof"
                && compressor.option("unsafe")) {
                if (!(self.right.expression instanceof AST_SymbolRef)
                    || !self.right.expression.undeclared()) {
                    self.right = self.right.expression;
                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                    if (self.operator.length == 2) self.operator += "=";
                }
            }
            break;
        }
        if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
          case "&&":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                return make_node(AST_False, self);
            }
            if (ll.length > 1 && ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && rr[1]) {
                return ll[0];
            }
            break;
          case "||":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (ll.length > 1 && !ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && !rr[1]) {
                return ll[0];
            }
            break;
          case "+":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[0] instanceof AST_String && ll[1]) ||
                (rr.length > 1 && rr[0] instanceof AST_String && rr[1])) {
                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            break;
        }
        if (compressor.option("comparisons")) {
            if (!(compressor.parent() instanceof AST_Binary)
                || compressor.parent() instanceof AST_Assign) {
                var negated = make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.negate(compressor)
                });
                self = best_of(self, negated);
            }
            switch (self.operator) {
              case "<": reverse(">"); break;
              case "<=": reverse(">="); break;
            }
        }
        if (self.operator == "+" && self.right instanceof AST_String
            && self.right.getValue() === "" && self.left instanceof AST_Binary
            && self.left.operator == "+" && self.left.is_string(compressor)) {
            return self.left;
        } else if (self.operator == "+" && self.right instanceof AST_String
                   && self.right.getValue() === "" && self.left instanceof AST_Binary
                   && self.left.operator == "+" && self.left.right instanceof AST_Number) {
            return make_node(AST_Binary, self, {
                left: self.left.left,
                operator: "+",
                right: make_node(AST_String, self.right, {
                    value: String(self.left.right.value)
                })
            });
        }
        if (compressor.option("evaluate")) {
            if (self.operator == "+") {
                if (self.left instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_String, null, {
                            value: "" + self.left.getValue() + self.right.left.getValue(),
                            start: self.left.start,
                            end: self.right.left.end
                        }),
                        right: self.right.right
                    });
                }
                if (self.right instanceof AST_Constant
                    && self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.right instanceof AST_Constant
                    && self.left.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: self.left.left,
                        right: make_node(AST_String, null, {
                            value: "" + self.left.right.getValue() + self.right.getValue(),
                            start: self.left.right.start,
                            end: self.right.end
                        })
                    });
                }
                if (self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.is_string(compressor)
                    && self.left.right instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_Binary, self.left, {
                            operator: "+",
                            left: self.left.left,
                            right: make_node(AST_String, null, {
                                value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                start: self.left.right.start,
                                end: self.right.left.end
                            })
                        }),
                        right: self.right.right
                    });
                }
            }
        }
        // x * (y * z)  ==>  x * y * z
        if (self.right instanceof AST_Binary
            && self.right.operator == self.operator
            && (self.operator == "*" || self.operator == "&&" || self.operator == "||"))
        {
            self.left = make_node(AST_Binary, self.left, {
                operator : self.operator,
                left     : self.left,
                right    : self.right.left
            });
            self.right = self.right.right;
            return self.transform(compressor);
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_SymbolRef, function(self, compressor){
        if (self.undeclared()) {
            var defines = compressor.option("global_defs");
            if (defines && defines.hasOwnProperty(self.name)) {
                return make_node_from_constant(compressor, defines[self.name], self);
            }
            switch (self.name) {
              case "undefined":
                return make_node(AST_Undefined, self);
              case "NaN":
                return make_node(AST_NaN, self);
              case "Infinity":
                return make_node(AST_Infinity, self);
            }
        }
        return self;
    });

    OPT(AST_Undefined, function(self, compressor){
        if (compressor.option("unsafe")) {
            var scope = compressor.find_parent(AST_Scope);
            var undef = scope.find_variable("undefined");
            if (undef) {
                var ref = make_node(AST_SymbolRef, self, {
                    name   : "undefined",
                    scope  : scope,
                    thedef : undef
                });
                ref.reference();
                return ref;
            }
        }
        return self;
    });

    var ASSIGN_OPS = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
    OPT(AST_Assign, function(self, compressor){
        self = self.lift_sequences(compressor);
        if (self.operator == "="
            && self.left instanceof AST_SymbolRef
            && self.right instanceof AST_Binary
            && self.right.left instanceof AST_SymbolRef
            && self.right.left.name == self.left.name
            && member(self.right.operator, ASSIGN_OPS)) {
            self.operator = self.right.operator + "=";
            self.right = self.right.right;
        }
        return self;
    });

    OPT(AST_Conditional, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        if (self.condition instanceof AST_Seq) {
            var car = self.condition.car;
            self.condition = self.condition.cdr;
            return AST_Seq.cons(car, self);
        }
        var cond = self.condition.evaluate(compressor);
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                return self.consequent;
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                return self.alternative;
            }
        }
        var negated = cond[0].negate(compressor);
        if (best_of(cond[0], negated) === negated) {
            self = make_node(AST_Conditional, self, {
                condition: negated,
                consequent: self.alternative,
                alternative: self.consequent
            });
        }
        var consequent = self.consequent;
        var alternative = self.alternative;
        if (consequent instanceof AST_Assign
            && alternative instanceof AST_Assign
            && consequent.operator == alternative.operator
            && consequent.left.equivalent_to(alternative.left)
           ) {
            /*
             * Stuff like this:
             * if (foo) exp = something; else exp = something_else;
             * ==>
             * exp = foo ? something : something_else;
             */
            self = make_node(AST_Assign, self, {
                operator: consequent.operator,
                left: consequent.left,
                right: make_node(AST_Conditional, self, {
                    condition: self.condition,
                    consequent: consequent.right,
                    alternative: alternative.right
                })
            });
        }
        return self;
    });

    OPT(AST_Boolean, function(self, compressor){
        if (compressor.option("booleans")) {
            var p = compressor.parent();
            if (p instanceof AST_Binary && (p.operator == "=="
                                            || p.operator == "!=")) {
                compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                    operator : p.operator,
                    value    : self.value,
                    file     : p.start.file,
                    line     : p.start.line,
                    col      : p.start.col,
                });
                return make_node(AST_Number, self, {
                    value: +self.value
                });
            }
            return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: make_node(AST_Number, self, {
                    value: 1 - self.value
                })
            });
        }
        return self;
    });

    OPT(AST_Sub, function(self, compressor){
        var prop = self.property;
        if (prop instanceof AST_String && compressor.option("properties")) {
            prop = prop.getValue();
            if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                return make_node(AST_Dot, self, {
                    expression : self.expression,
                    property   : prop
                });
            }
        }
        return self;
    });

    function literals_in_boolean_context(self, compressor) {
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            return make_node(AST_True, self);
        }
        return self;
    };
    OPT(AST_Array, literals_in_boolean_context);
    OPT(AST_Object, literals_in_boolean_context);
    OPT(AST_RegExp, literals_in_boolean_context);

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// a small wrapper around fitzgen's source-map library
function SourceMap(options) {
    options = defaults(options, {
        file : null,
        root : null,
        orig : null,
    });
    var generator = new MOZ_SourceMap.SourceMapGenerator({
        file       : options.file,
        sourceRoot : options.root
    });
    var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
        if (orig_map) {
            var info = orig_map.originalPositionFor({
                line: orig_line,
                column: orig_col
            });
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name = info.name;
        }
        generator.addMapping({
            generated : { line: gen_line, column: gen_col },
            original  : { line: orig_line, column: orig_col },
            source    : source,
            name      : name
        });
    };
    return {
        add        : add,
        get        : function() { return generator },
        toString   : function() { return generator.toString() }
    };
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

(function(){

    var MOZ_TO_ME = {
        TryStatement : function(M) {
            return new AST_Try({
                start    : my_start_token(M),
                end      : my_end_token(M),
                body     : from_moz(M.block).body,
                bcatch   : from_moz(M.handlers[0]),
                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
        },
        CatchClause : function(M) {
            return new AST_Catch({
                start   : my_start_token(M),
                end     : my_end_token(M),
                argname : from_moz(M.param),
                body    : from_moz(M.body).body
            });
        },
        ObjectExpression : function(M) {
            return new AST_Object({
                start      : my_start_token(M),
                end        : my_end_token(M),
                properties : M.properties.map(function(prop){
                    var key = prop.key;
                    var name = key.type == "Identifier" ? key.name : key.value;
                    var args = {
                        start    : my_start_token(key),
                        end      : my_end_token(prop.value),
                        key      : name,
                        value    : from_moz(prop.value)
                    };
                    switch (prop.kind) {
                      case "init":
                        return new AST_ObjectKeyVal(args);
                      case "set":
                        args.value.name = from_moz(key);
                        return new AST_ObjectSetter(args);
                      case "get":
                        args.value.name = from_moz(key);
                        return new AST_ObjectGetter(args);
                    }
                })
            });
        },
        SequenceExpression : function(M) {
            return AST_Seq.from_array(M.expressions.map(from_moz));
        },
        MemberExpression : function(M) {
            return new (M.computed ? AST_Sub : AST_Dot)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                property   : M.computed ? from_moz(M.property) : M.property.name,
                expression : from_moz(M.object)
            });
        },
        SwitchCase : function(M) {
            return new (M.test ? AST_Case : AST_Default)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                expression : from_moz(M.test),
                body       : M.consequent.map(from_moz)
            });
        },
        Literal : function(M) {
            var val = M.value, args = {
                start  : my_start_token(M),
                end    : my_end_token(M)
            };
            if (val === null) return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
              default:
                args.value = val;
                return new AST_RegExp(args);
            }
        },
        UnaryExpression: From_Moz_Unary,
        UpdateExpression: From_Moz_Unary,
        Identifier: function(M) {
            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
            return new (M.name == "this" ? AST_This
                        : p.type == "LabeledStatement" ? AST_Label
                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : AST_SymbolVar)
                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
                        : p.type == "CatchClause" ? AST_SymbolCatch
                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
                        : AST_SymbolRef)({
                            start : my_start_token(M),
                            end   : my_end_token(M),
                            name  : M.name
                        });
        }
    };

    function From_Moz_Unary(M) {
        var prefix = "prefix" in M ? M.prefix
            : M.type == "UnaryExpression" ? true : false;
        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start      : my_start_token(M),
            end        : my_end_token(M),
            operator   : M.operator,
            expression : from_moz(M.argument)
        });
    };

    var ME_TO_MOZ = {};

    map("Node", AST_Node);
    map("Program", AST_Toplevel, "body@body");
    map("Function", AST_Function, "id>name, params@argnames, body%body");
    map("EmptyStatement", AST_EmptyStatement);
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
    map("VariableDeclaration", AST_Var, "declarations@definitions");
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");

    map("ThisExpression", AST_This);
    map("ArrayExpression", AST_Array, "elements@elements");
    map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args");
    map("CallExpression", AST_Call, "callee>expression, arguments@args");

    /* -----[ tools ]----- */

    function my_start_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.start.line,
            col    : moznode.loc && moznode.loc.start.column,
            pos    : moznode.start,
            endpos : moznode.start
        });
    };

    function my_end_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.end.line,
            col    : moznode.loc && moznode.loc.end.column,
            pos    : moznode.end,
            endpos : moznode.end
        });
    };

    function map(moztype, mytype, propmap) {
        var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
        moz_to_me += "return new mytype({\n" +
            "start: my_start_token(M),\n" +
            "end: my_end_token(M)";

        if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop){
            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
            if (!m) throw new Error("Can't understand property map: " + prop);
            var moz = "M." + m[1], how = m[2], my = m[3];
            moz_to_me += ",\n" + my + ": ";
            if (how == "@") {
                moz_to_me += moz + ".map(from_moz)";
            } else if (how == ">") {
                moz_to_me += "from_moz(" + moz + ")";
            } else if (how == "=") {
                moz_to_me += moz;
            } else if (how == "%") {
                moz_to_me += "from_moz(" + moz + ").body";
            } else throw new Error("Can't understand operator in propmap: " + prop);
        });
        moz_to_me += "\n})}";

        // moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
        // console.log(moz_to_me);

        moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
            mytype, my_start_token, my_end_token, from_moz
        );
        return MOZ_TO_ME[moztype] = moz_to_me;
    };

    var FROM_MOZ_STACK = null;

    function from_moz(node) {
        FROM_MOZ_STACK.push(node);
        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
        FROM_MOZ_STACK.pop();
        return ret;
    };

    AST_Node.from_mozilla_ast = function(node){
        var save_stack = FROM_MOZ_STACK;
        FROM_MOZ_STACK = [];
        var ast = from_moz(node);
        FROM_MOZ_STACK = save_stack;
        return ast;
    };

})();


exports.sys = sys;
exports.MOZ_SourceMap = MOZ_SourceMap;
exports.UglifyJS = UglifyJS;
exports.array_to_hash = array_to_hash;
exports.slice = slice;
exports.characters = characters;
exports.member = member;
exports.find_if = find_if;
exports.repeat_string = repeat_string;
exports.DefaultsError = DefaultsError;
exports.defaults = defaults;
exports.merge = merge;
exports.noop = noop;
exports.MAP = MAP;
exports.push_uniq = push_uniq;
exports.string_template = string_template;
exports.remove = remove;
exports.mergeSort = mergeSort;
exports.set_difference = set_difference;
exports.set_intersection = set_intersection;
exports.makePredicate = makePredicate;
exports.all = all;
exports.Dictionary = Dictionary;
exports.DEFNODE = DEFNODE;
exports.AST_Token = AST_Token;
exports.AST_Node = AST_Node;
exports.AST_Statement = AST_Statement;
exports.AST_Debugger = AST_Debugger;
exports.AST_Directive = AST_Directive;
exports.AST_SimpleStatement = AST_SimpleStatement;
exports.walk_body = walk_body;
exports.AST_Block = AST_Block;
exports.AST_BlockStatement = AST_BlockStatement;
exports.AST_EmptyStatement = AST_EmptyStatement;
exports.AST_StatementWithBody = AST_StatementWithBody;
exports.AST_LabeledStatement = AST_LabeledStatement;
exports.AST_IterationStatement = AST_IterationStatement;
exports.AST_DWLoop = AST_DWLoop;
exports.AST_Do = AST_Do;
exports.AST_While = AST_While;
exports.AST_For = AST_For;
exports.AST_ForIn = AST_ForIn;
exports.AST_With = AST_With;
exports.AST_Scope = AST_Scope;
exports.AST_Toplevel = AST_Toplevel;
exports.AST_Lambda = AST_Lambda;
exports.AST_Accessor = AST_Accessor;
exports.AST_Function = AST_Function;
exports.AST_Defun = AST_Defun;
exports.AST_Jump = AST_Jump;
exports.AST_Exit = AST_Exit;
exports.AST_Return = AST_Return;
exports.AST_Throw = AST_Throw;
exports.AST_LoopControl = AST_LoopControl;
exports.AST_Break = AST_Break;
exports.AST_Continue = AST_Continue;
exports.AST_If = AST_If;
exports.AST_Switch = AST_Switch;
exports.AST_SwitchBranch = AST_SwitchBranch;
exports.AST_Default = AST_Default;
exports.AST_Case = AST_Case;
exports.AST_Try = AST_Try;
exports.AST_Catch = AST_Catch;
exports.AST_Finally = AST_Finally;
exports.AST_Definitions = AST_Definitions;
exports.AST_Var = AST_Var;
exports.AST_Const = AST_Const;
exports.AST_VarDef = AST_VarDef;
exports.AST_Call = AST_Call;
exports.AST_New = AST_New;
exports.AST_Seq = AST_Seq;
exports.AST_PropAccess = AST_PropAccess;
exports.AST_Dot = AST_Dot;
exports.AST_Sub = AST_Sub;
exports.AST_Unary = AST_Unary;
exports.AST_UnaryPrefix = AST_UnaryPrefix;
exports.AST_UnaryPostfix = AST_UnaryPostfix;
exports.AST_Binary = AST_Binary;
exports.AST_Conditional = AST_Conditional;
exports.AST_Assign = AST_Assign;
exports.AST_Array = AST_Array;
exports.AST_Object = AST_Object;
exports.AST_ObjectProperty = AST_ObjectProperty;
exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
exports.AST_ObjectSetter = AST_ObjectSetter;
exports.AST_ObjectGetter = AST_ObjectGetter;
exports.AST_Symbol = AST_Symbol;
exports.AST_SymbolAccessor = AST_SymbolAccessor;
exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
exports.AST_SymbolVar = AST_SymbolVar;
exports.AST_SymbolConst = AST_SymbolConst;
exports.AST_SymbolFunarg = AST_SymbolFunarg;
exports.AST_SymbolDefun = AST_SymbolDefun;
exports.AST_SymbolLambda = AST_SymbolLambda;
exports.AST_SymbolCatch = AST_SymbolCatch;
exports.AST_Label = AST_Label;
exports.AST_SymbolRef = AST_SymbolRef;
exports.AST_LabelRef = AST_LabelRef;
exports.AST_This = AST_This;
exports.AST_Constant = AST_Constant;
exports.AST_String = AST_String;
exports.AST_Number = AST_Number;
exports.AST_RegExp = AST_RegExp;
exports.AST_Atom = AST_Atom;
exports.AST_Null = AST_Null;
exports.AST_NaN = AST_NaN;
exports.AST_Undefined = AST_Undefined;
exports.AST_Hole = AST_Hole;
exports.AST_Infinity = AST_Infinity;
exports.AST_Boolean = AST_Boolean;
exports.AST_False = AST_False;
exports.AST_True = AST_True;
exports.TreeWalker = TreeWalker;
exports.KEYWORDS = KEYWORDS;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;
exports.OPERATOR_CHARS = OPERATOR_CHARS;
exports.RE_HEX_NUMBER = RE_HEX_NUMBER;
exports.RE_OCT_NUMBER = RE_OCT_NUMBER;
exports.RE_DEC_NUMBER = RE_DEC_NUMBER;
exports.OPERATORS = OPERATORS;
exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;
exports.PUNC_CHARS = PUNC_CHARS;
exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;
exports.UNICODE = UNICODE;
exports.is_letter = is_letter;
exports.is_digit = is_digit;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_unicode_combining_mark = is_unicode_combining_mark;
exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;
exports.is_identifier = is_identifier;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.is_identifier_string = is_identifier_string;
exports.parse_js_number = parse_js_number;
exports.JS_Parse_Error = JS_Parse_Error;
exports.js_error = js_error;
exports.is_token = is_token;
exports.EX_EOF = EX_EOF;
exports.tokenizer = tokenizer;
exports.UNARY_PREFIX = UNARY_PREFIX;
exports.UNARY_POSTFIX = UNARY_POSTFIX;
exports.ASSIGNMENT = ASSIGNMENT;
exports.PRECEDENCE = PRECEDENCE;
exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.parse = parse;
exports.TreeTransformer = TreeTransformer;
exports.SymbolDef = SymbolDef;
exports.base54 = base54;
exports.OutputStream = OutputStream;
exports.Compressor = Compressor;
exports.SourceMap = SourceMap;

exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }

exports.minify = function (files, options) {
    options = UglifyJS.defaults(options, {
        outSourceMap : null,
        sourceRoot   : null,
        inSourceMap  : null,
        fromString   : false,
        warnings     : false,
        mangle       : {},
        output       : null,
        compress     : {}
    });
    if (typeof files == "string")
        files = [ files ];

    UglifyJS.base54.reset();

    // 1. parse
    var toplevel = null;
    files.forEach(function(file){
        var code = options.fromString
            ? file
            : fs.readFileSync(file, "utf8");
        toplevel = UglifyJS.parse(code, {
            filename: options.fromString ? "?" : file,
            toplevel: toplevel
        });
    });

    // 2. compress
    if (options.compress) {
        var compress = { warnings: options.warnings };
        UglifyJS.merge(compress, options.compress);
        toplevel.figure_out_scope();
        var sq = UglifyJS.Compressor(compress);
        toplevel = toplevel.transform(sq);
    }

    // 3. mangle
    if (options.mangle) {
        toplevel.figure_out_scope();
        toplevel.compute_char_frequency();
        toplevel.mangle_names(options.mangle);
    }

    // 4. output
    var inMap = options.inSourceMap;
    var output = {};
    if (typeof options.inSourceMap == "string") {
        inMap = fs.readFileSync(options.inSourceMap, "utf8");
    }
    if (options.outSourceMap) {
        output.source_map = UglifyJS.SourceMap({
            file: options.outSourceMap,
            orig: inMap,
            root: options.sourceRoot
        });
    }
    if (options.output) {
        UglifyJS.merge(output, options.output);
    }
    var stream = UglifyJS.OutputStream(output);
    toplevel.print(stream);
    return {
        code : stream + "",
        map  : output.source_map + ""
    };
};

exports.describe_ast = function () {
    var out = UglifyJS.OutputStream({ beautify: true });
    function doitem(ctor) {
        out.print("AST_" + ctor.TYPE);
        var props = ctor.SELF_PROPS.filter(function(prop){
            return !/^\$/.test(prop);
        });
        if (props.length > 0) {
            out.space();
            out.with_parens(function(){
                props.forEach(function(prop, i){
                    if (i) out.space();
                    out.print(prop);
                });
            });
        }
        if (ctor.documentation) {
            out.space();
            out.print_string(ctor.documentation);
        }
        if (ctor.SUBCLASSES.length > 0) {
            out.space();
            out.with_block(function(){
                ctor.SUBCLASSES.forEach(function(ctor, i){
                    out.indent();
                    doitem(ctor);
                    out.newline();
                });
            });
        }
    };
    doitem(UglifyJS.AST_Node);
    return out + "";
};
},{"source-map":88,"util":4}],99:[function(require,module,exports){
var global=self;var uglify = require('uglify-js')


module.exports = addWith

function addWith(obj, src, exclude) {
  exclude = exclude || []
  exclude = exclude.concat(detect(obj))
  var vars = detect('(function () {' + src + '}())')//allows the `return` keyword
    .filter(function (v) {
      return !(v in global) && exclude.indexOf(v) === -1
    })

  if (vars.length === 0) return src

  var declareLocal = ''
  var local = 'locals'
  if (/^[a-zA-Z0-9$_]+$/.test(obj)) {
    local = obj
  } else {
    while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {
      local += '_'
    }
    declareLocal = local + ' = (' + obj + '),'
  }
  return 'var ' + declareLocal + vars
    .map(function (v) {
      return v + ' = ' + local + '.' + v
    }).join(',') + ';' + src
}

function detect(src) {
    var ast = uglify.parse(src.toString())
    ast.figure_out_scope()
    var globals = ast.globals
        .map(function (node, name) {
            return name
        })
    return globals;
}
},{"uglify-js":110}],100:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":105,"./source-map/source-map-generator":106,"./source-map/source-node":107}],101:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":108,"amdefine":109}],102:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":103,"amdefine":109}],103:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":109}],104:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":109}],105:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":101,"./base64-vlq":102,"./binary-search":104,"./util":108,"amdefine":109}],106:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":101,"./base64-vlq":102,"./util":108,"amdefine":109}],107:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":106,"./util":108,"amdefine":109}],108:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":109}],109:[function(require,module,exports){
var process=require("__browserify_process"),__filename="/../../node_modules/jade/node_modules/with/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js";/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

},{"__browserify_process":5,"path":3}],110:[function(require,module,exports){
var sys = require("util");
var MOZ_SourceMap = require("source-map");
var UglifyJS = exports;
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function array_to_hash(a) {
    var ret = Object.create(null);
    for (var i = 0; i < a.length; ++i)
        ret[a[i]] = true;
    return ret;
};

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
    return str.split("");
};

function member(name, array) {
    for (var i = array.length; --i >= 0;)
        if (array[i] == name)
            return true;
    return false;
};

function find_if(func, array) {
    for (var i = 0, n = array.length; i < n; ++i) {
        if (func(array[i]))
            return array[i];
    }
};

function repeat_string(str, i) {
    if (i <= 0) return "";
    if (i == 1) return str;
    var d = repeat_string(str, i >> 1);
    d += d;
    if (i & 1) d += str;
    return d;
};

function DefaultsError(msg, defs) {
    this.msg = msg;
    this.defs = defs;
};

function defaults(args, defs, croak) {
    if (args === true)
        args = {};
    var ret = args || {};
    if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))
        throw new DefaultsError("`" + i + "` is not a supported option", defs);
    for (var i in defs) if (defs.hasOwnProperty(i)) {
        ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];
    }
    return ret;
};

function merge(obj, ext) {
    for (var i in ext) if (ext.hasOwnProperty(i)) {
        obj[i] = ext[i];
    }
    return obj;
};

function noop() {};

var MAP = (function(){
    function MAP(a, f, backwards) {
        var ret = [], top = [], i;
        function doit() {
            var val = f(a[i], i);
            var is_last = val instanceof Last;
            if (is_last) val = val.v;
            if (val instanceof AtTop) {
                val = val.v;
                if (val instanceof Splice) {
                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    top.push(val);
                }
            }
            else if (val !== skip) {
                if (val instanceof Splice) {
                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    ret.push(val);
                }
            }
            return is_last;
        };
        if (a instanceof Array) {
            if (backwards) {
                for (i = a.length; --i >= 0;) if (doit()) break;
                ret.reverse();
                top.reverse();
            } else {
                for (i = 0; i < a.length; ++i) if (doit()) break;
            }
        }
        else {
            for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
        }
        return top.concat(ret);
    };
    MAP.at_top = function(val) { return new AtTop(val) };
    MAP.splice = function(val) { return new Splice(val) };
    MAP.last = function(val) { return new Last(val) };
    var skip = MAP.skip = {};
    function AtTop(val) { this.v = val };
    function Splice(val) { this.v = val };
    function Last(val) { this.v = val };
    return MAP;
})();

function push_uniq(array, el) {
    if (array.indexOf(el) < 0)
        array.push(el);
};

function string_template(text, props) {
    return text.replace(/\{(.+?)\}/g, function(str, p){
        return props[p];
    });
};

function remove(array, el) {
    for (var i = array.length; --i >= 0;) {
        if (array[i] === el) array.splice(i, 1);
    }
};

function mergeSort(array, cmp) {
    if (array.length < 2) return array.slice();
    function merge(a, b) {
        var r = [], ai = 0, bi = 0, i = 0;
        while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0
                ? r[i++] = a[ai++]
                : r[i++] = b[bi++];
        }
        if (ai < a.length) r.push.apply(r, a.slice(ai));
        if (bi < b.length) r.push.apply(r, b.slice(bi));
        return r;
    };
    function _ms(a) {
        if (a.length <= 1)
            return a;
        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
        left = _ms(left);
        right = _ms(right);
        return merge(left, right);
    };
    return _ms(array);
};

function set_difference(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) < 0;
    });
};

function set_intersection(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) >= 0;
    });
};

// this function is taken from Acorn [1], written by Marijn Haverbeke
// [1] https://github.com/marijnh/acorn
function makePredicate(words) {
    if (!(words instanceof Array)) words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
            }
        cats.push([words[i]]);
    }
    function compareTo(arr) {
        if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
        f += "return true}return false;";
    }
    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.
    if (cats.length > 3) {
        cats.sort(function(a, b) {return b.length - a.length;});
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
        }
        f += "}";
        // Otherwise, simply generate a flat `switch` statement.
    } else {
        compareTo(words);
    }
    return new Function("str", f);
};

function all(array, predicate) {
    for (var i = array.length; --i >= 0;)
        if (!predicate(array[i]))
            return false;
    return true;
};

function Dictionary() {
    this._values = Object.create(null);
    this._size = 0;
};
Dictionary.prototype = {
    set: function(key, val) {
        if (!this.has(key)) ++this._size;
        this._values["$" + key] = val;
        return this;
    },
    add: function(key, val) {
        if (this.has(key)) {
            this.get(key).push(val);
        } else {
            this.set(key, [ val ]);
        }
        return this;
    },
    get: function(key) { return this._values["$" + key] },
    del: function(key) {
        if (this.has(key)) {
            --this._size;
            delete this._values["$" + key];
        }
        return this;
    },
    has: function(key) { return ("$" + key) in this._values },
    each: function(f) {
        for (var i in this._values)
            f(this._values[i], i.substr(1));
    },
    size: function() {
        return this._size;
    },
    map: function(f) {
        var ret = [];
        for (var i in this._values)
            ret.push(f(this._values[i], i.substr(1)));
        return ret;
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function DEFNODE(type, props, methods, base) {
    if (arguments.length < 4) base = AST_Node;
    if (!props) props = [];
    else props = props.split(/\s+/);
    var self_props = props;
    if (base && base.PROPS)
        props = props.concat(base.PROPS);
    var code = "return function AST_" + type + "(props){ if (props) { ";
    for (var i = props.length; --i >= 0;) {
        code += "this." + props[i] + " = props." + props[i] + ";";
    }
    var proto = base && new base;
    if (proto && proto.initialize || (methods && methods.initialize))
        code += "this.initialize();";
    code += "}}";
    var ctor = new Function(code)();
    if (proto) {
        ctor.prototype = proto;
        ctor.BASE = base;
    }
    if (base) base.SUBCLASSES.push(ctor);
    ctor.prototype.CTOR = ctor;
    ctor.PROPS = props || null;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    if (type) {
        ctor.prototype.TYPE = ctor.TYPE = type;
    }
    if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
        if (/^\$/.test(i)) {
            ctor[i.substr(1)] = methods[i];
        } else {
            ctor.prototype[i] = methods[i];
        }
    }
    ctor.DEFMETHOD = function(name, method) {
        this.prototype[name] = method;
    };
    return ctor;
};

var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {
}, null);

var AST_Node = DEFNODE("Node", "start end", {
    clone: function() {
        return new this.CTOR(this);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
        start: "[AST_Token] The first token of this node",
        end: "[AST_Token] The last token of this node"
    },
    _walk: function(visitor) {
        return visitor._visit(this);
    },
    walk: function(visitor) {
        return this._walk(visitor); // not sure the indirection will be any help
    }
}, null);

AST_Node.warn_function = null;
AST_Node.warn = function(txt, props) {
    if (AST_Node.warn_function)
        AST_Node.warn_function(string_template(txt, props));
};

/* -----[ statements ]----- */

var AST_Statement = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
});

var AST_Debugger = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement",
}, AST_Statement);

var AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
        scope: "[AST_Scope/S] The scope that this directive affects"
    },
}, AST_Statement);

var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

function walk_body(node, visitor) {
    if (node.body instanceof AST_Statement) {
        node.body._walk(visitor);
    }
    else node.body.forEach(function(stat){
        stat._walk(visitor);
    });
};

var AST_Block = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually bracketed)",
    $propdoc: {
        body: "[AST_Statement*] an array of statements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
        });
    }
}, AST_Statement);

var AST_BlockStatement = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement",
}, AST_Block);

var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _walk: function(visitor) {
        return visitor._visit(this);
    }
}, AST_Statement);

var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
        label: "[AST_Label] a label definition"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.label._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_Do = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
}, AST_DWLoop);

var AST_While = DEFNODE("While", null, {
    $documentation: "A `while` statement",
}, AST_DWLoop);

var AST_For = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
        init: "[AST_Node?] the `for` initialization code, or null if empty",
        condition: "[AST_Node?] the `for` termination clause, or null if empty",
        step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.init) this.init._walk(visitor);
            if (this.condition) this.condition._walk(visitor);
            if (this.step) this.step._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        init: "[AST_Node] the `for/in` initialization code",
        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        object: "[AST_Node] the object that we're looping through"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_With = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
        expression: "[AST_Node] the `with` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ scope and functions ]----- */

var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
        directives: "[string*/S] an array of directives declared in this scope",
        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
    },
}, AST_Block);

var AST_Toplevel = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
    },
    wrap_enclose: function(arg_parameter_pairs) {
        var self = this;
        var args = [];
        var parameters = [];

        arg_parameter_pairs.forEach(function(pair) {
            var split = pair.split(":");

            args.push(split[0]);
            parameters.push(split[1]);
        });

        var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_Directive && node.value == "$ORIG") {
                return MAP.splice(self.body);
            }
        }));
        return wrapped_tl;
    },
    wrap_commonjs: function(name, export_all) {
        var self = this;
        var to_export = [];
        if (export_all) {
            self.figure_out_scope();
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                    if (!find_if(function(n){ return n.name == node.name }, to_export))
                        to_export.push(node);
                }
            }));
        }
        var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_SimpleStatement) {
                node = node.body;
                if (node instanceof AST_String) switch (node.getValue()) {
                  case "$ORIG":
                    return MAP.splice(self.body);
                  case "$EXPORTS":
                    var body = [];
                    to_export.forEach(function(sym){
                        body.push(new AST_SimpleStatement({
                            body: new AST_Assign({
                                left: new AST_Sub({
                                    expression: new AST_SymbolRef({ name: "exports" }),
                                    property: new AST_String({ value: sym.name }),
                                }),
                                operator: "=",
                                right: new AST_SymbolRef(sym),
                            }),
                        }));
                    });
                    return MAP.splice(body);
                }
            }
        }));
        return wrapped_tl;
    }
}, AST_Scope);

var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function",
        argnames: "[AST_SymbolFunarg*] array of function arguments",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.name) this.name._walk(visitor);
            this.argnames.forEach(function(arg){
                arg._walk(visitor);
            });
            walk_body(this, visitor);
        });
    }
}, AST_Scope);

var AST_Accessor = DEFNODE("Accessor", null, {
    $documentation: "A setter/getter function"
}, AST_Lambda);

var AST_Function = DEFNODE("Function", null, {
    $documentation: "A function expression"
}, AST_Lambda);

var AST_Defun = DEFNODE("Defun", null, {
    $documentation: "A function definition"
}, AST_Lambda);

/* -----[ JUMPS ]----- */

var AST_Jump = DEFNODE("Jump", null, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement);

var AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.value && function(){
            this.value._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Return = DEFNODE("Return", null, {
    $documentation: "A `return` statement"
}, AST_Exit);

var AST_Throw = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement"
}, AST_Exit);

var AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none",
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.label && function(){
            this.label._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Break = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
}, AST_LoopControl);

var AST_Continue = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
}, AST_LoopControl);

/* -----[ IF ]----- */

var AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative) this.alternative._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ SWITCH ]----- */

var AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
}, AST_Block);

var AST_Default = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch",
}, AST_SwitchBranch);

var AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_SwitchBranch);

/* -----[ EXCEPTIONS ]----- */

var AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
            if (this.bcatch) this.bcatch._walk(visitor);
            if (this.bfinally) this.bfinally._walk(visitor);
        });
    }
}, AST_Block);

// XXX: this is wrong according to ECMA-262 (12.4).  the catch block
// should introduce another scope, as the argname should be visible
// only inside the catch block.  However, doing it this way because of
// IE which simply introduces the name in the surrounding scope.  If
// we ever want to fix this then AST_Catch should inherit from
// AST_Scope.
var AST_Catch = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.argname._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_Finally = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block);

/* -----[ VAR/CONST ]----- */

var AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.definitions.forEach(function(def){
                def._walk(visitor);
            });
        });
    }
}, AST_Statement);

var AST_Var = DEFNODE("Var", null, {
    $documentation: "A `var` statement"
}, AST_Definitions);

var AST_Const = DEFNODE("Const", null, {
    $documentation: "A `const` statement"
}, AST_Definitions);

var AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.name._walk(visitor);
            if (this.value) this.value._walk(visitor);
        });
    }
});

/* -----[ OTHER ]----- */

var AST_Call = DEFNODE("Call", "expression args", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.args.forEach(function(arg){
                arg._walk(visitor);
            });
        });
    }
});

var AST_New = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
}, AST_Call);

var AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "A sequence expression (two comma-separated expressions)",
    $propdoc: {
        car: "[AST_Node] first element in sequence",
        cdr: "[AST_Node] second element in sequence"
    },
    $cons: function(x, y) {
        var seq = new AST_Seq(x);
        seq.car = x;
        seq.cdr = y;
        return seq;
    },
    $from_array: function(array) {
        if (array.length == 0) return null;
        if (array.length == 1) return array[0].clone();
        var list = null;
        for (var i = array.length; --i >= 0;) {
            list = AST_Seq.cons(array[i], list);
        }
        var p = list;
        while (p) {
            if (p.cdr && !p.cdr.cdr) {
                p.cdr = p.cdr.car;
                break;
            }
            p = p.cdr;
        }
        return list;
    },
    to_array: function() {
        var p = this, a = [];
        while (p) {
            a.push(p.car);
            if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                a.push(p.cdr);
                break;
            }
            p = p.cdr;
        }
        return a;
    },
    add: function(node) {
        var p = this;
        while (p) {
            if (!(p.cdr instanceof AST_Seq)) {
                var cell = AST_Seq.cons(p.cdr, node);
                return p.cdr = cell;
            }
            p = p.cdr;
        }
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.car._walk(visitor);
            if (this.cdr) this.cdr._walk(visitor);
        });
    }
});

var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
        expression: "[AST_Node] the “container” expression",
        property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
});

var AST_Dot = DEFNODE("Dot", null, {
    $documentation: "A dotted property access expression",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Sub = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.property._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
});

var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary);

var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary);

var AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.left._walk(visitor);
            this.right._walk(visitor);
        });
    }
});

var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
        });
    }
});

var AST_Assign = DEFNODE("Assign", null, {
    $documentation: "An assignment expression — `a = b + 5`",
}, AST_Binary);

/* -----[ LITERALS ]----- */

var AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.elements.forEach(function(el){
                el._walk(visitor);
            });
        });
    }
});

var AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.properties.forEach(function(prop){
                prop._walk(visitor);
            });
        });
    }
});

var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
        key: "[string] the property name; it's always a plain string in our AST, no matter if it was a string, number or identifier in original code",
        value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.value._walk(visitor);
        });
    }
});

var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
}, AST_ObjectProperty);

var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
}, AST_ObjectProperty);

var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
}, AST_ObjectProperty);

var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols",
});

var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol);

var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol);

var AST_SymbolVar = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable",
}, AST_SymbolDeclaration);

var AST_SymbolConst = DEFNODE("SymbolConst", null, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration);

var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument",
}, AST_SymbolVar);

var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function",
}, AST_SymbolDeclaration);

var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression",
}, AST_SymbolDeclaration);

var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch",
}, AST_SymbolDeclaration);

var AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LabelRef*] a list of nodes referring to this label"
    }
}, AST_Symbol);

var AST_SymbolRef = DEFNODE("SymbolRef", null, {
    $documentation: "Reference to some symbol (not definition/declaration)",
}, AST_Symbol);

var AST_LabelRef = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol",
}, AST_Symbol);

var AST_This = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
}, AST_Symbol);

var AST_Constant = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    getValue: function() {
        return this.value;
    }
});

var AST_String = DEFNODE("String", "value", {
    $documentation: "A string literal",
    $propdoc: {
        value: "[string] the contents of this string"
    }
}, AST_Constant);

var AST_Number = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
        value: "[number] the numeric value"
    }
}, AST_Constant);

var AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
        value: "[RegExp] the actual regexp"
    }
}, AST_Constant);

var AST_Atom = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
}, AST_Constant);

var AST_Null = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
}, AST_Atom);

var AST_NaN = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0/0
}, AST_Atom);

var AST_Undefined = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: (function(){}())
}, AST_Atom);

var AST_Hole = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: (function(){}())
}, AST_Atom);

var AST_Infinity = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1/0
}, AST_Atom);

var AST_Boolean = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
}, AST_Atom);

var AST_False = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
}, AST_Boolean);

var AST_True = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
}, AST_Boolean);

/* -----[ TreeWalker ]----- */

function TreeWalker(callback) {
    this.visit = callback;
    this.stack = [];
};
TreeWalker.prototype = {
    _visit: function(node, descend) {
        this.stack.push(node);
        var ret = this.visit(node, descend ? function(){
            descend.call(node);
        } : noop);
        if (!ret && descend) {
            descend.call(node);
        }
        this.stack.pop();
        return ret;
    },
    parent: function(n) {
        return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function (node) {
        this.stack.push(node);
    },
    pop: function() {
        return this.stack.pop();
    },
    self: function() {
        return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
        var stack = this.stack;
        for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof type) return x;
        }
    },
    has_directive: function(type) {
        return this.find_parent(AST_Scope).has_directive(type);
    },
    in_boolean_context: function() {
        var stack = this.stack;
        var i = stack.length, self = stack[--i];
        while (i > 0) {
            var p = stack[--i];
            if ((p instanceof AST_If           && p.condition === self) ||
                (p instanceof AST_Conditional  && p.condition === self) ||
                (p instanceof AST_DWLoop       && p.condition === self) ||
                (p instanceof AST_For          && p.condition === self) ||
                (p instanceof AST_UnaryPrefix  && p.operator == "!" && p.expression === self))
            {
                return true;
            }
            if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")))
                return false;
            self = p;
        }
    },
    loopcontrol_target: function(label) {
        var stack = this.stack;
        if (label) {
            for (var i = stack.length; --i >= 0;) {
                var x = stack[i];
                if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                    return x.body;
                }
            }
        } else {
            for (var i = stack.length; --i >= 0;) {
                var x = stack[i];
                if (x instanceof AST_Switch
                    || x instanceof AST_For
                    || x instanceof AST_ForIn
                    || x instanceof AST_DWLoop) return x;
            }
        }
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';
var KEYWORDS_ATOM = 'false null true';
var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile'
    + " " + KEYWORDS_ATOM + " " + KEYWORDS;
var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';

KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);

var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));

var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

// regexps adapted from http://xregexp.com/plugins/#unicode
var UNICODE = {
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};

function is_letter(code) {
    return (code >= 97 && code <= 122)
        || (code >= 65 && code <= 90)
        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));
};

function is_digit(code) {
    return code >= 48 && code <= 57; //XXX: find out if "UnicodeDigit" means something else than 0..9
};

function is_alphanumeric_char(code) {
    return is_digit(code) || is_letter(code);
};

function is_unicode_combining_mark(ch) {
    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
};

function is_identifier(name) {
    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
};

function is_identifier_start(code) {
    return code == 36 || code == 95 || is_letter(code);
};

function is_identifier_char(ch) {
    var code = ch.charCodeAt(0);
    return is_identifier_start(code)
        || is_digit(code)
        || code == 8204 // \u200c: zero-width non-joiner <ZWNJ>
        || code == 8205 // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        || is_unicode_combining_mark(ch)
        || is_unicode_connector_punctuation(ch)
    ;
};

function is_identifier_string(str){
    var i = str.length;
    if (i == 0) return false;
    if (is_digit(str.charCodeAt(0))) return false;
    while (--i >= 0) {
        if (!is_identifier_char(str.charAt(i)))
            return false;
    }
    return true;
};

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    } else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    } else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
};

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, filename, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT, filename) {

    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ''),
        filename        : filename,
        pos             : 0,
        tokpos          : 0,
        line            : 1,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };

    function peek() { return S.text.charAt(S.pos); };

    function next(signal_eof, in_string) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch)
            throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
        } else {
            ++S.col;
        }
        return ch;
    };

    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    };

    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    };

    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX(value)) ||
                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value)) ||
                           (type == "punc" && PUNC_BEFORE_EXPRESSION(value)));
        var ret = {
            type   : type,
            value  : value,
            line   : S.tokline,
            col    : S.tokcol,
            pos    : S.tokpos,
            endpos : S.pos,
            nlb    : S.newline_before,
            file   : filename
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
            // make note of any newlines in the comments that came before
            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
            }
        }
        S.newline_before = false;
        return new AST_Token(ret);
    };

    function skip_whitespace() {
        while (WHITESPACE_CHARS(peek()))
            next();
    };

    function read_while(pred) {
        var ret = "", ch, i = 0;
        while ((ch = peek()) && pred(ch, i++))
            ret += next();
        return ret;
    };

    function parse_error(err) {
        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
    };

    function read_num(prefix) {
        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
        var num = read_while(function(ch, i){
            var code = ch.charCodeAt(0);
            switch (code) {
              case 120: case 88: // xX
                return has_x ? false : (has_x = true);
              case 101: case 69: // eE
                return has_x ? true : has_e ? false : (has_e = after_e = true);
              case 45: // -
                return after_e || (i == 0 && !prefix);
              case 43: // +
                return after_e;
              case (after_e = false, 46): // .
                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
            }
            return is_alphanumeric_char(code);
        });
        if (prefix) num = prefix + num;
        var valid = parse_js_number(num);
        if (!isNaN(valid)) {
            return token("num", valid);
        } else {
            parse_error("Invalid syntax: " + num);
        }
    };

    function read_escaped_char(in_string) {
        var ch = next(true, in_string);
        switch (ch.charCodeAt(0)) {
          case 110 : return "\n";
          case 114 : return "\r";
          case 116 : return "\t";
          case 98  : return "\b";
          case 118 : return "\u000b"; // \v
          case 102 : return "\f";
          case 48  : return "\0";
          case 120 : return String.fromCharCode(hex_bytes(2)); // \x
          case 117 : return String.fromCharCode(hex_bytes(4)); // \u
          case 10  : return ""; // newline
          default  : return ch;
        }
    };

    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit))
                parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    };

    var read_string = with_eof_error("Unterminated string constant", function(){
        var quote = next(), ret = "";
        for (;;) {
            var ch = next(true);
            if (ch == "\\") {
                // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                // https://github.com/mishoo/UglifyJS/issues/178
                var octal_len = 0, first = null;
                ch = read_while(function(ch){
                    if (ch >= "0" && ch <= "7") {
                        if (!first) {
                            first = ch;
                            return ++octal_len;
                        }
                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                    }
                    return false;
                });
                if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                else ch = read_escaped_char(true);
            }
            else if (ch == quote) break;
            ret += ch;
        }
        return token("string", ret);
    });

    function read_line_comment() {
        next();
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        return token("comment1", ret, true);
    };

    var read_multiline_comment = with_eof_error("Unterminated multiline comment", function(){
        next();
        var i = find("*/", true);
        var text = S.text.substring(S.pos, i);
        var a = text.split("\n"), n = a.length;
        // update stream position
        S.pos = i + 2;
        S.line += n - 1;
        if (n > 1) S.col = a[n - 1].length;
        else S.col += a[n - 1].length;
        S.col += 2;
        S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
        return token("comment2", text, true);
    });

    function read_name() {
        var backslash = false, name = "", ch, escaped = false, hex;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") escaped = backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        if (KEYWORDS(name) && escaped) {
            hex = name.charCodeAt(0).toString(16).toUpperCase();
            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
        }
        return name;
    };

    var read_regexp = with_eof_error("Unterminated regular expression", function(regexp){
        var prev_backslash = false, ch, in_class = false;
        while ((ch = next(true))) if (prev_backslash) {
            regexp += "\\" + ch;
            prev_backslash = false;
        } else if (ch == "[") {
            in_class = true;
            regexp += ch;
        } else if (ch == "]" && in_class) {
            in_class = false;
            regexp += ch;
        } else if (ch == "/" && !in_class) {
            break;
        } else if (ch == "\\") {
            prev_backslash = true;
        } else {
            regexp += ch;
        }
        var mods = read_name();
        return token("regexp", new RegExp(regexp, mods));
    });

    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (OPERATORS(bigger)) {
                next();
                return grow(bigger);
            } else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    };

    function handle_slash() {
        next();
        var regex_allowed = S.regex_allowed;
        switch (peek()) {
          case "/":
            S.comments_before.push(read_line_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
          case "*":
            S.comments_before.push(read_multiline_comment());
            S.regex_allowed = regex_allowed;
            return next_token();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    };

    function handle_dot() {
        next();
        return is_digit(peek().charCodeAt(0))
            ? read_num(".")
            : token("punc", ".");
    };

    function read_word() {
        var word = read_name();
        return KEYWORDS_ATOM(word) ? token("atom", word)
            : !KEYWORDS(word) ? token("name", word)
            : OPERATORS(word) ? token("operator", word)
            : token("keyword", word);
    };

    function with_eof_error(eof_error, cont) {
        return function(x) {
            try {
                return cont(x);
            } catch(ex) {
                if (ex === EX_EOF) parse_error(eof_error);
                else throw ex;
            }
        };
    };

    function next_token(force_regexp) {
        if (force_regexp != null)
            return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        var ch = peek();
        if (!ch) return token("eof");
        var code = ch.charCodeAt(0);
        switch (code) {
          case 34: case 39: return read_string();
          case 46: return handle_dot();
          case 47: return handle_slash();
        }
        if (is_digit(code)) return read_num();
        if (PUNC_CHARS(ch)) return token("punc", next());
        if (OPERATOR_CHARS(ch)) return read_operator();
        if (code == 92 || is_identifier_start(code)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    };

    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };

    return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
]);

var UNARY_POSTFIX = makePredicate([ "--", "++" ]);

var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);

var PRECEDENCE = (function(a, ret){
    for (var i = 0, n = 1; i < a.length; ++i, ++n) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = n;
        }
    }
    return ret;
})(
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ],
    {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function parse($TEXT, options) {

    options = defaults(options, {
        strict     : false,
        filename   : null,
        toplevel   : null,
        expression : false
    });

    var S = {
        input         : typeof $TEXT == "string" ? tokenizer($TEXT, options.filename) : $TEXT,
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    };

    function peek() { return S.peeked || (S.peeked = S.input()); };

    function next() {
        S.prev = S.token;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        } else {
            S.token = S.input();
        }
        S.in_directives = S.in_directives && (
            S.token.type == "string" || is("punc", ";")
        );
        return S.token;
    };

    function prev() {
        return S.prev;
    };

    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 ctx.filename,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    };

    function token_error(token, msg) {
        croak(msg, token.line, token.col);
    };

    function unexpected(token) {
        if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
    };

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
    };

    function expect(punc) { return expect_token("punc", punc); };

    function can_insert_semicolon() {
        return !options.strict && (
            S.token.nlb || is("eof") || is("punc", "}")
        );
    };

    function semicolon() {
        if (is("punc", ";")) next();
        else if (!can_insert_semicolon()) unexpected();
    };

    function parenthesised() {
        expect("(");
        var exp = expression(true);
        expect(")");
        return exp;
    };

    function embed_tokens(parser) {
        return function() {
            var start = S.token;
            var expr = parser();
            var end = prev();
            expr.start = start;
            expr.end = end;
            return expr;
        };
    };

    var statement = embed_tokens(function() {
        var tmp;
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
        switch (S.token.type) {
          case "string":
            var dir = S.in_directives, stat = simple_statement();
            // XXXv2: decide how to fix directives
            if (dir && stat.body instanceof AST_String && !is("punc", ","))
                return new AST_Directive({ value: stat.body.value });
            return stat;
          case "num":
          case "regexp":
          case "operator":
          case "atom":
            return simple_statement();

          case "name":
            return is_token(peek(), "punc", ":")
                ? labeled_statement()
                : simple_statement();

          case "punc":
            switch (S.token.value) {
              case "{":
                return new AST_BlockStatement({
                    start : S.token,
                    body  : block_(),
                    end   : prev()
                });
              case "[":
              case "(":
                return simple_statement();
              case ";":
                next();
                return new AST_EmptyStatement();
              default:
                unexpected();
            }

          case "keyword":
            switch (tmp = S.token.value, next(), tmp) {
              case "break":
                return break_cont(AST_Break);

              case "continue":
                return break_cont(AST_Continue);

              case "debugger":
                semicolon();
                return new AST_Debugger();

              case "do":
                return new AST_Do({
                    body      : in_loop(statement),
                    condition : (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), tmp)
                });

              case "while":
                return new AST_While({
                    condition : parenthesised(),
                    body      : in_loop(statement)
                });

              case "for":
                return for_();

              case "function":
                return function_(true);

              case "if":
                return if_();

              case "return":
                if (S.in_function == 0)
                    croak("'return' outside of function");
                return new AST_Return({
                    value: ( is("punc", ";")
                             ? (next(), null)
                             : can_insert_semicolon()
                             ? null
                             : (tmp = expression(true), semicolon(), tmp) )
                });

              case "switch":
                return new AST_Switch({
                    expression : parenthesised(),
                    body       : in_loop(switch_body_)
                });

              case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return new AST_Throw({
                    value: (tmp = expression(true), semicolon(), tmp)
                });

              case "try":
                return try_();

              case "var":
                return tmp = var_(), semicolon(), tmp;

              case "const":
                return tmp = const_(), semicolon(), tmp;

              case "with":
                return new AST_With({
                    expression : parenthesised(),
                    body       : statement()
                });

              default:
                unexpected();
            }
        }
    });

    function labeled_statement() {
        var label = as_symbol(AST_Label);
        if (find_if(function(l){ return l.name == label.name }, S.labels)) {
            // ECMA-262, 12.12: An ECMAScript program is considered
            // syntactically incorrect if it contains a
            // LabelledStatement that is enclosed by a
            // LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice");
        }
        expect(":");
        S.labels.push(label);
        var stat = statement();
        S.labels.pop();
        return new AST_LabeledStatement({ body: stat, label: label });
    };

    function simple_statement(tmp) {
        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
    };

    function break_cont(type) {
        var label = null;
        if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
        }
        if (label != null) {
            if (!find_if(function(l){ return l.name == label.name }, S.labels))
                croak("Undefined label " + label.name);
        }
        else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
        semicolon();
        return new type({ label: label });
    };

    function for_() {
        expect("(");
        var init = null;
        if (!is("punc", ";")) {
            init = is("keyword", "var")
                ? (next(), var_(true))
                : expression(true, true);
            if (is("operator", "in")) {
                if (init instanceof AST_Var && init.definitions.length > 1)
                    croak("Only one variable declaration allowed in for..in loop");
                next();
                return for_in(init);
            }
        }
        return regular_for(init);
    };

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression(true);
        expect(";");
        var step = is("punc", ")") ? null : expression(true);
        expect(")");
        return new AST_For({
            init      : init,
            condition : test,
            step      : step,
            body      : in_loop(statement)
        });
    };

    function for_in(init) {
        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
        var obj = expression(true);
        expect(")");
        return new AST_ForIn({
            init   : init,
            name   : lhs,
            object : obj,
            body   : in_loop(statement)
        });
    };

    var function_ = function(in_statement, ctor) {
        var is_accessor = ctor === AST_Accessor;
        var name = (is("name") ? as_symbol(in_statement
                                           ? AST_SymbolDefun
                                           : is_accessor
                                           ? AST_SymbolAccessor
                                           : AST_SymbolLambda)
                    : is_accessor && (is("string") || is("num")) ? as_atom_node()
                    : null);
        if (in_statement && !name)
            unexpected();
        expect("(");
        if (!ctor) ctor = in_statement ? AST_Defun : AST_Function;
        return new ctor({
            name: name,
            argnames: (function(first, a){
                while (!is("punc", ")")) {
                    if (first) first = false; else expect(",");
                    a.push(as_symbol(AST_SymbolFunarg));
                }
                next();
                return a;
            })(true, []),
            body: (function(loop, labels){
                ++S.in_function;
                S.in_directives = true;
                S.in_loop = 0;
                S.labels = [];
                var a = block_();
                --S.in_function;
                S.in_loop = loop;
                S.labels = labels;
                return a;
            })(S.in_loop, S.labels)
        });
    };

    function if_() {
        var cond = parenthesised(), body = statement(), belse = null;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return new AST_If({
            condition   : cond,
            body        : body,
            alternative : belse
        });
    };

    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            a.push(statement());
        }
        next();
        return a;
    };

    function switch_body_() {
        expect("{");
        var a = [], cur = null, branch = null, tmp;
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            if (is("keyword", "case")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Case({
                    start      : (tmp = S.token, next(), tmp),
                    expression : expression(true),
                    body       : cur
                });
                a.push(branch);
                expect(":");
            }
            else if (is("keyword", "default")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Default({
                    start : (tmp = S.token, next(), expect(":"), tmp),
                    body  : cur
                });
                a.push(branch);
            }
            else {
                if (!cur) unexpected();
                cur.push(statement());
            }
        }
        if (branch) branch.end = prev();
        next();
        return a;
    };

    function try_() {
        var body = block_(), bcatch = null, bfinally = null;
        if (is("keyword", "catch")) {
            var start = S.token;
            next();
            expect("(");
            var name = as_symbol(AST_SymbolCatch);
            expect(")");
            bcatch = new AST_Catch({
                start   : start,
                argname : name,
                body    : block_(),
                end     : prev()
            });
        }
        if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
                start : start,
                body  : block_(),
                end   : prev()
            });
        }
        if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
        return new AST_Try({
            body     : body,
            bcatch   : bcatch,
            bfinally : bfinally
        });
    };

    function vardefs(no_in, in_const) {
        var a = [];
        for (;;) {
            a.push(new AST_VarDef({
                start : S.token,
                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                value : is("operator", "=") ? (next(), expression(false, no_in)) : null,
                end   : prev()
            }));
            if (!is("punc", ","))
                break;
            next();
        }
        return a;
    };

    var var_ = function(no_in) {
        return new AST_Var({
            start       : prev(),
            definitions : vardefs(no_in, false),
            end         : prev()
        });
    };

    var const_ = function() {
        return new AST_Const({
            start       : prev(),
            definitions : vardefs(false, true),
            end         : prev()
        });
    };

    var new_ = function() {
        var start = S.token;
        expect_token("operator", "new");
        var newexp = expr_atom(false), args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        } else {
            args = [];
        }
        return subscripts(new AST_New({
            start      : start,
            expression : newexp,
            args       : args,
            end        : prev()
        }), true);
    };

    function as_atom_node() {
        var tok = S.token, ret;
        switch (tok.type) {
          case "name":
            return as_symbol(AST_SymbolRef);
          case "num":
            ret = new AST_Number({ start: tok, end: tok, value: tok.value });
            break;
          case "string":
            ret = new AST_String({ start: tok, end: tok, value: tok.value });
            break;
          case "regexp":
            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });
            break;
          case "atom":
            switch (tok.value) {
              case "false":
                ret = new AST_False({ start: tok, end: tok });
                break;
              case "true":
                ret = new AST_True({ start: tok, end: tok });
                break;
              case "null":
                ret = new AST_Null({ start: tok, end: tok });
                break;
            }
            break;
        }
        next();
        return ret;
    };

    var expr_atom = function(allow_calls) {
        if (is("operator", "new")) {
            return new_();
        }
        var start = S.token;
        if (is("punc")) {
            switch (start.value) {
              case "(":
                next();
                var ex = expression(true);
                ex.start = start;
                ex.end = S.token;
                expect(")");
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_(), allow_calls);
            }
            unexpected();
        }
        if (is("keyword", "function")) {
            next();
            var func = function_(false);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
        }
        if (ATOMIC_START_TOKEN[S.token.type]) {
            return subscripts(as_atom_node(), allow_calls);
        }
        unexpected();
    };

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true, a = [];
        while (!is("punc", closing)) {
            if (first) first = false; else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    };

    var array_ = embed_tokens(function() {
        expect("[");
        return new AST_Array({
            elements: expr_list("]", !options.strict, true)
        });
    });

    var object_ = embed_tokens(function() {
        expect("{");
        var first = true, a = [];
        while (!is("punc", "}")) {
            if (first) first = false; else expect(",");
            if (!options.strict && is("punc", "}"))
                // allow trailing comma
                break;
            var start = S.token;
            var type = start.type;
            var name = as_property_name();
            if (type == "name" && !is("punc", ":")) {
                if (name == "get") {
                    a.push(new AST_ObjectGetter({
                        start : start,
                        key   : name,
                        value : function_(false, AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
                if (name == "set") {
                    a.push(new AST_ObjectSetter({
                        start : start,
                        key   : name,
                        value : function_(false, AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
            }
            expect(":");
            a.push(new AST_ObjectKeyVal({
                start : start,
                key   : name,
                value : expression(false),
                end   : prev()
            }));
        }
        next();
        return new AST_Object({ properties: a });
    });

    function as_property_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "num":
          case "string":
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function as_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function as_symbol(type, noerror) {
        if (!is("name")) {
            if (!noerror) croak("Name expected");
            return null;
        }
        var name = S.token.value;
        var sym = new (name == "this" ? AST_This : type)({
            name  : String(S.token.value),
            start : S.token,
            end   : S.token
        });
        next();
        return sym;
    };

    var subscripts = function(expr, allow_calls) {
        var start = expr.start;
        if (is("punc", ".")) {
            next();
            return subscripts(new AST_Dot({
                start      : start,
                expression : expr,
                property   : as_name(),
                end        : prev()
            }), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return subscripts(new AST_Sub({
                start      : start,
                expression : expr,
                property   : prop,
                end        : prev()
            }), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(new AST_Call({
                start      : start,
                expression : expr,
                args       : expr_list(")"),
                end        : prev()
            }), true);
        }
        return expr;
    };

    var maybe_unary = function(allow_calls) {
        var start = S.token;
        if (is("operator") && UNARY_PREFIX(start.value)) {
            next();
            var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
            val = make_unary(AST_UnaryPostfix, S.token.value, val);
            val.start = start;
            val.end = S.token;
            next();
        }
        return val;
    };

    function make_unary(ctor, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr))
            croak("Invalid use of " + op + " operator");
        return new ctor({ operator: op, expression: expr });
    };

    var expr_op = function(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(new AST_Binary({
                start    : left.start,
                left     : left,
                operator : op,
                right    : right,
                end      : right.end
            }), min_prec, no_in);
        }
        return left;
    };

    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    };

    var maybe_conditional = function(no_in) {
        var start = S.token;
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
                start       : start,
                condition   : expr,
                consequent  : yes,
                alternative : expression(false, no_in),
                end         : peek()
            });
        }
        return expr;
    };

    function is_assignable(expr) {
        if (!options.strict) return true;
        if (expr instanceof AST_This) return false;
        return (expr instanceof AST_PropAccess || expr instanceof AST_Symbol);
    };

    var maybe_assign = function(no_in) {
        var start = S.token;
        var left = maybe_conditional(no_in), val = S.token.value;
        if (is("operator") && ASSIGNMENT(val)) {
            if (is_assignable(left)) {
                next();
                return new AST_Assign({
                    start    : start,
                    left     : left,
                    operator : val,
                    right    : maybe_assign(no_in),
                    end      : prev()
                });
            }
            croak("Invalid assignment");
        }
        return left;
    };

    var expression = function(commas, no_in) {
        var start = S.token;
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return new AST_Seq({
                start  : start,
                car    : expr,
                cdr    : expression(true, no_in),
                end    : peek()
            });
        }
        return expr;
    };

    function in_loop(cont) {
        ++S.in_loop;
        var ret = cont();
        --S.in_loop;
        return ret;
    };

    if (options.expression) {
        return expression(true);
    }

    return (function(){
        var start = S.token;
        var body = [];
        while (!is("eof"))
            body.push(statement());
        var end = prev();
        var toplevel = options.toplevel;
        if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
        } else {
            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
        }
        return toplevel;
    })();

};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// Tree transformer helpers.

function TreeTransformer(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
}
TreeTransformer.prototype = new TreeWalker;

(function(undefined){

    function _(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list){
            var x, y;
            tw.push(this);
            if (tw.before) x = tw.before(this, descend, in_list);
            if (x === undefined) {
                if (!tw.after) {
                    x = this;
                    descend(x, tw);
                } else {
                    tw.stack[tw.stack.length - 1] = x = this.clone();
                    descend(x, tw);
                    y = tw.after(x, in_list);
                    if (y !== undefined) x = y;
                }
            }
            tw.pop();
            return x;
        });
    };

    function do_list(list, tw) {
        return MAP(list, function(node){
            return node.transform(tw, true);
        });
    };

    _(AST_Node, noop);

    _(AST_LabeledStatement, function(self, tw){
        self.label = self.label.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_SimpleStatement, function(self, tw){
        self.body = self.body.transform(tw);
    });

    _(AST_Block, function(self, tw){
        self.body = do_list(self.body, tw);
    });

    _(AST_DWLoop, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_For, function(self, tw){
        if (self.init) self.init = self.init.transform(tw);
        if (self.condition) self.condition = self.condition.transform(tw);
        if (self.step) self.step = self.step.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_ForIn, function(self, tw){
        self.init = self.init.transform(tw);
        self.object = self.object.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_With, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_Exit, function(self, tw){
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_LoopControl, function(self, tw){
        if (self.label) self.label = self.label.transform(tw);
    });

    _(AST_If, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
        if (self.alternative) self.alternative = self.alternative.transform(tw);
    });

    _(AST_Switch, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Case, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Try, function(self, tw){
        self.body = do_list(self.body, tw);
        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
    });

    _(AST_Catch, function(self, tw){
        self.argname = self.argname.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Definitions, function(self, tw){
        self.definitions = do_list(self.definitions, tw);
    });

    _(AST_VarDef, function(self, tw){
        self.name = self.name.transform(tw);
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_Lambda, function(self, tw){
        if (self.name) self.name = self.name.transform(tw);
        self.argnames = do_list(self.argnames, tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Call, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.args = do_list(self.args, tw);
    });

    _(AST_Seq, function(self, tw){
        self.car = self.car.transform(tw);
        self.cdr = self.cdr.transform(tw);
    });

    _(AST_Dot, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Sub, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.property = self.property.transform(tw);
    });

    _(AST_Unary, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Binary, function(self, tw){
        self.left = self.left.transform(tw);
        self.right = self.right.transform(tw);
    });

    _(AST_Conditional, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.consequent = self.consequent.transform(tw);
        self.alternative = self.alternative.transform(tw);
    });

    _(AST_Array, function(self, tw){
        self.elements = do_list(self.elements, tw);
    });

    _(AST_Object, function(self, tw){
        self.properties = do_list(self.properties, tw);
    });

    _(AST_ObjectProperty, function(self, tw){
        self.value = self.value.transform(tw);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function SymbolDef(scope, index, orig) {
    this.name = orig.name;
    this.orig = [ orig ];
    this.scope = scope;
    this.references = [];
    this.global = false;
    this.mangled_name = null;
    this.undeclared = false;
    this.constant = false;
    this.index = index;
};

SymbolDef.prototype = {
    unmangleable: function(options) {
        return (this.global && !(options && options.toplevel))
            || this.undeclared
            || (!(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with));
    },
    mangle: function(options) {
        if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            if (this.orig[0] instanceof AST_SymbolLambda && !options.screw_ie8)
                s = s.parent_scope;
            this.mangled_name = s.next_mangled(options);
        }
    }
};

AST_Toplevel.DEFMETHOD("figure_out_scope", function(){
    // This does what ast_add_scope did in UglifyJS v1.
    //
    // Part of it could be done at parse time, but it would complicate
    // the parser (and it's already kinda complex).  It's also worth
    // having it separated because we might need to call it multiple
    // times on the same tree.

    // pass 1: setup scope chaining and handle definitions
    var self = this;
    var scope = self.parent_scope = null;
    var labels = new Dictionary();
    var nesting = 0;
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Scope) {
            node.init_scope_vars(nesting);
            var save_scope = node.parent_scope = scope;
            var save_labels = labels;
            ++nesting;
            scope = node;
            labels = new Dictionary();
            descend();
            labels = save_labels;
            scope = save_scope;
            --nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Directive) {
            node.scope = scope;
            push_uniq(scope.directives, node.value);
            return true;
        }
        if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
                s.uses_with = true;
            return;
        }
        if (node instanceof AST_LabeledStatement) {
            var l = node.label;
            if (labels.has(l.name))
                throw new Error(string_template("Label {name} defined twice", l));
            labels.set(l.name, l);
            descend();
            labels.del(l.name);
            return true;        // no descend again
        }
        if (node instanceof AST_Symbol) {
            node.scope = scope;
        }
        if (node instanceof AST_Label) {
            node.thedef = node;
            node.init_scope_vars();
        }
        if (node instanceof AST_SymbolLambda) {
            scope.def_function(node);
        }
        else if (node instanceof AST_SymbolDefun) {
            // Careful here, the scope where this should be defined is
            // the parent scope.  The reason is that we enter a new
            // scope when we encounter the AST_Defun node (which is
            // instanceof AST_Scope) but we get to the symbol a bit
            // later.
            (node.scope = scope.parent_scope).def_function(node);
        }
        else if (node instanceof AST_SymbolVar
                 || node instanceof AST_SymbolConst) {
            var def = scope.def_variable(node);
            def.constant = node instanceof AST_SymbolConst;
            def.init = tw.parent().value;
        }
        else if (node instanceof AST_SymbolCatch) {
            // XXX: this is wrong according to ECMA-262 (12.4).  the
            // `catch` argument name should be visible only inside the
            // catch block.  For a quick fix AST_Catch should inherit
            // from AST_Scope.  Keeping it this way because of IE,
            // which doesn't obey the standard. (it introduces the
            // identifier in the enclosing scope)
            scope.def_variable(node);
        }
        if (node instanceof AST_LabelRef) {
            var sym = labels.get(node.name);
            if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
                name: node.name,
                line: node.start.line,
                col: node.start.col
            }));
            node.thedef = sym;
        }
    });
    self.walk(tw);

    // pass 2: find back references and eval
    var func = null;
    var globals = self.globals = new Dictionary();
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Lambda) {
            var prev_func = func;
            func = node;
            descend();
            func = prev_func;
            return true;
        }
        if (node instanceof AST_LabelRef) {
            node.reference();
            return true;
        }
        if (node instanceof AST_SymbolRef) {
            var name = node.name;
            var sym = node.scope.find_variable(name);
            if (!sym) {
                var g;
                if (globals.has(name)) {
                    g = globals.get(name);
                } else {
                    g = new SymbolDef(self, globals.size(), node);
                    g.undeclared = true;
                    g.global = true;
                    globals.set(name, g);
                }
                node.thedef = g;
                if (name == "eval" && tw.parent() instanceof AST_Call) {
                    for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope)
                        s.uses_eval = true;
                }
                if (name == "arguments") {
                    func.uses_arguments = true;
                }
            } else {
                node.thedef = sym;
            }
            node.reference();
            return true;
        }
    });
    self.walk(tw);
});

AST_Scope.DEFMETHOD("init_scope_vars", function(nesting){
    this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
    this.variables = new Dictionary(); // map name to AST_SymbolVar (variables defined in this scope; includes functions)
    this.functions = new Dictionary(); // map name to AST_SymbolDefun (functions defined in this scope)
    this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
    this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
    this.parent_scope = null; // the parent scope
    this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
    this.cname = -1;          // the current index for mangling functions/variables
    this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
});

AST_Scope.DEFMETHOD("strict", function(){
    return this.has_directive("use strict");
});

AST_Lambda.DEFMETHOD("init_scope_vars", function(){
    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
    this.uses_arguments = false;
});

AST_SymbolRef.DEFMETHOD("reference", function() {
    var def = this.definition();
    def.references.push(this);
    var s = this.scope;
    while (s) {
        push_uniq(s.enclosed, def);
        if (s === def.scope) break;
        s = s.parent_scope;
    }
    this.frame = this.scope.nesting - def.scope.nesting;
});

AST_Label.DEFMETHOD("init_scope_vars", function(){
    this.references = [];
});

AST_LabelRef.DEFMETHOD("reference", function(){
    this.thedef.references.push(this);
});

AST_Scope.DEFMETHOD("find_variable", function(name){
    if (name instanceof AST_Symbol) name = name.name;
    return this.variables.get(name)
        || (this.parent_scope && this.parent_scope.find_variable(name));
});

AST_Scope.DEFMETHOD("has_directive", function(value){
    return this.parent_scope && this.parent_scope.has_directive(value)
        || (this.directives.indexOf(value) >= 0 ? this : null);
});

AST_Scope.DEFMETHOD("def_function", function(symbol){
    this.functions.set(symbol.name, this.def_variable(symbol));
});

AST_Scope.DEFMETHOD("def_variable", function(symbol){
    var def;
    if (!this.variables.has(symbol.name)) {
        def = new SymbolDef(this, this.variables.size(), symbol);
        this.variables.set(symbol.name, def);
        def.global = !this.parent_scope;
    } else {
        def = this.variables.get(symbol.name);
        def.orig.push(symbol);
    }
    return symbol.thedef = def;
});

AST_Scope.DEFMETHOD("next_mangled", function(options){
    var ext = this.enclosed;
    out: while (true) {
        var m = base54(++this.cname);
        if (!is_identifier(m)) continue; // skip over "do"
        // we must ensure that the mangled name does not shadow a name
        // from some parent scope that is referenced in this or in
        // inner scopes.
        for (var i = ext.length; --i >= 0;) {
            var sym = ext[i];
            var name = sym.mangled_name || (sym.unmangleable(options) && sym.name);
            if (m == name) continue out;
        }
        return m;
    }
});

AST_Scope.DEFMETHOD("references", function(sym){
    if (sym instanceof AST_Symbol) sym = sym.definition();
    return this.enclosed.indexOf(sym) < 0 ? null : sym;
});

AST_Symbol.DEFMETHOD("unmangleable", function(options){
    return this.definition().unmangleable(options);
});

// property accessors are not mangleable
AST_SymbolAccessor.DEFMETHOD("unmangleable", function(){
    return true;
});

// labels are always mangleable
AST_Label.DEFMETHOD("unmangleable", function(){
    return false;
});

AST_Symbol.DEFMETHOD("unreferenced", function(){
    return this.definition().references.length == 0
        && !(this.scope.uses_eval || this.scope.uses_with);
});

AST_Symbol.DEFMETHOD("undeclared", function(){
    return this.definition().undeclared;
});

AST_LabelRef.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Label.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Symbol.DEFMETHOD("definition", function(){
    return this.thedef;
});

AST_Symbol.DEFMETHOD("global", function(){
    return this.definition().global;
});

AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options){
    return defaults(options, {
        except   : [],
        eval     : false,
        sort     : false,
        toplevel : false,
        screw_ie8 : false
    });
});

AST_Toplevel.DEFMETHOD("mangle_names", function(options){
    options = this._default_mangler_options(options);
    // We only need to mangle declaration nodes.  Special logic wired
    // into the code generator will display the mangled name if it's
    // present (and for AST_SymbolRef-s it'll use the mangled name of
    // the AST_SymbolDeclaration that it points to).
    var lname = -1;
    var to_mangle = [];
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_LabeledStatement) {
            // lname is incremented when we get to the AST_Label
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Scope) {
            var p = tw.parent(), a = [];
            node.variables.each(function(symbol){
                if (options.except.indexOf(symbol.name) < 0) {
                    a.push(symbol);
                }
            });
            if (options.sort) a.sort(function(a, b){
                return b.references.length - a.references.length;
            });
            to_mangle.push.apply(to_mangle, a);
            return;
        }
        if (node instanceof AST_Label) {
            var name;
            do name = base54(++lname); while (!is_identifier(name));
            node.mangled_name = name;
            return true;
        }
    });
    this.walk(tw);
    to_mangle.forEach(function(def){ def.mangle(options) });
});

AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options){
    options = this._default_mangler_options(options);
    var tw = new TreeWalker(function(node){
        if (node instanceof AST_Constant)
            base54.consider(node.print_to_string());
        else if (node instanceof AST_Return)
            base54.consider("return");
        else if (node instanceof AST_Throw)
            base54.consider("throw");
        else if (node instanceof AST_Continue)
            base54.consider("continue");
        else if (node instanceof AST_Break)
            base54.consider("break");
        else if (node instanceof AST_Debugger)
            base54.consider("debugger");
        else if (node instanceof AST_Directive)
            base54.consider(node.value);
        else if (node instanceof AST_While)
            base54.consider("while");
        else if (node instanceof AST_Do)
            base54.consider("do while");
        else if (node instanceof AST_If) {
            base54.consider("if");
            if (node.alternative) base54.consider("else");
        }
        else if (node instanceof AST_Var)
            base54.consider("var");
        else if (node instanceof AST_Const)
            base54.consider("const");
        else if (node instanceof AST_Lambda)
            base54.consider("function");
        else if (node instanceof AST_For)
            base54.consider("for");
        else if (node instanceof AST_ForIn)
            base54.consider("for in");
        else if (node instanceof AST_Switch)
            base54.consider("switch");
        else if (node instanceof AST_Case)
            base54.consider("case");
        else if (node instanceof AST_Default)
            base54.consider("default");
        else if (node instanceof AST_With)
            base54.consider("with");
        else if (node instanceof AST_ObjectSetter)
            base54.consider("set" + node.key);
        else if (node instanceof AST_ObjectGetter)
            base54.consider("get" + node.key);
        else if (node instanceof AST_ObjectKeyVal)
            base54.consider(node.key);
        else if (node instanceof AST_New)
            base54.consider("new");
        else if (node instanceof AST_This)
            base54.consider("this");
        else if (node instanceof AST_Try)
            base54.consider("try");
        else if (node instanceof AST_Catch)
            base54.consider("catch");
        else if (node instanceof AST_Finally)
            base54.consider("finally");
        else if (node instanceof AST_Symbol && node.unmangleable(options))
            base54.consider(node.name);
        else if (node instanceof AST_Unary || node instanceof AST_Binary)
            base54.consider(node.operator);
        else if (node instanceof AST_Dot)
            base54.consider(node.property);
    });
    this.walk(tw);
    base54.sort();
});

var base54 = (function() {
    var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
    var chars, frequency;
    function reset() {
        frequency = Object.create(null);
        chars = string.split("").map(function(ch){ return ch.charCodeAt(0) });
        chars.forEach(function(ch){ frequency[ch] = 0 });
    }
    base54.consider = function(str){
        for (var i = str.length; --i >= 0;) {
            var code = str.charCodeAt(i);
            if (code in frequency) ++frequency[code];
        }
    };
    base54.sort = function() {
        chars = mergeSort(chars, function(a, b){
            if (is_digit(a) && !is_digit(b)) return 1;
            if (is_digit(b) && !is_digit(a)) return -1;
            return frequency[b] - frequency[a];
        });
    };
    base54.reset = reset;
    reset();
    base54.get = function(){ return chars };
    base54.freq = function(){ return frequency };
    function base54(num) {
        var ret = "", base = 54;
        do {
            ret += String.fromCharCode(chars[num % base]);
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    };
    return base54;
})();

AST_Toplevel.DEFMETHOD("scope_warnings", function(options){
    options = defaults(options, {
        undeclared       : false, // this makes a lot of noise
        unreferenced     : true,
        assign_to_global : true,
        func_arguments   : true,
        nested_defuns    : true,
        eval             : true
    });
    var tw = new TreeWalker(function(node){
        if (options.undeclared
            && node instanceof AST_SymbolRef
            && node.undeclared())
        {
            // XXX: this also warns about JS standard names,
            // i.e. Object, Array, parseInt etc.  Should add a list of
            // exceptions.
            AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.assign_to_global)
        {
            var sym = null;
            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)
                sym = node.left;
            else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)
                sym = node.init;
            if (sym
                && (sym.undeclared()
                    || (sym.global() && sym.scope !== sym.definition().scope))) {
                AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                    msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                    name: sym.name,
                    file: sym.start.file,
                    line: sym.start.line,
                    col: sym.start.col
                });
            }
        }
        if (options.eval
            && node instanceof AST_SymbolRef
            && node.undeclared()
            && node.name == "eval") {
            AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
        }
        if (options.unreferenced
            && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label)
            && node.unreferenced()) {
            AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                type: node instanceof AST_Label ? "Label" : "Symbol",
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.func_arguments
            && node instanceof AST_Lambda
            && node.uses_arguments) {
            AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                name: node.name ? node.name.name : "anonymous",
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.nested_defuns
            && node instanceof AST_Defun
            && !(tw.parent() instanceof AST_Scope)) {
            AST_Node.warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                name: node.name.name,
                type: tw.parent().TYPE,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
    });
    this.walk(tw);
});

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function OutputStream(options) {

    options = defaults(options, {
        indent_start  : 0,
        indent_level  : 4,
        quote_keys    : false,
        space_colon   : true,
        ascii_only    : false,
        inline_script : false,
        width         : 80,
        max_line_len  : 32000,
        beautify      : false,
        source_map    : null,
        bracketize    : false,
        semicolons    : true,
        comments      : false,
        preserve_line : false,
        screw_ie8     : false,
    }, true);

    var indentation = 0;
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var OUTPUT = "";

    function to_ascii(str, identifier) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
                while (code.length < 2) code = "0" + code;
                return "\\x" + code;
            } else {
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
            }
        });
    };

    function make_string(str) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
            switch (s) {
              case "\\": return "\\\\";
              case "\b": return "\\b";
              case "\f": return "\\f";
              case "\n": return "\\n";
              case "\r": return "\\r";
              case "\u2028": return "\\u2028";
              case "\u2029": return "\\u2029";
              case '"': ++dq; return '"';
              case "'": ++sq; return "'";
              case "\0": return "\\x00";
            }
            return s;
        });
        if (options.ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
    };

    function encode_string(str) {
        var ret = make_string(str);
        if (options.inline_script)
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
        return ret;
    };

    function make_name(name) {
        name = name.toString();
        if (options.ascii_only)
            name = to_ascii(name, true);
        return name;
    };

    function make_indent(back) {
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
    };

    /* -----[ beautification/minification ]----- */

    var might_need_space = false;
    var might_need_semicolon = false;
    var last = null;

    function last_char() {
        return last.charAt(last.length - 1);
    };

    function maybe_newline() {
        if (options.max_line_len && current_col > options.max_line_len)
            print("\n");
    };

    var requireSemicolonChars = makePredicate("( [ + * / - , .");

    function print(str) {
        str = String(str);
        var ch = str.charAt(0);
        if (might_need_semicolon) {
            if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                if (options.semicolons || requireSemicolonChars(ch)) {
                    OUTPUT += ";";
                    current_col++;
                    current_pos++;
                } else {
                    OUTPUT += "\n";
                    current_pos++;
                    current_line++;
                    current_col = 0;
                }
                if (!options.beautify)
                    might_need_space = false;
            }
            might_need_semicolon = false;
            maybe_newline();
        }

        if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
            var target_line = stack[stack.length - 1].start.line;
            while (current_line < target_line) {
                OUTPUT += "\n";
                current_pos++;
                current_line++;
                current_col = 0;
                might_need_space = false;
            }
        }

        if (might_need_space) {
            var prev = last_char();
            if ((is_identifier_char(prev)
                 && (is_identifier_char(ch) || ch == "\\"))
                || (/^[\+\-\/]$/.test(ch) && ch == prev))
            {
                OUTPUT += " ";
                current_col++;
                current_pos++;
            }
            might_need_space = false;
        }
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        if (n == 0) {
            current_col += a[n].length;
        } else {
            current_col = a[n].length;
        }
        current_pos += str.length;
        last = str;
        OUTPUT += str;
    };

    var space = options.beautify ? function() {
        print(" ");
    } : function() {
        might_need_space = true;
    };

    var indent = options.beautify ? function(half) {
        if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
        }
    } : noop;

    var with_indent = options.beautify ? function(col, cont) {
        if (col === true) col = next_indent();
        var save_indentation = indentation;
        indentation = col;
        var ret = cont();
        indentation = save_indentation;
        return ret;
    } : function(col, cont) { return cont() };

    var newline = options.beautify ? function() {
        print("\n");
    } : noop;

    var semicolon = options.beautify ? function() {
        print(";");
    } : function() {
        might_need_semicolon = true;
    };

    function force_semicolon() {
        might_need_semicolon = false;
        print(";");
    };

    function next_indent() {
        return indentation + options.indent_level;
    };

    function with_block(cont) {
        var ret;
        print("{");
        newline();
        with_indent(next_indent(), function(){
            ret = cont();
        });
        indent();
        print("}");
        return ret;
    };

    function with_parens(cont) {
        print("(");
        //XXX: still nice to have that for argument lists
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print(")");
        return ret;
    };

    function with_square(cont) {
        print("[");
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print("]");
        return ret;
    };

    function comma() {
        print(",");
        space();
    };

    function colon() {
        print(":");
        if (options.space_colon) space();
    };

    var add_mapping = options.source_map ? function(token, name) {
        try {
            if (token) options.source_map.add(
                token.file || "?",
                current_line, current_col,
                token.line, token.col,
                (!name && token.type == "name") ? token.value : name
            );
        } catch(ex) {
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                file: token.file,
                line: token.line,
                col: token.col,
                cline: current_line,
                ccol: current_col,
                name: name || ""
            })
        }
    } : noop;

    function get() {
        return OUTPUT;
    };

    var stack = [];
    return {
        get             : get,
        toString        : get,
        indent          : indent,
        indentation     : function() { return indentation },
        current_width   : function() { return current_col - indentation },
        should_break    : function() { return options.width && this.current_width() >= options.width },
        newline         : newline,
        print           : print,
        space           : space,
        comma           : comma,
        colon           : colon,
        last            : function() { return last },
        semicolon       : semicolon,
        force_semicolon : force_semicolon,
        to_ascii        : to_ascii,
        print_name      : function(name) { print(make_name(name)) },
        print_string    : function(str) { print(encode_string(str)) },
        next_indent     : next_indent,
        with_indent     : with_indent,
        with_block      : with_block,
        with_parens     : with_parens,
        with_square     : with_square,
        add_mapping     : add_mapping,
        option          : function(opt) { return options[opt] },
        line            : function() { return current_line },
        col             : function() { return current_col },
        pos             : function() { return current_pos },
        push_node       : function(node) { stack.push(node) },
        pop_node        : function() { return stack.pop() },
        stack           : function() { return stack },
        parent          : function(n) {
            return stack[stack.length - 2 - (n || 0)];
        }
    };

};

/* -----[ code generators ]----- */

(function(){

    /* -----[ utils ]----- */

    function DEFPRINT(nodetype, generator) {
        nodetype.DEFMETHOD("_codegen", generator);
    };

    AST_Node.DEFMETHOD("print", function(stream, force_parens){
        var self = this, generator = self._codegen;
        function doit() {
            self.add_comments(stream);
            self.add_source_map(stream);
            generator(self, stream);
        }
        stream.push_node(self);
        if (force_parens || self.needs_parens(stream)) {
            stream.with_parens(doit);
        } else {
            doit();
        }
        stream.pop_node();
    });

    AST_Node.DEFMETHOD("print_to_string", function(options){
        var s = OutputStream(options);
        this.print(s);
        return s.get();
    });

    /* -----[ comments ]----- */

    AST_Node.DEFMETHOD("add_comments", function(output){
        var c = output.option("comments"), self = this;
        if (c) {
            var start = self.start;
            if (start && !start._comments_dumped) {
                start._comments_dumped = true;
                var comments = start.comments_before;

                // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                //      if this node is `return` or `throw`, we cannot allow comments before
                //      the returned or thrown value.
                if (self instanceof AST_Exit &&
                    self.value && self.value.start.comments_before.length > 0) {
                    comments = (comments || []).concat(self.value.start.comments_before);
                    self.value.start.comments_before = [];
                }

                if (c.test) {
                    comments = comments.filter(function(comment){
                        return c.test(comment.value);
                    });
                } else if (typeof c == "function") {
                    comments = comments.filter(function(comment){
                        return c(self, comment);
                    });
                }
                comments.forEach(function(c){
                    if (c.type == "comment1") {
                        output.print("//" + c.value + "\n");
                        output.indent();
                    }
                    else if (c.type == "comment2") {
                        output.print("/*" + c.value + "*/");
                        if (start.nlb) {
                            output.print("\n");
                            output.indent();
                        } else {
                            output.space();
                        }
                    }
                });
            }
        }
    });

    /* -----[ PARENTHESES ]----- */

    function PARENS(nodetype, func) {
        nodetype.DEFMETHOD("needs_parens", func);
    };

    PARENS(AST_Node, function(){
        return false;
    });

    // a function expression needs parens around it when it's provably
    // the first token to appear in a statement.
    PARENS(AST_Function, function(output){
        return first_in_statement(output);
    });

    // same goes for an object literal, because otherwise it would be
    // interpreted as a block of code.
    PARENS(AST_Object, function(output){
        return first_in_statement(output);
    });

    PARENS(AST_Unary, function(output){
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this;
    });

    PARENS(AST_Seq, function(output){
        var p = output.parent();
        return p instanceof AST_Call             // (foo, bar)() or foo(1, (2, 3), 4)
            || p instanceof AST_Unary            // !(foo, bar, baz)
            || p instanceof AST_Binary           // 1 + (2, 3) + 4 ==> 8
            || p instanceof AST_VarDef           // var a = (1, 2), b = a + a; ==> b == 4
            || p instanceof AST_Dot              // (1, {foo:2}).foo ==> 2
            || p instanceof AST_Array            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
            || p instanceof AST_ObjectProperty   // { foo: (1, 2) }.foo ==> 2
            || p instanceof AST_Conditional      /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                  * ==> 20 (side effect, set a := 10 and b := 20) */
        ;
    });

    PARENS(AST_Binary, function(output){
        var p = output.parent();
        // (foo && bar)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // typeof (foo && bar)
        if (p instanceof AST_Unary)
            return true;
        // (foo && bar)["prop"], (foo && bar).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // this deals with precedence: 3 * (2 + 1)
        if (p instanceof AST_Binary) {
            var po = p.operator, pp = PRECEDENCE[po];
            var so = this.operator, sp = PRECEDENCE[so];
            if (pp > sp
                || (pp == sp
                    && this === p.right
                    && !(so == po &&
                         (so == "*" ||
                          so == "&&" ||
                          so == "||")))) {
                return true;
            }
        }
    });

    PARENS(AST_PropAccess, function(output){
        var p = output.parent();
        if (p instanceof AST_New && p.expression === this) {
            // i.e. new (foo.bar().baz)
            //
            // if there's one call into this subtree, then we need
            // parens around it too, otherwise the call will be
            // interpreted as passing the arguments to the upper New
            // expression.
            try {
                this.walk(new TreeWalker(function(node){
                    if (node instanceof AST_Call) throw p;
                }));
            } catch(ex) {
                if (ex !== p) throw ex;
                return true;
            }
        }
    });

    PARENS(AST_Call, function(output){
        var p = output.parent();
        return p instanceof AST_New && p.expression === this;
    });

    PARENS(AST_New, function(output){
        var p = output.parent();
        if (no_constructor_parens(this, output)
            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
            return true;
    });

    PARENS(AST_Number, function(output){
        var p = output.parent();
        if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    PARENS(AST_NaN, function(output){
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    function assign_and_conditional_paren_rules(output) {
        var p = output.parent();
        // !(a = false) → true
        if (p instanceof AST_Unary)
            return true;
        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
        // (a = func)() —or— new (a = Object)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (a = foo) ? bar : baz
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // (a = foo)["prop"] —or— (a = foo).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    };

    PARENS(AST_Assign, assign_and_conditional_paren_rules);
    PARENS(AST_Conditional, assign_and_conditional_paren_rules);

    /* -----[ PRINTERS ]----- */

    DEFPRINT(AST_Directive, function(self, output){
        output.print_string(self.value);
        output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(self, output){
        output.print("debugger");
        output.semicolon();
    });

    /* -----[ statements ]----- */

    function display_body(body, is_toplevel, output) {
        var last = body.length - 1;
        body.forEach(function(stmt, i){
            if (!(stmt instanceof AST_EmptyStatement)) {
                output.indent();
                stmt.print(output);
                if (!(i == last && is_toplevel)) {
                    output.newline();
                    if (is_toplevel) output.newline();
                }
            }
        });
    };

    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output){
        force_statement(this.body, output);
    });

    DEFPRINT(AST_Statement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    DEFPRINT(AST_Toplevel, function(self, output){
        display_body(self.body, true, output);
        output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(self, output){
        self.label.print(output);
        output.colon();
        self.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    function print_bracketed(body, output) {
        if (body.length > 0) output.with_block(function(){
            display_body(body, false, output);
        });
        else output.print("{}");
    };
    DEFPRINT(AST_BlockStatement, function(self, output){
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_EmptyStatement, function(self, output){
        output.semicolon();
    });
    DEFPRINT(AST_Do, function(self, output){
        output.print("do");
        output.space();
        self._do_print_body(output);
        output.space();
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.semicolon();
    });
    DEFPRINT(AST_While, function(self, output){
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_For, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            if (self.init) {
                if (self.init instanceof AST_Definitions) {
                    self.init.print(output);
                } else {
                    parenthesize_for_noin(self.init, output, true);
                }
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.condition) {
                self.condition.print(output);
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.step) {
                self.step.print(output);
            }
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_ForIn, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            self.init.print(output);
            output.space();
            output.print("in");
            output.space();
            self.object.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_With, function(self, output){
        output.print("with");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        self._do_print_body(output);
    });

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword){
        var self = this;
        if (!nokeyword) {
            output.print("function");
        }
        if (self.name) {
            output.space();
            self.name.print(output);
        }
        output.with_parens(function(){
            self.argnames.forEach(function(arg, i){
                if (i) output.comma();
                arg.print(output);
            });
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Lambda, function(self, output){
        self._do_print(output);
    });

    /* -----[ exits ]----- */
    AST_Exit.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.value) {
            output.space();
            this.value.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Return, function(self, output){
        self._do_print(output, "return");
    });
    DEFPRINT(AST_Throw, function(self, output){
        self._do_print(output, "throw");
    });

    /* -----[ loop control ]----- */
    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.label) {
            output.space();
            this.label.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Break, function(self, output){
        self._do_print(output, "break");
    });
    DEFPRINT(AST_Continue, function(self, output){
        self._do_print(output, "continue");
    });

    /* -----[ if ]----- */
    function make_then(self, output) {
        if (output.option("bracketize")) {
            make_block(self.body, output);
            return;
        }
        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        if (!self.body)
            return output.force_semicolon();
        if (self.body instanceof AST_Do
            && !output.option("screw_ie8")) {
            // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
            // croaks with "syntax error" on code like this: if (foo)
            // do ... while(cond); else ...  we need block brackets
            // around do/while
            make_block(self.body, output);
            return;
        }
        var b = self.body;
        while (true) {
            if (b instanceof AST_If) {
                if (!b.alternative) {
                    make_block(self.body, output);
                    return;
                }
                b = b.alternative;
            }
            else if (b instanceof AST_StatementWithBody) {
                b = b.body;
            }
            else break;
        }
        force_statement(self.body, output);
    };
    DEFPRINT(AST_If, function(self, output){
        output.print("if");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        if (self.alternative) {
            make_then(self, output);
            output.space();
            output.print("else");
            output.space();
            force_statement(self.alternative, output);
        } else {
            self._do_print_body(output);
        }
    });

    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output){
        output.print("switch");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        if (self.body.length > 0) output.with_block(function(){
            self.body.forEach(function(stmt, i){
                if (i) output.newline();
                output.indent(true);
                stmt.print(output);
            });
        });
        else output.print("{}");
    });
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output){
        if (this.body.length > 0) {
            output.newline();
            this.body.forEach(function(stmt){
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
    });
    DEFPRINT(AST_Default, function(self, output){
        output.print("default:");
        self._do_print_body(output);
    });
    DEFPRINT(AST_Case, function(self, output){
        output.print("case");
        output.space();
        self.expression.print(output);
        output.print(":");
        self._do_print_body(output);
    });

    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output){
        output.print("try");
        output.space();
        print_bracketed(self.body, output);
        if (self.bcatch) {
            output.space();
            self.bcatch.print(output);
        }
        if (self.bfinally) {
            output.space();
            self.bfinally.print(output);
        }
    });
    DEFPRINT(AST_Catch, function(self, output){
        output.print("catch");
        output.space();
        output.with_parens(function(){
            self.argname.print(output);
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Finally, function(self, output){
        output.print("finally");
        output.space();
        print_bracketed(self.body, output);
    });

    /* -----[ var/const ]----- */
    AST_Definitions.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        output.space();
        this.definitions.forEach(function(def, i){
            if (i) output.comma();
            def.print(output);
        });
        var p = output.parent();
        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
        var avoid_semicolon = in_for && p.init === this;
        if (!avoid_semicolon)
            output.semicolon();
    });
    DEFPRINT(AST_Var, function(self, output){
        self._do_print(output, "var");
    });
    DEFPRINT(AST_Const, function(self, output){
        self._do_print(output, "const");
    });

    function parenthesize_for_noin(node, output, noin) {
        if (!noin) node.print(output);
        else try {
            // need to take some precautions here:
            //    https://github.com/mishoo/UglifyJS2/issues/60
            node.walk(new TreeWalker(function(node){
                if (node instanceof AST_Binary && node.operator == "in")
                    throw output;
            }));
            node.print(output);
        } catch(ex) {
            if (ex !== output) throw ex;
            node.print(output, true);
        }
    };

    DEFPRINT(AST_VarDef, function(self, output){
        self.name.print(output);
        if (self.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self.value, output, noin);
        }
    });

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output){
        self.expression.print(output);
        if (self instanceof AST_New && no_constructor_parens(self, output))
            return;
        output.with_parens(function(){
            self.args.forEach(function(expr, i){
                if (i) output.comma();
                expr.print(output);
            });
        });
    });
    DEFPRINT(AST_New, function(self, output){
        output.print("new");
        output.space();
        AST_Call.prototype._codegen(self, output);
    });

    AST_Seq.DEFMETHOD("_do_print", function(output){
        this.car.print(output);
        if (this.cdr) {
            output.comma();
            if (output.should_break()) {
                output.newline();
                output.indent();
            }
            this.cdr.print(output);
        }
    });
    DEFPRINT(AST_Seq, function(self, output){
        self._do_print(output);
        // var p = output.parent();
        // if (p instanceof AST_Statement) {
        //     output.with_indent(output.next_indent(), function(){
        //         self._do_print(output);
        //     });
        // } else {
        //     self._do_print(output);
        // }
    });
    DEFPRINT(AST_Dot, function(self, output){
        var expr = self.expression;
        expr.print(output);
        if (expr instanceof AST_Number && expr.getValue() >= 0) {
            if (!/[xa-f.]/i.test(output.last())) {
                output.print(".");
            }
        }
        output.print(".");
        // the name after dot would be mapped about here.
        output.add_mapping(self.end);
        output.print_name(self.property);
    });
    DEFPRINT(AST_Sub, function(self, output){
        self.expression.print(output);
        output.print("[");
        self.property.print(output);
        output.print("]");
    });
    DEFPRINT(AST_UnaryPrefix, function(self, output){
        var op = self.operator;
        output.print(op);
        if (/^[a-z]/i.test(op))
            output.space();
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(self, output){
        self.expression.print(output);
        output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(self, output){
        self.left.print(output);
        output.space();
        output.print(self.operator);
        output.space();
        self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(self, output){
        self.condition.print(output);
        output.space();
        output.print("?");
        output.space();
        self.consequent.print(output);
        output.space();
        output.colon();
        self.alternative.print(output);
    });

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output){
        output.with_square(function(){
            var a = self.elements, len = a.length;
            if (len > 0) output.space();
            a.forEach(function(exp, i){
                if (i) output.comma();
                exp.print(output);
                // If the final element is a hole, we need to make sure it
                // doesn't look like a trailing comma, by inserting an actual
                // trailing comma.
                if (i === len - 1 && exp instanceof AST_Hole)
                  output.comma();
            });
            if (len > 0) output.space();
        });
    });
    DEFPRINT(AST_Object, function(self, output){
        if (self.properties.length > 0) output.with_block(function(){
            self.properties.forEach(function(prop, i){
                if (i) {
                    output.print(",");
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else output.print("{}");
    });
    DEFPRINT(AST_ObjectKeyVal, function(self, output){
        var key = self.key;
        if (output.option("quote_keys")) {
            output.print_string(key + "");
        } else if ((typeof key == "number"
                    || !output.option("beautify")
                    && +key + "" == key)
                   && parseFloat(key) >= 0) {
            output.print(make_num(key));
        } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
            output.print_name(key);
        } else {
            output.print_string(key);
        }
        output.colon();
        self.value.print(output);
    });
    DEFPRINT(AST_ObjectSetter, function(self, output){
        output.print("set");
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_ObjectGetter, function(self, output){
        output.print("get");
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_Symbol, function(self, output){
        var def = self.definition();
        output.print_name(def ? def.mangled_name || def.name : self.name);
    });
    DEFPRINT(AST_Undefined, function(self, output){
        output.print("void 0");
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Infinity, function(self, output){
        output.print("1/0");
    });
    DEFPRINT(AST_NaN, function(self, output){
        output.print("0/0");
    });
    DEFPRINT(AST_This, function(self, output){
        output.print("this");
    });
    DEFPRINT(AST_Constant, function(self, output){
        output.print(self.getValue());
    });
    DEFPRINT(AST_String, function(self, output){
        output.print_string(self.getValue());
    });
    DEFPRINT(AST_Number, function(self, output){
        output.print(make_num(self.getValue()));
    });
    DEFPRINT(AST_RegExp, function(self, output){
        var str = self.getValue().toString();
        if (output.option("ascii_only"))
            str = output.to_ascii(str);
        output.print(str);
        var p = output.parent();
        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)
            output.print(" ");
    });

    function force_statement(stat, output) {
        if (output.option("bracketize")) {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.print("{}");
            else if (stat instanceof AST_BlockStatement)
                stat.print(output);
            else output.with_block(function(){
                output.indent();
                stat.print(output);
                output.newline();
            });
        } else {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.force_semicolon();
            else
                stat.print(output);
        }
    };

    // return true if the node at the top of the stack (that means the
    // innermost node in the current output) is lexically the first in
    // a statement.
    function first_in_statement(output) {
        var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
        while (i > 0) {
            if (p instanceof AST_Statement && p.body === node)
                return true;
            if ((p instanceof AST_Seq           && p.car === node        ) ||
                (p instanceof AST_Call          && p.expression === node && !(p instanceof AST_New) ) ||
                (p instanceof AST_Dot           && p.expression === node ) ||
                (p instanceof AST_Sub           && p.expression === node ) ||
                (p instanceof AST_Conditional   && p.condition === node  ) ||
                (p instanceof AST_Binary        && p.left === node       ) ||
                (p instanceof AST_UnaryPostfix  && p.expression === node ))
            {
                node = p;
                p = a[--i];
            } else {
                return false;
            }
        }
    };

    // self should be AST_New.  decide if we want to show parens or not.
    function no_constructor_parens(self, output) {
        return self.args.length == 0 && !output.option("beautify");
    };

    function best_of(a) {
        var best = a[0], len = best.length;
        for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
                best = a[i];
                len = best.length;
            }
        }
        return best;
    };

    function make_num(num) {
        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
        if (Math.floor(num) === num) {
            if (num >= 0) {
                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                       "0" + num.toString(8)); // same.
            } else {
                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                       "-0" + (-num).toString(8)); // same.
            }
            if ((m = /^(.*?)(0+)$/.exec(num))) {
                a.push(m[1] + "e" + m[2].length);
            }
        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
            a.push(m[2] + "e-" + (m[1].length + m[2].length),
                   str.substr(str.indexOf(".")));
        }
        return best_of(a);
    };

    function make_block(stmt, output) {
        if (stmt instanceof AST_BlockStatement) {
            stmt.print(output);
            return;
        }
        output.with_block(function(){
            output.indent();
            stmt.print(output);
            output.newline();
        });
    };

    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) {
        nodetype.DEFMETHOD("add_source_map", function(stream){
            generator(this, stream);
        });
    };

    // We could easily add info for ALL nodes, but it seems to me that
    // would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop);

    function basic_sourcemap_gen(self, output) {
        output.add_mapping(self.start);
    };

    // XXX: I'm not exactly sure if we need it for all of these nodes,
    // or if we should add even more.

    DEFMAP(AST_Directive, basic_sourcemap_gen);
    DEFMAP(AST_Debugger, basic_sourcemap_gen);
    DEFMAP(AST_Symbol, basic_sourcemap_gen);
    DEFMAP(AST_Jump, basic_sourcemap_gen);
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
    DEFMAP(AST_LabeledStatement, noop); // since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen);
    DEFMAP(AST_Switch, basic_sourcemap_gen);
    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
    DEFMAP(AST_Toplevel, noop);
    DEFMAP(AST_New, basic_sourcemap_gen);
    DEFMAP(AST_Try, basic_sourcemap_gen);
    DEFMAP(AST_Catch, basic_sourcemap_gen);
    DEFMAP(AST_Finally, basic_sourcemap_gen);
    DEFMAP(AST_Definitions, basic_sourcemap_gen);
    DEFMAP(AST_Constant, basic_sourcemap_gen);
    DEFMAP(AST_ObjectProperty, function(self, output){
        output.add_mapping(self.start, self.key);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function Compressor(options, false_by_default) {
    if (!(this instanceof Compressor))
        return new Compressor(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
        sequences     : !false_by_default,
        properties    : !false_by_default,
        dead_code     : !false_by_default,
        drop_debugger : !false_by_default,
        unsafe        : false,
        unsafe_comps  : false,
        conditionals  : !false_by_default,
        comparisons   : !false_by_default,
        evaluate      : !false_by_default,
        booleans      : !false_by_default,
        loops         : !false_by_default,
        unused        : !false_by_default,
        hoist_funs    : !false_by_default,
        hoist_vars    : false,
        if_return     : !false_by_default,
        join_vars     : !false_by_default,
        cascade       : !false_by_default,
        side_effects  : !false_by_default,
        negate_iife   : !false_by_default,
        screw_ie8     : false,

        warnings      : true,
        global_defs   : {}
    }, true);
};

Compressor.prototype = new TreeTransformer;
merge(Compressor.prototype, {
    option: function(key) { return this.options[key] },
    warn: function() {
        if (this.options.warnings)
            AST_Node.warn.apply(AST_Node, arguments);
    },
    before: function(node, descend, in_list) {
        if (node._squeezed) return node;
        if (node instanceof AST_Scope) {
            node.drop_unused(this);
            node = node.hoist_declarations(this);
        }
        descend(node, this);
        node = node.optimize(this);
        if (node instanceof AST_Scope) {
            // dead code removal might leave further unused declarations.
            // this'll usually save very few bytes, but the performance
            // hit seems negligible so I'll just drop it here.

            // no point to repeat warnings.
            var save_warnings = this.options.warnings;
            this.options.warnings = false;
            node.drop_unused(this);
            this.options.warnings = save_warnings;
        }
        node._squeezed = true;
        return node;
    }
});

(function(){

    function OPT(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor){
            var self = this;
            if (self._optimized) return self;
            var opt = optimizer(self, compressor);
            opt._optimized = true;
            if (opt === self) return opt;
            return opt.transform(compressor);
        });
    };

    OPT(AST_Node, function(self, compressor){
        return self;
    });

    AST_Node.DEFMETHOD("equivalent_to", function(node){
        // XXX: this is a rather expensive way to test two node's equivalence:
        return this.print_to_string() == node.print_to_string();
    });

    function make_node(ctor, orig, props) {
        if (!props) props = {};
        if (orig) {
            if (!props.start) props.start = orig.start;
            if (!props.end) props.end = orig.end;
        }
        return new ctor(props);
    };

    function make_node_from_constant(compressor, val, orig) {
        // XXX: WIP.
        // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
        //     if (node instanceof AST_SymbolRef) {
        //         var scope = compressor.find_parent(AST_Scope);
        //         var def = scope.find_variable(node);
        //         node.thedef = def;
        //         return node;
        //     }
        // })).transform(compressor);

        if (val instanceof AST_Node) return val.transform(compressor);
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
                value: val
            }).optimize(compressor);
          case "number":
            return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                value: val
            }).optimize(compressor);
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
          case "undefined":
            return make_node(AST_Undefined, orig).optimize(compressor);
          default:
            if (val === null) {
                return make_node(AST_Null, orig).optimize(compressor);
            }
            if (val instanceof RegExp) {
                return make_node(AST_RegExp, orig).optimize(compressor);
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
                type: typeof val
            }));
        }
    };

    function as_statement_array(thing) {
        if (thing === null) return [];
        if (thing instanceof AST_BlockStatement) return thing.body;
        if (thing instanceof AST_EmptyStatement) return [];
        if (thing instanceof AST_Statement) return [ thing ];
        throw new Error("Can't convert thing to statement array");
    };

    function is_empty(thing) {
        if (thing === null) return true;
        if (thing instanceof AST_EmptyStatement) return true;
        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
        return false;
    };

    function loop_body(x) {
        if (x instanceof AST_Switch) return x;
        if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
            return (x.body instanceof AST_BlockStatement ? x.body : x);
        }
        return x;
    };

    function tighten_body(statements, compressor) {
        var CHANGED;
        do {
            CHANGED = false;
            statements = eliminate_spurious_blocks(statements);
            if (compressor.option("dead_code")) {
                statements = eliminate_dead_code(statements, compressor);
            }
            if (compressor.option("if_return")) {
                statements = handle_if_return(statements, compressor);
            }
            if (compressor.option("sequences")) {
                statements = sequencesize(statements, compressor);
            }
            if (compressor.option("join_vars")) {
                statements = join_consecutive_vars(statements, compressor);
            }
        } while (CHANGED);

        if (compressor.option("negate_iife")) {
            negate_iifes(statements, compressor);
        }

        return statements;

        function eliminate_spurious_blocks(statements) {
            var seen_dirs = [];
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_BlockStatement) {
                    CHANGED = true;
                    a.push.apply(a, eliminate_spurious_blocks(stat.body));
                } else if (stat instanceof AST_EmptyStatement) {
                    CHANGED = true;
                } else if (stat instanceof AST_Directive) {
                    if (seen_dirs.indexOf(stat.value) < 0) {
                        a.push(stat);
                        seen_dirs.push(stat.value);
                    } else {
                        CHANGED = true;
                    }
                } else {
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function handle_if_return(statements, compressor) {
            var self = compressor.self();
            var in_lambda = self instanceof AST_Lambda;
            var ret = [];
            loop: for (var i = statements.length; --i >= 0;) {
                var stat = statements[i];
                switch (true) {
                  case (in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0):
                    CHANGED = true;
                    // note, ret.length is probably always zero
                    // because we drop unreachable code before this
                    // step.  nevertheless, it's good to check.
                    continue loop;
                  case stat instanceof AST_If:
                    if (stat.body instanceof AST_Return) {
                        //---
                        // pretty silly case, but:
                        // if (foo()) return; return; ==> foo(); return;
                        if (((in_lambda && ret.length == 0)
                             || (ret[0] instanceof AST_Return && !ret[0].value))
                            && !stat.body.value && !stat.alternative) {
                            CHANGED = true;
                            var cond = make_node(AST_SimpleStatement, stat.condition, {
                                body: stat.condition
                            });
                            ret.unshift(cond);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; return y; ==> return foo() ? x : y;
                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0];
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                        if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                value: make_node(AST_Undefined, stat)
                            });
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                        if (!stat.body.value && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.condition = stat.condition.negate(compressor);
                            stat.body = make_node(AST_BlockStatement, stat, {
                                body: as_statement_array(stat.alternative).concat(ret)
                            });
                            stat.alternative = null;
                            ret = [ stat.transform(compressor) ];
                            continue loop;
                        }
                        //---
                        if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement
                            && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                            CHANGED = true;
                            ret.push(make_node(AST_Return, ret[0], {
                                value: make_node(AST_Undefined, ret[0])
                            }).transform(compressor));
                            ret = as_statement_array(stat.alternative).concat(ret);
                            ret.unshift(stat);
                            continue loop;
                        }
                    }

                    var ab = aborts(stat.body);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab.label);
                        }
                        CHANGED = true;
                        var body = as_statement_array(stat.body).slice(0, -1);
                        stat = stat.clone();
                        stat.condition = stat.condition.negate(compressor);
                        stat.body = make_node(AST_BlockStatement, stat, {
                            body: ret
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat, {
                            body: body
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    var ab = aborts(stat.alternative);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab.label);
                        }
                        CHANGED = true;
                        stat = stat.clone();
                        stat.body = make_node(AST_BlockStatement, stat.body, {
                            body: as_statement_array(stat.body).concat(ret)
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                            body: as_statement_array(stat.alternative).slice(0, -1)
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    ret.unshift(stat);
                    break;
                  default:
                    ret.unshift(stat);
                    break;
                }
            }
            return ret;
        };

        function eliminate_dead_code(statements, compressor) {
            var has_quit = false;
            var orig = statements.length;
            var self = compressor.self();
            statements = statements.reduce(function(a, stat){
                if (has_quit) {
                    extract_declarations_from_unreachable_code(compressor, stat, a);
                } else {
                    if (stat instanceof AST_LoopControl) {
                        var lct = compressor.loopcontrol_target(stat.label);
                        if ((stat instanceof AST_Break
                             && lct instanceof AST_BlockStatement
                             && loop_body(lct) === self) || (stat instanceof AST_Continue
                                                             && loop_body(lct) === self)) {
                            if (stat.label) {
                                remove(stat.label.thedef.references, stat.label);
                            }
                        } else {
                            a.push(stat);
                        }
                    } else {
                        a.push(stat);
                    }
                    if (aborts(stat)) has_quit = true;
                }
                return a;
            }, []);
            CHANGED = statements.length != orig;
            return statements;
        };

        function sequencesize(statements, compressor) {
            if (statements.length < 2) return statements;
            var seq = [], ret = [];
            function push_seq() {
                seq = AST_Seq.from_array(seq);
                if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                    body: seq
                }));
                seq = [];
            };
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) seq.push(stat.body);
                else push_seq(), ret.push(stat);
            });
            push_seq();
            ret = sequencesize_2(ret, compressor);
            CHANGED = ret.length != statements.length;
            return ret;
        };

        function sequencesize_2(statements, compressor) {
            function cons_seq(right) {
                ret.pop();
                var left = prev.body;
                if (left instanceof AST_Seq) {
                    left.add(right);
                } else {
                    left = AST_Seq.cons(left, right);
                }
                return left.transform(compressor);
            };
            var ret = [], prev = null;
            statements.forEach(function(stat){
                if (prev) {
                    if (stat instanceof AST_For) {
                        var opera = {};
                        try {
                            prev.body.walk(new TreeWalker(function(node){
                                if (node instanceof AST_Binary && node.operator == "in")
                                    throw opera;
                            }));
                            if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                stat.init = cons_seq(stat.init);
                            }
                            else if (!stat.init) {
                                stat.init = prev.body;
                                ret.pop();
                            }
                        } catch(ex) {
                            if (ex !== opera) throw ex;
                        }
                    }
                    else if (stat instanceof AST_If) {
                        stat.condition = cons_seq(stat.condition);
                    }
                    else if (stat instanceof AST_With) {
                        stat.expression = cons_seq(stat.expression);
                    }
                    else if (stat instanceof AST_Exit && stat.value) {
                        stat.value = cons_seq(stat.value);
                    }
                    else if (stat instanceof AST_Exit) {
                        stat.value = cons_seq(make_node(AST_Undefined, stat));
                    }
                    else if (stat instanceof AST_Switch) {
                        stat.expression = cons_seq(stat.expression);
                    }
                }
                ret.push(stat);
                prev = stat instanceof AST_SimpleStatement ? stat : null;
            });
            return ret;
        };

        function join_consecutive_vars(statements, compressor) {
            var prev = null;
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                    prev.definitions = prev.definitions.concat(stat.definitions);
                    CHANGED = true;
                }
                else if (stat instanceof AST_For
                         && prev instanceof AST_Definitions
                         && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                    CHANGED = true;
                    a.pop();
                    if (stat.init) {
                        stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                    } else {
                        stat.init = prev;
                    }
                    a.push(stat);
                    prev = stat;
                }
                else {
                    prev = stat;
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function negate_iifes(statements, compressor) {
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) {
                    stat.body = (function transform(thing) {
                        return thing.transform(new TreeTransformer(function(node){
                            if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                return make_node(AST_UnaryPrefix, node, {
                                    operator: "!",
                                    expression: node
                                });
                            }
                            else if (node instanceof AST_Call) {
                                node.expression = transform(node.expression);
                            }
                            else if (node instanceof AST_Seq) {
                                node.car = transform(node.car);
                            }
                            else if (node instanceof AST_Conditional) {
                                var expr = transform(node.condition);
                                if (expr !== node.condition) {
                                    // it has been negated, reverse
                                    node.condition = expr;
                                    var tmp = node.consequent;
                                    node.consequent = node.alternative;
                                    node.alternative = tmp;
                                }
                            }
                            return node;
                        }));
                    })(stat.body);
                }
            });
        };

    };

    function extract_declarations_from_unreachable_code(compressor, stat, target) {
        compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
        stat.walk(new TreeWalker(function(node){
            if (node instanceof AST_Definitions) {
                compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                node.remove_initializers();
                target.push(node);
                return true;
            }
            if (node instanceof AST_Defun) {
                target.push(node);
                return true;
            }
            if (node instanceof AST_Scope) {
                return true;
            }
        }));
    };

    /* -----[ boolean/negation helpers ]----- */

    // methods to determine whether an expression has a boolean result type
    (function (def){
        var unary_bool = [ "!", "delete" ];
        var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
        def(AST_Node, function(){ return false });
        def(AST_UnaryPrefix, function(){
            return member(this.operator, unary_bool);
        });
        def(AST_Binary, function(){
            return member(this.operator, binary_bool) ||
                ( (this.operator == "&&" || this.operator == "||") &&
                  this.left.is_boolean() && this.right.is_boolean() );
        });
        def(AST_Conditional, function(){
            return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def(AST_Assign, function(){
            return this.operator == "=" && this.right.is_boolean();
        });
        def(AST_Seq, function(){
            return this.cdr.is_boolean();
        });
        def(AST_True, function(){ return true });
        def(AST_False, function(){ return true });
    })(function(node, func){
        node.DEFMETHOD("is_boolean", func);
    });

    // methods to determine if an expression has a string result type
    (function (def){
        def(AST_Node, function(){ return false });
        def(AST_String, function(){ return true });
        def(AST_UnaryPrefix, function(){
            return this.operator == "typeof";
        });
        def(AST_Binary, function(compressor){
            return this.operator == "+" &&
                (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def(AST_Assign, function(compressor){
            return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def(AST_Seq, function(compressor){
            return this.cdr.is_string(compressor);
        });
        def(AST_Conditional, function(compressor){
            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
        def(AST_Call, function(compressor){
            return compressor.option("unsafe")
                && this.expression instanceof AST_SymbolRef
                && this.expression.name == "String"
                && this.expression.undeclared();
        });
    })(function(node, func){
        node.DEFMETHOD("is_string", func);
    });

    function best_of(ast1, ast2) {
        return ast1.print_to_string().length >
            ast2.print_to_string().length
            ? ast2 : ast1;
    };

    // methods to evaluate a constant expression
    (function (def){
        // The evaluate method returns an array with one or two
        // elements.  If the node has been successfully reduced to a
        // constant, then the second element tells us the value;
        // otherwise the second element is missing.  The first element
        // of the array is always an AST_Node descendant; when
        // evaluation was successful it's a node that represents the
        // constant; otherwise it's the original node.
        AST_Node.DEFMETHOD("evaluate", function(compressor){
            if (!compressor.option("evaluate")) return [ this ];
            try {
                var val = this._eval(), ast = make_node_from_constant(compressor, val, this);
                return [ best_of(ast, this), val ];
            } catch(ex) {
                if (ex !== def) throw ex;
                return [ this ];
            }
        });
        def(AST_Statement, function(){
            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
        });
        def(AST_Function, function(){
            // XXX: AST_Function inherits from AST_Scope, which itself
            // inherits from AST_Statement; however, an AST_Function
            // isn't really a statement.  This could byte in other
            // places too. :-( Wish JS had multiple inheritance.
            throw def;
        });
        function ev(node) {
            return node._eval();
        };
        def(AST_Node, function(){
            throw def;          // not constant
        });
        def(AST_Constant, function(){
            return this.getValue();
        });
        def(AST_UnaryPrefix, function(){
            var e = this.expression;
            switch (this.operator) {
              case "!": return !ev(e);
              case "typeof":
                // Function would be evaluated to an array and so typeof would
                // incorrectly return 'object'. Hence making is a special case.
                if (e instanceof AST_Function) return typeof function(){};

                e = ev(e);

                // typeof <RegExp> returns "object" or "function" on different platforms
                // so cannot evaluate reliably
                if (e instanceof RegExp) throw def;

                return typeof e;
              case "void": return void ev(e);
              case "~": return ~ev(e);
              case "-":
                e = ev(e);
                if (e === 0) throw def;
                return -e;
              case "+": return +ev(e);
            }
            throw def;
        });
        def(AST_Binary, function(){
            var left = this.left, right = this.right;
            switch (this.operator) {
              case "&&"         : return ev(left) &&         ev(right);
              case "||"         : return ev(left) ||         ev(right);
              case "|"          : return ev(left) |          ev(right);
              case "&"          : return ev(left) &          ev(right);
              case "^"          : return ev(left) ^          ev(right);
              case "+"          : return ev(left) +          ev(right);
              case "*"          : return ev(left) *          ev(right);
              case "/"          : return ev(left) /          ev(right);
              case "%"          : return ev(left) %          ev(right);
              case "-"          : return ev(left) -          ev(right);
              case "<<"         : return ev(left) <<         ev(right);
              case ">>"         : return ev(left) >>         ev(right);
              case ">>>"        : return ev(left) >>>        ev(right);
              case "=="         : return ev(left) ==         ev(right);
              case "==="        : return ev(left) ===        ev(right);
              case "!="         : return ev(left) !=         ev(right);
              case "!=="        : return ev(left) !==        ev(right);
              case "<"          : return ev(left) <          ev(right);
              case "<="         : return ev(left) <=         ev(right);
              case ">"          : return ev(left) >          ev(right);
              case ">="         : return ev(left) >=         ev(right);
              case "in"         : return ev(left) in         ev(right);
              case "instanceof" : return ev(left) instanceof ev(right);
            }
            throw def;
        });
        def(AST_Conditional, function(){
            return ev(this.condition)
                ? ev(this.consequent)
                : ev(this.alternative);
        });
        def(AST_SymbolRef, function(){
            var d = this.definition();
            if (d && d.constant && d.init) return ev(d.init);
            throw def;
        });
    })(function(node, func){
        node.DEFMETHOD("_eval", func);
    });

    // method to negate an expression
    (function(def){
        function basic_negation(exp) {
            return make_node(AST_UnaryPrefix, exp, {
                operator: "!",
                expression: exp
            });
        };
        def(AST_Node, function(){
            return basic_negation(this);
        });
        def(AST_Statement, function(){
            throw new Error("Cannot negate a statement");
        });
        def(AST_Function, function(){
            return basic_negation(this);
        });
        def(AST_UnaryPrefix, function(){
            if (this.operator == "!")
                return this.expression;
            return basic_negation(this);
        });
        def(AST_Seq, function(compressor){
            var self = this.clone();
            self.cdr = self.cdr.negate(compressor);
            return self;
        });
        def(AST_Conditional, function(compressor){
            var self = this.clone();
            self.consequent = self.consequent.negate(compressor);
            self.alternative = self.alternative.negate(compressor);
            return best_of(basic_negation(this), self);
        });
        def(AST_Binary, function(compressor){
            var self = this.clone(), op = this.operator;
            if (compressor.option("unsafe_comps")) {
                switch (op) {
                  case "<=" : self.operator = ">"  ; return self;
                  case "<"  : self.operator = ">=" ; return self;
                  case ">=" : self.operator = "<"  ; return self;
                  case ">"  : self.operator = "<=" ; return self;
                }
            }
            switch (op) {
              case "==" : self.operator = "!="; return self;
              case "!=" : self.operator = "=="; return self;
              case "===": self.operator = "!=="; return self;
              case "!==": self.operator = "==="; return self;
              case "&&":
                self.operator = "||";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
              case "||":
                self.operator = "&&";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
            }
            return basic_negation(this);
        });
    })(function(node, func){
        node.DEFMETHOD("negate", function(compressor){
            return func.call(this, compressor);
        });
    });

    // determine if expression has side effects
    (function(def){
        def(AST_Node, function(){ return true });

        def(AST_EmptyStatement, function(){ return false });
        def(AST_Constant, function(){ return false });
        def(AST_This, function(){ return false });

        def(AST_Block, function(){
            for (var i = this.body.length; --i >= 0;) {
                if (this.body[i].has_side_effects())
                    return true;
            }
            return false;
        });

        def(AST_SimpleStatement, function(){
            return this.body.has_side_effects();
        });
        def(AST_Defun, function(){ return true });
        def(AST_Function, function(){ return false });
        def(AST_Binary, function(){
            return this.left.has_side_effects()
                || this.right.has_side_effects();
        });
        def(AST_Assign, function(){ return true });
        def(AST_Conditional, function(){
            return this.condition.has_side_effects()
                || this.consequent.has_side_effects()
                || this.alternative.has_side_effects();
        });
        def(AST_Unary, function(){
            return this.operator == "delete"
                || this.operator == "++"
                || this.operator == "--"
                || this.expression.has_side_effects();
        });
        def(AST_SymbolRef, function(){ return false });
        def(AST_Object, function(){
            for (var i = this.properties.length; --i >= 0;)
                if (this.properties[i].has_side_effects())
                    return true;
            return false;
        });
        def(AST_ObjectProperty, function(){
            return this.value.has_side_effects();
        });
        def(AST_Array, function(){
            for (var i = this.elements.length; --i >= 0;)
                if (this.elements[i].has_side_effects())
                    return true;
            return false;
        });
        // def(AST_Dot, function(){
        //     return this.expression.has_side_effects();
        // });
        // def(AST_Sub, function(){
        //     return this.expression.has_side_effects()
        //         || this.property.has_side_effects();
        // });
        def(AST_PropAccess, function(){
            return true;
        });
        def(AST_Seq, function(){
            return this.car.has_side_effects()
                || this.cdr.has_side_effects();
        });
    })(function(node, func){
        node.DEFMETHOD("has_side_effects", func);
    });

    // tell me if a statement aborts
    function aborts(thing) {
        return thing && thing.aborts();
    };
    (function(def){
        def(AST_Statement, function(){ return null });
        def(AST_Jump, function(){ return this });
        function block_aborts(){
            var n = this.body.length;
            return n > 0 && aborts(this.body[n - 1]);
        };
        def(AST_BlockStatement, block_aborts);
        def(AST_SwitchBranch, block_aborts);
        def(AST_If, function(){
            return this.alternative && aborts(this.body) && aborts(this.alternative);
        });
    })(function(node, func){
        node.DEFMETHOD("aborts", func);
    });

    /* -----[ optimizers ]----- */

    OPT(AST_Directive, function(self, compressor){
        if (self.scope.has_directive(self.value) !== self.scope) {
            return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    OPT(AST_Debugger, function(self, compressor){
        if (compressor.option("drop_debugger"))
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_LabeledStatement, function(self, compressor){
        if (self.body instanceof AST_Break
            && compressor.loopcontrol_target(self.body.label) === self.body) {
            return make_node(AST_EmptyStatement, self);
        }
        return self.label.references.length == 0 ? self.body : self;
    });

    OPT(AST_Block, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_BlockStatement, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        switch (self.body.length) {
          case 1: return self.body[0];
          case 0: return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    AST_Scope.DEFMETHOD("drop_unused", function(compressor){
        var self = this;
        if (compressor.option("unused")
            && !(self instanceof AST_Toplevel)
            && !self.uses_eval
           ) {
            var in_use = [];
            var initializations = new Dictionary();
            // pass 1: find out which symbols are directly used in
            // this scope (not in nested scopes).
            var scope = this;
            var tw = new TreeWalker(function(node, descend){
                if (node !== self) {
                    if (node instanceof AST_Defun) {
                        initializations.add(node.name.name, node);
                        return true; // don't go in nested scopes
                    }
                    if (node instanceof AST_Definitions && scope === self) {
                        node.definitions.forEach(function(def){
                            if (def.value) {
                                initializations.add(def.name.name, def.value);
                                if (def.value.has_side_effects()) {
                                    def.value.walk(tw);
                                }
                            }
                        });
                        return true;
                    }
                    if (node instanceof AST_SymbolRef) {
                        push_uniq(in_use, node.definition());
                        return true;
                    }
                    if (node instanceof AST_Scope) {
                        var save_scope = scope;
                        scope = node;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                }
            });
            self.walk(tw);
            // pass 2: for every used symbol we need to walk its
            // initialization code to figure out if it uses other
            // symbols (that may not be in_use).
            for (var i = 0; i < in_use.length; ++i) {
                in_use[i].orig.forEach(function(decl){
                    // undeclared globals will be instanceof AST_SymbolRef
                    var init = initializations.get(decl.name);
                    if (init) init.forEach(function(init){
                        var tw = new TreeWalker(function(node){
                            if (node instanceof AST_SymbolRef) {
                                push_uniq(in_use, node.definition());
                            }
                        });
                        init.walk(tw);
                    });
                });
            }
            // pass 3: we should drop declarations not in_use
            var tt = new TreeTransformer(
                function before(node, descend, in_list) {
                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                        for (var a = node.argnames, i = a.length; --i >= 0;) {
                            var sym = a[i];
                            if (sym.unreferenced()) {
                                a.pop();
                                compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                    name : sym.name,
                                    file : sym.start.file,
                                    line : sym.start.line,
                                    col  : sym.start.col
                                });
                            }
                            else break;
                        }
                    }
                    if (node instanceof AST_Defun && node !== self) {
                        if (!member(node.name.definition(), in_use)) {
                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                name : node.name.name,
                                file : node.name.start.file,
                                line : node.name.start.line,
                                col  : node.name.start.col
                            });
                            return make_node(AST_EmptyStatement, node);
                        }
                        return node;
                    }
                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                        var def = node.definitions.filter(function(def){
                            if (member(def.name.definition(), in_use)) return true;
                            var w = {
                                name : def.name.name,
                                file : def.name.start.file,
                                line : def.name.start.line,
                                col  : def.name.start.col
                            };
                            if (def.value && def.value.has_side_effects()) {
                                def._unused_side_effects = true;
                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                return true;
                            }
                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                            return false;
                        });
                        // place uninitialized names at the start
                        def = mergeSort(def, function(a, b){
                            if (!a.value && b.value) return -1;
                            if (!b.value && a.value) return 1;
                            return 0;
                        });
                        // for unused names whose initialization has
                        // side effects, we can cascade the init. code
                        // into the next one, or next statement.
                        var side_effects = [];
                        for (var i = 0; i < def.length;) {
                            var x = def[i];
                            if (x._unused_side_effects) {
                                side_effects.push(x.value);
                                def.splice(i, 1);
                            } else {
                                if (side_effects.length > 0) {
                                    side_effects.push(x.value);
                                    x.value = AST_Seq.from_array(side_effects);
                                    side_effects = [];
                                }
                                ++i;
                            }
                        }
                        if (side_effects.length > 0) {
                            side_effects = make_node(AST_BlockStatement, node, {
                                body: [ make_node(AST_SimpleStatement, node, {
                                    body: AST_Seq.from_array(side_effects)
                                }) ]
                            });
                        } else {
                            side_effects = null;
                        }
                        if (def.length == 0 && !side_effects) {
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (def.length == 0) {
                            return side_effects;
                        }
                        node.definitions = def;
                        if (side_effects) {
                            side_effects.body.unshift(node);
                            node = side_effects;
                        }
                        return node;
                    }
                    if (node instanceof AST_For && node.init instanceof AST_BlockStatement) {
                        descend(node, this);
                        // certain combination of unused name + side effect leads to:
                        //    https://github.com/mishoo/UglifyJS2/issues/44
                        // that's an invalid AST.
                        // We fix it at this stage by moving the `var` outside the `for`.
                        var body = node.init.body.slice(0, -1);
                        node.init = node.init.body.slice(-1)[0].body;
                        body.push(node);
                        return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                            body: body
                        });
                    }
                    if (node instanceof AST_Scope && node !== self)
                        return node;
                }
            );
            self.transform(tt);
        }
    });

    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        var self = this;
        if (hoist_funs || hoist_vars) {
            var dirs = [];
            var hoisted = [];
            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
            // let's count var_decl first, we seem to waste a lot of
            // space if we hoist `var` when there's only one.
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }));
            hoist_vars = hoist_vars && var_decl > 1;
            var tt = new TreeTransformer(
                function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def){
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments();
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === node) {
                                if (seq == null) return node.definitions[0].name;
                                return seq;
                            }
                            if (p instanceof AST_For && p.init === node) {
                                return seq;
                            }
                            if (!seq) return make_node(AST_EmptyStatement, node);
                            return make_node(AST_SimpleStatement, node, {
                                body: seq
                            });
                        }
                        if (node instanceof AST_Scope)
                            return node; // to avoid descending in nested scopes
                    }
                }
            );
            self = self.transform(tt);
            if (vars_found > 0) {
                // collect only vars which don't show up in self's arguments list
                var defs = [];
                vars.each(function(def, name){
                    if (self instanceof AST_Lambda
                        && find_if(function(x){ return x.name == def.name.name },
                                   self.argnames)) {
                        vars.del(name);
                    } else {
                        def = def.clone();
                        def.value = null;
                        defs.push(def);
                        vars.set(name, def);
                    }
                });
                if (defs.length > 0) {
                    // try to merge in assignments
                    for (var i = 0; i < self.body.length;) {
                        if (self.body[i] instanceof AST_SimpleStatement) {
                            var expr = self.body[i].body, sym, assign;
                            if (expr instanceof AST_Assign
                                && expr.operator == "="
                                && (sym = expr.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = expr.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body.splice(i, 1);
                                continue;
                            }
                            if (expr instanceof AST_Seq
                                && (assign = expr.car) instanceof AST_Assign
                                && assign.operator == "="
                                && (sym = assign.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = assign.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body[i].body = expr.cdr;
                                continue;
                            }
                        }
                        if (self.body[i] instanceof AST_EmptyStatement) {
                            self.body.splice(i, 1);
                            continue;
                        }
                        if (self.body[i] instanceof AST_BlockStatement) {
                            var tmp = [ i, 1 ].concat(self.body[i].body);
                            self.body.splice.apply(self.body, tmp);
                            continue;
                        }
                        break;
                    }
                    defs = make_node(AST_Var, self, {
                        definitions: defs
                    });
                    hoisted.push(defs);
                };
            }
            self.body = dirs.concat(hoisted, self.body);
        }
        return self;
    });

    OPT(AST_SimpleStatement, function(self, compressor){
        if (compressor.option("side_effects")) {
            if (!self.body.has_side_effects()) {
                compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                return make_node(AST_EmptyStatement, self);
            }
        }
        return self;
    });

    OPT(AST_DWLoop, function(self, compressor){
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (!compressor.option("loops")) return self;
        if (cond.length > 1) {
            if (cond[1]) {
                return make_node(AST_For, self, {
                    body: self.body
                });
            } else if (self instanceof AST_While) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        return self;
    });

    function if_break_in_loop(self, compressor) {
        function drop_it(rest) {
            rest = as_statement_array(rest);
            if (self.body instanceof AST_BlockStatement) {
                self.body = self.body.clone();
                self.body.body = rest.concat(self.body.body.slice(1));
                self.body = self.body.transform(compressor);
            } else {
                self.body = make_node(AST_BlockStatement, self.body, {
                    body: rest
                }).transform(compressor);
            }
            if_break_in_loop(self, compressor);
        }
        var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
        if (first instanceof AST_If) {
            if (first.body instanceof AST_Break
                && compressor.loopcontrol_target(first.body.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition.negate(compressor),
                    });
                } else {
                    self.condition = first.condition.negate(compressor);
                }
                drop_it(first.alternative);
            }
            else if (first.alternative instanceof AST_Break
                     && compressor.loopcontrol_target(first.alternative.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition,
                    });
                } else {
                    self.condition = first.condition;
                }
                drop_it(first.body);
            }
        }
    };

    OPT(AST_While, function(self, compressor) {
        if (!compressor.option("loops")) return self;
        self = AST_DWLoop.prototype.optimize.call(self, compressor);
        if (self instanceof AST_While) {
            if_break_in_loop(self, compressor);
            self = make_node(AST_For, self, self).transform(compressor);
        }
        return self;
    });

    OPT(AST_For, function(self, compressor){
        var cond = self.condition;
        if (cond) {
            cond = cond.evaluate(compressor);
            self.condition = cond[0];
        }
        if (!compressor.option("loops")) return self;
        if (cond) {
            if (cond.length > 1 && !cond[1]) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.init instanceof AST_Statement) {
                        a.push(self.init);
                    }
                    else if (self.init) {
                        a.push(make_node(AST_SimpleStatement, self.init, {
                            body: self.init
                        }));
                    }
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        if_break_in_loop(self, compressor);
        return self;
    });

    OPT(AST_If, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        // if condition can be statically determined, warn and drop
        // one of the blocks.  note, statically determined implies
        // “has no side effects”; also it doesn't work for cases like
        // `x && true`, though it probably should.
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.alternative) {
                        extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                    }
                    a.push(self.body);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    if (self.alternative) a.push(self.alternative);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            }
        }
        if (is_empty(self.alternative)) self.alternative = null;
        var negated = self.condition.negate(compressor);
        var negated_is_best = best_of(self.condition, negated) === negated;
        if (self.alternative && negated_is_best) {
            negated_is_best = false; // because we already do the switch here.
            self.condition = negated;
            var tmp = self.body;
            self.body = self.alternative || make_node(AST_EmptyStatement);
            self.alternative = tmp;
        }
        if (is_empty(self.body) && is_empty(self.alternative)) {
            return make_node(AST_SimpleStatement, self.condition, {
                body: self.condition
            }).transform(compressor);
        }
        if (self.body instanceof AST_SimpleStatement
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.body,
                    alternative : self.alternative.body
                })
            }).transform(compressor);
        }
        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
            if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : negated,
                    right    : self.body.body
                })
            }).transform(compressor);
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "&&",
                    left     : self.condition,
                    right    : self.body.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_EmptyStatement
            && self.alternative
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : self.condition,
                    right    : self.alternative.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_Exit
            && self.alternative instanceof AST_Exit
            && self.body.TYPE == self.alternative.TYPE) {
            return make_node(self.body.CTOR, self, {
                value: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_If
            && !self.body.alternative
            && !self.alternative) {
            self.condition = make_node(AST_Binary, self.condition, {
                operator: "&&",
                left: self.condition,
                right: self.body.condition
            }).transform(compressor);
            self.body = self.body.body;
        }
        if (aborts(self.body)) {
            if (self.alternative) {
                var alt = self.alternative;
                self.alternative = null;
                return make_node(AST_BlockStatement, self, {
                    body: [ self, alt ]
                }).transform(compressor);
            }
        }
        if (aborts(self.alternative)) {
            var body = self.body;
            self.body = self.alternative;
            self.condition = negated_is_best ? negated : self.condition.negate(compressor);
            self.alternative = null;
            return make_node(AST_BlockStatement, self, {
                body: [ self, body ]
            }).transform(compressor);
        }
        return self;
    });

    OPT(AST_Switch, function(self, compressor){
        if (self.body.length == 0 && compressor.option("conditionals")) {
            return make_node(AST_SimpleStatement, self, {
                body: self.expression
            }).transform(compressor);
        }
        for(;;) {
            var last_branch = self.body[self.body.length - 1];
            if (last_branch) {
                var stat = last_branch.body[last_branch.body.length - 1]; // last statement
                if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self)
                    last_branch.body.pop();
                if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                    self.body.pop();
                    continue;
                }
            }
            break;
        }
        var exp = self.expression.evaluate(compressor);
        out: if (exp.length == 2) try {
            // constant expression
            self.expression = exp[0];
            if (!compressor.option("dead_code")) break out;
            var value = exp[1];
            var in_if = false;
            var in_block = false;
            var started = false;
            var stopped = false;
            var ruined = false;
            var tt = new TreeTransformer(function(node, descend, in_list){
                if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                    // no need to descend these node types
                    return node;
                }
                else if (node instanceof AST_Switch && node === self) {
                    node = node.clone();
                    descend(node, this);
                    return ruined ? node : make_node(AST_BlockStatement, node, {
                        body: node.body.reduce(function(a, branch){
                            return a.concat(branch.body);
                        }, [])
                    }).transform(compressor);
                }
                else if (node instanceof AST_If || node instanceof AST_Try) {
                    var save = in_if;
                    in_if = !in_block;
                    descend(node, this);
                    in_if = save;
                    return node;
                }
                else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                    var save = in_block;
                    in_block = true;
                    descend(node, this);
                    in_block = save;
                    return node;
                }
                else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                    if (in_if) {
                        ruined = true;
                        return node;
                    }
                    if (in_block) return node;
                    stopped = true;
                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                }
                else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                    if (stopped) return MAP.skip;
                    if (node instanceof AST_Case) {
                        var exp = node.expression.evaluate(compressor);
                        if (exp.length < 2) {
                            // got a case with non-constant expression, baling out
                            throw self;
                        }
                        if (exp[1] === value || started) {
                            started = true;
                            if (aborts(node)) stopped = true;
                            descend(node, this);
                            return node;
                        }
                        return MAP.skip;
                    }
                    descend(node, this);
                    return node;
                }
            });
            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
            self = self.transform(tt);
        } catch(ex) {
            if (ex !== self) throw ex;
        }
        return self;
    });

    OPT(AST_Case, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_Try, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    AST_Definitions.DEFMETHOD("remove_initializers", function(){
        this.definitions.forEach(function(def){ def.value = null });
    });

    AST_Definitions.DEFMETHOD("to_assignments", function(){
        var assignments = this.definitions.reduce(function(a, def){
            if (def.value) {
                var name = make_node(AST_SymbolRef, def.name, def.name);
                a.push(make_node(AST_Assign, def, {
                    operator : "=",
                    left     : name,
                    right    : def.value
                }));
            }
            return a;
        }, []);
        if (assignments.length == 0) return null;
        return AST_Seq.from_array(assignments);
    });

    OPT(AST_Definitions, function(self, compressor){
        if (self.definitions.length == 0)
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_Function, function(self, compressor){
        self = AST_Lambda.prototype.optimize.call(self, compressor);
        if (compressor.option("unused")) {
            if (self.name && self.name.unreferenced()) {
                self.name = null;
            }
        }
        return self;
    });

    OPT(AST_Call, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Array":
                    if (self.args.length != 1) {
                        return make_node(AST_Array, self, {
                            elements: self.args
                        });
                    }
                    break;
                  case "Object":
                    if (self.args.length == 0) {
                        return make_node(AST_Object, self, {
                            properties: []
                        });
                    }
                    break;
                  case "String":
                    if (self.args.length == 0) return make_node(AST_String, self, {
                        value: ""
                    });
                    return make_node(AST_Binary, self, {
                        left: self.args[0],
                        operator: "+",
                        right: make_node(AST_String, self, { value: "" })
                    });
                  case "Function":
                    if (all(self.args, function(x){ return x instanceof AST_String })) {
                        // quite a corner-case, but we can handle it:
                        //   https://github.com/mishoo/UglifyJS2/issues/203
                        // if the code argument is a constant, then we can minify it.
                        try {
                            var code = "(function(" + self.args.slice(0, -1).map(function(arg){
                                return arg.value;
                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                            var ast = parse(code);
                            ast.figure_out_scope();
                            var comp = new Compressor(compressor.options);
                            ast = ast.transform(comp);
                            ast.figure_out_scope();
                            ast.mangle_names();
                            var fun = ast.body[0].body.expression;
                            var args = fun.argnames.map(function(arg, i){
                                return make_node(AST_String, self.args[i], {
                                    value: arg.print_to_string()
                                });
                            });
                            var code = OutputStream();
                            AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                            code = code.toString().replace(/^\{|\}$/g, "");
                            args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                value: code
                            }));
                            self.args = args;
                            return self;
                        } catch(ex) {
                            if (ex instanceof JS_Parse_Error) {
                                compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                compressor.warn(ex.toString());
                            } else {
                                console.log(ex);
                            }
                        }
                    }
                    break;
                }
            }
            else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                return make_node(AST_Binary, self, {
                    left: make_node(AST_String, self, { value: "" }),
                    operator: "+",
                    right: exp.expression
                }).transform(compressor);
            }
        }
        if (compressor.option("side_effects")) {
            if (self.expression instanceof AST_Function
                && self.args.length == 0
                && !AST_Block.prototype.has_side_effects.call(self.expression)) {
                return make_node(AST_Undefined, self).transform(compressor);
            }
        }
        return self;
    });

    OPT(AST_New, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Object":
                  case "RegExp":
                  case "Function":
                  case "Error":
                  case "Array":
                    return make_node(AST_Call, self, self).transform(compressor);
                }
            }
        }
        return self;
    });

    OPT(AST_Seq, function(self, compressor){
        if (!compressor.option("side_effects"))
            return self;
        if (!self.car.has_side_effects()) {
            // we shouldn't compress (1,eval)(something) to
            // eval(something) because that changes the meaning of
            // eval (becomes lexical instead of global).
            var p;
            if (!(self.cdr instanceof AST_SymbolRef
                  && self.cdr.name == "eval"
                  && self.cdr.undeclared()
                  && (p = compressor.parent()) instanceof AST_Call
                  && p.expression === self)) {
                return self.cdr;
            }
        }
        if (compressor.option("cascade")) {
            if (self.car instanceof AST_Assign
                && !self.car.left.has_side_effects()
                && self.car.left.equivalent_to(self.cdr)) {
                return self.car;
            }
            if (!self.car.has_side_effects()
                && !self.cdr.has_side_effects()
                && self.car.equivalent_to(self.cdr)) {
                return self.car;
            }
        }
        return self;
    });

    AST_Unary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.expression instanceof AST_Seq) {
                var seq = this.expression;
                var x = seq.to_array();
                this.expression = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    OPT(AST_UnaryPostfix, function(self, compressor){
        return self.lift_sequences(compressor);
    });

    OPT(AST_UnaryPrefix, function(self, compressor){
        self = self.lift_sequences(compressor);
        var e = self.expression;
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            switch (self.operator) {
              case "!":
                if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                    // !!foo ==> foo, if we're in boolean context
                    return e.expression;
                }
                break;
              case "typeof":
                // typeof always returns a non-empty string, thus it's
                // always true in booleans
                compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (e instanceof AST_Binary && self.operator == "!") {
                self = best_of(self, e.negate(compressor));
            }
        }
        return self.evaluate(compressor)[0];
    });

    AST_Binary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.left instanceof AST_Seq) {
                var seq = this.left;
                var x = seq.to_array();
                this.left = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
            if (this.right instanceof AST_Seq
                && !(this.operator == "||" || this.operator == "&&")
                && !this.left.has_side_effects()) {
                var seq = this.right;
                var x = seq.to_array();
                this.right = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    var commutativeOperators = makePredicate("== === != !== * & | ^");

    OPT(AST_Binary, function(self, compressor){
        var reverse = compressor.has_directive("use asm") ? noop
            : function(op, force) {
                if (force || !(self.left.has_side_effects() || self.right.has_side_effects())) {
                    if (op) self.operator = op;
                    var tmp = self.left;
                    self.left = self.right;
                    self.right = tmp;
                }
            };
        if (commutativeOperators(self.operator)) {
            if (self.right instanceof AST_Constant
                && !(self.left instanceof AST_Constant)) {
                // if right is a constant, whatever side effects the
                // left side might have could not influence the
                // result.  hence, force switch.
                reverse(null, true);
            }
        }
        self = self.lift_sequences(compressor);
        if (compressor.option("comparisons")) switch (self.operator) {
          case "===":
          case "!==":
            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                (self.left.is_boolean() && self.right.is_boolean())) {
                self.operator = self.operator.substr(0, 2);
            }
            // XXX: intentionally falling down to the next case
          case "==":
          case "!=":
            if (self.left instanceof AST_String
                && self.left.value == "undefined"
                && self.right instanceof AST_UnaryPrefix
                && self.right.operator == "typeof"
                && compressor.option("unsafe")) {
                if (!(self.right.expression instanceof AST_SymbolRef)
                    || !self.right.expression.undeclared()) {
                    self.right = self.right.expression;
                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                    if (self.operator.length == 2) self.operator += "=";
                }
            }
            break;
        }
        if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
          case "&&":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                return make_node(AST_False, self);
            }
            if (ll.length > 1 && ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && rr[1]) {
                return ll[0];
            }
            break;
          case "||":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (ll.length > 1 && !ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && !rr[1]) {
                return ll[0];
            }
            break;
          case "+":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[0] instanceof AST_String && ll[1]) ||
                (rr.length > 1 && rr[0] instanceof AST_String && rr[1])) {
                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            break;
        }
        var exp = self.evaluate(compressor);
        if (exp.length > 1) {
            if (best_of(exp[0], self) !== self)
                return exp[0];
        }
        if (compressor.option("comparisons")) {
            if (!(compressor.parent() instanceof AST_Binary)
                || compressor.parent() instanceof AST_Assign) {
                var negated = make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.negate(compressor)
                });
                self = best_of(self, negated);
            }
            switch (self.operator) {
              case "<": reverse(">"); break;
              case "<=": reverse(">="); break;
            }
        }
        if (self.operator == "+" && self.right instanceof AST_String
            && self.right.getValue() === "" && self.left instanceof AST_Binary
            && self.left.operator == "+" && self.left.is_string(compressor)) {
            return self.left;
        }
        return self;
    });

    OPT(AST_SymbolRef, function(self, compressor){
        if (self.undeclared()) {
            var defines = compressor.option("global_defs");
            if (defines && defines.hasOwnProperty(self.name)) {
                return make_node_from_constant(compressor, defines[self.name], self);
            }
            switch (self.name) {
              case "undefined":
                return make_node(AST_Undefined, self);
              case "NaN":
                return make_node(AST_NaN, self);
              case "Infinity":
                return make_node(AST_Infinity, self);
            }
        }
        return self;
    });

    OPT(AST_Undefined, function(self, compressor){
        if (compressor.option("unsafe")) {
            var scope = compressor.find_parent(AST_Scope);
            var undef = scope.find_variable("undefined");
            if (undef) {
                var ref = make_node(AST_SymbolRef, self, {
                    name   : "undefined",
                    scope  : scope,
                    thedef : undef
                });
                ref.reference();
                return ref;
            }
        }
        return self;
    });

    var ASSIGN_OPS = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
    OPT(AST_Assign, function(self, compressor){
        self = self.lift_sequences(compressor);
        if (self.operator == "="
            && self.left instanceof AST_SymbolRef
            && self.right instanceof AST_Binary
            && self.right.left instanceof AST_SymbolRef
            && self.right.left.name == self.left.name
            && member(self.right.operator, ASSIGN_OPS)) {
            self.operator = self.right.operator + "=";
            self.right = self.right.right;
        }
        return self;
    });

    OPT(AST_Conditional, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        if (self.condition instanceof AST_Seq) {
            var car = self.condition.car;
            self.condition = self.condition.cdr;
            return AST_Seq.cons(car, self);
        }
        var cond = self.condition.evaluate(compressor);
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                return self.consequent;
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                return self.alternative;
            }
        }
        var negated = cond[0].negate(compressor);
        if (best_of(cond[0], negated) === negated) {
            self = make_node(AST_Conditional, self, {
                condition: negated,
                consequent: self.alternative,
                alternative: self.consequent
            });
        }
        var consequent = self.consequent;
        var alternative = self.alternative;
        if (consequent instanceof AST_Assign
            && alternative instanceof AST_Assign
            && consequent.operator == alternative.operator
            && consequent.left.equivalent_to(alternative.left)
           ) {
            /*
             * Stuff like this:
             * if (foo) exp = something; else exp = something_else;
             * ==>
             * exp = foo ? something : something_else;
             */
            self = make_node(AST_Assign, self, {
                operator: consequent.operator,
                left: consequent.left,
                right: make_node(AST_Conditional, self, {
                    condition: self.condition,
                    consequent: consequent.right,
                    alternative: alternative.right
                })
            });
        }
        return self;
    });

    OPT(AST_Boolean, function(self, compressor){
        if (compressor.option("booleans")) {
            var p = compressor.parent();
            if (p instanceof AST_Binary && (p.operator == "=="
                                            || p.operator == "!=")) {
                compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                    operator : p.operator,
                    value    : self.value,
                    file     : p.start.file,
                    line     : p.start.line,
                    col      : p.start.col,
                });
                return make_node(AST_Number, self, {
                    value: +self.value
                });
            }
            return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: make_node(AST_Number, self, {
                    value: 1 - self.value
                })
            });
        }
        return self;
    });

    OPT(AST_Sub, function(self, compressor){
        var prop = self.property;
        if (prop instanceof AST_String && compressor.option("properties")) {
            prop = prop.getValue();
            if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                return make_node(AST_Dot, self, {
                    expression : self.expression,
                    property   : prop
                });
            }
        }
        return self;
    });

    function literals_in_boolean_context(self, compressor) {
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            return make_node(AST_True, self);
        }
        return self;
    };
    OPT(AST_Array, literals_in_boolean_context);
    OPT(AST_Object, literals_in_boolean_context);
    OPT(AST_RegExp, literals_in_boolean_context);

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// a small wrapper around fitzgen's source-map library
function SourceMap(options) {
    options = defaults(options, {
        file : null,
        root : null,
        orig : null,
    });
    var generator = new MOZ_SourceMap.SourceMapGenerator({
        file       : options.file,
        sourceRoot : options.root
    });
    var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
        if (orig_map) {
            var info = orig_map.originalPositionFor({
                line: orig_line,
                column: orig_col
            });
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name = info.name;
        }
        generator.addMapping({
            generated : { line: gen_line, column: gen_col },
            original  : { line: orig_line, column: orig_col },
            source    : source,
            name      : name
        });
    };
    return {
        add        : add,
        get        : function() { return generator },
        toString   : function() { return generator.toString() }
    };
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

(function(){

    var MOZ_TO_ME = {
        TryStatement : function(M) {
            return new AST_Try({
                start    : my_start_token(M),
                end      : my_end_token(M),
                body     : from_moz(M.block).body,
                bcatch   : from_moz(M.handlers[0]),
                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
        },
        CatchClause : function(M) {
            return new AST_Catch({
                start   : my_start_token(M),
                end     : my_end_token(M),
                argname : from_moz(M.param),
                body    : from_moz(M.body).body
            });
        },
        ObjectExpression : function(M) {
            return new AST_Object({
                start      : my_start_token(M),
                end        : my_end_token(M),
                properties : M.properties.map(function(prop){
                    var key = prop.key;
                    var name = key.type == "Identifier" ? key.name : key.value;
                    var args = {
                        start    : my_start_token(key),
                        end      : my_end_token(prop.value),
                        key      : name,
                        value    : from_moz(prop.value)
                    };
                    switch (prop.kind) {
                      case "init":
                        return new AST_ObjectKeyVal(args);
                      case "set":
                        args.value.name = from_moz(key);
                        return new AST_ObjectSetter(args);
                      case "get":
                        args.value.name = from_moz(key);
                        return new AST_ObjectGetter(args);
                    }
                })
            });
        },
        SequenceExpression : function(M) {
            return AST_Seq.from_array(M.expressions.map(from_moz));
        },
        MemberExpression : function(M) {
            return new (M.computed ? AST_Sub : AST_Dot)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                property   : M.computed ? from_moz(M.property) : M.property.name,
                expression : from_moz(M.object)
            });
        },
        SwitchCase : function(M) {
            return new (M.test ? AST_Case : AST_Default)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                expression : from_moz(M.test),
                body       : M.consequent.map(from_moz)
            });
        },
        Literal : function(M) {
            var val = M.value, args = {
                start  : my_start_token(M),
                end    : my_end_token(M)
            };
            if (val === null) return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
              default:
                args.value = val;
                return new AST_RegExp(args);
            }
        },
        UnaryExpression: From_Moz_Unary,
        UpdateExpression: From_Moz_Unary,
        Identifier: function(M) {
            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
            return new (M.name == "this" ? AST_This
                        : p.type == "LabeledStatement" ? AST_Label
                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : AST_SymbolVar)
                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
                        : p.type == "CatchClause" ? AST_SymbolCatch
                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
                        : AST_SymbolRef)({
                            start : my_start_token(M),
                            end   : my_end_token(M),
                            name  : M.name
                        });
        }
    };

    function From_Moz_Unary(M) {
        var prefix = "prefix" in M ? M.prefix
            : M.type == "UnaryExpression" ? true : false;
        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start      : my_start_token(M),
            end        : my_end_token(M),
            operator   : M.operator,
            expression : from_moz(M.argument)
        });
    };

    var ME_TO_MOZ = {};

    map("Node", AST_Node);
    map("Program", AST_Toplevel, "body@body");
    map("Function", AST_Function, "id>name, params@argnames, body%body");
    map("EmptyStatement", AST_EmptyStatement);
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
    map("VariableDeclaration", AST_Var, "declarations@definitions");
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");

    map("ThisExpression", AST_This);
    map("ArrayExpression", AST_Array, "elements@elements");
    map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args");
    map("CallExpression", AST_Call, "callee>expression, arguments@args");

    /* -----[ tools ]----- */

    function my_start_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.start.line,
            col    : moznode.loc && moznode.loc.start.column,
            pos    : moznode.start,
            endpos : moznode.start
        });
    };

    function my_end_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.end.line,
            col    : moznode.loc && moznode.loc.end.column,
            pos    : moznode.end,
            endpos : moznode.end
        });
    };

    function map(moztype, mytype, propmap) {
        var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
        moz_to_me += "return new mytype({\n" +
            "start: my_start_token(M),\n" +
            "end: my_end_token(M)";

        if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop){
            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
            if (!m) throw new Error("Can't understand property map: " + prop);
            var moz = "M." + m[1], how = m[2], my = m[3];
            moz_to_me += ",\n" + my + ": ";
            if (how == "@") {
                moz_to_me += moz + ".map(from_moz)";
            } else if (how == ">") {
                moz_to_me += "from_moz(" + moz + ")";
            } else if (how == "=") {
                moz_to_me += moz;
            } else if (how == "%") {
                moz_to_me += "from_moz(" + moz + ").body";
            } else throw new Error("Can't understand operator in propmap: " + prop);
        });
        moz_to_me += "\n})}";

        // moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
        // console.log(moz_to_me);

        moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
            mytype, my_start_token, my_end_token, from_moz
        );
        return MOZ_TO_ME[moztype] = moz_to_me;
    };

    var FROM_MOZ_STACK = null;

    function from_moz(node) {
        FROM_MOZ_STACK.push(node);
        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
        FROM_MOZ_STACK.pop();
        return ret;
    };

    AST_Node.from_mozilla_ast = function(node){
        var save_stack = FROM_MOZ_STACK;
        FROM_MOZ_STACK = [];
        var ast = from_moz(node);
        FROM_MOZ_STACK = save_stack;
        return ast;
    };

})();


exports.sys = sys;
exports.MOZ_SourceMap = MOZ_SourceMap;
exports.UglifyJS = UglifyJS;
exports.array_to_hash = array_to_hash;
exports.slice = slice;
exports.characters = characters;
exports.member = member;
exports.find_if = find_if;
exports.repeat_string = repeat_string;
exports.DefaultsError = DefaultsError;
exports.defaults = defaults;
exports.merge = merge;
exports.noop = noop;
exports.MAP = MAP;
exports.push_uniq = push_uniq;
exports.string_template = string_template;
exports.remove = remove;
exports.mergeSort = mergeSort;
exports.set_difference = set_difference;
exports.set_intersection = set_intersection;
exports.makePredicate = makePredicate;
exports.all = all;
exports.Dictionary = Dictionary;
exports.DEFNODE = DEFNODE;
exports.AST_Token = AST_Token;
exports.AST_Node = AST_Node;
exports.AST_Statement = AST_Statement;
exports.AST_Debugger = AST_Debugger;
exports.AST_Directive = AST_Directive;
exports.AST_SimpleStatement = AST_SimpleStatement;
exports.walk_body = walk_body;
exports.AST_Block = AST_Block;
exports.AST_BlockStatement = AST_BlockStatement;
exports.AST_EmptyStatement = AST_EmptyStatement;
exports.AST_StatementWithBody = AST_StatementWithBody;
exports.AST_LabeledStatement = AST_LabeledStatement;
exports.AST_DWLoop = AST_DWLoop;
exports.AST_Do = AST_Do;
exports.AST_While = AST_While;
exports.AST_For = AST_For;
exports.AST_ForIn = AST_ForIn;
exports.AST_With = AST_With;
exports.AST_Scope = AST_Scope;
exports.AST_Toplevel = AST_Toplevel;
exports.AST_Lambda = AST_Lambda;
exports.AST_Accessor = AST_Accessor;
exports.AST_Function = AST_Function;
exports.AST_Defun = AST_Defun;
exports.AST_Jump = AST_Jump;
exports.AST_Exit = AST_Exit;
exports.AST_Return = AST_Return;
exports.AST_Throw = AST_Throw;
exports.AST_LoopControl = AST_LoopControl;
exports.AST_Break = AST_Break;
exports.AST_Continue = AST_Continue;
exports.AST_If = AST_If;
exports.AST_Switch = AST_Switch;
exports.AST_SwitchBranch = AST_SwitchBranch;
exports.AST_Default = AST_Default;
exports.AST_Case = AST_Case;
exports.AST_Try = AST_Try;
exports.AST_Catch = AST_Catch;
exports.AST_Finally = AST_Finally;
exports.AST_Definitions = AST_Definitions;
exports.AST_Var = AST_Var;
exports.AST_Const = AST_Const;
exports.AST_VarDef = AST_VarDef;
exports.AST_Call = AST_Call;
exports.AST_New = AST_New;
exports.AST_Seq = AST_Seq;
exports.AST_PropAccess = AST_PropAccess;
exports.AST_Dot = AST_Dot;
exports.AST_Sub = AST_Sub;
exports.AST_Unary = AST_Unary;
exports.AST_UnaryPrefix = AST_UnaryPrefix;
exports.AST_UnaryPostfix = AST_UnaryPostfix;
exports.AST_Binary = AST_Binary;
exports.AST_Conditional = AST_Conditional;
exports.AST_Assign = AST_Assign;
exports.AST_Array = AST_Array;
exports.AST_Object = AST_Object;
exports.AST_ObjectProperty = AST_ObjectProperty;
exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
exports.AST_ObjectSetter = AST_ObjectSetter;
exports.AST_ObjectGetter = AST_ObjectGetter;
exports.AST_Symbol = AST_Symbol;
exports.AST_SymbolAccessor = AST_SymbolAccessor;
exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
exports.AST_SymbolVar = AST_SymbolVar;
exports.AST_SymbolConst = AST_SymbolConst;
exports.AST_SymbolFunarg = AST_SymbolFunarg;
exports.AST_SymbolDefun = AST_SymbolDefun;
exports.AST_SymbolLambda = AST_SymbolLambda;
exports.AST_SymbolCatch = AST_SymbolCatch;
exports.AST_Label = AST_Label;
exports.AST_SymbolRef = AST_SymbolRef;
exports.AST_LabelRef = AST_LabelRef;
exports.AST_This = AST_This;
exports.AST_Constant = AST_Constant;
exports.AST_String = AST_String;
exports.AST_Number = AST_Number;
exports.AST_RegExp = AST_RegExp;
exports.AST_Atom = AST_Atom;
exports.AST_Null = AST_Null;
exports.AST_NaN = AST_NaN;
exports.AST_Undefined = AST_Undefined;
exports.AST_Hole = AST_Hole;
exports.AST_Infinity = AST_Infinity;
exports.AST_Boolean = AST_Boolean;
exports.AST_False = AST_False;
exports.AST_True = AST_True;
exports.TreeWalker = TreeWalker;
exports.KEYWORDS = KEYWORDS;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;
exports.OPERATOR_CHARS = OPERATOR_CHARS;
exports.RE_HEX_NUMBER = RE_HEX_NUMBER;
exports.RE_OCT_NUMBER = RE_OCT_NUMBER;
exports.RE_DEC_NUMBER = RE_DEC_NUMBER;
exports.OPERATORS = OPERATORS;
exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;
exports.PUNC_CHARS = PUNC_CHARS;
exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;
exports.UNICODE = UNICODE;
exports.is_letter = is_letter;
exports.is_digit = is_digit;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_unicode_combining_mark = is_unicode_combining_mark;
exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;
exports.is_identifier = is_identifier;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.is_identifier_string = is_identifier_string;
exports.parse_js_number = parse_js_number;
exports.JS_Parse_Error = JS_Parse_Error;
exports.js_error = js_error;
exports.is_token = is_token;
exports.EX_EOF = EX_EOF;
exports.tokenizer = tokenizer;
exports.UNARY_PREFIX = UNARY_PREFIX;
exports.UNARY_POSTFIX = UNARY_POSTFIX;
exports.ASSIGNMENT = ASSIGNMENT;
exports.PRECEDENCE = PRECEDENCE;
exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.parse = parse;
exports.TreeTransformer = TreeTransformer;
exports.SymbolDef = SymbolDef;
exports.base54 = base54;
exports.OutputStream = OutputStream;
exports.Compressor = Compressor;
exports.SourceMap = SourceMap;

exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }

exports.minify = function (files, options) {
    options = UglifyJS.defaults(options, {
        outSourceMap : null,
        sourceRoot   : null,
        inSourceMap  : null,
        fromString   : false,
        warnings     : false,
        mangle       : {},
        output       : null,
        compress     : {}
    });
    if (typeof files == "string")
        files = [ files ];

    UglifyJS.base54.reset();

    // 1. parse
    var toplevel = null;
    files.forEach(function(file){
        var code = options.fromString
            ? file
            : fs.readFileSync(file, "utf8");
        toplevel = UglifyJS.parse(code, {
            filename: options.fromString ? "?" : file,
            toplevel: toplevel
        });
    });

    // 2. compress
    if (options.compress) {
        var compress = { warnings: options.warnings };
        UglifyJS.merge(compress, options.compress);
        toplevel.figure_out_scope();
        var sq = UglifyJS.Compressor(compress);
        toplevel = toplevel.transform(sq);
    }

    // 3. mangle
    if (options.mangle) {
        toplevel.figure_out_scope();
        toplevel.compute_char_frequency();
        toplevel.mangle_names(options.mangle);
    }

    // 4. output
    var inMap = options.inSourceMap;
    var output = {};
    if (typeof options.inSourceMap == "string") {
        inMap = fs.readFileSync(options.inSourceMap, "utf8");
    }
    if (options.outSourceMap) {
        output.source_map = UglifyJS.SourceMap({
            file: options.outSourceMap,
            orig: inMap,
            root: options.sourceRoot
        });
    }
    if (options.output) {
        UglifyJS.merge(output, options.output);
    }
    var stream = UglifyJS.OutputStream(output);
    toplevel.print(stream);
    return {
        code : stream + "",
        map  : output.source_map + ""
    };
};

exports.describe_ast = function () {
    var out = UglifyJS.OutputStream({ beautify: true });
    function doitem(ctor) {
        out.print("AST_" + ctor.TYPE);
        var props = ctor.SELF_PROPS.filter(function(prop){
            return !/^\$/.test(prop);
        });
        if (props.length > 0) {
            out.space();
            out.with_parens(function(){
                props.forEach(function(prop, i){
                    if (i) out.space();
                    out.print(prop);
                });
            });
        }
        if (ctor.documentation) {
            out.space();
            out.print_string(ctor.documentation);
        }
        if (ctor.SUBCLASSES.length > 0) {
            out.space();
            out.with_block(function(){
                ctor.SUBCLASSES.forEach(function(ctor, i){
                    out.indent();
                    doitem(ctor);
                    out.newline();
                });
            });
        }
    };
    doitem(UglifyJS.AST_Node);
    return out + "";
};
},{"source-map":100,"util":4}],111:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":116,"./source-map/source-map-generator":117,"./source-map/source-node":118}],112:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":119,"amdefine":120}],113:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":114,"amdefine":120}],114:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":120}],115:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":120}],116:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":112,"./base64-vlq":113,"./binary-search":115,"./util":119,"amdefine":120}],117:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":112,"./base64-vlq":113,"./util":119,"amdefine":120}],118:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":117,"./util":119,"amdefine":120}],119:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":120}],120:[function(require,module,exports){
var process=require("__browserify_process"),__filename="/../../node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js";/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

},{"__browserify_process":5,"path":3}],121:[function(require,module,exports){
var sys = require("util");
var MOZ_SourceMap = require("source-map");
var UglifyJS = exports;
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function array_to_hash(a) {
    var ret = Object.create(null);
    for (var i = 0; i < a.length; ++i)
        ret[a[i]] = true;
    return ret;
};

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
    return str.split("");
};

function member(name, array) {
    for (var i = array.length; --i >= 0;)
        if (array[i] == name)
            return true;
    return false;
};

function find_if(func, array) {
    for (var i = 0, n = array.length; i < n; ++i) {
        if (func(array[i]))
            return array[i];
    }
};

function repeat_string(str, i) {
    if (i <= 0) return "";
    if (i == 1) return str;
    var d = repeat_string(str, i >> 1);
    d += d;
    if (i & 1) d += str;
    return d;
};

function DefaultsError(msg, defs) {
    this.msg = msg;
    this.defs = defs;
};

function defaults(args, defs, croak) {
    if (args === true)
        args = {};
    var ret = args || {};
    if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))
        throw new DefaultsError("`" + i + "` is not a supported option", defs);
    for (var i in defs) if (defs.hasOwnProperty(i)) {
        ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];
    }
    return ret;
};

function merge(obj, ext) {
    for (var i in ext) if (ext.hasOwnProperty(i)) {
        obj[i] = ext[i];
    }
    return obj;
};

function noop() {};

var MAP = (function(){
    function MAP(a, f, backwards) {
        var ret = [], top = [], i;
        function doit() {
            var val = f(a[i], i);
            var is_last = val instanceof Last;
            if (is_last) val = val.v;
            if (val instanceof AtTop) {
                val = val.v;
                if (val instanceof Splice) {
                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    top.push(val);
                }
            }
            else if (val !== skip) {
                if (val instanceof Splice) {
                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    ret.push(val);
                }
            }
            return is_last;
        };
        if (a instanceof Array) {
            if (backwards) {
                for (i = a.length; --i >= 0;) if (doit()) break;
                ret.reverse();
                top.reverse();
            } else {
                for (i = 0; i < a.length; ++i) if (doit()) break;
            }
        }
        else {
            for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
        }
        return top.concat(ret);
    };
    MAP.at_top = function(val) { return new AtTop(val) };
    MAP.splice = function(val) { return new Splice(val) };
    MAP.last = function(val) { return new Last(val) };
    var skip = MAP.skip = {};
    function AtTop(val) { this.v = val };
    function Splice(val) { this.v = val };
    function Last(val) { this.v = val };
    return MAP;
})();

function push_uniq(array, el) {
    if (array.indexOf(el) < 0)
        array.push(el);
};

function string_template(text, props) {
    return text.replace(/\{(.+?)\}/g, function(str, p){
        return props[p];
    });
};

function remove(array, el) {
    for (var i = array.length; --i >= 0;) {
        if (array[i] === el) array.splice(i, 1);
    }
};

function mergeSort(array, cmp) {
    if (array.length < 2) return array.slice();
    function merge(a, b) {
        var r = [], ai = 0, bi = 0, i = 0;
        while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0
                ? r[i++] = a[ai++]
                : r[i++] = b[bi++];
        }
        if (ai < a.length) r.push.apply(r, a.slice(ai));
        if (bi < b.length) r.push.apply(r, b.slice(bi));
        return r;
    };
    function _ms(a) {
        if (a.length <= 1)
            return a;
        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
        left = _ms(left);
        right = _ms(right);
        return merge(left, right);
    };
    return _ms(array);
};

function set_difference(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) < 0;
    });
};

function set_intersection(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) >= 0;
    });
};

// this function is taken from Acorn [1], written by Marijn Haverbeke
// [1] https://github.com/marijnh/acorn
function makePredicate(words) {
    if (!(words instanceof Array)) words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
            }
        cats.push([words[i]]);
    }
    function compareTo(arr) {
        if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
        f += "return true}return false;";
    }
    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.
    if (cats.length > 3) {
        cats.sort(function(a, b) {return b.length - a.length;});
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
        }
        f += "}";
        // Otherwise, simply generate a flat `switch` statement.
    } else {
        compareTo(words);
    }
    return new Function("str", f);
};

function all(array, predicate) {
    for (var i = array.length; --i >= 0;)
        if (!predicate(array[i]))
            return false;
    return true;
};

function Dictionary() {
    this._values = Object.create(null);
    this._size = 0;
};
Dictionary.prototype = {
    set: function(key, val) {
        if (!this.has(key)) ++this._size;
        this._values["$" + key] = val;
        return this;
    },
    add: function(key, val) {
        if (this.has(key)) {
            this.get(key).push(val);
        } else {
            this.set(key, [ val ]);
        }
        return this;
    },
    get: function(key) { return this._values["$" + key] },
    del: function(key) {
        if (this.has(key)) {
            --this._size;
            delete this._values["$" + key];
        }
        return this;
    },
    has: function(key) { return ("$" + key) in this._values },
    each: function(f) {
        for (var i in this._values)
            f(this._values[i], i.substr(1));
    },
    size: function() {
        return this._size;
    },
    map: function(f) {
        var ret = [];
        for (var i in this._values)
            ret.push(f(this._values[i], i.substr(1)));
        return ret;
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function DEFNODE(type, props, methods, base) {
    if (arguments.length < 4) base = AST_Node;
    if (!props) props = [];
    else props = props.split(/\s+/);
    var self_props = props;
    if (base && base.PROPS)
        props = props.concat(base.PROPS);
    var code = "return function AST_" + type + "(props){ if (props) { ";
    for (var i = props.length; --i >= 0;) {
        code += "this." + props[i] + " = props." + props[i] + ";";
    }
    var proto = base && new base;
    if (proto && proto.initialize || (methods && methods.initialize))
        code += "this.initialize();";
    code += "}}";
    var ctor = new Function(code)();
    if (proto) {
        ctor.prototype = proto;
        ctor.BASE = base;
    }
    if (base) base.SUBCLASSES.push(ctor);
    ctor.prototype.CTOR = ctor;
    ctor.PROPS = props || null;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    if (type) {
        ctor.prototype.TYPE = ctor.TYPE = type;
    }
    if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
        if (/^\$/.test(i)) {
            ctor[i.substr(1)] = methods[i];
        } else {
            ctor.prototype[i] = methods[i];
        }
    }
    ctor.DEFMETHOD = function(name, method) {
        this.prototype[name] = method;
    };
    return ctor;
};

var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {
}, null);

var AST_Node = DEFNODE("Node", "start end", {
    clone: function() {
        return new this.CTOR(this);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
        start: "[AST_Token] The first token of this node",
        end: "[AST_Token] The last token of this node"
    },
    _walk: function(visitor) {
        return visitor._visit(this);
    },
    walk: function(visitor) {
        return this._walk(visitor); // not sure the indirection will be any help
    }
}, null);

AST_Node.warn_function = null;
AST_Node.warn = function(txt, props) {
    if (AST_Node.warn_function)
        AST_Node.warn_function(string_template(txt, props));
};

/* -----[ statements ]----- */

var AST_Statement = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
});

var AST_Debugger = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement",
}, AST_Statement);

var AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
        scope: "[AST_Scope/S] The scope that this directive affects"
    },
}, AST_Statement);

var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

function walk_body(node, visitor) {
    if (node.body instanceof AST_Statement) {
        node.body._walk(visitor);
    }
    else node.body.forEach(function(stat){
        stat._walk(visitor);
    });
};

var AST_Block = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually bracketed)",
    $propdoc: {
        body: "[AST_Statement*] an array of statements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
        });
    }
}, AST_Statement);

var AST_BlockStatement = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement",
}, AST_Block);

var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _walk: function(visitor) {
        return visitor._visit(this);
    }
}, AST_Statement);

var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
        label: "[AST_Label] a label definition"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.label._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_IterationStatement = DEFNODE("IterationStatement", null, {
    $documentation: "Internal class.  All loops inherit from it."
}, AST_StatementWithBody);

var AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_Do = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
}, AST_DWLoop);

var AST_While = DEFNODE("While", null, {
    $documentation: "A `while` statement",
}, AST_DWLoop);

var AST_For = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
        init: "[AST_Node?] the `for` initialization code, or null if empty",
        condition: "[AST_Node?] the `for` termination clause, or null if empty",
        step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.init) this.init._walk(visitor);
            if (this.condition) this.condition._walk(visitor);
            if (this.step) this.step._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        init: "[AST_Node] the `for/in` initialization code",
        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        object: "[AST_Node] the object that we're looping through"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_With = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
        expression: "[AST_Node] the `with` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ scope and functions ]----- */

var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
        directives: "[string*/S] an array of directives declared in this scope",
        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
    },
}, AST_Block);

var AST_Toplevel = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
    },
    wrap_enclose: function(arg_parameter_pairs) {
        var self = this;
        var args = [];
        var parameters = [];

        arg_parameter_pairs.forEach(function(pair) {
            var split = pair.split(":");

            args.push(split[0]);
            parameters.push(split[1]);
        });

        var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_Directive && node.value == "$ORIG") {
                return MAP.splice(self.body);
            }
        }));
        return wrapped_tl;
    },
    wrap_commonjs: function(name, export_all) {
        var self = this;
        var to_export = [];
        if (export_all) {
            self.figure_out_scope();
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                    if (!find_if(function(n){ return n.name == node.name }, to_export))
                        to_export.push(node);
                }
            }));
        }
        var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_SimpleStatement) {
                node = node.body;
                if (node instanceof AST_String) switch (node.getValue()) {
                  case "$ORIG":
                    return MAP.splice(self.body);
                  case "$EXPORTS":
                    var body = [];
                    to_export.forEach(function(sym){
                        body.push(new AST_SimpleStatement({
                            body: new AST_Assign({
                                left: new AST_Sub({
                                    expression: new AST_SymbolRef({ name: "exports" }),
                                    property: new AST_String({ value: sym.name }),
                                }),
                                operator: "=",
                                right: new AST_SymbolRef(sym),
                            }),
                        }));
                    });
                    return MAP.splice(body);
                }
            }
        }));
        return wrapped_tl;
    }
}, AST_Scope);

var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function",
        argnames: "[AST_SymbolFunarg*] array of function arguments",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.name) this.name._walk(visitor);
            this.argnames.forEach(function(arg){
                arg._walk(visitor);
            });
            walk_body(this, visitor);
        });
    }
}, AST_Scope);

var AST_Accessor = DEFNODE("Accessor", null, {
    $documentation: "A setter/getter function.  The `name` property is always null."
}, AST_Lambda);

var AST_Function = DEFNODE("Function", null, {
    $documentation: "A function expression"
}, AST_Lambda);

var AST_Defun = DEFNODE("Defun", null, {
    $documentation: "A function definition"
}, AST_Lambda);

/* -----[ JUMPS ]----- */

var AST_Jump = DEFNODE("Jump", null, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement);

var AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.value && function(){
            this.value._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Return = DEFNODE("Return", null, {
    $documentation: "A `return` statement"
}, AST_Exit);

var AST_Throw = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement"
}, AST_Exit);

var AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none",
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.label && function(){
            this.label._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Break = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
}, AST_LoopControl);

var AST_Continue = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
}, AST_LoopControl);

/* -----[ IF ]----- */

var AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative) this.alternative._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ SWITCH ]----- */

var AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
}, AST_Block);

var AST_Default = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch",
}, AST_SwitchBranch);

var AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_SwitchBranch);

/* -----[ EXCEPTIONS ]----- */

var AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
            if (this.bcatch) this.bcatch._walk(visitor);
            if (this.bfinally) this.bfinally._walk(visitor);
        });
    }
}, AST_Block);

// XXX: this is wrong according to ECMA-262 (12.4).  the catch block
// should introduce another scope, as the argname should be visible
// only inside the catch block.  However, doing it this way because of
// IE which simply introduces the name in the surrounding scope.  If
// we ever want to fix this then AST_Catch should inherit from
// AST_Scope.
var AST_Catch = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.argname._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_Finally = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block);

/* -----[ VAR/CONST ]----- */

var AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.definitions.forEach(function(def){
                def._walk(visitor);
            });
        });
    }
}, AST_Statement);

var AST_Var = DEFNODE("Var", null, {
    $documentation: "A `var` statement"
}, AST_Definitions);

var AST_Const = DEFNODE("Const", null, {
    $documentation: "A `const` statement"
}, AST_Definitions);

var AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.name._walk(visitor);
            if (this.value) this.value._walk(visitor);
        });
    }
});

/* -----[ OTHER ]----- */

var AST_Call = DEFNODE("Call", "expression args", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.args.forEach(function(arg){
                arg._walk(visitor);
            });
        });
    }
});

var AST_New = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
}, AST_Call);

var AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "A sequence expression (two comma-separated expressions)",
    $propdoc: {
        car: "[AST_Node] first element in sequence",
        cdr: "[AST_Node] second element in sequence"
    },
    $cons: function(x, y) {
        var seq = new AST_Seq(x);
        seq.car = x;
        seq.cdr = y;
        return seq;
    },
    $from_array: function(array) {
        if (array.length == 0) return null;
        if (array.length == 1) return array[0].clone();
        var list = null;
        for (var i = array.length; --i >= 0;) {
            list = AST_Seq.cons(array[i], list);
        }
        var p = list;
        while (p) {
            if (p.cdr && !p.cdr.cdr) {
                p.cdr = p.cdr.car;
                break;
            }
            p = p.cdr;
        }
        return list;
    },
    to_array: function() {
        var p = this, a = [];
        while (p) {
            a.push(p.car);
            if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                a.push(p.cdr);
                break;
            }
            p = p.cdr;
        }
        return a;
    },
    add: function(node) {
        var p = this;
        while (p) {
            if (!(p.cdr instanceof AST_Seq)) {
                var cell = AST_Seq.cons(p.cdr, node);
                return p.cdr = cell;
            }
            p = p.cdr;
        }
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.car._walk(visitor);
            if (this.cdr) this.cdr._walk(visitor);
        });
    }
});

var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
        expression: "[AST_Node] the “container” expression",
        property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
});

var AST_Dot = DEFNODE("Dot", null, {
    $documentation: "A dotted property access expression",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Sub = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.property._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
});

var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary);

var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary);

var AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.left._walk(visitor);
            this.right._walk(visitor);
        });
    }
});

var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
        });
    }
});

var AST_Assign = DEFNODE("Assign", null, {
    $documentation: "An assignment expression — `a = b + 5`",
}, AST_Binary);

/* -----[ LITERALS ]----- */

var AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.elements.forEach(function(el){
                el._walk(visitor);
            });
        });
    }
});

var AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.properties.forEach(function(prop){
                prop._walk(visitor);
            });
        });
    }
});

var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
        key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",
        value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.value._walk(visitor);
        });
    }
});

var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
}, AST_ObjectProperty);

var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
}, AST_ObjectProperty);

var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
}, AST_ObjectProperty);

var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols",
});

var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol);

var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol);

var AST_SymbolVar = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable",
}, AST_SymbolDeclaration);

var AST_SymbolConst = DEFNODE("SymbolConst", null, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration);

var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument",
}, AST_SymbolVar);

var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function",
}, AST_SymbolDeclaration);

var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression",
}, AST_SymbolDeclaration);

var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch",
}, AST_SymbolDeclaration);

var AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function() {
        this.references = [];
        this.thedef = this;
    }
}, AST_Symbol);

var AST_SymbolRef = DEFNODE("SymbolRef", null, {
    $documentation: "Reference to some symbol (not definition/declaration)",
}, AST_Symbol);

var AST_LabelRef = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol",
}, AST_Symbol);

var AST_This = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
}, AST_Symbol);

var AST_Constant = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    getValue: function() {
        return this.value;
    }
});

var AST_String = DEFNODE("String", "value", {
    $documentation: "A string literal",
    $propdoc: {
        value: "[string] the contents of this string"
    }
}, AST_Constant);

var AST_Number = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
        value: "[number] the numeric value"
    }
}, AST_Constant);

var AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
        value: "[RegExp] the actual regexp"
    }
}, AST_Constant);

var AST_Atom = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
}, AST_Constant);

var AST_Null = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
}, AST_Atom);

var AST_NaN = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0/0
}, AST_Atom);

var AST_Undefined = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: (function(){}())
}, AST_Atom);

var AST_Hole = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: (function(){}())
}, AST_Atom);

var AST_Infinity = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1/0
}, AST_Atom);

var AST_Boolean = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
}, AST_Atom);

var AST_False = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
}, AST_Boolean);

var AST_True = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
}, AST_Boolean);

/* -----[ TreeWalker ]----- */

function TreeWalker(callback) {
    this.visit = callback;
    this.stack = [];
};
TreeWalker.prototype = {
    _visit: function(node, descend) {
        this.stack.push(node);
        var ret = this.visit(node, descend ? function(){
            descend.call(node);
        } : noop);
        if (!ret && descend) {
            descend.call(node);
        }
        this.stack.pop();
        return ret;
    },
    parent: function(n) {
        return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function (node) {
        this.stack.push(node);
    },
    pop: function() {
        return this.stack.pop();
    },
    self: function() {
        return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
        var stack = this.stack;
        for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof type) return x;
        }
    },
    has_directive: function(type) {
        return this.find_parent(AST_Scope).has_directive(type);
    },
    in_boolean_context: function() {
        var stack = this.stack;
        var i = stack.length, self = stack[--i];
        while (i > 0) {
            var p = stack[--i];
            if ((p instanceof AST_If           && p.condition === self) ||
                (p instanceof AST_Conditional  && p.condition === self) ||
                (p instanceof AST_DWLoop       && p.condition === self) ||
                (p instanceof AST_For          && p.condition === self) ||
                (p instanceof AST_UnaryPrefix  && p.operator == "!" && p.expression === self))
            {
                return true;
            }
            if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")))
                return false;
            self = p;
        }
    },
    loopcontrol_target: function(label) {
        var stack = this.stack;
        if (label) for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                return x.body;
            }
        } else for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_Switch || x instanceof AST_IterationStatement)
                return x;
        }
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';
var KEYWORDS_ATOM = 'false null true';
var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile'
    + " " + KEYWORDS_ATOM + " " + KEYWORDS;
var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';

KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);

var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));

var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

// regexps adapted from http://xregexp.com/plugins/#unicode
var UNICODE = {
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};

function is_letter(code) {
    return (code >= 97 && code <= 122)
        || (code >= 65 && code <= 90)
        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));
};

function is_digit(code) {
    return code >= 48 && code <= 57; //XXX: find out if "UnicodeDigit" means something else than 0..9
};

function is_alphanumeric_char(code) {
    return is_digit(code) || is_letter(code);
};

function is_unicode_combining_mark(ch) {
    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
};

function is_identifier(name) {
    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
};

function is_identifier_start(code) {
    return code == 36 || code == 95 || is_letter(code);
};

function is_identifier_char(ch) {
    var code = ch.charCodeAt(0);
    return is_identifier_start(code)
        || is_digit(code)
        || code == 8204 // \u200c: zero-width non-joiner <ZWNJ>
        || code == 8205 // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        || is_unicode_combining_mark(ch)
        || is_unicode_connector_punctuation(ch)
    ;
};

function is_identifier_string(str){
    var i = str.length;
    if (i == 0) return false;
    if (!is_identifier_start(str.charCodeAt(0))) return false;
    while (--i >= 0) {
        if (!is_identifier_char(str.charAt(i)))
            return false;
    }
    return true;
};

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    } else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    } else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
};

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, filename, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT, filename, html5_comments) {

    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ''),
        filename        : filename,
        pos             : 0,
        tokpos          : 0,
        line            : 1,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };

    function peek() { return S.text.charAt(S.pos); };

    function next(signal_eof, in_string) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch)
            throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
        } else {
            ++S.col;
        }
        return ch;
    };

    function forward(i) {
        while (i-- > 0) next();
    };

    function looking_at(str) {
        return S.text.substr(S.pos, str.length) == str;
    };

    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    };

    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    };

    var prev_was_dot = false;
    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX(value)) ||
                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value)) ||
                           (type == "punc" && PUNC_BEFORE_EXPRESSION(value)));
        prev_was_dot = (type == "punc" && value == ".");
        var ret = {
            type   : type,
            value  : value,
            line   : S.tokline,
            col    : S.tokcol,
            pos    : S.tokpos,
            endpos : S.pos,
            nlb    : S.newline_before,
            file   : filename
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
            // make note of any newlines in the comments that came before
            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
            }
        }
        S.newline_before = false;
        return new AST_Token(ret);
    };

    function skip_whitespace() {
        while (WHITESPACE_CHARS(peek()))
            next();
    };

    function read_while(pred) {
        var ret = "", ch, i = 0;
        while ((ch = peek()) && pred(ch, i++))
            ret += next();
        return ret;
    };

    function parse_error(err) {
        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
    };

    function read_num(prefix) {
        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
        var num = read_while(function(ch, i){
            var code = ch.charCodeAt(0);
            switch (code) {
              case 120: case 88: // xX
                return has_x ? false : (has_x = true);
              case 101: case 69: // eE
                return has_x ? true : has_e ? false : (has_e = after_e = true);
              case 45: // -
                return after_e || (i == 0 && !prefix);
              case 43: // +
                return after_e;
              case (after_e = false, 46): // .
                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
            }
            return is_alphanumeric_char(code);
        });
        if (prefix) num = prefix + num;
        var valid = parse_js_number(num);
        if (!isNaN(valid)) {
            return token("num", valid);
        } else {
            parse_error("Invalid syntax: " + num);
        }
    };

    function read_escaped_char(in_string) {
        var ch = next(true, in_string);
        switch (ch.charCodeAt(0)) {
          case 110 : return "\n";
          case 114 : return "\r";
          case 116 : return "\t";
          case 98  : return "\b";
          case 118 : return "\u000b"; // \v
          case 102 : return "\f";
          case 48  : return "\0";
          case 120 : return String.fromCharCode(hex_bytes(2)); // \x
          case 117 : return String.fromCharCode(hex_bytes(4)); // \u
          case 10  : return ""; // newline
          default  : return ch;
        }
    };

    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit))
                parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    };

    var read_string = with_eof_error("Unterminated string constant", function(){
        var quote = next(), ret = "";
        for (;;) {
            var ch = next(true);
            if (ch == "\\") {
                // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                // https://github.com/mishoo/UglifyJS/issues/178
                var octal_len = 0, first = null;
                ch = read_while(function(ch){
                    if (ch >= "0" && ch <= "7") {
                        if (!first) {
                            first = ch;
                            return ++octal_len;
                        }
                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                    }
                    return false;
                });
                if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                else ch = read_escaped_char(true);
            }
            else if (ch == quote) break;
            ret += ch;
        }
        return token("string", ret);
    });

    function skip_line_comment(type) {
        var regex_allowed = S.regex_allowed;
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        S.comments_before.push(token(type, ret, true));
        S.regex_allowed = regex_allowed;
        return next_token();
    };

    var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function(){
        var regex_allowed = S.regex_allowed;
        var i = find("*/", true);
        var text = S.text.substring(S.pos, i);
        var a = text.split("\n"), n = a.length;
        // update stream position
        S.pos = i + 2;
        S.line += n - 1;
        if (n > 1) S.col = a[n - 1].length;
        else S.col += a[n - 1].length;
        S.col += 2;
        var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
        S.comments_before.push(token("comment2", text, true));
        S.regex_allowed = regex_allowed;
        S.newline_before = nlb;
        return next_token();
    });

    function read_name() {
        var backslash = false, name = "", ch, escaped = false, hex;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") escaped = backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        if (KEYWORDS(name) && escaped) {
            hex = name.charCodeAt(0).toString(16).toUpperCase();
            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
        }
        return name;
    };

    var read_regexp = with_eof_error("Unterminated regular expression", function(regexp){
        var prev_backslash = false, ch, in_class = false;
        while ((ch = next(true))) if (prev_backslash) {
            regexp += "\\" + ch;
            prev_backslash = false;
        } else if (ch == "[") {
            in_class = true;
            regexp += ch;
        } else if (ch == "]" && in_class) {
            in_class = false;
            regexp += ch;
        } else if (ch == "/" && !in_class) {
            break;
        } else if (ch == "\\") {
            prev_backslash = true;
        } else {
            regexp += ch;
        }
        var mods = read_name();
        return token("regexp", new RegExp(regexp, mods));
    });

    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (OPERATORS(bigger)) {
                next();
                return grow(bigger);
            } else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    };

    function handle_slash() {
        next();
        switch (peek()) {
          case "/":
            next();
            return skip_line_comment("comment1");
          case "*":
            next();
            return skip_multiline_comment();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    };

    function handle_dot() {
        next();
        return is_digit(peek().charCodeAt(0))
            ? read_num(".")
            : token("punc", ".");
    };

    function read_word() {
        var word = read_name();
        if (prev_was_dot) return token("name", word);
        return KEYWORDS_ATOM(word) ? token("atom", word)
            : !KEYWORDS(word) ? token("name", word)
            : OPERATORS(word) ? token("operator", word)
            : token("keyword", word);
    };

    function with_eof_error(eof_error, cont) {
        return function(x) {
            try {
                return cont(x);
            } catch(ex) {
                if (ex === EX_EOF) parse_error(eof_error);
                else throw ex;
            }
        };
    };

    function next_token(force_regexp) {
        if (force_regexp != null)
            return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        if (html5_comments) {
            if (looking_at("<!--")) {
                forward(4);
                return skip_line_comment("comment3");
            }
            if (looking_at("-->") && S.newline_before) {
                forward(3);
                return skip_line_comment("comment4");
            }
        }
        var ch = peek();
        if (!ch) return token("eof");
        var code = ch.charCodeAt(0);
        switch (code) {
          case 34: case 39: return read_string();
          case 46: return handle_dot();
          case 47: return handle_slash();
        }
        if (is_digit(code)) return read_num();
        if (PUNC_CHARS(ch)) return token("punc", next());
        if (OPERATOR_CHARS(ch)) return read_operator();
        if (code == 92 || is_identifier_start(code)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    };

    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };

    return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
]);

var UNARY_POSTFIX = makePredicate([ "--", "++" ]);

var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);

var PRECEDENCE = (function(a, ret){
    for (var i = 0; i < a.length; ++i) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = i + 1;
        }
    }
    return ret;
})(
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ],
    {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function parse($TEXT, options) {

    options = defaults(options, {
        strict         : false,
        filename       : null,
        toplevel       : null,
        expression     : false,
        html5_comments : true,
    });

    var S = {
        input         : (typeof $TEXT == "string"
                         ? tokenizer($TEXT, options.filename,
                                     options.html5_comments)
                         : $TEXT),
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    };

    function peek() { return S.peeked || (S.peeked = S.input()); };

    function next() {
        S.prev = S.token;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        } else {
            S.token = S.input();
        }
        S.in_directives = S.in_directives && (
            S.token.type == "string" || is("punc", ";")
        );
        return S.token;
    };

    function prev() {
        return S.prev;
    };

    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 ctx.filename,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    };

    function token_error(token, msg) {
        croak(msg, token.line, token.col);
    };

    function unexpected(token) {
        if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
    };

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
    };

    function expect(punc) { return expect_token("punc", punc); };

    function can_insert_semicolon() {
        return !options.strict && (
            S.token.nlb || is("eof") || is("punc", "}")
        );
    };

    function semicolon() {
        if (is("punc", ";")) next();
        else if (!can_insert_semicolon()) unexpected();
    };

    function parenthesised() {
        expect("(");
        var exp = expression(true);
        expect(")");
        return exp;
    };

    function embed_tokens(parser) {
        return function() {
            var start = S.token;
            var expr = parser();
            var end = prev();
            expr.start = start;
            expr.end = end;
            return expr;
        };
    };

    function handle_regexp() {
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
    };

    var statement = embed_tokens(function() {
        var tmp;
        handle_regexp();
        switch (S.token.type) {
          case "string":
            var dir = S.in_directives, stat = simple_statement();
            // XXXv2: decide how to fix directives
            if (dir && stat.body instanceof AST_String && !is("punc", ","))
                return new AST_Directive({ value: stat.body.value });
            return stat;
          case "num":
          case "regexp":
          case "operator":
          case "atom":
            return simple_statement();

          case "name":
            return is_token(peek(), "punc", ":")
                ? labeled_statement()
                : simple_statement();

          case "punc":
            switch (S.token.value) {
              case "{":
                return new AST_BlockStatement({
                    start : S.token,
                    body  : block_(),
                    end   : prev()
                });
              case "[":
              case "(":
                return simple_statement();
              case ";":
                next();
                return new AST_EmptyStatement();
              default:
                unexpected();
            }

          case "keyword":
            switch (tmp = S.token.value, next(), tmp) {
              case "break":
                return break_cont(AST_Break);

              case "continue":
                return break_cont(AST_Continue);

              case "debugger":
                semicolon();
                return new AST_Debugger();

              case "do":
                return new AST_Do({
                    body      : in_loop(statement),
                    condition : (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), tmp)
                });

              case "while":
                return new AST_While({
                    condition : parenthesised(),
                    body      : in_loop(statement)
                });

              case "for":
                return for_();

              case "function":
                return function_(AST_Defun);

              case "if":
                return if_();

              case "return":
                if (S.in_function == 0)
                    croak("'return' outside of function");
                return new AST_Return({
                    value: ( is("punc", ";")
                             ? (next(), null)
                             : can_insert_semicolon()
                             ? null
                             : (tmp = expression(true), semicolon(), tmp) )
                });

              case "switch":
                return new AST_Switch({
                    expression : parenthesised(),
                    body       : in_loop(switch_body_)
                });

              case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return new AST_Throw({
                    value: (tmp = expression(true), semicolon(), tmp)
                });

              case "try":
                return try_();

              case "var":
                return tmp = var_(), semicolon(), tmp;

              case "const":
                return tmp = const_(), semicolon(), tmp;

              case "with":
                return new AST_With({
                    expression : parenthesised(),
                    body       : statement()
                });

              default:
                unexpected();
            }
        }
    });

    function labeled_statement() {
        var label = as_symbol(AST_Label);
        if (find_if(function(l){ return l.name == label.name }, S.labels)) {
            // ECMA-262, 12.12: An ECMAScript program is considered
            // syntactically incorrect if it contains a
            // LabelledStatement that is enclosed by a
            // LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice");
        }
        expect(":");
        S.labels.push(label);
        var stat = statement();
        S.labels.pop();
        if (!(stat instanceof AST_IterationStatement)) {
            // check for `continue` that refers to this label.
            // those should be reported as syntax errors.
            // https://github.com/mishoo/UglifyJS2/issues/287
            label.references.forEach(function(ref){
                if (ref instanceof AST_Continue) {
                    ref = ref.label.start;
                    croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
                          ref.line, ref.col, ref.pos);
                }
            });
        }
        return new AST_LabeledStatement({ body: stat, label: label });
    };

    function simple_statement(tmp) {
        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
    };

    function break_cont(type) {
        var label = null, ldef;
        if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
        }
        if (label != null) {
            ldef = find_if(function(l){ return l.name == label.name }, S.labels);
            if (!ldef)
                croak("Undefined label " + label.name);
            label.thedef = ldef;
        }
        else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
        semicolon();
        var stat = new type({ label: label });
        if (ldef) ldef.references.push(stat);
        return stat;
    };

    function for_() {
        expect("(");
        var init = null;
        if (!is("punc", ";")) {
            init = is("keyword", "var")
                ? (next(), var_(true))
                : expression(true, true);
            if (is("operator", "in")) {
                if (init instanceof AST_Var && init.definitions.length > 1)
                    croak("Only one variable declaration allowed in for..in loop");
                next();
                return for_in(init);
            }
        }
        return regular_for(init);
    };

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression(true);
        expect(";");
        var step = is("punc", ")") ? null : expression(true);
        expect(")");
        return new AST_For({
            init      : init,
            condition : test,
            step      : step,
            body      : in_loop(statement)
        });
    };

    function for_in(init) {
        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
        var obj = expression(true);
        expect(")");
        return new AST_ForIn({
            init   : init,
            name   : lhs,
            object : obj,
            body   : in_loop(statement)
        });
    };

    var function_ = function(ctor) {
        var in_statement = ctor === AST_Defun;
        var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
        if (in_statement && !name)
            unexpected();
        expect("(");
        return new ctor({
            name: name,
            argnames: (function(first, a){
                while (!is("punc", ")")) {
                    if (first) first = false; else expect(",");
                    a.push(as_symbol(AST_SymbolFunarg));
                }
                next();
                return a;
            })(true, []),
            body: (function(loop, labels){
                ++S.in_function;
                S.in_directives = true;
                S.in_loop = 0;
                S.labels = [];
                var a = block_();
                --S.in_function;
                S.in_loop = loop;
                S.labels = labels;
                return a;
            })(S.in_loop, S.labels)
        });
    };

    function if_() {
        var cond = parenthesised(), body = statement(), belse = null;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return new AST_If({
            condition   : cond,
            body        : body,
            alternative : belse
        });
    };

    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            a.push(statement());
        }
        next();
        return a;
    };

    function switch_body_() {
        expect("{");
        var a = [], cur = null, branch = null, tmp;
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            if (is("keyword", "case")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Case({
                    start      : (tmp = S.token, next(), tmp),
                    expression : expression(true),
                    body       : cur
                });
                a.push(branch);
                expect(":");
            }
            else if (is("keyword", "default")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Default({
                    start : (tmp = S.token, next(), expect(":"), tmp),
                    body  : cur
                });
                a.push(branch);
            }
            else {
                if (!cur) unexpected();
                cur.push(statement());
            }
        }
        if (branch) branch.end = prev();
        next();
        return a;
    };

    function try_() {
        var body = block_(), bcatch = null, bfinally = null;
        if (is("keyword", "catch")) {
            var start = S.token;
            next();
            expect("(");
            var name = as_symbol(AST_SymbolCatch);
            expect(")");
            bcatch = new AST_Catch({
                start   : start,
                argname : name,
                body    : block_(),
                end     : prev()
            });
        }
        if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
                start : start,
                body  : block_(),
                end   : prev()
            });
        }
        if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
        return new AST_Try({
            body     : body,
            bcatch   : bcatch,
            bfinally : bfinally
        });
    };

    function vardefs(no_in, in_const) {
        var a = [];
        for (;;) {
            a.push(new AST_VarDef({
                start : S.token,
                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                value : is("operator", "=") ? (next(), expression(false, no_in)) : null,
                end   : prev()
            }));
            if (!is("punc", ","))
                break;
            next();
        }
        return a;
    };

    var var_ = function(no_in) {
        return new AST_Var({
            start       : prev(),
            definitions : vardefs(no_in, false),
            end         : prev()
        });
    };

    var const_ = function() {
        return new AST_Const({
            start       : prev(),
            definitions : vardefs(false, true),
            end         : prev()
        });
    };

    var new_ = function() {
        var start = S.token;
        expect_token("operator", "new");
        var newexp = expr_atom(false), args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        } else {
            args = [];
        }
        return subscripts(new AST_New({
            start      : start,
            expression : newexp,
            args       : args,
            end        : prev()
        }), true);
    };

    function as_atom_node() {
        var tok = S.token, ret;
        switch (tok.type) {
          case "name":
          case "keyword":
            ret = _make_symbol(AST_SymbolRef);
            break;
          case "num":
            ret = new AST_Number({ start: tok, end: tok, value: tok.value });
            break;
          case "string":
            ret = new AST_String({ start: tok, end: tok, value: tok.value });
            break;
          case "regexp":
            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });
            break;
          case "atom":
            switch (tok.value) {
              case "false":
                ret = new AST_False({ start: tok, end: tok });
                break;
              case "true":
                ret = new AST_True({ start: tok, end: tok });
                break;
              case "null":
                ret = new AST_Null({ start: tok, end: tok });
                break;
            }
            break;
        }
        next();
        return ret;
    };

    var expr_atom = function(allow_calls) {
        if (is("operator", "new")) {
            return new_();
        }
        var start = S.token;
        if (is("punc")) {
            switch (start.value) {
              case "(":
                next();
                var ex = expression(true);
                ex.start = start;
                ex.end = S.token;
                expect(")");
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_(), allow_calls);
            }
            unexpected();
        }
        if (is("keyword", "function")) {
            next();
            var func = function_(AST_Function);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
        }
        if (ATOMIC_START_TOKEN[S.token.type]) {
            return subscripts(as_atom_node(), allow_calls);
        }
        unexpected();
    };

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true, a = [];
        while (!is("punc", closing)) {
            if (first) first = false; else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    };

    var array_ = embed_tokens(function() {
        expect("[");
        return new AST_Array({
            elements: expr_list("]", !options.strict, true)
        });
    });

    var object_ = embed_tokens(function() {
        expect("{");
        var first = true, a = [];
        while (!is("punc", "}")) {
            if (first) first = false; else expect(",");
            if (!options.strict && is("punc", "}"))
                // allow trailing comma
                break;
            var start = S.token;
            var type = start.type;
            var name = as_property_name();
            if (type == "name" && !is("punc", ":")) {
                if (name == "get") {
                    a.push(new AST_ObjectGetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
                if (name == "set") {
                    a.push(new AST_ObjectSetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
            }
            expect(":");
            a.push(new AST_ObjectKeyVal({
                start : start,
                key   : name,
                value : expression(false),
                end   : prev()
            }));
        }
        next();
        return new AST_Object({ properties: a });
    });

    function as_property_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "num":
          case "string":
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function as_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function _make_symbol(type) {
        var name = S.token.value;
        return new (name == "this" ? AST_This : type)({
            name  : String(name),
            start : S.token,
            end   : S.token
        });
    };

    function as_symbol(type, noerror) {
        if (!is("name")) {
            if (!noerror) croak("Name expected");
            return null;
        }
        var sym = _make_symbol(type);
        next();
        return sym;
    };

    var subscripts = function(expr, allow_calls) {
        var start = expr.start;
        if (is("punc", ".")) {
            next();
            return subscripts(new AST_Dot({
                start      : start,
                expression : expr,
                property   : as_name(),
                end        : prev()
            }), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return subscripts(new AST_Sub({
                start      : start,
                expression : expr,
                property   : prop,
                end        : prev()
            }), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(new AST_Call({
                start      : start,
                expression : expr,
                args       : expr_list(")"),
                end        : prev()
            }), true);
        }
        return expr;
    };

    var maybe_unary = function(allow_calls) {
        var start = S.token;
        if (is("operator") && UNARY_PREFIX(start.value)) {
            next();
            handle_regexp();
            var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
            val = make_unary(AST_UnaryPostfix, S.token.value, val);
            val.start = start;
            val.end = S.token;
            next();
        }
        return val;
    };

    function make_unary(ctor, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr))
            croak("Invalid use of " + op + " operator");
        return new ctor({ operator: op, expression: expr });
    };

    var expr_op = function(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(new AST_Binary({
                start    : left.start,
                left     : left,
                operator : op,
                right    : right,
                end      : right.end
            }), min_prec, no_in);
        }
        return left;
    };

    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    };

    var maybe_conditional = function(no_in) {
        var start = S.token;
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
                start       : start,
                condition   : expr,
                consequent  : yes,
                alternative : expression(false, no_in),
                end         : peek()
            });
        }
        return expr;
    };

    function is_assignable(expr) {
        if (!options.strict) return true;
        if (expr instanceof AST_This) return false;
        return (expr instanceof AST_PropAccess || expr instanceof AST_Symbol);
    };

    var maybe_assign = function(no_in) {
        var start = S.token;
        var left = maybe_conditional(no_in), val = S.token.value;
        if (is("operator") && ASSIGNMENT(val)) {
            if (is_assignable(left)) {
                next();
                return new AST_Assign({
                    start    : start,
                    left     : left,
                    operator : val,
                    right    : maybe_assign(no_in),
                    end      : prev()
                });
            }
            croak("Invalid assignment");
        }
        return left;
    };

    var expression = function(commas, no_in) {
        var start = S.token;
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return new AST_Seq({
                start  : start,
                car    : expr,
                cdr    : expression(true, no_in),
                end    : peek()
            });
        }
        return expr;
    };

    function in_loop(cont) {
        ++S.in_loop;
        var ret = cont();
        --S.in_loop;
        return ret;
    };

    if (options.expression) {
        return expression(true);
    }

    return (function(){
        var start = S.token;
        var body = [];
        while (!is("eof"))
            body.push(statement());
        var end = prev();
        var toplevel = options.toplevel;
        if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
        } else {
            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
        }
        return toplevel;
    })();

};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// Tree transformer helpers.

function TreeTransformer(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
}
TreeTransformer.prototype = new TreeWalker;

(function(undefined){

    function _(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list){
            var x, y;
            tw.push(this);
            if (tw.before) x = tw.before(this, descend, in_list);
            if (x === undefined) {
                if (!tw.after) {
                    x = this;
                    descend(x, tw);
                } else {
                    tw.stack[tw.stack.length - 1] = x = this.clone();
                    descend(x, tw);
                    y = tw.after(x, in_list);
                    if (y !== undefined) x = y;
                }
            }
            tw.pop();
            return x;
        });
    };

    function do_list(list, tw) {
        return MAP(list, function(node){
            return node.transform(tw, true);
        });
    };

    _(AST_Node, noop);

    _(AST_LabeledStatement, function(self, tw){
        self.label = self.label.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_SimpleStatement, function(self, tw){
        self.body = self.body.transform(tw);
    });

    _(AST_Block, function(self, tw){
        self.body = do_list(self.body, tw);
    });

    _(AST_DWLoop, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_For, function(self, tw){
        if (self.init) self.init = self.init.transform(tw);
        if (self.condition) self.condition = self.condition.transform(tw);
        if (self.step) self.step = self.step.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_ForIn, function(self, tw){
        self.init = self.init.transform(tw);
        self.object = self.object.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_With, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_Exit, function(self, tw){
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_LoopControl, function(self, tw){
        if (self.label) self.label = self.label.transform(tw);
    });

    _(AST_If, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
        if (self.alternative) self.alternative = self.alternative.transform(tw);
    });

    _(AST_Switch, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Case, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Try, function(self, tw){
        self.body = do_list(self.body, tw);
        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
    });

    _(AST_Catch, function(self, tw){
        self.argname = self.argname.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Definitions, function(self, tw){
        self.definitions = do_list(self.definitions, tw);
    });

    _(AST_VarDef, function(self, tw){
        self.name = self.name.transform(tw);
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_Lambda, function(self, tw){
        if (self.name) self.name = self.name.transform(tw);
        self.argnames = do_list(self.argnames, tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Call, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.args = do_list(self.args, tw);
    });

    _(AST_Seq, function(self, tw){
        self.car = self.car.transform(tw);
        self.cdr = self.cdr.transform(tw);
    });

    _(AST_Dot, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Sub, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.property = self.property.transform(tw);
    });

    _(AST_Unary, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Binary, function(self, tw){
        self.left = self.left.transform(tw);
        self.right = self.right.transform(tw);
    });

    _(AST_Conditional, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.consequent = self.consequent.transform(tw);
        self.alternative = self.alternative.transform(tw);
    });

    _(AST_Array, function(self, tw){
        self.elements = do_list(self.elements, tw);
    });

    _(AST_Object, function(self, tw){
        self.properties = do_list(self.properties, tw);
    });

    _(AST_ObjectProperty, function(self, tw){
        self.value = self.value.transform(tw);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function SymbolDef(scope, index, orig) {
    this.name = orig.name;
    this.orig = [ orig ];
    this.scope = scope;
    this.references = [];
    this.global = false;
    this.mangled_name = null;
    this.undeclared = false;
    this.constant = false;
    this.index = index;
};

SymbolDef.prototype = {
    unmangleable: function(options) {
        return (this.global && !(options && options.toplevel))
            || this.undeclared
            || (!(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with));
    },
    mangle: function(options) {
        if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            if (!options.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda)
                s = s.parent_scope;
            this.mangled_name = s.next_mangled(options, this);
        }
    }
};

AST_Toplevel.DEFMETHOD("figure_out_scope", function(){
    // This does what ast_add_scope did in UglifyJS v1.
    //
    // Part of it could be done at parse time, but it would complicate
    // the parser (and it's already kinda complex).  It's also worth
    // having it separated because we might need to call it multiple
    // times on the same tree.

    // pass 1: setup scope chaining and handle definitions
    var self = this;
    var scope = self.parent_scope = null;
    var nesting = 0;
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Scope) {
            node.init_scope_vars(nesting);
            var save_scope = node.parent_scope = scope;
            ++nesting;
            scope = node;
            descend();
            scope = save_scope;
            --nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Directive) {
            node.scope = scope;
            push_uniq(scope.directives, node.value);
            return true;
        }
        if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
                s.uses_with = true;
            return;
        }
        if (node instanceof AST_Symbol) {
            node.scope = scope;
        }
        if (node instanceof AST_SymbolLambda) {
            scope.def_function(node);
        }
        else if (node instanceof AST_SymbolDefun) {
            // Careful here, the scope where this should be defined is
            // the parent scope.  The reason is that we enter a new
            // scope when we encounter the AST_Defun node (which is
            // instanceof AST_Scope) but we get to the symbol a bit
            // later.
            (node.scope = scope.parent_scope).def_function(node);
        }
        else if (node instanceof AST_SymbolVar
                 || node instanceof AST_SymbolConst) {
            var def = scope.def_variable(node);
            def.constant = node instanceof AST_SymbolConst;
            def.init = tw.parent().value;
        }
        else if (node instanceof AST_SymbolCatch) {
            // XXX: this is wrong according to ECMA-262 (12.4).  the
            // `catch` argument name should be visible only inside the
            // catch block.  For a quick fix AST_Catch should inherit
            // from AST_Scope.  Keeping it this way because of IE,
            // which doesn't obey the standard. (it introduces the
            // identifier in the enclosing scope)
            scope.def_variable(node);
        }
    });
    self.walk(tw);

    // pass 2: find back references and eval
    var func = null;
    var globals = self.globals = new Dictionary();
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Lambda) {
            var prev_func = func;
            func = node;
            descend();
            func = prev_func;
            return true;
        }
        if (node instanceof AST_SymbolRef) {
            var name = node.name;
            var sym = node.scope.find_variable(name);
            if (!sym) {
                var g;
                if (globals.has(name)) {
                    g = globals.get(name);
                } else {
                    g = new SymbolDef(self, globals.size(), node);
                    g.undeclared = true;
                    g.global = true;
                    globals.set(name, g);
                }
                node.thedef = g;
                if (name == "eval" && tw.parent() instanceof AST_Call) {
                    for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope)
                        s.uses_eval = true;
                }
                if (func && name == "arguments") {
                    func.uses_arguments = true;
                }
            } else {
                node.thedef = sym;
            }
            node.reference();
            return true;
        }
    });
    self.walk(tw);
});

AST_Scope.DEFMETHOD("init_scope_vars", function(nesting){
    this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
    this.variables = new Dictionary(); // map name to AST_SymbolVar (variables defined in this scope; includes functions)
    this.functions = new Dictionary(); // map name to AST_SymbolDefun (functions defined in this scope)
    this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
    this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
    this.parent_scope = null; // the parent scope
    this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
    this.cname = -1;          // the current index for mangling functions/variables
    this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
});

AST_Scope.DEFMETHOD("strict", function(){
    return this.has_directive("use strict");
});

AST_Lambda.DEFMETHOD("init_scope_vars", function(){
    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
    this.uses_arguments = false;
});

AST_SymbolRef.DEFMETHOD("reference", function() {
    var def = this.definition();
    def.references.push(this);
    var s = this.scope;
    while (s) {
        push_uniq(s.enclosed, def);
        if (s === def.scope) break;
        s = s.parent_scope;
    }
    this.frame = this.scope.nesting - def.scope.nesting;
});

AST_Scope.DEFMETHOD("find_variable", function(name){
    if (name instanceof AST_Symbol) name = name.name;
    return this.variables.get(name)
        || (this.parent_scope && this.parent_scope.find_variable(name));
});

AST_Scope.DEFMETHOD("has_directive", function(value){
    return this.parent_scope && this.parent_scope.has_directive(value)
        || (this.directives.indexOf(value) >= 0 ? this : null);
});

AST_Scope.DEFMETHOD("def_function", function(symbol){
    this.functions.set(symbol.name, this.def_variable(symbol));
});

AST_Scope.DEFMETHOD("def_variable", function(symbol){
    var def;
    if (!this.variables.has(symbol.name)) {
        def = new SymbolDef(this, this.variables.size(), symbol);
        this.variables.set(symbol.name, def);
        def.global = !this.parent_scope;
    } else {
        def = this.variables.get(symbol.name);
        def.orig.push(symbol);
    }
    return symbol.thedef = def;
});

AST_Scope.DEFMETHOD("next_mangled", function(options){
    var ext = this.enclosed;
    out: while (true) {
        var m = base54(++this.cname);
        if (!is_identifier(m)) continue; // skip over "do"
        // we must ensure that the mangled name does not shadow a name
        // from some parent scope that is referenced in this or in
        // inner scopes.
        for (var i = ext.length; --i >= 0;) {
            var sym = ext[i];
            var name = sym.mangled_name || (sym.unmangleable(options) && sym.name);
            if (m == name) continue out;
        }
        return m;
    }
});

AST_Function.DEFMETHOD("next_mangled", function(options, def){
    // #179, #326
    // in Safari strict mode, something like (function x(x){...}) is a syntax error;
    // a function expression's argument cannot shadow the function expression's name

    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
    while (true) {
        var name = AST_Lambda.prototype.next_mangled.call(this, options, def);
        if (!(tricky_def && tricky_def.mangled_name == name))
            return name;
    }
});

AST_Scope.DEFMETHOD("references", function(sym){
    if (sym instanceof AST_Symbol) sym = sym.definition();
    return this.enclosed.indexOf(sym) < 0 ? null : sym;
});

AST_Symbol.DEFMETHOD("unmangleable", function(options){
    return this.definition().unmangleable(options);
});

// property accessors are not mangleable
AST_SymbolAccessor.DEFMETHOD("unmangleable", function(){
    return true;
});

// labels are always mangleable
AST_Label.DEFMETHOD("unmangleable", function(){
    return false;
});

AST_Symbol.DEFMETHOD("unreferenced", function(){
    return this.definition().references.length == 0
        && !(this.scope.uses_eval || this.scope.uses_with);
});

AST_Symbol.DEFMETHOD("undeclared", function(){
    return this.definition().undeclared;
});

AST_LabelRef.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Label.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Symbol.DEFMETHOD("definition", function(){
    return this.thedef;
});

AST_Symbol.DEFMETHOD("global", function(){
    return this.definition().global;
});

AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options){
    return defaults(options, {
        except   : [],
        eval     : false,
        sort     : false,
        toplevel : false,
        screw_ie8 : false
    });
});

AST_Toplevel.DEFMETHOD("mangle_names", function(options){
    options = this._default_mangler_options(options);
    // We only need to mangle declaration nodes.  Special logic wired
    // into the code generator will display the mangled name if it's
    // present (and for AST_SymbolRef-s it'll use the mangled name of
    // the AST_SymbolDeclaration that it points to).
    var lname = -1;
    var to_mangle = [];
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_LabeledStatement) {
            // lname is incremented when we get to the AST_Label
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Scope) {
            var p = tw.parent(), a = [];
            node.variables.each(function(symbol){
                if (options.except.indexOf(symbol.name) < 0) {
                    a.push(symbol);
                }
            });
            if (options.sort) a.sort(function(a, b){
                return b.references.length - a.references.length;
            });
            to_mangle.push.apply(to_mangle, a);
            return;
        }
        if (node instanceof AST_Label) {
            var name;
            do name = base54(++lname); while (!is_identifier(name));
            node.mangled_name = name;
            return true;
        }
    });
    this.walk(tw);
    to_mangle.forEach(function(def){ def.mangle(options) });
});

AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options){
    options = this._default_mangler_options(options);
    var tw = new TreeWalker(function(node){
        if (node instanceof AST_Constant)
            base54.consider(node.print_to_string());
        else if (node instanceof AST_Return)
            base54.consider("return");
        else if (node instanceof AST_Throw)
            base54.consider("throw");
        else if (node instanceof AST_Continue)
            base54.consider("continue");
        else if (node instanceof AST_Break)
            base54.consider("break");
        else if (node instanceof AST_Debugger)
            base54.consider("debugger");
        else if (node instanceof AST_Directive)
            base54.consider(node.value);
        else if (node instanceof AST_While)
            base54.consider("while");
        else if (node instanceof AST_Do)
            base54.consider("do while");
        else if (node instanceof AST_If) {
            base54.consider("if");
            if (node.alternative) base54.consider("else");
        }
        else if (node instanceof AST_Var)
            base54.consider("var");
        else if (node instanceof AST_Const)
            base54.consider("const");
        else if (node instanceof AST_Lambda)
            base54.consider("function");
        else if (node instanceof AST_For)
            base54.consider("for");
        else if (node instanceof AST_ForIn)
            base54.consider("for in");
        else if (node instanceof AST_Switch)
            base54.consider("switch");
        else if (node instanceof AST_Case)
            base54.consider("case");
        else if (node instanceof AST_Default)
            base54.consider("default");
        else if (node instanceof AST_With)
            base54.consider("with");
        else if (node instanceof AST_ObjectSetter)
            base54.consider("set" + node.key);
        else if (node instanceof AST_ObjectGetter)
            base54.consider("get" + node.key);
        else if (node instanceof AST_ObjectKeyVal)
            base54.consider(node.key);
        else if (node instanceof AST_New)
            base54.consider("new");
        else if (node instanceof AST_This)
            base54.consider("this");
        else if (node instanceof AST_Try)
            base54.consider("try");
        else if (node instanceof AST_Catch)
            base54.consider("catch");
        else if (node instanceof AST_Finally)
            base54.consider("finally");
        else if (node instanceof AST_Symbol && node.unmangleable(options))
            base54.consider(node.name);
        else if (node instanceof AST_Unary || node instanceof AST_Binary)
            base54.consider(node.operator);
        else if (node instanceof AST_Dot)
            base54.consider(node.property);
    });
    this.walk(tw);
    base54.sort();
});

var base54 = (function() {
    var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
    var chars, frequency;
    function reset() {
        frequency = Object.create(null);
        chars = string.split("").map(function(ch){ return ch.charCodeAt(0) });
        chars.forEach(function(ch){ frequency[ch] = 0 });
    }
    base54.consider = function(str){
        for (var i = str.length; --i >= 0;) {
            var code = str.charCodeAt(i);
            if (code in frequency) ++frequency[code];
        }
    };
    base54.sort = function() {
        chars = mergeSort(chars, function(a, b){
            if (is_digit(a) && !is_digit(b)) return 1;
            if (is_digit(b) && !is_digit(a)) return -1;
            return frequency[b] - frequency[a];
        });
    };
    base54.reset = reset;
    reset();
    base54.get = function(){ return chars };
    base54.freq = function(){ return frequency };
    function base54(num) {
        var ret = "", base = 54;
        do {
            ret += String.fromCharCode(chars[num % base]);
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    };
    return base54;
})();

AST_Toplevel.DEFMETHOD("scope_warnings", function(options){
    options = defaults(options, {
        undeclared       : false, // this makes a lot of noise
        unreferenced     : true,
        assign_to_global : true,
        func_arguments   : true,
        nested_defuns    : true,
        eval             : true
    });
    var tw = new TreeWalker(function(node){
        if (options.undeclared
            && node instanceof AST_SymbolRef
            && node.undeclared())
        {
            // XXX: this also warns about JS standard names,
            // i.e. Object, Array, parseInt etc.  Should add a list of
            // exceptions.
            AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.assign_to_global)
        {
            var sym = null;
            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)
                sym = node.left;
            else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)
                sym = node.init;
            if (sym
                && (sym.undeclared()
                    || (sym.global() && sym.scope !== sym.definition().scope))) {
                AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                    msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                    name: sym.name,
                    file: sym.start.file,
                    line: sym.start.line,
                    col: sym.start.col
                });
            }
        }
        if (options.eval
            && node instanceof AST_SymbolRef
            && node.undeclared()
            && node.name == "eval") {
            AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
        }
        if (options.unreferenced
            && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label)
            && node.unreferenced()) {
            AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                type: node instanceof AST_Label ? "Label" : "Symbol",
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.func_arguments
            && node instanceof AST_Lambda
            && node.uses_arguments) {
            AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                name: node.name ? node.name.name : "anonymous",
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.nested_defuns
            && node instanceof AST_Defun
            && !(tw.parent() instanceof AST_Scope)) {
            AST_Node.warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                name: node.name.name,
                type: tw.parent().TYPE,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
    });
    this.walk(tw);
});

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function OutputStream(options) {

    options = defaults(options, {
        indent_start  : 0,
        indent_level  : 4,
        quote_keys    : false,
        space_colon   : true,
        ascii_only    : false,
        inline_script : false,
        width         : 80,
        max_line_len  : 32000,
        beautify      : false,
        source_map    : null,
        bracketize    : false,
        semicolons    : true,
        comments      : false,
        preserve_line : false,
        screw_ie8     : false,
        preamble      : null,
    }, true);

    var indentation = 0;
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var OUTPUT = "";

    function to_ascii(str, identifier) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
                while (code.length < 2) code = "0" + code;
                return "\\x" + code;
            } else {
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
            }
        });
    };

    function make_string(str) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
            switch (s) {
              case "\\": return "\\\\";
              case "\b": return "\\b";
              case "\f": return "\\f";
              case "\n": return "\\n";
              case "\r": return "\\r";
              case "\u2028": return "\\u2028";
              case "\u2029": return "\\u2029";
              case '"': ++dq; return '"';
              case "'": ++sq; return "'";
              case "\0": return "\\x00";
            }
            return s;
        });
        if (options.ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
    };

    function encode_string(str) {
        var ret = make_string(str);
        if (options.inline_script)
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
        return ret;
    };

    function make_name(name) {
        name = name.toString();
        if (options.ascii_only)
            name = to_ascii(name, true);
        return name;
    };

    function make_indent(back) {
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
    };

    /* -----[ beautification/minification ]----- */

    var might_need_space = false;
    var might_need_semicolon = false;
    var last = null;

    function last_char() {
        return last.charAt(last.length - 1);
    };

    function maybe_newline() {
        if (options.max_line_len && current_col > options.max_line_len)
            print("\n");
    };

    var requireSemicolonChars = makePredicate("( [ + * / - , .");

    function print(str) {
        str = String(str);
        var ch = str.charAt(0);
        if (might_need_semicolon) {
            if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                if (options.semicolons || requireSemicolonChars(ch)) {
                    OUTPUT += ";";
                    current_col++;
                    current_pos++;
                } else {
                    OUTPUT += "\n";
                    current_pos++;
                    current_line++;
                    current_col = 0;
                }
                if (!options.beautify)
                    might_need_space = false;
            }
            might_need_semicolon = false;
            maybe_newline();
        }

        if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
            var target_line = stack[stack.length - 1].start.line;
            while (current_line < target_line) {
                OUTPUT += "\n";
                current_pos++;
                current_line++;
                current_col = 0;
                might_need_space = false;
            }
        }

        if (might_need_space) {
            var prev = last_char();
            if ((is_identifier_char(prev)
                 && (is_identifier_char(ch) || ch == "\\"))
                || (/^[\+\-\/]$/.test(ch) && ch == prev))
            {
                OUTPUT += " ";
                current_col++;
                current_pos++;
            }
            might_need_space = false;
        }
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        if (n == 0) {
            current_col += a[n].length;
        } else {
            current_col = a[n].length;
        }
        current_pos += str.length;
        last = str;
        OUTPUT += str;
    };

    var space = options.beautify ? function() {
        print(" ");
    } : function() {
        might_need_space = true;
    };

    var indent = options.beautify ? function(half) {
        if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
        }
    } : noop;

    var with_indent = options.beautify ? function(col, cont) {
        if (col === true) col = next_indent();
        var save_indentation = indentation;
        indentation = col;
        var ret = cont();
        indentation = save_indentation;
        return ret;
    } : function(col, cont) { return cont() };

    var newline = options.beautify ? function() {
        print("\n");
    } : noop;

    var semicolon = options.beautify ? function() {
        print(";");
    } : function() {
        might_need_semicolon = true;
    };

    function force_semicolon() {
        might_need_semicolon = false;
        print(";");
    };

    function next_indent() {
        return indentation + options.indent_level;
    };

    function with_block(cont) {
        var ret;
        print("{");
        newline();
        with_indent(next_indent(), function(){
            ret = cont();
        });
        indent();
        print("}");
        return ret;
    };

    function with_parens(cont) {
        print("(");
        //XXX: still nice to have that for argument lists
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print(")");
        return ret;
    };

    function with_square(cont) {
        print("[");
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print("]");
        return ret;
    };

    function comma() {
        print(",");
        space();
    };

    function colon() {
        print(":");
        if (options.space_colon) space();
    };

    var add_mapping = options.source_map ? function(token, name) {
        try {
            if (token) options.source_map.add(
                token.file || "?",
                current_line, current_col,
                token.line, token.col,
                (!name && token.type == "name") ? token.value : name
            );
        } catch(ex) {
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                file: token.file,
                line: token.line,
                col: token.col,
                cline: current_line,
                ccol: current_col,
                name: name || ""
            })
        }
    } : noop;

    function get() {
        return OUTPUT;
    };

    if (options.preamble) {
        print(options.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
    }

    var stack = [];
    return {
        get             : get,
        toString        : get,
        indent          : indent,
        indentation     : function() { return indentation },
        current_width   : function() { return current_col - indentation },
        should_break    : function() { return options.width && this.current_width() >= options.width },
        newline         : newline,
        print           : print,
        space           : space,
        comma           : comma,
        colon           : colon,
        last            : function() { return last },
        semicolon       : semicolon,
        force_semicolon : force_semicolon,
        to_ascii        : to_ascii,
        print_name      : function(name) { print(make_name(name)) },
        print_string    : function(str) { print(encode_string(str)) },
        next_indent     : next_indent,
        with_indent     : with_indent,
        with_block      : with_block,
        with_parens     : with_parens,
        with_square     : with_square,
        add_mapping     : add_mapping,
        option          : function(opt) { return options[opt] },
        line            : function() { return current_line },
        col             : function() { return current_col },
        pos             : function() { return current_pos },
        push_node       : function(node) { stack.push(node) },
        pop_node        : function() { return stack.pop() },
        stack           : function() { return stack },
        parent          : function(n) {
            return stack[stack.length - 2 - (n || 0)];
        }
    };

};

/* -----[ code generators ]----- */

(function(){

    /* -----[ utils ]----- */

    function DEFPRINT(nodetype, generator) {
        nodetype.DEFMETHOD("_codegen", generator);
    };

    AST_Node.DEFMETHOD("print", function(stream, force_parens){
        var self = this, generator = self._codegen;
        function doit() {
            self.add_comments(stream);
            self.add_source_map(stream);
            generator(self, stream);
        }
        stream.push_node(self);
        if (force_parens || self.needs_parens(stream)) {
            stream.with_parens(doit);
        } else {
            doit();
        }
        stream.pop_node();
    });

    AST_Node.DEFMETHOD("print_to_string", function(options){
        var s = OutputStream(options);
        this.print(s);
        return s.get();
    });

    /* -----[ comments ]----- */

    AST_Node.DEFMETHOD("add_comments", function(output){
        var c = output.option("comments"), self = this;
        if (c) {
            var start = self.start;
            if (start && !start._comments_dumped) {
                start._comments_dumped = true;
                var comments = start.comments_before || [];

                // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                //      if this node is `return` or `throw`, we cannot allow comments before
                //      the returned or thrown value.
                if (self instanceof AST_Exit && self.value
                    && self.value.start.comments_before
                    && self.value.start.comments_before.length > 0) {
                    comments = comments.concat(self.value.start.comments_before);
                    self.value.start.comments_before = [];
                }

                if (c.test) {
                    comments = comments.filter(function(comment){
                        return c.test(comment.value);
                    });
                } else if (typeof c == "function") {
                    comments = comments.filter(function(comment){
                        return c(self, comment);
                    });
                }
                comments.forEach(function(c){
                    if (/comment[134]/.test(c.type)) {
                        output.print("//" + c.value + "\n");
                        output.indent();
                    }
                    else if (c.type == "comment2") {
                        output.print("/*" + c.value + "*/");
                        if (start.nlb) {
                            output.print("\n");
                            output.indent();
                        } else {
                            output.space();
                        }
                    }
                });
            }
        }
    });

    /* -----[ PARENTHESES ]----- */

    function PARENS(nodetype, func) {
        nodetype.DEFMETHOD("needs_parens", func);
    };

    PARENS(AST_Node, function(){
        return false;
    });

    // a function expression needs parens around it when it's provably
    // the first token to appear in a statement.
    PARENS(AST_Function, function(output){
        return first_in_statement(output);
    });

    // same goes for an object literal, because otherwise it would be
    // interpreted as a block of code.
    PARENS(AST_Object, function(output){
        return first_in_statement(output);
    });

    PARENS(AST_Unary, function(output){
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this;
    });

    PARENS(AST_Seq, function(output){
        var p = output.parent();
        return p instanceof AST_Call             // (foo, bar)() or foo(1, (2, 3), 4)
            || p instanceof AST_Unary            // !(foo, bar, baz)
            || p instanceof AST_Binary           // 1 + (2, 3) + 4 ==> 8
            || p instanceof AST_VarDef           // var a = (1, 2), b = a + a; ==> b == 4
            || p instanceof AST_Dot              // (1, {foo:2}).foo ==> 2
            || p instanceof AST_Array            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
            || p instanceof AST_ObjectProperty   // { foo: (1, 2) }.foo ==> 2
            || p instanceof AST_Conditional      /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                  * ==> 20 (side effect, set a := 10 and b := 20) */
        ;
    });

    PARENS(AST_Binary, function(output){
        var p = output.parent();
        // (foo && bar)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // typeof (foo && bar)
        if (p instanceof AST_Unary)
            return true;
        // (foo && bar)["prop"], (foo && bar).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // this deals with precedence: 3 * (2 + 1)
        if (p instanceof AST_Binary) {
            var po = p.operator, pp = PRECEDENCE[po];
            var so = this.operator, sp = PRECEDENCE[so];
            if (pp > sp
                || (pp == sp
                    && this === p.right)) {
                return true;
            }
        }
    });

    PARENS(AST_PropAccess, function(output){
        var p = output.parent();
        if (p instanceof AST_New && p.expression === this) {
            // i.e. new (foo.bar().baz)
            //
            // if there's one call into this subtree, then we need
            // parens around it too, otherwise the call will be
            // interpreted as passing the arguments to the upper New
            // expression.
            try {
                this.walk(new TreeWalker(function(node){
                    if (node instanceof AST_Call) throw p;
                }));
            } catch(ex) {
                if (ex !== p) throw ex;
                return true;
            }
        }
    });

    PARENS(AST_Call, function(output){
        var p = output.parent(), p1;
        if (p instanceof AST_New && p.expression === this)
            return true;

        // workaround for Safari bug.
        // https://bugs.webkit.org/show_bug.cgi?id=123506
        return this.expression instanceof AST_Function
            && p instanceof AST_PropAccess
            && p.expression === this
            && (p1 = output.parent(1)) instanceof AST_Assign
            && p1.left === p;
    });

    PARENS(AST_New, function(output){
        var p = output.parent();
        if (no_constructor_parens(this, output)
            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
            return true;
    });

    PARENS(AST_Number, function(output){
        var p = output.parent();
        if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    PARENS(AST_NaN, function(output){
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    function assign_and_conditional_paren_rules(output) {
        var p = output.parent();
        // !(a = false) → true
        if (p instanceof AST_Unary)
            return true;
        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
        // (a = func)() —or— new (a = Object)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (a = foo) ? bar : baz
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // (a = foo)["prop"] —or— (a = foo).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    };

    PARENS(AST_Assign, assign_and_conditional_paren_rules);
    PARENS(AST_Conditional, assign_and_conditional_paren_rules);

    /* -----[ PRINTERS ]----- */

    DEFPRINT(AST_Directive, function(self, output){
        output.print_string(self.value);
        output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(self, output){
        output.print("debugger");
        output.semicolon();
    });

    /* -----[ statements ]----- */

    function display_body(body, is_toplevel, output) {
        var last = body.length - 1;
        body.forEach(function(stmt, i){
            if (!(stmt instanceof AST_EmptyStatement)) {
                output.indent();
                stmt.print(output);
                if (!(i == last && is_toplevel)) {
                    output.newline();
                    if (is_toplevel) output.newline();
                }
            }
        });
    };

    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output){
        force_statement(this.body, output);
    });

    DEFPRINT(AST_Statement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    DEFPRINT(AST_Toplevel, function(self, output){
        display_body(self.body, true, output);
        output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(self, output){
        self.label.print(output);
        output.colon();
        self.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    function print_bracketed(body, output) {
        if (body.length > 0) output.with_block(function(){
            display_body(body, false, output);
        });
        else output.print("{}");
    };
    DEFPRINT(AST_BlockStatement, function(self, output){
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_EmptyStatement, function(self, output){
        output.semicolon();
    });
    DEFPRINT(AST_Do, function(self, output){
        output.print("do");
        output.space();
        self._do_print_body(output);
        output.space();
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.semicolon();
    });
    DEFPRINT(AST_While, function(self, output){
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_For, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            if (self.init) {
                if (self.init instanceof AST_Definitions) {
                    self.init.print(output);
                } else {
                    parenthesize_for_noin(self.init, output, true);
                }
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.condition) {
                self.condition.print(output);
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.step) {
                self.step.print(output);
            }
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_ForIn, function(self, output){
        output.print("for");
        output.space();
        output.with_parens(function(){
            self.init.print(output);
            output.space();
            output.print("in");
            output.space();
            self.object.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_With, function(self, output){
        output.print("with");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        self._do_print_body(output);
    });

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword){
        var self = this;
        if (!nokeyword) {
            output.print("function");
        }
        if (self.name) {
            output.space();
            self.name.print(output);
        }
        output.with_parens(function(){
            self.argnames.forEach(function(arg, i){
                if (i) output.comma();
                arg.print(output);
            });
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Lambda, function(self, output){
        self._do_print(output);
    });

    /* -----[ exits ]----- */
    AST_Exit.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.value) {
            output.space();
            this.value.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Return, function(self, output){
        self._do_print(output, "return");
    });
    DEFPRINT(AST_Throw, function(self, output){
        self._do_print(output, "throw");
    });

    /* -----[ loop control ]----- */
    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.label) {
            output.space();
            this.label.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Break, function(self, output){
        self._do_print(output, "break");
    });
    DEFPRINT(AST_Continue, function(self, output){
        self._do_print(output, "continue");
    });

    /* -----[ if ]----- */
    function make_then(self, output) {
        if (output.option("bracketize")) {
            make_block(self.body, output);
            return;
        }
        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        if (!self.body)
            return output.force_semicolon();
        if (self.body instanceof AST_Do
            && !output.option("screw_ie8")) {
            // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
            // croaks with "syntax error" on code like this: if (foo)
            // do ... while(cond); else ...  we need block brackets
            // around do/while
            make_block(self.body, output);
            return;
        }
        var b = self.body;
        while (true) {
            if (b instanceof AST_If) {
                if (!b.alternative) {
                    make_block(self.body, output);
                    return;
                }
                b = b.alternative;
            }
            else if (b instanceof AST_StatementWithBody) {
                b = b.body;
            }
            else break;
        }
        force_statement(self.body, output);
    };
    DEFPRINT(AST_If, function(self, output){
        output.print("if");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        if (self.alternative) {
            make_then(self, output);
            output.space();
            output.print("else");
            output.space();
            force_statement(self.alternative, output);
        } else {
            self._do_print_body(output);
        }
    });

    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output){
        output.print("switch");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        if (self.body.length > 0) output.with_block(function(){
            self.body.forEach(function(stmt, i){
                if (i) output.newline();
                output.indent(true);
                stmt.print(output);
            });
        });
        else output.print("{}");
    });
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output){
        if (this.body.length > 0) {
            output.newline();
            this.body.forEach(function(stmt){
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
    });
    DEFPRINT(AST_Default, function(self, output){
        output.print("default:");
        self._do_print_body(output);
    });
    DEFPRINT(AST_Case, function(self, output){
        output.print("case");
        output.space();
        self.expression.print(output);
        output.print(":");
        self._do_print_body(output);
    });

    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output){
        output.print("try");
        output.space();
        print_bracketed(self.body, output);
        if (self.bcatch) {
            output.space();
            self.bcatch.print(output);
        }
        if (self.bfinally) {
            output.space();
            self.bfinally.print(output);
        }
    });
    DEFPRINT(AST_Catch, function(self, output){
        output.print("catch");
        output.space();
        output.with_parens(function(){
            self.argname.print(output);
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Finally, function(self, output){
        output.print("finally");
        output.space();
        print_bracketed(self.body, output);
    });

    /* -----[ var/const ]----- */
    AST_Definitions.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        output.space();
        this.definitions.forEach(function(def, i){
            if (i) output.comma();
            def.print(output);
        });
        var p = output.parent();
        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
        var avoid_semicolon = in_for && p.init === this;
        if (!avoid_semicolon)
            output.semicolon();
    });
    DEFPRINT(AST_Var, function(self, output){
        self._do_print(output, "var");
    });
    DEFPRINT(AST_Const, function(self, output){
        self._do_print(output, "const");
    });

    function parenthesize_for_noin(node, output, noin) {
        if (!noin) node.print(output);
        else try {
            // need to take some precautions here:
            //    https://github.com/mishoo/UglifyJS2/issues/60
            node.walk(new TreeWalker(function(node){
                if (node instanceof AST_Binary && node.operator == "in")
                    throw output;
            }));
            node.print(output);
        } catch(ex) {
            if (ex !== output) throw ex;
            node.print(output, true);
        }
    };

    DEFPRINT(AST_VarDef, function(self, output){
        self.name.print(output);
        if (self.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self.value, output, noin);
        }
    });

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output){
        self.expression.print(output);
        if (self instanceof AST_New && no_constructor_parens(self, output))
            return;
        output.with_parens(function(){
            self.args.forEach(function(expr, i){
                if (i) output.comma();
                expr.print(output);
            });
        });
    });
    DEFPRINT(AST_New, function(self, output){
        output.print("new");
        output.space();
        AST_Call.prototype._codegen(self, output);
    });

    AST_Seq.DEFMETHOD("_do_print", function(output){
        this.car.print(output);
        if (this.cdr) {
            output.comma();
            if (output.should_break()) {
                output.newline();
                output.indent();
            }
            this.cdr.print(output);
        }
    });
    DEFPRINT(AST_Seq, function(self, output){
        self._do_print(output);
        // var p = output.parent();
        // if (p instanceof AST_Statement) {
        //     output.with_indent(output.next_indent(), function(){
        //         self._do_print(output);
        //     });
        // } else {
        //     self._do_print(output);
        // }
    });
    DEFPRINT(AST_Dot, function(self, output){
        var expr = self.expression;
        expr.print(output);
        if (expr instanceof AST_Number && expr.getValue() >= 0) {
            if (!/[xa-f.]/i.test(output.last())) {
                output.print(".");
            }
        }
        output.print(".");
        // the name after dot would be mapped about here.
        output.add_mapping(self.end);
        output.print_name(self.property);
    });
    DEFPRINT(AST_Sub, function(self, output){
        self.expression.print(output);
        output.print("[");
        self.property.print(output);
        output.print("]");
    });
    DEFPRINT(AST_UnaryPrefix, function(self, output){
        var op = self.operator;
        output.print(op);
        if (/^[a-z]/i.test(op))
            output.space();
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(self, output){
        self.expression.print(output);
        output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(self, output){
        self.left.print(output);
        output.space();
        output.print(self.operator);
        if (self.operator == "<"
            && self.right instanceof AST_UnaryPrefix
            && self.right.operator == "!"
            && self.right.expression instanceof AST_UnaryPrefix
            && self.right.expression.operator == "--") {
            // space is mandatory to avoid outputting <!--
            // http://javascript.spec.whatwg.org/#comment-syntax
            output.print(" ");
        } else {
            // the space is optional depending on "beautify"
            output.space();
        }
        self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(self, output){
        self.condition.print(output);
        output.space();
        output.print("?");
        output.space();
        self.consequent.print(output);
        output.space();
        output.colon();
        self.alternative.print(output);
    });

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output){
        output.with_square(function(){
            var a = self.elements, len = a.length;
            if (len > 0) output.space();
            a.forEach(function(exp, i){
                if (i) output.comma();
                exp.print(output);
                // If the final element is a hole, we need to make sure it
                // doesn't look like a trailing comma, by inserting an actual
                // trailing comma.
                if (i === len - 1 && exp instanceof AST_Hole)
                  output.comma();
            });
            if (len > 0) output.space();
        });
    });
    DEFPRINT(AST_Object, function(self, output){
        if (self.properties.length > 0) output.with_block(function(){
            self.properties.forEach(function(prop, i){
                if (i) {
                    output.print(",");
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else output.print("{}");
    });
    DEFPRINT(AST_ObjectKeyVal, function(self, output){
        var key = self.key;
        if (output.option("quote_keys")) {
            output.print_string(key + "");
        } else if ((typeof key == "number"
                    || !output.option("beautify")
                    && +key + "" == key)
                   && parseFloat(key) >= 0) {
            output.print(make_num(key));
        } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
            output.print_name(key);
        } else {
            output.print_string(key);
        }
        output.colon();
        self.value.print(output);
    });
    DEFPRINT(AST_ObjectSetter, function(self, output){
        output.print("set");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_ObjectGetter, function(self, output){
        output.print("get");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_Symbol, function(self, output){
        var def = self.definition();
        output.print_name(def ? def.mangled_name || def.name : self.name);
    });
    DEFPRINT(AST_Undefined, function(self, output){
        output.print("void 0");
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Infinity, function(self, output){
        output.print("1/0");
    });
    DEFPRINT(AST_NaN, function(self, output){
        output.print("0/0");
    });
    DEFPRINT(AST_This, function(self, output){
        output.print("this");
    });
    DEFPRINT(AST_Constant, function(self, output){
        output.print(self.getValue());
    });
    DEFPRINT(AST_String, function(self, output){
        output.print_string(self.getValue());
    });
    DEFPRINT(AST_Number, function(self, output){
        output.print(make_num(self.getValue()));
    });
    DEFPRINT(AST_RegExp, function(self, output){
        var str = self.getValue().toString();
        if (output.option("ascii_only"))
            str = output.to_ascii(str);
        output.print(str);
        var p = output.parent();
        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)
            output.print(" ");
    });

    function force_statement(stat, output) {
        if (output.option("bracketize")) {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.print("{}");
            else if (stat instanceof AST_BlockStatement)
                stat.print(output);
            else output.with_block(function(){
                output.indent();
                stat.print(output);
                output.newline();
            });
        } else {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.force_semicolon();
            else
                stat.print(output);
        }
    };

    // return true if the node at the top of the stack (that means the
    // innermost node in the current output) is lexically the first in
    // a statement.
    function first_in_statement(output) {
        var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
        while (i > 0) {
            if (p instanceof AST_Statement && p.body === node)
                return true;
            if ((p instanceof AST_Seq           && p.car === node        ) ||
                (p instanceof AST_Call          && p.expression === node && !(p instanceof AST_New) ) ||
                (p instanceof AST_Dot           && p.expression === node ) ||
                (p instanceof AST_Sub           && p.expression === node ) ||
                (p instanceof AST_Conditional   && p.condition === node  ) ||
                (p instanceof AST_Binary        && p.left === node       ) ||
                (p instanceof AST_UnaryPostfix  && p.expression === node ))
            {
                node = p;
                p = a[--i];
            } else {
                return false;
            }
        }
    };

    // self should be AST_New.  decide if we want to show parens or not.
    function no_constructor_parens(self, output) {
        return self.args.length == 0 && !output.option("beautify");
    };

    function best_of(a) {
        var best = a[0], len = best.length;
        for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
                best = a[i];
                len = best.length;
            }
        }
        return best;
    };

    function make_num(num) {
        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
        if (Math.floor(num) === num) {
            if (num >= 0) {
                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                       "0" + num.toString(8)); // same.
            } else {
                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                       "-0" + (-num).toString(8)); // same.
            }
            if ((m = /^(.*?)(0+)$/.exec(num))) {
                a.push(m[1] + "e" + m[2].length);
            }
        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
            a.push(m[2] + "e-" + (m[1].length + m[2].length),
                   str.substr(str.indexOf(".")));
        }
        return best_of(a);
    };

    function make_block(stmt, output) {
        if (stmt instanceof AST_BlockStatement) {
            stmt.print(output);
            return;
        }
        output.with_block(function(){
            output.indent();
            stmt.print(output);
            output.newline();
        });
    };

    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) {
        nodetype.DEFMETHOD("add_source_map", function(stream){
            generator(this, stream);
        });
    };

    // We could easily add info for ALL nodes, but it seems to me that
    // would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop);

    function basic_sourcemap_gen(self, output) {
        output.add_mapping(self.start);
    };

    // XXX: I'm not exactly sure if we need it for all of these nodes,
    // or if we should add even more.

    DEFMAP(AST_Directive, basic_sourcemap_gen);
    DEFMAP(AST_Debugger, basic_sourcemap_gen);
    DEFMAP(AST_Symbol, basic_sourcemap_gen);
    DEFMAP(AST_Jump, basic_sourcemap_gen);
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
    DEFMAP(AST_LabeledStatement, noop); // since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen);
    DEFMAP(AST_Switch, basic_sourcemap_gen);
    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
    DEFMAP(AST_Toplevel, noop);
    DEFMAP(AST_New, basic_sourcemap_gen);
    DEFMAP(AST_Try, basic_sourcemap_gen);
    DEFMAP(AST_Catch, basic_sourcemap_gen);
    DEFMAP(AST_Finally, basic_sourcemap_gen);
    DEFMAP(AST_Definitions, basic_sourcemap_gen);
    DEFMAP(AST_Constant, basic_sourcemap_gen);
    DEFMAP(AST_ObjectProperty, function(self, output){
        output.add_mapping(self.start, self.key);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function Compressor(options, false_by_default) {
    if (!(this instanceof Compressor))
        return new Compressor(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
        sequences     : !false_by_default,
        properties    : !false_by_default,
        dead_code     : !false_by_default,
        drop_debugger : !false_by_default,
        unsafe        : false,
        unsafe_comps  : false,
        conditionals  : !false_by_default,
        comparisons   : !false_by_default,
        evaluate      : !false_by_default,
        booleans      : !false_by_default,
        loops         : !false_by_default,
        unused        : !false_by_default,
        hoist_funs    : !false_by_default,
        hoist_vars    : false,
        if_return     : !false_by_default,
        join_vars     : !false_by_default,
        cascade       : !false_by_default,
        side_effects  : !false_by_default,
        pure_getters  : false,
        pure_funcs    : null,
        negate_iife   : !false_by_default,
        screw_ie8     : false,

        warnings      : true,
        global_defs   : {}
    }, true);
};

Compressor.prototype = new TreeTransformer;
merge(Compressor.prototype, {
    option: function(key) { return this.options[key] },
    warn: function() {
        if (this.options.warnings)
            AST_Node.warn.apply(AST_Node, arguments);
    },
    before: function(node, descend, in_list) {
        if (node._squeezed) return node;
        if (node instanceof AST_Scope) {
            //node.drop_unused(this);
            node = node.hoist_declarations(this);
        }
        descend(node, this);
        node = node.optimize(this);
        if (node instanceof AST_Scope) {
            node.drop_unused(this);
            descend(node, this);
        }
        node._squeezed = true;
        return node;
    }
});

(function(){

    function OPT(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor){
            var self = this;
            if (self._optimized) return self;
            var opt = optimizer(self, compressor);
            opt._optimized = true;
            if (opt === self) return opt;
            return opt.transform(compressor);
        });
    };

    OPT(AST_Node, function(self, compressor){
        return self;
    });

    AST_Node.DEFMETHOD("equivalent_to", function(node){
        // XXX: this is a rather expensive way to test two node's equivalence:
        return this.print_to_string() == node.print_to_string();
    });

    function make_node(ctor, orig, props) {
        if (!props) props = {};
        if (orig) {
            if (!props.start) props.start = orig.start;
            if (!props.end) props.end = orig.end;
        }
        return new ctor(props);
    };

    function make_node_from_constant(compressor, val, orig) {
        // XXX: WIP.
        // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
        //     if (node instanceof AST_SymbolRef) {
        //         var scope = compressor.find_parent(AST_Scope);
        //         var def = scope.find_variable(node);
        //         node.thedef = def;
        //         return node;
        //     }
        // })).transform(compressor);

        if (val instanceof AST_Node) return val.transform(compressor);
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
                value: val
            }).optimize(compressor);
          case "number":
            return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                value: val
            }).optimize(compressor);
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
          case "undefined":
            return make_node(AST_Undefined, orig).optimize(compressor);
          default:
            if (val === null) {
                return make_node(AST_Null, orig).optimize(compressor);
            }
            if (val instanceof RegExp) {
                return make_node(AST_RegExp, orig).optimize(compressor);
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
                type: typeof val
            }));
        }
    };

    function as_statement_array(thing) {
        if (thing === null) return [];
        if (thing instanceof AST_BlockStatement) return thing.body;
        if (thing instanceof AST_EmptyStatement) return [];
        if (thing instanceof AST_Statement) return [ thing ];
        throw new Error("Can't convert thing to statement array");
    };

    function is_empty(thing) {
        if (thing === null) return true;
        if (thing instanceof AST_EmptyStatement) return true;
        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
        return false;
    };

    function loop_body(x) {
        if (x instanceof AST_Switch) return x;
        if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
            return (x.body instanceof AST_BlockStatement ? x.body : x);
        }
        return x;
    };

    function tighten_body(statements, compressor) {
        var CHANGED;
        do {
            CHANGED = false;
            statements = eliminate_spurious_blocks(statements);
            if (compressor.option("dead_code")) {
                statements = eliminate_dead_code(statements, compressor);
            }
            if (compressor.option("if_return")) {
                statements = handle_if_return(statements, compressor);
            }
            if (compressor.option("sequences")) {
                statements = sequencesize(statements, compressor);
            }
            if (compressor.option("join_vars")) {
                statements = join_consecutive_vars(statements, compressor);
            }
        } while (CHANGED);

        if (compressor.option("negate_iife")) {
            negate_iifes(statements, compressor);
        }

        return statements;

        function eliminate_spurious_blocks(statements) {
            var seen_dirs = [];
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_BlockStatement) {
                    CHANGED = true;
                    a.push.apply(a, eliminate_spurious_blocks(stat.body));
                } else if (stat instanceof AST_EmptyStatement) {
                    CHANGED = true;
                } else if (stat instanceof AST_Directive) {
                    if (seen_dirs.indexOf(stat.value) < 0) {
                        a.push(stat);
                        seen_dirs.push(stat.value);
                    } else {
                        CHANGED = true;
                    }
                } else {
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function handle_if_return(statements, compressor) {
            var self = compressor.self();
            var in_lambda = self instanceof AST_Lambda;
            var ret = [];
            loop: for (var i = statements.length; --i >= 0;) {
                var stat = statements[i];
                switch (true) {
                  case (in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0):
                    CHANGED = true;
                    // note, ret.length is probably always zero
                    // because we drop unreachable code before this
                    // step.  nevertheless, it's good to check.
                    continue loop;
                  case stat instanceof AST_If:
                    if (stat.body instanceof AST_Return) {
                        //---
                        // pretty silly case, but:
                        // if (foo()) return; return; ==> foo(); return;
                        if (((in_lambda && ret.length == 0)
                             || (ret[0] instanceof AST_Return && !ret[0].value))
                            && !stat.body.value && !stat.alternative) {
                            CHANGED = true;
                            var cond = make_node(AST_SimpleStatement, stat.condition, {
                                body: stat.condition
                            });
                            ret.unshift(cond);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; return y; ==> return foo() ? x : y;
                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0];
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                        if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                value: make_node(AST_Undefined, stat)
                            });
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                        if (!stat.body.value && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.condition = stat.condition.negate(compressor);
                            stat.body = make_node(AST_BlockStatement, stat, {
                                body: as_statement_array(stat.alternative).concat(ret)
                            });
                            stat.alternative = null;
                            ret = [ stat.transform(compressor) ];
                            continue loop;
                        }
                        //---
                        if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement
                            && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                            CHANGED = true;
                            ret.push(make_node(AST_Return, ret[0], {
                                value: make_node(AST_Undefined, ret[0])
                            }).transform(compressor));
                            ret = as_statement_array(stat.alternative).concat(ret);
                            ret.unshift(stat);
                            continue loop;
                        }
                    }

                    var ab = aborts(stat.body);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        var body = as_statement_array(stat.body).slice(0, -1);
                        stat = stat.clone();
                        stat.condition = stat.condition.negate(compressor);
                        stat.body = make_node(AST_BlockStatement, stat, {
                            body: ret
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat, {
                            body: body
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    var ab = aborts(stat.alternative);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        stat = stat.clone();
                        stat.body = make_node(AST_BlockStatement, stat.body, {
                            body: as_statement_array(stat.body).concat(ret)
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                            body: as_statement_array(stat.alternative).slice(0, -1)
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    ret.unshift(stat);
                    break;
                  default:
                    ret.unshift(stat);
                    break;
                }
            }
            return ret;
        };

        function eliminate_dead_code(statements, compressor) {
            var has_quit = false;
            var orig = statements.length;
            var self = compressor.self();
            statements = statements.reduce(function(a, stat){
                if (has_quit) {
                    extract_declarations_from_unreachable_code(compressor, stat, a);
                } else {
                    if (stat instanceof AST_LoopControl) {
                        var lct = compressor.loopcontrol_target(stat.label);
                        if ((stat instanceof AST_Break
                             && lct instanceof AST_BlockStatement
                             && loop_body(lct) === self) || (stat instanceof AST_Continue
                                                             && loop_body(lct) === self)) {
                            if (stat.label) {
                                remove(stat.label.thedef.references, stat);
                            }
                        } else {
                            a.push(stat);
                        }
                    } else {
                        a.push(stat);
                    }
                    if (aborts(stat)) has_quit = true;
                }
                return a;
            }, []);
            CHANGED = statements.length != orig;
            return statements;
        };

        function sequencesize(statements, compressor) {
            if (statements.length < 2) return statements;
            var seq = [], ret = [];
            function push_seq() {
                seq = AST_Seq.from_array(seq);
                if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                    body: seq
                }));
                seq = [];
            };
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) seq.push(stat.body);
                else push_seq(), ret.push(stat);
            });
            push_seq();
            ret = sequencesize_2(ret, compressor);
            CHANGED = ret.length != statements.length;
            return ret;
        };

        function sequencesize_2(statements, compressor) {
            function cons_seq(right) {
                ret.pop();
                var left = prev.body;
                if (left instanceof AST_Seq) {
                    left.add(right);
                } else {
                    left = AST_Seq.cons(left, right);
                }
                return left.transform(compressor);
            };
            var ret = [], prev = null;
            statements.forEach(function(stat){
                if (prev) {
                    if (stat instanceof AST_For) {
                        var opera = {};
                        try {
                            prev.body.walk(new TreeWalker(function(node){
                                if (node instanceof AST_Binary && node.operator == "in")
                                    throw opera;
                            }));
                            if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                stat.init = cons_seq(stat.init);
                            }
                            else if (!stat.init) {
                                stat.init = prev.body;
                                ret.pop();
                            }
                        } catch(ex) {
                            if (ex !== opera) throw ex;
                        }
                    }
                    else if (stat instanceof AST_If) {
                        stat.condition = cons_seq(stat.condition);
                    }
                    else if (stat instanceof AST_With) {
                        stat.expression = cons_seq(stat.expression);
                    }
                    else if (stat instanceof AST_Exit && stat.value) {
                        stat.value = cons_seq(stat.value);
                    }
                    else if (stat instanceof AST_Exit) {
                        stat.value = cons_seq(make_node(AST_Undefined, stat));
                    }
                    else if (stat instanceof AST_Switch) {
                        stat.expression = cons_seq(stat.expression);
                    }
                }
                ret.push(stat);
                prev = stat instanceof AST_SimpleStatement ? stat : null;
            });
            return ret;
        };

        function join_consecutive_vars(statements, compressor) {
            var prev = null;
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                    prev.definitions = prev.definitions.concat(stat.definitions);
                    CHANGED = true;
                }
                else if (stat instanceof AST_For
                         && prev instanceof AST_Definitions
                         && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                    CHANGED = true;
                    a.pop();
                    if (stat.init) {
                        stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                    } else {
                        stat.init = prev;
                    }
                    a.push(stat);
                    prev = stat;
                }
                else {
                    prev = stat;
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function negate_iifes(statements, compressor) {
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) {
                    stat.body = (function transform(thing) {
                        return thing.transform(new TreeTransformer(function(node){
                            if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                return make_node(AST_UnaryPrefix, node, {
                                    operator: "!",
                                    expression: node
                                });
                            }
                            else if (node instanceof AST_Call) {
                                node.expression = transform(node.expression);
                            }
                            else if (node instanceof AST_Seq) {
                                node.car = transform(node.car);
                            }
                            else if (node instanceof AST_Conditional) {
                                var expr = transform(node.condition);
                                if (expr !== node.condition) {
                                    // it has been negated, reverse
                                    node.condition = expr;
                                    var tmp = node.consequent;
                                    node.consequent = node.alternative;
                                    node.alternative = tmp;
                                }
                            }
                            return node;
                        }));
                    })(stat.body);
                }
            });
        };

    };

    function extract_declarations_from_unreachable_code(compressor, stat, target) {
        compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
        stat.walk(new TreeWalker(function(node){
            if (node instanceof AST_Definitions) {
                compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                node.remove_initializers();
                target.push(node);
                return true;
            }
            if (node instanceof AST_Defun) {
                target.push(node);
                return true;
            }
            if (node instanceof AST_Scope) {
                return true;
            }
        }));
    };

    /* -----[ boolean/negation helpers ]----- */

    // methods to determine whether an expression has a boolean result type
    (function (def){
        var unary_bool = [ "!", "delete" ];
        var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
        def(AST_Node, function(){ return false });
        def(AST_UnaryPrefix, function(){
            return member(this.operator, unary_bool);
        });
        def(AST_Binary, function(){
            return member(this.operator, binary_bool) ||
                ( (this.operator == "&&" || this.operator == "||") &&
                  this.left.is_boolean() && this.right.is_boolean() );
        });
        def(AST_Conditional, function(){
            return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def(AST_Assign, function(){
            return this.operator == "=" && this.right.is_boolean();
        });
        def(AST_Seq, function(){
            return this.cdr.is_boolean();
        });
        def(AST_True, function(){ return true });
        def(AST_False, function(){ return true });
    })(function(node, func){
        node.DEFMETHOD("is_boolean", func);
    });

    // methods to determine if an expression has a string result type
    (function (def){
        def(AST_Node, function(){ return false });
        def(AST_String, function(){ return true });
        def(AST_UnaryPrefix, function(){
            return this.operator == "typeof";
        });
        def(AST_Binary, function(compressor){
            return this.operator == "+" &&
                (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def(AST_Assign, function(compressor){
            return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def(AST_Seq, function(compressor){
            return this.cdr.is_string(compressor);
        });
        def(AST_Conditional, function(compressor){
            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
        def(AST_Call, function(compressor){
            return compressor.option("unsafe")
                && this.expression instanceof AST_SymbolRef
                && this.expression.name == "String"
                && this.expression.undeclared();
        });
    })(function(node, func){
        node.DEFMETHOD("is_string", func);
    });

    function best_of(ast1, ast2) {
        return ast1.print_to_string().length >
            ast2.print_to_string().length
            ? ast2 : ast1;
    };

    // methods to evaluate a constant expression
    (function (def){
        // The evaluate method returns an array with one or two
        // elements.  If the node has been successfully reduced to a
        // constant, then the second element tells us the value;
        // otherwise the second element is missing.  The first element
        // of the array is always an AST_Node descendant; if
        // evaluation was successful it's a node that represents the
        // constant; otherwise it's the original or a replacement node.
        AST_Node.DEFMETHOD("evaluate", function(compressor){
            if (!compressor.option("evaluate")) return [ this ];
            try {
                var val = this._eval(compressor);
                return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
            } catch(ex) {
                if (ex !== def) throw ex;
                return [ this ];
            }
        });
        def(AST_Statement, function(){
            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
        });
        def(AST_Function, function(){
            // XXX: AST_Function inherits from AST_Scope, which itself
            // inherits from AST_Statement; however, an AST_Function
            // isn't really a statement.  This could byte in other
            // places too. :-( Wish JS had multiple inheritance.
            throw def;
        });
        function ev(node, compressor) {
            if (!compressor) throw new Error("Compressor must be passed");

            return node._eval(compressor);
        };
        def(AST_Node, function(){
            throw def;          // not constant
        });
        def(AST_Constant, function(){
            return this.getValue();
        });
        def(AST_UnaryPrefix, function(compressor){
            var e = this.expression;
            switch (this.operator) {
              case "!": return !ev(e, compressor);
              case "typeof":
                // Function would be evaluated to an array and so typeof would
                // incorrectly return 'object'. Hence making is a special case.
                if (e instanceof AST_Function) return typeof function(){};

                e = ev(e, compressor);

                // typeof <RegExp> returns "object" or "function" on different platforms
                // so cannot evaluate reliably
                if (e instanceof RegExp) throw def;

                return typeof e;
              case "void": return void ev(e, compressor);
              case "~": return ~ev(e, compressor);
              case "-":
                e = ev(e, compressor);
                if (e === 0) throw def;
                return -e;
              case "+": return +ev(e, compressor);
            }
            throw def;
        });
        def(AST_Binary, function(c){
            var left = this.left, right = this.right;
            switch (this.operator) {
              case "&&"         : return ev(left, c) &&         ev(right, c);
              case "||"         : return ev(left, c) ||         ev(right, c);
              case "|"          : return ev(left, c) |          ev(right, c);
              case "&"          : return ev(left, c) &          ev(right, c);
              case "^"          : return ev(left, c) ^          ev(right, c);
              case "+"          : return ev(left, c) +          ev(right, c);
              case "*"          : return ev(left, c) *          ev(right, c);
              case "/"          : return ev(left, c) /          ev(right, c);
              case "%"          : return ev(left, c) %          ev(right, c);
              case "-"          : return ev(left, c) -          ev(right, c);
              case "<<"         : return ev(left, c) <<         ev(right, c);
              case ">>"         : return ev(left, c) >>         ev(right, c);
              case ">>>"        : return ev(left, c) >>>        ev(right, c);
              case "=="         : return ev(left, c) ==         ev(right, c);
              case "==="        : return ev(left, c) ===        ev(right, c);
              case "!="         : return ev(left, c) !=         ev(right, c);
              case "!=="        : return ev(left, c) !==        ev(right, c);
              case "<"          : return ev(left, c) <          ev(right, c);
              case "<="         : return ev(left, c) <=         ev(right, c);
              case ">"          : return ev(left, c) >          ev(right, c);
              case ">="         : return ev(left, c) >=         ev(right, c);
              case "in"         : return ev(left, c) in         ev(right, c);
              case "instanceof" : return ev(left, c) instanceof ev(right, c);
            }
            throw def;
        });
        def(AST_Conditional, function(compressor){
            return ev(this.condition, compressor)
                ? ev(this.consequent, compressor)
                : ev(this.alternative, compressor);
        });
        def(AST_SymbolRef, function(compressor){
            var d = this.definition();
            if (d && d.constant && d.init) return ev(d.init, compressor);
            throw def;
        });
    })(function(node, func){
        node.DEFMETHOD("_eval", func);
    });

    // method to negate an expression
    (function(def){
        function basic_negation(exp) {
            return make_node(AST_UnaryPrefix, exp, {
                operator: "!",
                expression: exp
            });
        };
        def(AST_Node, function(){
            return basic_negation(this);
        });
        def(AST_Statement, function(){
            throw new Error("Cannot negate a statement");
        });
        def(AST_Function, function(){
            return basic_negation(this);
        });
        def(AST_UnaryPrefix, function(){
            if (this.operator == "!")
                return this.expression;
            return basic_negation(this);
        });
        def(AST_Seq, function(compressor){
            var self = this.clone();
            self.cdr = self.cdr.negate(compressor);
            return self;
        });
        def(AST_Conditional, function(compressor){
            var self = this.clone();
            self.consequent = self.consequent.negate(compressor);
            self.alternative = self.alternative.negate(compressor);
            return best_of(basic_negation(this), self);
        });
        def(AST_Binary, function(compressor){
            var self = this.clone(), op = this.operator;
            if (compressor.option("unsafe_comps")) {
                switch (op) {
                  case "<=" : self.operator = ">"  ; return self;
                  case "<"  : self.operator = ">=" ; return self;
                  case ">=" : self.operator = "<"  ; return self;
                  case ">"  : self.operator = "<=" ; return self;
                }
            }
            switch (op) {
              case "==" : self.operator = "!="; return self;
              case "!=" : self.operator = "=="; return self;
              case "===": self.operator = "!=="; return self;
              case "!==": self.operator = "==="; return self;
              case "&&":
                self.operator = "||";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
              case "||":
                self.operator = "&&";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
            }
            return basic_negation(this);
        });
    })(function(node, func){
        node.DEFMETHOD("negate", function(compressor){
            return func.call(this, compressor);
        });
    });

    // determine if expression has side effects
    (function(def){
        def(AST_Node, function(compressor){ return true });

        def(AST_EmptyStatement, function(compressor){ return false });
        def(AST_Constant, function(compressor){ return false });
        def(AST_This, function(compressor){ return false });

        def(AST_Call, function(compressor){
            var pure = compressor.option("pure_funcs");
            if (!pure) return true;
            return pure.indexOf(this.expression.print_to_string()) < 0;
        });

        def(AST_Block, function(compressor){
            for (var i = this.body.length; --i >= 0;) {
                if (this.body[i].has_side_effects(compressor))
                    return true;
            }
            return false;
        });

        def(AST_SimpleStatement, function(compressor){
            return this.body.has_side_effects(compressor);
        });
        def(AST_Defun, function(compressor){ return true });
        def(AST_Function, function(compressor){ return false });
        def(AST_Binary, function(compressor){
            return this.left.has_side_effects(compressor)
                || this.right.has_side_effects(compressor);
        });
        def(AST_Assign, function(compressor){ return true });
        def(AST_Conditional, function(compressor){
            return this.condition.has_side_effects(compressor)
                || this.consequent.has_side_effects(compressor)
                || this.alternative.has_side_effects(compressor);
        });
        def(AST_Unary, function(compressor){
            return this.operator == "delete"
                || this.operator == "++"
                || this.operator == "--"
                || this.expression.has_side_effects(compressor);
        });
        def(AST_SymbolRef, function(compressor){ return false });
        def(AST_Object, function(compressor){
            for (var i = this.properties.length; --i >= 0;)
                if (this.properties[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_ObjectProperty, function(compressor){
            return this.value.has_side_effects(compressor);
        });
        def(AST_Array, function(compressor){
            for (var i = this.elements.length; --i >= 0;)
                if (this.elements[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_Dot, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor);
        });
        def(AST_Sub, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor)
                || this.property.has_side_effects(compressor);
        });
        def(AST_PropAccess, function(compressor){
            return !compressor.option("pure_getters");
        });
        def(AST_Seq, function(compressor){
            return this.car.has_side_effects(compressor)
                || this.cdr.has_side_effects(compressor);
        });
    })(function(node, func){
        node.DEFMETHOD("has_side_effects", func);
    });

    // tell me if a statement aborts
    function aborts(thing) {
        return thing && thing.aborts();
    };
    (function(def){
        def(AST_Statement, function(){ return null });
        def(AST_Jump, function(){ return this });
        function block_aborts(){
            var n = this.body.length;
            return n > 0 && aborts(this.body[n - 1]);
        };
        def(AST_BlockStatement, block_aborts);
        def(AST_SwitchBranch, block_aborts);
        def(AST_If, function(){
            return this.alternative && aborts(this.body) && aborts(this.alternative);
        });
    })(function(node, func){
        node.DEFMETHOD("aborts", func);
    });

    /* -----[ optimizers ]----- */

    OPT(AST_Directive, function(self, compressor){
        if (self.scope.has_directive(self.value) !== self.scope) {
            return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    OPT(AST_Debugger, function(self, compressor){
        if (compressor.option("drop_debugger"))
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_LabeledStatement, function(self, compressor){
        if (self.body instanceof AST_Break
            && compressor.loopcontrol_target(self.body.label) === self.body) {
            return make_node(AST_EmptyStatement, self);
        }
        return self.label.references.length == 0 ? self.body : self;
    });

    OPT(AST_Block, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_BlockStatement, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        switch (self.body.length) {
          case 1: return self.body[0];
          case 0: return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    AST_Scope.DEFMETHOD("drop_unused", function(compressor){
        var self = this;
        if (compressor.option("unused")
            && !(self instanceof AST_Toplevel)
            && !self.uses_eval
           ) {
            var in_use = [];
            var initializations = new Dictionary();
            // pass 1: find out which symbols are directly used in
            // this scope (not in nested scopes).
            var scope = this;
            var tw = new TreeWalker(function(node, descend){
                if (node !== self) {
                    if (node instanceof AST_Defun) {
                        initializations.add(node.name.name, node);
                        return true; // don't go in nested scopes
                    }
                    if (node instanceof AST_Definitions && scope === self) {
                        node.definitions.forEach(function(def){
                            if (def.value) {
                                initializations.add(def.name.name, def.value);
                                if (def.value.has_side_effects(compressor)) {
                                    def.value.walk(tw);
                                }
                            }
                        });
                        return true;
                    }
                    if (node instanceof AST_SymbolRef) {
                        push_uniq(in_use, node.definition());
                        return true;
                    }
                    if (node instanceof AST_Scope) {
                        var save_scope = scope;
                        scope = node;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                }
            });
            self.walk(tw);
            // pass 2: for every used symbol we need to walk its
            // initialization code to figure out if it uses other
            // symbols (that may not be in_use).
            for (var i = 0; i < in_use.length; ++i) {
                in_use[i].orig.forEach(function(decl){
                    // undeclared globals will be instanceof AST_SymbolRef
                    var init = initializations.get(decl.name);
                    if (init) init.forEach(function(init){
                        var tw = new TreeWalker(function(node){
                            if (node instanceof AST_SymbolRef) {
                                push_uniq(in_use, node.definition());
                            }
                        });
                        init.walk(tw);
                    });
                });
            }
            // pass 3: we should drop declarations not in_use
            var tt = new TreeTransformer(
                function before(node, descend, in_list) {
                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                        for (var a = node.argnames, i = a.length; --i >= 0;) {
                            var sym = a[i];
                            if (sym.unreferenced()) {
                                a.pop();
                                compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                    name : sym.name,
                                    file : sym.start.file,
                                    line : sym.start.line,
                                    col  : sym.start.col
                                });
                            }
                            else break;
                        }
                    }
                    if (node instanceof AST_Defun && node !== self) {
                        if (!member(node.name.definition(), in_use)) {
                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                name : node.name.name,
                                file : node.name.start.file,
                                line : node.name.start.line,
                                col  : node.name.start.col
                            });
                            return make_node(AST_EmptyStatement, node);
                        }
                        return node;
                    }
                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                        var def = node.definitions.filter(function(def){
                            if (member(def.name.definition(), in_use)) return true;
                            var w = {
                                name : def.name.name,
                                file : def.name.start.file,
                                line : def.name.start.line,
                                col  : def.name.start.col
                            };
                            if (def.value && def.value.has_side_effects(compressor)) {
                                def._unused_side_effects = true;
                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                return true;
                            }
                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                            return false;
                        });
                        // place uninitialized names at the start
                        def = mergeSort(def, function(a, b){
                            if (!a.value && b.value) return -1;
                            if (!b.value && a.value) return 1;
                            return 0;
                        });
                        // for unused names whose initialization has
                        // side effects, we can cascade the init. code
                        // into the next one, or next statement.
                        var side_effects = [];
                        for (var i = 0; i < def.length;) {
                            var x = def[i];
                            if (x._unused_side_effects) {
                                side_effects.push(x.value);
                                def.splice(i, 1);
                            } else {
                                if (side_effects.length > 0) {
                                    side_effects.push(x.value);
                                    x.value = AST_Seq.from_array(side_effects);
                                    side_effects = [];
                                }
                                ++i;
                            }
                        }
                        if (side_effects.length > 0) {
                            side_effects = make_node(AST_BlockStatement, node, {
                                body: [ make_node(AST_SimpleStatement, node, {
                                    body: AST_Seq.from_array(side_effects)
                                }) ]
                            });
                        } else {
                            side_effects = null;
                        }
                        if (def.length == 0 && !side_effects) {
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (def.length == 0) {
                            return side_effects;
                        }
                        node.definitions = def;
                        if (side_effects) {
                            side_effects.body.unshift(node);
                            node = side_effects;
                        }
                        return node;
                    }
                    if (node instanceof AST_For) {
                        descend(node, this);

                        if (node.init instanceof AST_BlockStatement) {
                            // certain combination of unused name + side effect leads to:
                            //    https://github.com/mishoo/UglifyJS2/issues/44
                            // that's an invalid AST.
                            // We fix it at this stage by moving the `var` outside the `for`.

                            var body = node.init.body.slice(0, -1);
                            node.init = node.init.body.slice(-1)[0].body;
                            body.push(node);

                            return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                                body: body
                            });
                        }
                    }
                    if (node instanceof AST_Scope && node !== self)
                        return node;
                }
            );
            self.transform(tt);
        }
    });

    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        var self = this;
        if (hoist_funs || hoist_vars) {
            var dirs = [];
            var hoisted = [];
            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
            // let's count var_decl first, we seem to waste a lot of
            // space if we hoist `var` when there's only one.
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }));
            hoist_vars = hoist_vars && var_decl > 1;
            var tt = new TreeTransformer(
                function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def){
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments();
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === node) {
                                if (seq == null) return node.definitions[0].name;
                                return seq;
                            }
                            if (p instanceof AST_For && p.init === node) {
                                return seq;
                            }
                            if (!seq) return make_node(AST_EmptyStatement, node);
                            return make_node(AST_SimpleStatement, node, {
                                body: seq
                            });
                        }
                        if (node instanceof AST_Scope)
                            return node; // to avoid descending in nested scopes
                    }
                }
            );
            self = self.transform(tt);
            if (vars_found > 0) {
                // collect only vars which don't show up in self's arguments list
                var defs = [];
                vars.each(function(def, name){
                    if (self instanceof AST_Lambda
                        && find_if(function(x){ return x.name == def.name.name },
                                   self.argnames)) {
                        vars.del(name);
                    } else {
                        def = def.clone();
                        def.value = null;
                        defs.push(def);
                        vars.set(name, def);
                    }
                });
                if (defs.length > 0) {
                    // try to merge in assignments
                    for (var i = 0; i < self.body.length;) {
                        if (self.body[i] instanceof AST_SimpleStatement) {
                            var expr = self.body[i].body, sym, assign;
                            if (expr instanceof AST_Assign
                                && expr.operator == "="
                                && (sym = expr.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = expr.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body.splice(i, 1);
                                continue;
                            }
                            if (expr instanceof AST_Seq
                                && (assign = expr.car) instanceof AST_Assign
                                && assign.operator == "="
                                && (sym = assign.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = assign.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body[i].body = expr.cdr;
                                continue;
                            }
                        }
                        if (self.body[i] instanceof AST_EmptyStatement) {
                            self.body.splice(i, 1);
                            continue;
                        }
                        if (self.body[i] instanceof AST_BlockStatement) {
                            var tmp = [ i, 1 ].concat(self.body[i].body);
                            self.body.splice.apply(self.body, tmp);
                            continue;
                        }
                        break;
                    }
                    defs = make_node(AST_Var, self, {
                        definitions: defs
                    });
                    hoisted.push(defs);
                };
            }
            self.body = dirs.concat(hoisted, self.body);
        }
        return self;
    });

    OPT(AST_SimpleStatement, function(self, compressor){
        if (compressor.option("side_effects")) {
            if (!self.body.has_side_effects(compressor)) {
                compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                return make_node(AST_EmptyStatement, self);
            }
        }
        return self;
    });

    OPT(AST_DWLoop, function(self, compressor){
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (!compressor.option("loops")) return self;
        if (cond.length > 1) {
            if (cond[1]) {
                return make_node(AST_For, self, {
                    body: self.body
                });
            } else if (self instanceof AST_While) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        return self;
    });

    function if_break_in_loop(self, compressor) {
        function drop_it(rest) {
            rest = as_statement_array(rest);
            if (self.body instanceof AST_BlockStatement) {
                self.body = self.body.clone();
                self.body.body = rest.concat(self.body.body.slice(1));
                self.body = self.body.transform(compressor);
            } else {
                self.body = make_node(AST_BlockStatement, self.body, {
                    body: rest
                }).transform(compressor);
            }
            if_break_in_loop(self, compressor);
        }
        var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
        if (first instanceof AST_If) {
            if (first.body instanceof AST_Break
                && compressor.loopcontrol_target(first.body.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition.negate(compressor),
                    });
                } else {
                    self.condition = first.condition.negate(compressor);
                }
                drop_it(first.alternative);
            }
            else if (first.alternative instanceof AST_Break
                     && compressor.loopcontrol_target(first.alternative.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition,
                    });
                } else {
                    self.condition = first.condition;
                }
                drop_it(first.body);
            }
        }
    };

    OPT(AST_While, function(self, compressor) {
        if (!compressor.option("loops")) return self;
        self = AST_DWLoop.prototype.optimize.call(self, compressor);
        if (self instanceof AST_While) {
            if_break_in_loop(self, compressor);
            self = make_node(AST_For, self, self).transform(compressor);
        }
        return self;
    });

    OPT(AST_For, function(self, compressor){
        var cond = self.condition;
        if (cond) {
            cond = cond.evaluate(compressor);
            self.condition = cond[0];
        }
        if (!compressor.option("loops")) return self;
        if (cond) {
            if (cond.length > 1 && !cond[1]) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.init instanceof AST_Statement) {
                        a.push(self.init);
                    }
                    else if (self.init) {
                        a.push(make_node(AST_SimpleStatement, self.init, {
                            body: self.init
                        }));
                    }
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        if_break_in_loop(self, compressor);
        return self;
    });

    OPT(AST_If, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        // if condition can be statically determined, warn and drop
        // one of the blocks.  note, statically determined implies
        // “has no side effects”; also it doesn't work for cases like
        // `x && true`, though it probably should.
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.alternative) {
                        extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                    }
                    a.push(self.body);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    if (self.alternative) a.push(self.alternative);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            }
        }
        if (is_empty(self.alternative)) self.alternative = null;
        var negated = self.condition.negate(compressor);
        var negated_is_best = best_of(self.condition, negated) === negated;
        if (self.alternative && negated_is_best) {
            negated_is_best = false; // because we already do the switch here.
            self.condition = negated;
            var tmp = self.body;
            self.body = self.alternative || make_node(AST_EmptyStatement);
            self.alternative = tmp;
        }
        if (is_empty(self.body) && is_empty(self.alternative)) {
            return make_node(AST_SimpleStatement, self.condition, {
                body: self.condition
            }).transform(compressor);
        }
        if (self.body instanceof AST_SimpleStatement
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.body,
                    alternative : self.alternative.body
                })
            }).transform(compressor);
        }
        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
            if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : negated,
                    right    : self.body.body
                })
            }).transform(compressor);
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "&&",
                    left     : self.condition,
                    right    : self.body.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_EmptyStatement
            && self.alternative
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : self.condition,
                    right    : self.alternative.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_Exit
            && self.alternative instanceof AST_Exit
            && self.body.TYPE == self.alternative.TYPE) {
            return make_node(self.body.CTOR, self, {
                value: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_If
            && !self.body.alternative
            && !self.alternative) {
            self.condition = make_node(AST_Binary, self.condition, {
                operator: "&&",
                left: self.condition,
                right: self.body.condition
            }).transform(compressor);
            self.body = self.body.body;
        }
        if (aborts(self.body)) {
            if (self.alternative) {
                var alt = self.alternative;
                self.alternative = null;
                return make_node(AST_BlockStatement, self, {
                    body: [ self, alt ]
                }).transform(compressor);
            }
        }
        if (aborts(self.alternative)) {
            var body = self.body;
            self.body = self.alternative;
            self.condition = negated_is_best ? negated : self.condition.negate(compressor);
            self.alternative = null;
            return make_node(AST_BlockStatement, self, {
                body: [ self, body ]
            }).transform(compressor);
        }
        return self;
    });

    OPT(AST_Switch, function(self, compressor){
        if (self.body.length == 0 && compressor.option("conditionals")) {
            return make_node(AST_SimpleStatement, self, {
                body: self.expression
            }).transform(compressor);
        }
        for(;;) {
            var last_branch = self.body[self.body.length - 1];
            if (last_branch) {
                var stat = last_branch.body[last_branch.body.length - 1]; // last statement
                if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self)
                    last_branch.body.pop();
                if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                    self.body.pop();
                    continue;
                }
            }
            break;
        }
        var exp = self.expression.evaluate(compressor);
        out: if (exp.length == 2) try {
            // constant expression
            self.expression = exp[0];
            if (!compressor.option("dead_code")) break out;
            var value = exp[1];
            var in_if = false;
            var in_block = false;
            var started = false;
            var stopped = false;
            var ruined = false;
            var tt = new TreeTransformer(function(node, descend, in_list){
                if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                    // no need to descend these node types
                    return node;
                }
                else if (node instanceof AST_Switch && node === self) {
                    node = node.clone();
                    descend(node, this);
                    return ruined ? node : make_node(AST_BlockStatement, node, {
                        body: node.body.reduce(function(a, branch){
                            return a.concat(branch.body);
                        }, [])
                    }).transform(compressor);
                }
                else if (node instanceof AST_If || node instanceof AST_Try) {
                    var save = in_if;
                    in_if = !in_block;
                    descend(node, this);
                    in_if = save;
                    return node;
                }
                else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                    var save = in_block;
                    in_block = true;
                    descend(node, this);
                    in_block = save;
                    return node;
                }
                else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                    if (in_if) {
                        ruined = true;
                        return node;
                    }
                    if (in_block) return node;
                    stopped = true;
                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                }
                else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                    if (stopped) return MAP.skip;
                    if (node instanceof AST_Case) {
                        var exp = node.expression.evaluate(compressor);
                        if (exp.length < 2) {
                            // got a case with non-constant expression, baling out
                            throw self;
                        }
                        if (exp[1] === value || started) {
                            started = true;
                            if (aborts(node)) stopped = true;
                            descend(node, this);
                            return node;
                        }
                        return MAP.skip;
                    }
                    descend(node, this);
                    return node;
                }
            });
            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
            self = self.transform(tt);
        } catch(ex) {
            if (ex !== self) throw ex;
        }
        return self;
    });

    OPT(AST_Case, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_Try, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    AST_Definitions.DEFMETHOD("remove_initializers", function(){
        this.definitions.forEach(function(def){ def.value = null });
    });

    AST_Definitions.DEFMETHOD("to_assignments", function(){
        var assignments = this.definitions.reduce(function(a, def){
            if (def.value) {
                var name = make_node(AST_SymbolRef, def.name, def.name);
                a.push(make_node(AST_Assign, def, {
                    operator : "=",
                    left     : name,
                    right    : def.value
                }));
            }
            return a;
        }, []);
        if (assignments.length == 0) return null;
        return AST_Seq.from_array(assignments);
    });

    OPT(AST_Definitions, function(self, compressor){
        if (self.definitions.length == 0)
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_Function, function(self, compressor){
        self = AST_Lambda.prototype.optimize.call(self, compressor);
        if (compressor.option("unused")) {
            if (self.name && self.name.unreferenced()) {
                self.name = null;
            }
        }
        return self;
    });

    OPT(AST_Call, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Array":
                    if (self.args.length != 1) {
                        return make_node(AST_Array, self, {
                            elements: self.args
                        }).transform(compressor);
                    }
                    break;
                  case "Object":
                    if (self.args.length == 0) {
                        return make_node(AST_Object, self, {
                            properties: []
                        });
                    }
                    break;
                  case "String":
                    if (self.args.length == 0) return make_node(AST_String, self, {
                        value: ""
                    });
                    if (self.args.length <= 1) return make_node(AST_Binary, self, {
                        left: self.args[0],
                        operator: "+",
                        right: make_node(AST_String, self, { value: "" })
                    }).transform(compressor);
                    break;
                  case "Number":
                    if (self.args.length == 0) return make_node(AST_Number, self, {
                        value: 0
                    });
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: self.args[0],
                        operator: "+"
                    }).transform(compressor);
                  case "Boolean":
                    if (self.args.length == 0) return make_node(AST_False, self);
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: make_node(AST_UnaryPrefix, null, {
                            expression: self.args[0],
                            operator: "!"
                        }),
                        operator: "!"
                    }).transform(compressor);
                    break;
                  case "Function":
                    if (all(self.args, function(x){ return x instanceof AST_String })) {
                        // quite a corner-case, but we can handle it:
                        //   https://github.com/mishoo/UglifyJS2/issues/203
                        // if the code argument is a constant, then we can minify it.
                        try {
                            var code = "(function(" + self.args.slice(0, -1).map(function(arg){
                                return arg.value;
                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                            var ast = parse(code);
                            ast.figure_out_scope();
                            var comp = new Compressor(compressor.options);
                            ast = ast.transform(comp);
                            ast.figure_out_scope();
                            ast.mangle_names();
                            var fun;
                            try {
                                ast.walk(new TreeWalker(function(node){
                                    if (node instanceof AST_Lambda) {
                                        fun = node;
                                        throw ast;
                                    }
                                }));
                            } catch(ex) {
                                if (ex !== ast) throw ex;
                            };
                            var args = fun.argnames.map(function(arg, i){
                                return make_node(AST_String, self.args[i], {
                                    value: arg.print_to_string()
                                });
                            });
                            var code = OutputStream();
                            AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                            code = code.toString().replace(/^\{|\}$/g, "");
                            args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                value: code
                            }));
                            self.args = args;
                            return self;
                        } catch(ex) {
                            if (ex instanceof JS_Parse_Error) {
                                compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                compressor.warn(ex.toString());
                            } else {
                                console.log(ex);
                                throw ex;
                            }
                        }
                    }
                    break;
                }
            }
            else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                return make_node(AST_Binary, self, {
                    left: make_node(AST_String, self, { value: "" }),
                    operator: "+",
                    right: exp.expression
                }).transform(compressor);
            }
            else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
                var separator = self.args.length == 0 ? "," : self.args[0].evaluate(compressor)[1];
                if (separator == null) break EXIT; // not a constant
                var elements = exp.expression.elements.reduce(function(a, el){
                    el = el.evaluate(compressor);
                    if (a.length == 0 || el.length == 1) {
                        a.push(el);
                    } else {
                        var last = a[a.length - 1];
                        if (last.length == 2) {
                            // it's a constant
                            var val = "" + last[1] + separator + el[1];
                            a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                        } else {
                            a.push(el);
                        }
                    }
                    return a;
                }, []);
                if (elements.length == 0) return make_node(AST_String, self, { value: "" });
                if (elements.length == 1) return elements[0][0];
                if (separator == "") {
                    var first;
                    if (elements[0][0] instanceof AST_String
                        || elements[1][0] instanceof AST_String) {
                        first = elements.shift()[0];
                    } else {
                        first = make_node(AST_String, self, { value: "" });
                    }
                    return elements.reduce(function(prev, el){
                        return make_node(AST_Binary, el[0], {
                            operator : "+",
                            left     : prev,
                            right    : el[0],
                        });
                    }, first).transform(compressor);
                }
                // need this awkward cloning to not affect original element
                // best_of will decide which one to get through.
                var node = self.clone();
                node.expression = node.expression.clone();
                node.expression.expression = node.expression.expression.clone();
                node.expression.expression.elements = elements.map(function(el){
                    return el[0];
                });
                return best_of(self, node);
            }
        }
        if (compressor.option("side_effects")) {
            if (self.expression instanceof AST_Function
                && self.args.length == 0
                && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {
                return make_node(AST_Undefined, self).transform(compressor);
            }
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_New, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Object":
                  case "RegExp":
                  case "Function":
                  case "Error":
                  case "Array":
                    return make_node(AST_Call, self, self).transform(compressor);
                }
            }
        }
        return self;
    });

    OPT(AST_Seq, function(self, compressor){
        if (!compressor.option("side_effects"))
            return self;
        if (!self.car.has_side_effects(compressor)) {
            // we shouldn't compress (1,eval)(something) to
            // eval(something) because that changes the meaning of
            // eval (becomes lexical instead of global).
            var p;
            if (!(self.cdr instanceof AST_SymbolRef
                  && self.cdr.name == "eval"
                  && self.cdr.undeclared()
                  && (p = compressor.parent()) instanceof AST_Call
                  && p.expression === self)) {
                return self.cdr;
            }
        }
        if (compressor.option("cascade")) {
            if (self.car instanceof AST_Assign
                && !self.car.left.has_side_effects(compressor)
                && self.car.left.equivalent_to(self.cdr)) {
                return self.car;
            }
            if (!self.car.has_side_effects(compressor)
                && !self.cdr.has_side_effects(compressor)
                && self.car.equivalent_to(self.cdr)) {
                return self.car;
            }
        }
        return self;
    });

    AST_Unary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.expression instanceof AST_Seq) {
                var seq = this.expression;
                var x = seq.to_array();
                this.expression = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    OPT(AST_UnaryPostfix, function(self, compressor){
        return self.lift_sequences(compressor);
    });

    OPT(AST_UnaryPrefix, function(self, compressor){
        self = self.lift_sequences(compressor);
        var e = self.expression;
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            switch (self.operator) {
              case "!":
                if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                    // !!foo ==> foo, if we're in boolean context
                    return e.expression;
                }
                break;
              case "typeof":
                // typeof always returns a non-empty string, thus it's
                // always true in booleans
                compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (e instanceof AST_Binary && self.operator == "!") {
                self = best_of(self, e.negate(compressor));
            }
        }
        return self.evaluate(compressor)[0];
    });

    function has_side_effects_or_prop_access(node, compressor) {
        var save_pure_getters = compressor.option("pure_getters");
        compressor.options.pure_getters = false;
        var ret = node.has_side_effects(compressor);
        compressor.options.pure_getters = save_pure_getters;
        return ret;
    }

    AST_Binary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.left instanceof AST_Seq) {
                var seq = this.left;
                var x = seq.to_array();
                this.left = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
            if (this.right instanceof AST_Seq
                && this instanceof AST_Assign
                && !has_side_effects_or_prop_access(this.left, compressor)) {
                var seq = this.right;
                var x = seq.to_array();
                this.right = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    var commutativeOperators = makePredicate("== === != !== * & | ^");

    OPT(AST_Binary, function(self, compressor){
        var reverse = compressor.has_directive("use asm") ? noop
            : function(op, force) {
                if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {
                    if (op) self.operator = op;
                    var tmp = self.left;
                    self.left = self.right;
                    self.right = tmp;
                }
            };
        if (commutativeOperators(self.operator)) {
            if (self.right instanceof AST_Constant
                && !(self.left instanceof AST_Constant)) {
                // if right is a constant, whatever side effects the
                // left side might have could not influence the
                // result.  hence, force switch.

                if (!(self.left instanceof AST_Binary
                      && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
                    reverse(null, true);
                }
            }
            if (/^[!=]==?$/.test(self.operator)) {
                if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                    if (self.right.consequent instanceof AST_SymbolRef
                        && self.right.consequent.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition;
                        if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor);
                    }
                    if (self.right.alternative instanceof AST_SymbolRef
                        && self.right.alternative.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.right.condition;
                    }
                }
                if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                    if (self.left.consequent instanceof AST_SymbolRef
                        && self.left.consequent.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition;
                        if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor);
                    }
                    if (self.left.alternative instanceof AST_SymbolRef
                        && self.left.alternative.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.left.condition;
                    }
                }
            }
        }
        self = self.lift_sequences(compressor);
        if (compressor.option("comparisons")) switch (self.operator) {
          case "===":
          case "!==":
            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                (self.left.is_boolean() && self.right.is_boolean())) {
                self.operator = self.operator.substr(0, 2);
            }
            // XXX: intentionally falling down to the next case
          case "==":
          case "!=":
            if (self.left instanceof AST_String
                && self.left.value == "undefined"
                && self.right instanceof AST_UnaryPrefix
                && self.right.operator == "typeof"
                && compressor.option("unsafe")) {
                if (!(self.right.expression instanceof AST_SymbolRef)
                    || !self.right.expression.undeclared()) {
                    self.right = self.right.expression;
                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                    if (self.operator.length == 2) self.operator += "=";
                }
            }
            break;
        }
        if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
          case "&&":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                return make_node(AST_False, self);
            }
            if (ll.length > 1 && ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && rr[1]) {
                return ll[0];
            }
            break;
          case "||":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (ll.length > 1 && !ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && !rr[1]) {
                return ll[0];
            }
            break;
          case "+":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[0] instanceof AST_String && ll[1]) ||
                (rr.length > 1 && rr[0] instanceof AST_String && rr[1])) {
                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            break;
        }
        if (compressor.option("comparisons")) {
            if (!(compressor.parent() instanceof AST_Binary)
                || compressor.parent() instanceof AST_Assign) {
                var negated = make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.negate(compressor)
                });
                self = best_of(self, negated);
            }
            switch (self.operator) {
              case "<": reverse(">"); break;
              case "<=": reverse(">="); break;
            }
        }
        if (self.operator == "+" && self.right instanceof AST_String
            && self.right.getValue() === "" && self.left instanceof AST_Binary
            && self.left.operator == "+" && self.left.is_string(compressor)) {
            return self.left;
        } else if (self.operator == "+" && self.right instanceof AST_String
                   && self.right.getValue() === "" && self.left instanceof AST_Binary
                   && self.left.operator == "+" && self.left.right instanceof AST_Number) {
            return make_node(AST_Binary, self, {
                left: self.left.left,
                operator: "+",
                right: make_node(AST_String, self.right, {
                    value: String(self.left.right.value)
                })
            });
        }
        if (compressor.option("evaluate")) {
            if (self.operator == "+") {
                if (self.left instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_String, null, {
                            value: "" + self.left.getValue() + self.right.left.getValue(),
                            start: self.left.start,
                            end: self.right.left.end
                        }),
                        right: self.right.right
                    });
                }
                if (self.right instanceof AST_Constant
                    && self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.right instanceof AST_Constant
                    && self.left.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: self.left.left,
                        right: make_node(AST_String, null, {
                            value: "" + self.left.right.getValue() + self.right.getValue(),
                            start: self.left.right.start,
                            end: self.right.end
                        })
                    });
                }
                if (self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.is_string(compressor)
                    && self.left.right instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_Binary, self.left, {
                            operator: "+",
                            left: self.left.left,
                            right: make_node(AST_String, null, {
                                value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                start: self.left.right.start,
                                end: self.right.left.end
                            })
                        }),
                        right: self.right.right
                    });
                }
            }
        }
        // x * (y * z)  ==>  x * y * z
        if (self.right instanceof AST_Binary
            && self.right.operator == self.operator
            && (self.operator == "*" || self.operator == "&&" || self.operator == "||"))
        {
            self.left = make_node(AST_Binary, self.left, {
                operator : self.operator,
                left     : self.left,
                right    : self.right.left
            });
            self.right = self.right.right;
            return self.transform(compressor);
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_SymbolRef, function(self, compressor){
        if (self.undeclared()) {
            var defines = compressor.option("global_defs");
            if (defines && defines.hasOwnProperty(self.name)) {
                return make_node_from_constant(compressor, defines[self.name], self);
            }
            switch (self.name) {
              case "undefined":
                return make_node(AST_Undefined, self);
              case "NaN":
                return make_node(AST_NaN, self);
              case "Infinity":
                return make_node(AST_Infinity, self);
            }
        }
        return self;
    });

    OPT(AST_Undefined, function(self, compressor){
        if (compressor.option("unsafe")) {
            var scope = compressor.find_parent(AST_Scope);
            var undef = scope.find_variable("undefined");
            if (undef) {
                var ref = make_node(AST_SymbolRef, self, {
                    name   : "undefined",
                    scope  : scope,
                    thedef : undef
                });
                ref.reference();
                return ref;
            }
        }
        return self;
    });

    var ASSIGN_OPS = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
    OPT(AST_Assign, function(self, compressor){
        self = self.lift_sequences(compressor);
        if (self.operator == "="
            && self.left instanceof AST_SymbolRef
            && self.right instanceof AST_Binary
            && self.right.left instanceof AST_SymbolRef
            && self.right.left.name == self.left.name
            && member(self.right.operator, ASSIGN_OPS)) {
            self.operator = self.right.operator + "=";
            self.right = self.right.right;
        }
        return self;
    });

    OPT(AST_Conditional, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        if (self.condition instanceof AST_Seq) {
            var car = self.condition.car;
            self.condition = self.condition.cdr;
            return AST_Seq.cons(car, self);
        }
        var cond = self.condition.evaluate(compressor);
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                return self.consequent;
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                return self.alternative;
            }
        }
        var negated = cond[0].negate(compressor);
        if (best_of(cond[0], negated) === negated) {
            self = make_node(AST_Conditional, self, {
                condition: negated,
                consequent: self.alternative,
                alternative: self.consequent
            });
        }
        var consequent = self.consequent;
        var alternative = self.alternative;
        if (consequent instanceof AST_Assign
            && alternative instanceof AST_Assign
            && consequent.operator == alternative.operator
            && consequent.left.equivalent_to(alternative.left)
           ) {
            /*
             * Stuff like this:
             * if (foo) exp = something; else exp = something_else;
             * ==>
             * exp = foo ? something : something_else;
             */
            self = make_node(AST_Assign, self, {
                operator: consequent.operator,
                left: consequent.left,
                right: make_node(AST_Conditional, self, {
                    condition: self.condition,
                    consequent: consequent.right,
                    alternative: alternative.right
                })
            });
        }
        return self;
    });

    OPT(AST_Boolean, function(self, compressor){
        if (compressor.option("booleans")) {
            var p = compressor.parent();
            if (p instanceof AST_Binary && (p.operator == "=="
                                            || p.operator == "!=")) {
                compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                    operator : p.operator,
                    value    : self.value,
                    file     : p.start.file,
                    line     : p.start.line,
                    col      : p.start.col,
                });
                return make_node(AST_Number, self, {
                    value: +self.value
                });
            }
            return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: make_node(AST_Number, self, {
                    value: 1 - self.value
                })
            });
        }
        return self;
    });

    OPT(AST_Sub, function(self, compressor){
        var prop = self.property;
        if (prop instanceof AST_String && compressor.option("properties")) {
            prop = prop.getValue();
            if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                return make_node(AST_Dot, self, {
                    expression : self.expression,
                    property   : prop
                });
            }
        }
        return self;
    });

    function literals_in_boolean_context(self, compressor) {
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            return make_node(AST_True, self);
        }
        return self;
    };
    OPT(AST_Array, literals_in_boolean_context);
    OPT(AST_Object, literals_in_boolean_context);
    OPT(AST_RegExp, literals_in_boolean_context);

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// a small wrapper around fitzgen's source-map library
function SourceMap(options) {
    options = defaults(options, {
        file : null,
        root : null,
        orig : null,
    });
    var generator = new MOZ_SourceMap.SourceMapGenerator({
        file       : options.file,
        sourceRoot : options.root
    });
    var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
        if (orig_map) {
            var info = orig_map.originalPositionFor({
                line: orig_line,
                column: orig_col
            });
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name = info.name;
        }
        generator.addMapping({
            generated : { line: gen_line, column: gen_col },
            original  : { line: orig_line, column: orig_col },
            source    : source,
            name      : name
        });
    };
    return {
        add        : add,
        get        : function() { return generator },
        toString   : function() { return generator.toString() }
    };
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

(function(){

    var MOZ_TO_ME = {
        TryStatement : function(M) {
            return new AST_Try({
                start    : my_start_token(M),
                end      : my_end_token(M),
                body     : from_moz(M.block).body,
                bcatch   : from_moz(M.handlers[0]),
                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
        },
        CatchClause : function(M) {
            return new AST_Catch({
                start   : my_start_token(M),
                end     : my_end_token(M),
                argname : from_moz(M.param),
                body    : from_moz(M.body).body
            });
        },
        ObjectExpression : function(M) {
            return new AST_Object({
                start      : my_start_token(M),
                end        : my_end_token(M),
                properties : M.properties.map(function(prop){
                    var key = prop.key;
                    var name = key.type == "Identifier" ? key.name : key.value;
                    var args = {
                        start    : my_start_token(key),
                        end      : my_end_token(prop.value),
                        key      : name,
                        value    : from_moz(prop.value)
                    };
                    switch (prop.kind) {
                      case "init":
                        return new AST_ObjectKeyVal(args);
                      case "set":
                        args.value.name = from_moz(key);
                        return new AST_ObjectSetter(args);
                      case "get":
                        args.value.name = from_moz(key);
                        return new AST_ObjectGetter(args);
                    }
                })
            });
        },
        SequenceExpression : function(M) {
            return AST_Seq.from_array(M.expressions.map(from_moz));
        },
        MemberExpression : function(M) {
            return new (M.computed ? AST_Sub : AST_Dot)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                property   : M.computed ? from_moz(M.property) : M.property.name,
                expression : from_moz(M.object)
            });
        },
        SwitchCase : function(M) {
            return new (M.test ? AST_Case : AST_Default)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                expression : from_moz(M.test),
                body       : M.consequent.map(from_moz)
            });
        },
        Literal : function(M) {
            var val = M.value, args = {
                start  : my_start_token(M),
                end    : my_end_token(M)
            };
            if (val === null) return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
              default:
                args.value = val;
                return new AST_RegExp(args);
            }
        },
        UnaryExpression: From_Moz_Unary,
        UpdateExpression: From_Moz_Unary,
        Identifier: function(M) {
            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
            return new (M.name == "this" ? AST_This
                        : p.type == "LabeledStatement" ? AST_Label
                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : AST_SymbolVar)
                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
                        : p.type == "CatchClause" ? AST_SymbolCatch
                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
                        : AST_SymbolRef)({
                            start : my_start_token(M),
                            end   : my_end_token(M),
                            name  : M.name
                        });
        }
    };

    function From_Moz_Unary(M) {
        var prefix = "prefix" in M ? M.prefix
            : M.type == "UnaryExpression" ? true : false;
        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start      : my_start_token(M),
            end        : my_end_token(M),
            operator   : M.operator,
            expression : from_moz(M.argument)
        });
    };

    var ME_TO_MOZ = {};

    map("Node", AST_Node);
    map("Program", AST_Toplevel, "body@body");
    map("Function", AST_Function, "id>name, params@argnames, body%body");
    map("EmptyStatement", AST_EmptyStatement);
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
    map("VariableDeclaration", AST_Var, "declarations@definitions");
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");

    map("ThisExpression", AST_This);
    map("ArrayExpression", AST_Array, "elements@elements");
    map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args");
    map("CallExpression", AST_Call, "callee>expression, arguments@args");

    /* -----[ tools ]----- */

    function my_start_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.start.line,
            col    : moznode.loc && moznode.loc.start.column,
            pos    : moznode.start,
            endpos : moznode.start
        });
    };

    function my_end_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.end.line,
            col    : moznode.loc && moznode.loc.end.column,
            pos    : moznode.end,
            endpos : moznode.end
        });
    };

    function map(moztype, mytype, propmap) {
        var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
        moz_to_me += "return new mytype({\n" +
            "start: my_start_token(M),\n" +
            "end: my_end_token(M)";

        if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop){
            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
            if (!m) throw new Error("Can't understand property map: " + prop);
            var moz = "M." + m[1], how = m[2], my = m[3];
            moz_to_me += ",\n" + my + ": ";
            if (how == "@") {
                moz_to_me += moz + ".map(from_moz)";
            } else if (how == ">") {
                moz_to_me += "from_moz(" + moz + ")";
            } else if (how == "=") {
                moz_to_me += moz;
            } else if (how == "%") {
                moz_to_me += "from_moz(" + moz + ").body";
            } else throw new Error("Can't understand operator in propmap: " + prop);
        });
        moz_to_me += "\n})}";

        // moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
        // console.log(moz_to_me);

        moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
            mytype, my_start_token, my_end_token, from_moz
        );
        return MOZ_TO_ME[moztype] = moz_to_me;
    };

    var FROM_MOZ_STACK = null;

    function from_moz(node) {
        FROM_MOZ_STACK.push(node);
        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
        FROM_MOZ_STACK.pop();
        return ret;
    };

    AST_Node.from_mozilla_ast = function(node){
        var save_stack = FROM_MOZ_STACK;
        FROM_MOZ_STACK = [];
        var ast = from_moz(node);
        FROM_MOZ_STACK = save_stack;
        return ast;
    };

})();


exports.sys = sys;
exports.MOZ_SourceMap = MOZ_SourceMap;
exports.UglifyJS = UglifyJS;
exports.array_to_hash = array_to_hash;
exports.slice = slice;
exports.characters = characters;
exports.member = member;
exports.find_if = find_if;
exports.repeat_string = repeat_string;
exports.DefaultsError = DefaultsError;
exports.defaults = defaults;
exports.merge = merge;
exports.noop = noop;
exports.MAP = MAP;
exports.push_uniq = push_uniq;
exports.string_template = string_template;
exports.remove = remove;
exports.mergeSort = mergeSort;
exports.set_difference = set_difference;
exports.set_intersection = set_intersection;
exports.makePredicate = makePredicate;
exports.all = all;
exports.Dictionary = Dictionary;
exports.DEFNODE = DEFNODE;
exports.AST_Token = AST_Token;
exports.AST_Node = AST_Node;
exports.AST_Statement = AST_Statement;
exports.AST_Debugger = AST_Debugger;
exports.AST_Directive = AST_Directive;
exports.AST_SimpleStatement = AST_SimpleStatement;
exports.walk_body = walk_body;
exports.AST_Block = AST_Block;
exports.AST_BlockStatement = AST_BlockStatement;
exports.AST_EmptyStatement = AST_EmptyStatement;
exports.AST_StatementWithBody = AST_StatementWithBody;
exports.AST_LabeledStatement = AST_LabeledStatement;
exports.AST_IterationStatement = AST_IterationStatement;
exports.AST_DWLoop = AST_DWLoop;
exports.AST_Do = AST_Do;
exports.AST_While = AST_While;
exports.AST_For = AST_For;
exports.AST_ForIn = AST_ForIn;
exports.AST_With = AST_With;
exports.AST_Scope = AST_Scope;
exports.AST_Toplevel = AST_Toplevel;
exports.AST_Lambda = AST_Lambda;
exports.AST_Accessor = AST_Accessor;
exports.AST_Function = AST_Function;
exports.AST_Defun = AST_Defun;
exports.AST_Jump = AST_Jump;
exports.AST_Exit = AST_Exit;
exports.AST_Return = AST_Return;
exports.AST_Throw = AST_Throw;
exports.AST_LoopControl = AST_LoopControl;
exports.AST_Break = AST_Break;
exports.AST_Continue = AST_Continue;
exports.AST_If = AST_If;
exports.AST_Switch = AST_Switch;
exports.AST_SwitchBranch = AST_SwitchBranch;
exports.AST_Default = AST_Default;
exports.AST_Case = AST_Case;
exports.AST_Try = AST_Try;
exports.AST_Catch = AST_Catch;
exports.AST_Finally = AST_Finally;
exports.AST_Definitions = AST_Definitions;
exports.AST_Var = AST_Var;
exports.AST_Const = AST_Const;
exports.AST_VarDef = AST_VarDef;
exports.AST_Call = AST_Call;
exports.AST_New = AST_New;
exports.AST_Seq = AST_Seq;
exports.AST_PropAccess = AST_PropAccess;
exports.AST_Dot = AST_Dot;
exports.AST_Sub = AST_Sub;
exports.AST_Unary = AST_Unary;
exports.AST_UnaryPrefix = AST_UnaryPrefix;
exports.AST_UnaryPostfix = AST_UnaryPostfix;
exports.AST_Binary = AST_Binary;
exports.AST_Conditional = AST_Conditional;
exports.AST_Assign = AST_Assign;
exports.AST_Array = AST_Array;
exports.AST_Object = AST_Object;
exports.AST_ObjectProperty = AST_ObjectProperty;
exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
exports.AST_ObjectSetter = AST_ObjectSetter;
exports.AST_ObjectGetter = AST_ObjectGetter;
exports.AST_Symbol = AST_Symbol;
exports.AST_SymbolAccessor = AST_SymbolAccessor;
exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
exports.AST_SymbolVar = AST_SymbolVar;
exports.AST_SymbolConst = AST_SymbolConst;
exports.AST_SymbolFunarg = AST_SymbolFunarg;
exports.AST_SymbolDefun = AST_SymbolDefun;
exports.AST_SymbolLambda = AST_SymbolLambda;
exports.AST_SymbolCatch = AST_SymbolCatch;
exports.AST_Label = AST_Label;
exports.AST_SymbolRef = AST_SymbolRef;
exports.AST_LabelRef = AST_LabelRef;
exports.AST_This = AST_This;
exports.AST_Constant = AST_Constant;
exports.AST_String = AST_String;
exports.AST_Number = AST_Number;
exports.AST_RegExp = AST_RegExp;
exports.AST_Atom = AST_Atom;
exports.AST_Null = AST_Null;
exports.AST_NaN = AST_NaN;
exports.AST_Undefined = AST_Undefined;
exports.AST_Hole = AST_Hole;
exports.AST_Infinity = AST_Infinity;
exports.AST_Boolean = AST_Boolean;
exports.AST_False = AST_False;
exports.AST_True = AST_True;
exports.TreeWalker = TreeWalker;
exports.KEYWORDS = KEYWORDS;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;
exports.OPERATOR_CHARS = OPERATOR_CHARS;
exports.RE_HEX_NUMBER = RE_HEX_NUMBER;
exports.RE_OCT_NUMBER = RE_OCT_NUMBER;
exports.RE_DEC_NUMBER = RE_DEC_NUMBER;
exports.OPERATORS = OPERATORS;
exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;
exports.PUNC_CHARS = PUNC_CHARS;
exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;
exports.UNICODE = UNICODE;
exports.is_letter = is_letter;
exports.is_digit = is_digit;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_unicode_combining_mark = is_unicode_combining_mark;
exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;
exports.is_identifier = is_identifier;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.is_identifier_string = is_identifier_string;
exports.parse_js_number = parse_js_number;
exports.JS_Parse_Error = JS_Parse_Error;
exports.js_error = js_error;
exports.is_token = is_token;
exports.EX_EOF = EX_EOF;
exports.tokenizer = tokenizer;
exports.UNARY_PREFIX = UNARY_PREFIX;
exports.UNARY_POSTFIX = UNARY_POSTFIX;
exports.ASSIGNMENT = ASSIGNMENT;
exports.PRECEDENCE = PRECEDENCE;
exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.parse = parse;
exports.TreeTransformer = TreeTransformer;
exports.SymbolDef = SymbolDef;
exports.base54 = base54;
exports.OutputStream = OutputStream;
exports.Compressor = Compressor;
exports.SourceMap = SourceMap;

exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }

exports.minify = function (files, options) {
    options = UglifyJS.defaults(options, {
        outSourceMap : null,
        sourceRoot   : null,
        inSourceMap  : null,
        fromString   : false,
        warnings     : false,
        mangle       : {},
        output       : null,
        compress     : {}
    });
    if (typeof files == "string")
        files = [ files ];

    UglifyJS.base54.reset();

    // 1. parse
    var toplevel = null;
    files.forEach(function(file){
        var code = options.fromString
            ? file
            : fs.readFileSync(file, "utf8");
        toplevel = UglifyJS.parse(code, {
            filename: options.fromString ? "?" : file,
            toplevel: toplevel
        });
    });

    // 2. compress
    if (options.compress) {
        var compress = { warnings: options.warnings };
        UglifyJS.merge(compress, options.compress);
        toplevel.figure_out_scope();
        var sq = UglifyJS.Compressor(compress);
        toplevel = toplevel.transform(sq);
    }

    // 3. mangle
    if (options.mangle) {
        toplevel.figure_out_scope();
        toplevel.compute_char_frequency();
        toplevel.mangle_names(options.mangle);
    }

    // 4. output
    var inMap = options.inSourceMap;
    var output = {};
    if (typeof options.inSourceMap == "string") {
        inMap = fs.readFileSync(options.inSourceMap, "utf8");
    }
    if (options.outSourceMap) {
        output.source_map = UglifyJS.SourceMap({
            file: options.outSourceMap,
            orig: inMap,
            root: options.sourceRoot
        });
    }
    if (options.output) {
        UglifyJS.merge(output, options.output);
    }
    var stream = UglifyJS.OutputStream(output);
    toplevel.print(stream);
    return {
        code : stream + "",
        map  : output.source_map + ""
    };
};

exports.describe_ast = function () {
    var out = UglifyJS.OutputStream({ beautify: true });
    function doitem(ctor) {
        out.print("AST_" + ctor.TYPE);
        var props = ctor.SELF_PROPS.filter(function(prop){
            return !/^\$/.test(prop);
        });
        if (props.length > 0) {
            out.space();
            out.with_parens(function(){
                props.forEach(function(prop, i){
                    if (i) out.space();
                    out.print(prop);
                });
            });
        }
        if (ctor.documentation) {
            out.space();
            out.print_string(ctor.documentation);
        }
        if (ctor.SUBCLASSES.length > 0) {
            out.space();
            out.with_block(function(){
                ctor.SUBCLASSES.forEach(function(ctor, i){
                    out.indent();
                    doitem(ctor);
                    out.newline();
                });
            });
        }
    };
    doitem(UglifyJS.AST_Node);
    return out + "";
};
},{"source-map":111,"util":4}],122:[function(require,module,exports){
var uglify = require('uglify-js')
var jade = require('jade/lib/jade.js')
var hljs = require('highlight.js')
var hljade = require('../highlight-jade.js')
var highlighters = {
  javascript: function (src) {
    return hljs.highlight('javascript', src).value;
  },
  html: function (src) {
    return hljs.highlight('xml', src).value;
  },
  jade: hljade
}

function $(selector, parent) {
  return (parent || document).querySelectorAll(selector)
}
function _(selector, parent) {
  return (parent || document).querySelector(selector)
}
function on(element, event, handler) {
  if (element)
    element.addEventListener(event, handler, false)
}


function enableTab(el) {
  el.onkeydown = function(e) {
    if (e.keyCode === 9) {// tab was pressed

      // get caret position/selection
      var val = this.value
      var start = this.selectionStart
      var end = this.selectionEnd

      // set textarea value to: text before caret + '  ' + text after caret
      this.value = val.substring(0, start) + '  ' + val.substring(end);

      // put caret at right position again
      this.selectionStart = this.selectionEnd = start + 2;

      // prevent the focus lose
      e.preventDefault()
    }
  }
  return el
}
function makeEditable(pre, language, onUpdate) {
  if (!pre) return
  var src = pre.textContent
  var editMode = false
  on(pre, 'click', function () {
    if (!editMode) {
      editMode = true
      pre.innerHTML = ''
      var textarea = document.createElement('textarea')
      enableTab(textarea)
      textarea.textContent = src
      pre.appendChild(textarea)
      textarea.focus()
      on(textarea, 'blur', function () {
        editMode = false
        src = textarea.value
        pre.innerHTML = ''
        var code = document.createElement('code')
        try {
          code.innerHTML = highlighters[language](src)
        } catch (ex) {
          code.textContent = src
        }
        pre.appendChild(code)
        onUpdate(src)
      })
    }
  })
}
function makeInteractive(control) {
  var jade = _('[data-control="input-jade"]', control)
  var jadeSRC = jade.textContent
  var js = _('[data-control="input-js"]', control)
  var jsSRC = js ? js.textContent : '{ pageTitle: "Jade", youAreUsingJade: true }'
  makeEditable(jade, 'jade', function (jade) {
    jadeSRC = jade
    update(control, jadeSRC, jsSRC)
  })
  makeEditable(js, 'javascript', function (js) {
    jsSRC = js
    update(control, jadeSRC, jsSRC)
  })
  if (_('[data-control="output-html"]', control) && _('[data-control="output-html"]', control).textContent.trim() === '')
    update(control, jadeSRC, jsSRC)
}
function update(control, jadeSRC, js) {
  var jsOut = _('[data-control="output-js"]', control)
  var htmlOut = _('[data-control="output-html"]', control)
  var jsObjA = {}
  var jsObjB = {}
  try {
    jsObjA = Function('', 'return ' + js)()
    jsObjB = Function('', 'return ' + js)()
  } catch (ex) {

  }
  if (jsOut) {
    jsObjA.client = true
    if (jsObjA.compileDebug === undefined) jsObjA.compileDebug = false
    var jsOutSrc = jade.compile(jadeSRC, jsObjA).toString()
    try {
      jsOutSrc = uglify.minify(jsOutSrc, {
        fromString: true,
        mangle: false,
        output: {beautify: true},
        compress: false
      }).code
    } catch (ex) {}
    jsOut.innerHTML = ''
    var code = document.createElement('code')
    try {
      code.innerHTML = highlighters.javascript(jsOutSrc)
    } catch (ex) {
      code.textContent = jsOutSrc
    }
    jsOut.appendChild(code)
  }
  if (htmlOut) {
    if (jsObjB.compileDebug === undefined) jsObjB.compileDebug = true
    if (jsObjB.pretty === undefined) jsObjB.pretty = true
    var htmlOutSrc = jade.compile(jadeSRC, jsObjB)(jsObjB)
    htmlOut.innerHTML = ''
    var code = document.createElement('code')
    try {
      code.innerHTML = highlighters.html(htmlOutSrc)
    } catch (ex) {
      code.textContent = htmlOutSrc
    }
    htmlOut.appendChild(code)
  }
}
var interactives = $('[data-control="interactive"]')
for (var i = 0; i < interactives.length; i++) {
  makeInteractive(interactives[i])
}
},{"../highlight-jade.js":123,"highlight.js":30,"jade/lib/jade.js":65,"uglify-js":121}],123:[function(require,module,exports){
var Lexer = require('jade/lib/lexer');
var hljs = require('highlight.js');
 
function highlightJavaScript(js) {
  return hljs.highlight('javascript', js).value;
}
 
function escape(src) {
  return src.replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
}
 
module.exports = highlightJade;
function highlightJade(jade) {
  var lexer = new Lexer(jade);
 
  var format = ''
  var last = null;
  var tok = {};
  var buf = [];
  var textMode = false;
  var textIndent = 0;
  var textBuf = '';
  function enterTextMode() {
    textMode = true;
    textIndent = 0;
    textBuf = '';
  }
  function exitTextMode() {
    if (textMode) {
      textMode = false;
      textIndent = 0;
      if (format === 'javascript') {
        buf.push(highlightJavaScript(textBuf))
      } else {
        buf.push(escape(textBuf));
      }
    }
  }
  while (tok.type !== 'eos') {
    last = tok;
    var before = lexer.input;
    tok = lexer.next();
    var after = lexer.input;
    var src = before.substr(0, before.length - after.length);
    if (textMode) {
      textBuf += escape(src);
      if (tok.type === 'indent') textIndent++;
      if (tok.type === 'outdent') textIndent--;
      if (textIndent <= 0) exitTextMode();
    } else {
      if (tok.type === 'tag') {
        switch (tok.val) {
          case 'script':
            format = 'javascript';
            break;
          case 'style':
            format = 'css';
            break;
          default:
            format = '';
            break;
        }
      }
      switch (tok.type) {
        case 'text':
          if (tok.val === '.') {
            buf.push(escape(src));
            enterTextMode();
          } else {
            buf.push(escape(src));
          }
          break;
        case 'newline':
          buf.push(escape(src));
          if (textIndent <= 0) exitTextMode();
          break;
        case 'outdent':
          buf.push(escape(src));
          break;
        case 'indent':
          buf.push(escape(src));
          break;
        case 'filter':
          buf.push('<span class="keyword">' + escape(src) + '</span>');
          enterTextMode();
          break;
        case 'code':
          buf.push(highlightJavaScript(src));
          break;
        case 'attrs':
          buf.push(highlightJavaScript(src).replace(/(<span[^<]+<\/)|(^\([^=]+=)|(,[^=]+=)/g, function (_, span, begin, mid) {
            if (span) return _;
            if (begin) {
              return '(<span class="attribute">' + begin.substr(1, begin.length - 2) + '</span>='
            }
            if (mid) {
              return ',<span class="attribute">' + mid.substr(1, mid.length - 2) + '</span>='
            }
          }));
          break;
        case 'include':
          buf.push('<span class="keyword">include</span> <span class="string">' + escape(src.replace(/^include /, '')) + '</span>');
          break;
        case 'extends':
          buf.push('<span class="keyword">extends</span> <span class="string">' + escape(src.replace(/^extends /, '')) + '</span>');
          break;
        case 'block':
          buf.push('<span class="keyword">block</span>' + escape(src.replace(/^block/, '')));
          break;
        case 'mixin':
          buf.push('<span class="keyword">mixin</span>' + highlightJavaScript(src.replace(/^mixin/, '')));
          break;
        case 'call':
          buf.push('<span class="keyword">+</span>' + highlightJavaScript(src.replace(/^\+/, '')));
          break;
        case 'yield':
          buf.push('<span class="keyword">' + escape(src) + '</span>');
          break;
        case 'eos':
          break;
        default:
          buf.push('<span class="' + tok.type + '">' + escape(src) + '</span>');
      }
    }
  }
  return buf.join('');
};
},{"highlight.js":30,"jade/lib/lexer":66}]},{},[122])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL2V2ZW50cy5qcyIsIi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vZnMuanMiLCIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3BhdGguanMiLCIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3V0aWwuanMiLCIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy8xYy5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2FjdGlvbnNjcmlwdC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2FwYWNoZS5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2FwcGxlc2NyaXB0LmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvYXZyYXNtLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvYXhhcHRhLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvYmFzaC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2JyYWluZnVjay5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2Nsb2p1cmUuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9jbWFrZS5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2NvZmZlZXNjcmlwdC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2NwcC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2NzLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvY3NzLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2RlbHBoaS5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2RpZmYuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9kamFuZ28uanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9kb3MuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcmxhbmctcmVwbC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VybGFuZy5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2dsc2wuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9nby5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2hhc2tlbGwuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9oaWdobGlnaHQuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9odHRwLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvaW5pLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvamF2YS5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2phdmFzY3JpcHQuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9qc29uLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGlzcC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2x1YS5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL21hcmtkb3duLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbWF0bGFiLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbWVsLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbmdpbnguanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9vYmplY3RpdmVjLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvcGFyc2VyMy5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL3BlcmwuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9waHAuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9wcm9maWxlLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvcHl0aG9uLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvci5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL3JpYi5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL3JzbC5qcyIsIi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL3J1YnkuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9ydXN0LmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvc2NhbGEuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9zbWFsbHRhbGsuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9zcWwuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy90ZXguanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy92YWxhLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvdmJzY3JpcHQuanMiLCIvbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy92aGRsLmpzIiwiL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMveG1sLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9jb21waWxlci5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvZG9jdHlwZXMuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbGliL2ZpbHRlcnMtY2xpZW50LmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9pbmxpbmUtdGFncy5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvamFkZS5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbGV4ZXIuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbGliL25vZGVzL2F0dHJzLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9ub2Rlcy9ibG9jay1jb21tZW50LmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9ub2Rlcy9ibG9jay5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvY2FzZS5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvY29kZS5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvY29tbWVudC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvZG9jdHlwZS5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvZWFjaC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvZmlsdGVyLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9ub2Rlcy9pbmRleC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvbGl0ZXJhbC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvbWl4aW4uanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbGliL25vZGVzL25vZGUuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbGliL25vZGVzL3RhZy5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvbm9kZXMvdGV4dC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9saWIvcGFyc2VyLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9ydW50aW1lLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL2xpYi9zZWxmLWNsb3NpbmcuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbGliL3V0aWxzLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jaGFyYWN0ZXItcGFyc2VyL2luZGV4LmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9pbmRleC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvY29uc3RhbnRpbm9wbGUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvY29uc3RhbnRpbm9wbGUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9hcnJheS1zZXQuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL2NvbnN0YW50aW5vcGxlL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvY29uc3RhbnRpbm9wbGUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL2NvbnN0YW50aW5vcGxlL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmluYXJ5LXNlYXJjaC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvY29uc3RhbnRpbm9wbGUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL2NvbnN0YW50aW5vcGxlL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2FtZGVmaW5lL2FtZGVmaW5lLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL3Rvb2xzL25vZGUuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvaW5kZXguanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvd2l0aC9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2FycmF5LXNldC5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvd2l0aC9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC12bHEuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iaW5hcnktc2VhcmNoLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy93aXRoL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIi9ub2RlX21vZHVsZXMvamFkZS9ub2RlX21vZHVsZXMvd2l0aC9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy93aXRoL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW5vZGUuanMiLCIvbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC91dGlsLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy93aXRoL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbm9kZV9tb2R1bGVzL2FtZGVmaW5lL2FtZGVmaW5lLmpzIiwiL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy93aXRoL25vZGVfbW9kdWxlcy91Z2xpZnktanMvdG9vbHMvbm9kZS5qcyIsIi9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLmpzIiwiL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwiL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsIi9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC5qcyIsIi9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2Utbm9kZS5qcyIsIi9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCIvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy90b29scy9ub2RlLmpzIiwiL3NyYy9jbGllbnQvaW5kZXguanMiLCIvc3JjL2hpZ2hsaWdodC1qYWRlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMStPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMStPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHJvY2Vzcz1yZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIik7aWYgKCFwcm9jZXNzLkV2ZW50RW1pdHRlcikgcHJvY2Vzcy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nXG4gICAgPyBBcnJheS5pc0FycmF5XG4gICAgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9XG47XG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4vLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbi8vXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xufTtcblxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKVxuICAgIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEV2ZW50RW1pdHRlciBpcyBkZWZpbmVkIGluIHNyYy9ub2RlX2V2ZW50cy5jY1xuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBpID0gaW5kZXhPZihsaXN0LCBsaXN0ZW5lcik7XG4gICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpcztcbiAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICB9XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5fZXZlbnRzW3R5cGVdID09PSAnZnVuY3Rpb24nKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcbiIsIi8vIG5vdGhpbmcgdG8gc2VlIGhlcmUuLi4gbm8gZmlsZSBtZXRob2RzIGZvciB0aGUgYnJvd3NlclxuIiwidmFyIHByb2Nlc3M9cmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpO2Z1bmN0aW9uIGZpbHRlciAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gUmVnZXggdG8gc3BsaXQgYSBmaWxlbmFtZSBpbnRvIFsqLCBkaXIsIGJhc2VuYW1lLCBleHRdXG4vLyBwb3NpeCB2ZXJzaW9uXG52YXIgc3BsaXRQYXRoUmUgPSAvXiguK1xcLyg/ISQpfFxcLyk/KCg/Oi4rPyk/KFxcLlteLl0qKT8pJC87XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xudmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICB2YXIgcGF0aCA9IChpID49IDApXG4gICAgICA/IGFyZ3VtZW50c1tpXVxuICAgICAgOiBwcm9jZXNzLmN3ZCgpO1xuXG4gIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnIHx8ICFwYXRoKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbi8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xudmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nO1xuXG4vLyBOb3JtYWxpemUgdGhlIHBhdGhcbnBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cbiAgXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgZGlyID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVsxXSB8fCAnJztcbiAgdmFyIGlzV2luZG93cyA9IGZhbHNlO1xuICBpZiAoIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWVcbiAgICByZXR1cm4gJy4nO1xuICB9IGVsc2UgaWYgKGRpci5sZW5ndGggPT09IDEgfHxcbiAgICAgIChpc1dpbmRvd3MgJiYgZGlyLmxlbmd0aCA8PSAzICYmIGRpci5jaGFyQXQoMSkgPT09ICc6JykpIHtcbiAgICAvLyBJdCBpcyBqdXN0IGEgc2xhc2ggb3IgYSBkcml2ZSBsZXR0ZXIgd2l0aCBhIHNsYXNoXG4gICAgcmV0dXJuIGRpcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJdCBpcyBhIGZ1bGwgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICByZXR1cm4gZGlyLnN1YnN0cmluZygwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbMl0gfHwgJyc7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVszXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbihvYmope3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nfTtcbmV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbihvYmope3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSd9O1xuXG5cbmV4cG9ydHMucHJpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMucHV0cyA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5kZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbmV4cG9ydHMuaW5zcGVjdCA9IGZ1bmN0aW9uKG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgc2VlbiA9IFtdO1xuXG4gIHZhciBzdHlsaXplID0gZnVuY3Rpb24oc3RyLCBzdHlsZVR5cGUpIHtcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbiAgICB2YXIgc3R5bGVzID1cbiAgICAgICAgeyAnYm9sZCcgOiBbMSwgMjJdLFxuICAgICAgICAgICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgICAgICAgICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICAgICAgICAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgICAgICAgICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICAgICAgICAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICAgICAgICAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAgICAgICAgICdibHVlJyA6IFszNCwgMzldLFxuICAgICAgICAgICdjeWFuJyA6IFszNiwgMzldLFxuICAgICAgICAgICdncmVlbicgOiBbMzIsIDM5XSxcbiAgICAgICAgICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgICAgICAgICAncmVkJyA6IFszMSwgMzldLFxuICAgICAgICAgICd5ZWxsb3cnIDogWzMzLCAzOV0gfTtcblxuICAgIHZhciBzdHlsZSA9XG4gICAgICAgIHsgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICAgICAgICAgJ251bWJlcic6ICdibHVlJyxcbiAgICAgICAgICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAgICAgICAgICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICAgICAgICAgJ251bGwnOiAnYm9sZCcsXG4gICAgICAgICAgJ3N0cmluZyc6ICdncmVlbicsXG4gICAgICAgICAgJ2RhdGUnOiAnbWFnZW50YScsXG4gICAgICAgICAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgICAgICAgICAncmVnZXhwJzogJ3JlZCcgfVtzdHlsZVR5cGVdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gJ1xcdTAwMWJbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXHUwMDFiWycgKyBzdHlsZXNbc3R5bGVdWzFdICsgJ20nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEgY29sb3JzKSB7XG4gICAgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7IHJldHVybiBzdHI7IH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlICE9PSBleHBvcnRzICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciB2aXNpYmxlX2tleXMgPSBPYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSBzaG93SGlkZGVuID8gT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXModmFsdWUpIDogdmlzaWJsZV9rZXlzO1xuXG4gICAgLy8gRnVuY3Rpb25zIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGF0ZXMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZFxuICAgIGlmIChpc0RhdGUodmFsdWUpICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSh2YWx1ZS50b1VUQ1N0cmluZygpLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCB0eXBlLCBicmFjZXM7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdBcnJheSc7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ09iamVjdCc7XG4gICAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gKGlzUmVnRXhwKHZhbHVlKSkgPyAnICcgKyB2YWx1ZSA6ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIHZhbHVlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICB2YXIgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbmFtZSwgc3RyO1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVfa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gICAgfSk7XG5cbiAgICBzZWVuLnBvcCgpO1xuXG4gICAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgIG51bUxpbmVzRXN0Kys7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGxlbmd0aCA+IDUwKSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBicmFjZXNbMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICB0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcyl7XG4gIHZhciBJREVOVF9SRV9SVSA9ICdbYS16QS1a0LAt0Y/QkC3Qr11bYS16QS1aMC05X9CwLdGP0JAt0K9dKic7XG4gIHZhciBPbmVTX0tFWVdPUkRTID0gJ9Cy0L7Qt9Cy0YDQsNGCINC00LDRgtCwINC00LvRjyDQtdGB0LvQuCDQuCDQuNC70Lgg0LjQvdCw0YfQtSDQuNC90LDRh9C10LXRgdC70Lgg0LjRgdC60LvRjtGH0LXQvdC40LUg0LrQvtC90LXRhtC10YHQu9C4ICcgK1xuICAgICfQutC+0L3QtdGG0L/QvtC/0YvRgtC60Lgg0LrQvtC90LXRhtC/0YDQvtGG0LXQtNGD0YDRiyDQutC+0L3QtdGG0YTRg9C90LrRhtC40Lgg0LrQvtC90LXRhtGG0LjQutC70LAg0LrQvtC90YHRgtCw0L3RgtCwINC90LUg0L/QtdGA0LXQudGC0Lgg0L/QtdGA0LXQvCAnICtcbiAgICAn0L/QtdGA0LXRh9C40YHQu9C10L3QuNC1INC/0L4g0L/QvtC60LAg0L/QvtC/0YvRgtC60LAg0L/RgNC10YDQstCw0YLRjCDQv9GA0L7QtNC+0LvQttC40YLRjCDQv9GA0L7RhtC10LTRg9GA0LAg0YHRgtGA0L7QutCwINGC0L7Qs9C00LAg0YTRgSDRhNGD0L3QutGG0LjRjyDRhtC40LrQuyAnICtcbiAgICAn0YfQuNGB0LvQviDRjdC60YHQv9C+0YDRgic7XG4gIHZhciBPbmVTX0JVSUxUX0lOID0gJ2Fuc2l0b29lbSBvZW10b2Fuc2kg0LLQstC10YHRgtC40LLQuNC00YHRg9Cx0LrQvtC90YLQviDQstCy0LXRgdGC0LjQtNCw0YLRgyDQstCy0LXRgdGC0LjQt9C90LDRh9C10L3QuNC1ICcgK1xuICAgICfQstCy0LXRgdGC0LjQv9C10YDQtdGH0LjRgdC70LXQvdC40LUg0LLQstC10YHRgtC40L/QtdGA0LjQvtC0INCy0LLQtdGB0YLQuNC/0LvQsNC90YHRh9C10YLQvtCyINCy0LLQtdGB0YLQuNGB0YLRgNC+0LrRgyDQstCy0LXRgdGC0LjRh9C40YHQu9C+INCy0L7Qv9GA0L7RgSAnICtcbiAgICAn0LLQvtGB0YHRgtCw0L3QvtCy0LjRgtGM0LfQvdCw0YfQtdC90LjQtSDQstGA0LXQsyDQstGL0LHRgNCw0L3QvdGL0LnQv9C70LDQvdGB0YfQtdGC0L7QsiDQstGL0LfQstCw0YLRjNC40YHQutC70Y7Rh9C10L3QuNC1INC00LDRgtCw0LPQvtC0INC00LDRgtCw0LzQtdGB0Y/RhiAnICtcbiAgICAn0LTQsNGC0LDRh9C40YHQu9C+INC00L7QsdCw0LLQuNGC0YzQvNC10YHRj9GGINC30LDQstC10YDRiNC40YLRjNGA0LDQsdC+0YLRg9GB0LjRgdGC0LXQvNGLINC30LDQs9C+0LvQvtCy0L7QutGB0LjRgdGC0LXQvNGLINC30LDQv9C40YHRjNC20YPRgNC90LDQu9Cw0YDQtdCz0LjRgdGC0YDQsNGG0LjQuCAnICtcbiAgICAn0LfQsNC/0YPRgdGC0LjRgtGM0L/RgNC40LvQvtC20LXQvdC40LUg0LfQsNGE0LjQutGB0LjRgNC+0LLQsNGC0YzRgtGA0LDQvdC30LDQutGG0LjRjiDQt9C90LDRh9C10L3QuNC10LLRgdGC0YDQvtC60YMg0LfQvdCw0YfQtdC90LjQtdCy0YHRgtGA0L7QutGD0LLQvdGD0YLRgCAnICtcbiAgICAn0LfQvdCw0YfQtdC90LjQtdCy0YTQsNC50Lsg0LfQvdCw0YfQtdC90LjQtdC40LfRgdGC0YDQvtC60Lgg0LfQvdCw0YfQtdC90LjQtdC40LfRgdGC0YDQvtC60LjQstC90YPRgtGAINC30L3QsNGH0LXQvdC40LXQuNC30YTQsNC50LvQsCDQuNC80Y/QutC+0LzQv9GM0Y7RgtC10YDQsCAnICtcbiAgICAn0LjQvNGP0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINC60LDRgtCw0LvQvtCz0LLRgNC10LzQtdC90L3Ri9GF0YTQsNC50LvQvtCyINC60LDRgtCw0LvQvtCz0LjQsSDQutCw0YLQsNC70L7Qs9C/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQutCw0YLQsNC70L7Qs9C/0YDQvtCz0YDQsNC80LzRiyAnICtcbiAgICAn0LrQvtC00YHQuNC80LIg0LrQvtC80LDQvdC00LDRgdC40YHRgtC10LzRiyDQutC+0L3Qs9C+0LTQsCDQutC+0L3QtdGG0L/QtdGA0LjQvtC00LDQsdC4INC60L7QvdC10YbRgNCw0YHRgdGH0LjRgtCw0L3QvdC+0LPQvtC/0LXRgNC40L7QtNCw0LHQuCAnICtcbiAgICAn0LrQvtC90LXRhtGB0YLQsNC90LTQsNGA0YLQvdC+0LPQvtC40L3RgtC10YDQstCw0LvQsCDQutC+0L3QutCy0LDRgNGC0LDQu9CwINC60L7QvdC80LXRgdGP0YbQsCDQutC+0L3QvdC10LTQtdC70Lgg0LvQtdCyINC70L7QsyDQu9C+0LMxMCDQvNCw0LrRgSAnICtcbiAgICAn0LzQsNC60YHQuNC80LDQu9GM0L3QvtC10LrQvtC70LjRh9C10YHRgtCy0L7RgdGD0LHQutC+0L3RgtC+INC80LjQvSDQvNC+0L3QvtC/0L7Qu9GM0L3Ri9C50YDQtdC20LjQvCDQvdCw0LfQstCw0L3QuNC10LjQvdGC0LXRgNGE0LXQudGB0LAg0L3QsNC30LLQsNC90LjQtdC90LDQsdC+0YDQsNC/0YDQsNCyICcgK1xuICAgICfQvdCw0LfQvdCw0YfQuNGC0YzQstC40LQg0L3QsNC30L3QsNGH0LjRgtGM0YHRh9C10YIg0L3QsNC50YLQuCDQvdCw0LnRgtC40L/QvtC80LXRh9C10L3QvdGL0LXQvdCw0YPQtNCw0LvQtdC90LjQtSDQvdCw0LnRgtC40YHRgdGL0LvQutC4INC90LDRh9Cw0LvQvtC/0LXRgNC40L7QtNCw0LHQuCAnICtcbiAgICAn0L3QsNGH0LDQu9C+0YHRgtCw0L3QtNCw0YDRgtC90L7Qs9C+0LjQvdGC0LXRgNCy0LDQu9CwINC90LDRh9Cw0YLRjNGC0YDQsNC90LfQsNC60YbQuNGOINC90LDRh9Cz0L7QtNCwINC90LDRh9C60LLQsNGA0YLQsNC70LAg0L3QsNGH0LzQtdGB0Y/RhtCwINC90LDRh9C90LXQtNC10LvQuCAnICtcbiAgICAn0L3QvtC80LXRgNC00L3Rj9Cz0L7QtNCwINC90L7QvNC10YDQtNC90Y/QvdC10LTQtdC70Lgg0L3QvtC80LXRgNC90LXQtNC10LvQuNCz0L7QtNCwINC90YDQtdCzINC+0LHRgNCw0LHQvtGC0LrQsNC+0LbQuNC00LDQvdC40Y8g0L7QutGAINC+0L/QuNGB0LDQvdC40LXQvtGI0LjQsdC60LggJyArXG4gICAgJ9C+0YHQvdC+0LLQvdC+0LnQttGD0YDQvdCw0LvRgNCw0YHRh9C10YLQvtCyINC+0YHQvdC+0LLQvdC+0LnQv9C70LDQvdGB0YfQtdGC0L7QsiDQvtGB0L3QvtCy0L3QvtC50Y/Qt9GL0Log0L7RgtC60YDRi9GC0YzRhNC+0YDQvNGDINC+0YLQutGA0YvRgtGM0YTQvtGA0LzRg9C80L7QtNCw0LvRjNC90L4gJyArXG4gICAgJ9C+0YLQvNC10L3QuNGC0YzRgtGA0LDQvdC30LDQutGG0LjRjiDQvtGH0LjRgdGC0LjRgtGM0L7QutC90L7RgdC+0L7QsdGJ0LXQvdC40Lkg0L/QtdGA0LjQvtC00YHRgtGAINC/0L7Qu9C90L7QtdC40LzRj9C/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQv9C+0LvRg9GH0LjRgtGM0LLRgNC10LzRj9GC0LAgJyArXG4gICAgJ9C/0L7Qu9GD0YfQuNGC0YzQtNCw0YLRg9GC0LAg0L/QvtC70YPRh9C40YLRjNC00L7QutGD0LzQtdC90YLRgtCwINC/0L7Qu9GD0YfQuNGC0YzQt9C90LDRh9C10L3QuNGP0L7RgtCx0L7RgNCwINC/0L7Qu9GD0YfQuNGC0YzQv9C+0LfQuNGG0LjRjtGC0LAgJyArXG4gICAgJ9C/0L7Qu9GD0YfQuNGC0YzQv9GD0YHRgtC+0LXQt9C90LDRh9C10L3QuNC1INC/0L7Qu9GD0YfQuNGC0YzRgtCwINC/0YDQsNCyINC/0YDQsNCy0L7QtNC+0YHRgtGD0L/QsCDQv9GA0LXQtNGD0L/RgNC10LbQtNC10L3QuNC1INC/0YDQtdGE0LjQutGB0LDQstGC0L7QvdGD0LzQtdGA0LDRhtC40LggJyArXG4gICAgJ9C/0YPRgdGC0LDRj9GB0YLRgNC+0LrQsCDQv9GD0YHRgtC+0LXQt9C90LDRh9C10L3QuNC1INGA0LDQsdC+0YfQsNGP0LTQsNGC0YLRjNC/0YPRgdGC0L7QtdC30L3QsNGH0LXQvdC40LUg0YDQsNCx0L7Rh9Cw0Y/QtNCw0YLQsCDRgNCw0LfQtNC10LvQuNGC0LXQu9GM0YHRgtGA0LDQvdC40YYgJyArXG4gICAgJ9GA0LDQt9C00LXQu9C40YLQtdC70YzRgdGC0YDQvtC6INGA0LDQt9C8INGA0LDQt9C+0LHRgNCw0YLRjNC/0L7Qt9C40YbQuNGO0LTQvtC60YPQvNC10L3RgtCwINGA0LDRgdGB0YfQuNGC0LDRgtGM0YDQtdCz0LjRgdGC0YDRi9C90LAgJyArXG4gICAgJ9GA0LDRgdGB0YfQuNGC0LDRgtGM0YDQtdCz0LjRgdGC0YDRi9C/0L4g0YHQuNCz0L3QsNC7INGB0LjQvNCyINGB0LjQvNCy0L7Qu9GC0LDQsdGD0LvRj9GG0LjQuCDRgdC+0LfQtNCw0YLRjNC+0LHRitC10LrRgiDRgdC+0LrRgNC7INGB0L7QutGA0LvQvyDRgdC+0LrRgNC/ICcgK1xuICAgICfRgdC+0L7QsdGJ0LjRgtGMINGB0L7RgdGC0L7Rj9C90LjQtSDRgdC+0YXRgNCw0L3QuNGC0YzQt9C90LDRh9C10L3QuNC1INGB0YDQtdC0INGB0YLQsNGC0YPRgdCy0L7Qt9Cy0YDQsNGC0LAg0YHRgtGA0LTQu9C40L3QsCDRgdGC0YDQt9Cw0LzQtdC90LjRgtGMICcgK1xuICAgICfRgdGC0YDQutC+0LvQuNGH0LXRgdGC0LLQvtGB0YLRgNC+0Log0YHRgtGA0L/QvtC70YPRh9C40YLRjNGB0YLRgNC+0LrRgyAg0YHRgtGA0YfQuNGB0LvQvtCy0YXQvtC20LTQtdC90LjQuSDRgdGE0L7RgNC80LjRgNC+0LLQsNGC0YzQv9C+0LfQuNGG0LjRjtC00L7QutGD0LzQtdC90YLQsCAnICtcbiAgICAn0YHRh9C10YLQv9C+0LrQvtC00YMg0YLQtdC60YPRidCw0Y/QtNCw0YLQsCDRgtC10LrRg9GJ0LXQtdCy0YDQtdC80Y8g0YLQuNC/0LfQvdCw0YfQtdC90LjRjyDRgtC40L/Qt9C90LDRh9C10L3QuNGP0YHRgtGAINGD0LTQsNC70LjRgtGM0L7QsdGK0LXQutGC0YsgJyArXG4gICAgJ9GD0YHRgtCw0L3QvtCy0LjRgtGM0YLQsNC90LAg0YPRgdGC0LDQvdC+0LLQuNGC0YzRgtCw0L/QviDRhNC40LrRgdGI0LDQsdC70L7QvSDRhNC+0YDQvNCw0YIg0YbQtdC7INGI0LDQsdC70L7QvSc7XG4gIHZhciBEUVVPVEUgPSAge2NsYXNzTmFtZTogJ2RxdW90ZScsICBiZWdpbjogJ1wiXCInfTtcbiAgdmFyIFNUUl9TVEFSVCA9IHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCJ8JCcsXG4gICAgICBjb250YWluczogW0RRVU9URV0sXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9O1xuICB2YXIgU1RSX0NPTlQgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1xcXFx8JywgZW5kOiAnXCJ8JCcsXG4gICAgY29udGFpbnM6IFtEUVVPVEVdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGxleGVtczogSURFTlRfUkVfUlUsXG4gICAga2V5d29yZHM6IHtrZXl3b3JkOiBPbmVTX0tFWVdPUkRTLCBidWlsdF9pbjogT25lU19CVUlMVF9JTn0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuTlVNQkVSX01PREUsXG4gICAgICBTVFJfU1RBUlQsIFNUUl9DT05ULFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luOiAnKNC/0YDQvtGG0LXQtNGD0YDQsHzRhNGD0L3QutGG0LjRjyknLCBlbmQ6ICckJyxcbiAgICAgICAgbGV4ZW1zOiBJREVOVF9SRV9SVSxcbiAgICAgICAga2V5d29yZHM6ICfQv9GA0L7RhtC10LTRg9GA0LAg0YTRg9C90LrRhtC40Y8nLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtjbGFzc05hbWU6ICd0aXRsZScsIGJlZ2luOiBJREVOVF9SRV9SVX0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndGFpbCcsXG4gICAgICAgICAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgICAgICAgICAgbGV4ZW1zOiBJREVOVF9SRV9SVSxcbiAgICAgICAgICAgICAgICBrZXl3b3JkczogJ9C30L3QsNGHJyxcbiAgICAgICAgICAgICAgICBjb250YWluczogW1NUUl9TVEFSVCwgU1RSX0NPTlRdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdleHBvcnQnLFxuICAgICAgICAgICAgICAgIGJlZ2luOiAn0Y3QutGB0L/QvtGA0YInLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsZXhlbXM6IElERU5UX1JFX1JVLFxuICAgICAgICAgICAgICAgIGtleXdvcmRzOiAn0Y3QutGB0L/QvtGA0YInLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtjbGFzc05hbWU6ICdwcmVwcm9jZXNzb3InLCBiZWdpbjogJyMnLCBlbmQ6ICckJ30sXG4gICAgICB7Y2xhc3NOYW1lOiAnZGF0ZScsIGJlZ2luOiAnXFwnXFxcXGR7Mn1cXFxcLlxcXFxkezJ9XFxcXC4oXFxcXGR7Mn18XFxcXGR7NH0pXFwnJ31cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW2EtekEtWl8kXVthLXpBLVowLTlfJF0qJztcbiAgdmFyIElERU5UX0ZVTkNfUkVUVVJOX1RZUEVfUkUgPSAnKFsqXXxbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopJztcblxuICB2YXIgQVMzX1JFU1RfQVJHX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAncmVzdF9hcmcnLFxuICAgIGJlZ2luOiAnWy5dezN9JywgZW5kOiBJREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDEwXG4gIH07XG4gIHZhciBUSVRMRV9NT0RFID0ge2NsYXNzTmFtZTogJ3RpdGxlJywgYmVnaW46IElERU5UX1JFfTtcblxuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOiAnYXMgYnJlYWsgY2FzZSBjYXRjaCBjbGFzcyBjb25zdCBjb250aW51ZSBkZWZhdWx0IGRlbGV0ZSBkbyBkeW5hbWljIGVhY2ggJyArXG4gICAgICAgICdlbHNlIGV4dGVuZHMgZmluYWwgZmluYWxseSBmb3IgZnVuY3Rpb24gZ2V0IGlmIGltcGxlbWVudHMgaW1wb3J0IGluIGluY2x1ZGUgJyArXG4gICAgICAgICdpbnN0YW5jZW9mIGludGVyZmFjZSBpbnRlcm5hbCBpcyBuYW1lc3BhY2UgbmF0aXZlIG5ldyBvdmVycmlkZSBwYWNrYWdlIHByaXZhdGUgJyArXG4gICAgICAgICdwcm90ZWN0ZWQgcHVibGljIHJldHVybiBzZXQgc3RhdGljIHN1cGVyIHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdXNlIHZhciB2b2lkICcgK1xuICAgICAgICAnd2hpbGUgd2l0aCcsXG4gICAgICBsaXRlcmFsOiAndHJ1ZSBmYWxzZSBudWxsIHVuZGVmaW5lZCdcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncGFja2FnZScsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ3snLFxuICAgICAgICBrZXl3b3JkczogJ3BhY2thZ2UnLFxuICAgICAgICBjb250YWluczogW1RJVExFX01PREVdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ3snLFxuICAgICAgICBrZXl3b3JkczogJ2NsYXNzIGludGVyZmFjZScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSxcbiAgICAgICAgICAgIGtleXdvcmRzOiAnZXh0ZW5kcyBpbXBsZW1lbnRzJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgVElUTEVfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdwcmVwcm9jZXNzb3InLFxuICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBlbmQ6ICc7JyxcbiAgICAgICAga2V5d29yZHM6ICdpbXBvcnQgaW5jbHVkZSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSwgZW5kOiAnW3s7XScsXG4gICAgICAgIGtleXdvcmRzOiAnZnVuY3Rpb24nLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXFMnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFRJVExFX01PREUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICAgICAgQVMzX1JFU1RfQVJHX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgYmVnaW46ICc6JyxcbiAgICAgICAgICAgIGVuZDogSURFTlRfRlVOQ19SRVRVUk5fVFlQRV9SRSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgTlVNQkVSID0ge2NsYXNzTmFtZTogJ251bWJlcicsIGJlZ2luOiAnW1xcXFwkJV1cXFxcZCsnfTtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOiAnYWNjZXB0ZmlsdGVyIGFjY2VwdG11dGV4IGFjY2VwdHBhdGhpbmZvIGFjY2Vzc2ZpbGVuYW1lIGFjdGlvbiBhZGRhbHQgJyArXG4gICAgICAgICdhZGRhbHRieWVuY29kaW5nIGFkZGFsdGJ5dHlwZSBhZGRjaGFyc2V0IGFkZGRlZmF1bHRjaGFyc2V0IGFkZGRlc2NyaXB0aW9uICcgK1xuICAgICAgICAnYWRkZW5jb2RpbmcgYWRkaGFuZGxlciBhZGRpY29uIGFkZGljb25ieWVuY29kaW5nIGFkZGljb25ieXR5cGUgYWRkaW5wdXRmaWx0ZXIgJyArXG4gICAgICAgICdhZGRsYW5ndWFnZSBhZGRtb2R1bGVpbmZvIGFkZG91dHB1dGZpbHRlciBhZGRvdXRwdXRmaWx0ZXJieXR5cGUgYWRkdHlwZSBhbGlhcyAnICtcbiAgICAgICAgJ2FsaWFzbWF0Y2ggYWxsb3cgYWxsb3djb25uZWN0IGFsbG93ZW5jb2RlZHNsYXNoZXMgYWxsb3dvdmVycmlkZSBhbm9ueW1vdXMgJyArXG4gICAgICAgICdhbm9ueW1vdXNfbG9nZW1haWwgYW5vbnltb3VzX211c3RnaXZlZW1haWwgYW5vbnltb3VzX25vdXNlcmlkIGFub255bW91c192ZXJpZnllbWFpbCAnICtcbiAgICAgICAgJ2F1dGhiYXNpY2F1dGhvcml0YXRpdmUgYXV0aGJhc2ljcHJvdmlkZXIgYXV0aGRiZHVzZXJwd3F1ZXJ5IGF1dGhkYmR1c2VycmVhbG1xdWVyeSAnICtcbiAgICAgICAgJ2F1dGhkYm1ncm91cGZpbGUgYXV0aGRibXR5cGUgYXV0aGRibXVzZXJmaWxlIGF1dGhkZWZhdWx0YXV0aG9yaXRhdGl2ZSAnICtcbiAgICAgICAgJ2F1dGhkaWdlc3RhbGdvcml0aG0gYXV0aGRpZ2VzdGRvbWFpbiBhdXRoZGlnZXN0bmNjaGVjayBhdXRoZGlnZXN0bm9uY2Vmb3JtYXQgJyArXG4gICAgICAgICdhdXRoZGlnZXN0bm9uY2VsaWZldGltZSBhdXRoZGlnZXN0cHJvdmlkZXIgYXV0aGRpZ2VzdHFvcCBhdXRoZGlnZXN0c2htZW1zaXplICcgK1xuICAgICAgICAnYXV0aGdyb3VwZmlsZSBhdXRobGRhcGJpbmRkbiBhdXRobGRhcGJpbmRwYXNzd29yZCBhdXRobGRhcGNoYXJzZXRjb25maWcgJyArXG4gICAgICAgICdhdXRobGRhcGNvbXBhcmVkbm9uc2VydmVyIGF1dGhsZGFwZGVyZWZlcmVuY2VhbGlhc2VzIGF1dGhsZGFwZ3JvdXBhdHRyaWJ1dGUgJyArXG4gICAgICAgICdhdXRobGRhcGdyb3VwYXR0cmlidXRlaXNkbiBhdXRobGRhcHJlbW90ZXVzZXJhdHRyaWJ1dGUgYXV0aGxkYXByZW1vdGV1c2VyaXNkbiAnICtcbiAgICAgICAgJ2F1dGhsZGFwdXJsIGF1dGhuYW1lIGF1dGhucHJvdmlkZXJhbGlhcyBhdXRodHlwZSBhdXRodXNlcmZpbGUgYXV0aHpkYm1hdXRob3JpdGF0aXZlICcgK1xuICAgICAgICAnYXV0aHpkYm10eXBlIGF1dGh6ZGVmYXVsdGF1dGhvcml0YXRpdmUgYXV0aHpncm91cGZpbGVhdXRob3JpdGF0aXZlICcgK1xuICAgICAgICAnYXV0aHpsZGFwYXV0aG9yaXRhdGl2ZSBhdXRoem93bmVyYXV0aG9yaXRhdGl2ZSBhdXRoenVzZXJhdXRob3JpdGF0aXZlICcgK1xuICAgICAgICAnYmFsYW5jZXJtZW1iZXIgYnJvd3Nlcm1hdGNoIGJyb3dzZXJtYXRjaG5vY2FzZSBidWZmZXJlZGxvZ3MgY2FjaGVkZWZhdWx0ZXhwaXJlICcgK1xuICAgICAgICAnY2FjaGVkaXJsZW5ndGggY2FjaGVkaXJsZXZlbHMgY2FjaGVkaXNhYmxlIGNhY2hlZW5hYmxlIGNhY2hlZmlsZSAnICtcbiAgICAgICAgJ2NhY2hlaWdub3JlY2FjaGVjb250cm9sIGNhY2hlaWdub3JlaGVhZGVycyBjYWNoZWlnbm9yZW5vbGFzdG1vZCAnICtcbiAgICAgICAgJ2NhY2hlaWdub3JlcXVlcnlzdHJpbmcgY2FjaGVsYXN0bW9kaWZpZWRmYWN0b3IgY2FjaGVtYXhleHBpcmUgY2FjaGVtYXhmaWxlc2l6ZSAnICtcbiAgICAgICAgJ2NhY2hlbWluZmlsZXNpemUgY2FjaGVuZWdvdGlhdGVkZG9jcyBjYWNoZXJvb3QgY2FjaGVzdG9yZW5vc3RvcmUgY2FjaGVzdG9yZXByaXZhdGUgJyArXG4gICAgICAgICdjZ2ltYXBleHRlbnNpb24gY2hhcnNldGRlZmF1bHQgY2hhcnNldG9wdGlvbnMgY2hhcnNldHNvdXJjZWVuYyBjaGVja2Nhc2Vvbmx5ICcgK1xuICAgICAgICAnY2hlY2tzcGVsbGluZyBjaHJvb3RkaXIgY29udGVudGRpZ2VzdCBjb29raWVkb21haW4gY29va2llZXhwaXJlcyBjb29raWVsb2cgJyArXG4gICAgICAgICdjb29raWVuYW1lIGNvb2tpZXN0eWxlIGNvb2tpZXRyYWNraW5nIGNvcmVkdW1wZGlyZWN0b3J5IGN1c3RvbWxvZyBkYXYgJyArXG4gICAgICAgICdkYXZkZXB0aGluZmluaXR5IGRhdmdlbmVyaWNsb2NrZGIgZGF2bG9ja2RiIGRhdm1pbnRpbWVvdXQgZGJkZXhwdGltZSBkYmRrZWVwICcgK1xuICAgICAgICAnZGJkbWF4IGRiZG1pbiBkYmRwYXJhbXMgZGJkcGVyc2lzdCBkYmRwcmVwYXJlc3FsIGRiZHJpdmVyIGRlZmF1bHRpY29uICcgK1xuICAgICAgICAnZGVmYXVsdGxhbmd1YWdlIGRlZmF1bHR0eXBlIGRlZmxhdGVidWZmZXJzaXplIGRlZmxhdGVjb21wcmVzc2lvbmxldmVsICcgK1xuICAgICAgICAnZGVmbGF0ZWZpbHRlcm5vdGUgZGVmbGF0ZW1lbWxldmVsIGRlZmxhdGV3aW5kb3dzaXplIGRlbnkgZGlyZWN0b3J5aW5kZXggJyArXG4gICAgICAgICdkaXJlY3RvcnltYXRjaCBkaXJlY3RvcnlzbGFzaCBkb2N1bWVudHJvb3QgZHVtcGlvaW5wdXQgZHVtcGlvbG9nbGV2ZWwgZHVtcGlvb3V0cHV0ICcgK1xuICAgICAgICAnZW5hYmxlZXhjZXB0aW9uaG9vayBlbmFibGVtbWFwIGVuYWJsZXNlbmRmaWxlIGVycm9yZG9jdW1lbnQgZXJyb3Jsb2cgZXhhbXBsZSAnICtcbiAgICAgICAgJ2V4cGlyZXNhY3RpdmUgZXhwaXJlc2J5dHlwZSBleHBpcmVzZGVmYXVsdCBleHRlbmRlZHN0YXR1cyBleHRmaWx0ZXJkZWZpbmUgJyArXG4gICAgICAgICdleHRmaWx0ZXJvcHRpb25zIGZpbGVldGFnIGZpbHRlcmNoYWluIGZpbHRlcmRlY2xhcmUgZmlsdGVycHJvdG9jb2wgZmlsdGVycHJvdmlkZXIgJyArXG4gICAgICAgICdmaWx0ZXJ0cmFjZSBmb3JjZWxhbmd1YWdlcHJpb3JpdHkgZm9yY2V0eXBlIGZvcmVuc2ljbG9nIGdyYWNlZnVsc2h1dGRvd250aW1lb3V0ICcgK1xuICAgICAgICAnZ3JvdXAgaGVhZGVyIGhlYWRlcm5hbWUgaG9zdG5hbWVsb29rdXBzIGlkZW50aXR5Y2hlY2sgaWRlbnRpdHljaGVja3RpbWVvdXQgJyArXG4gICAgICAgICdpbWFwYmFzZSBpbWFwZGVmYXVsdCBpbWFwbWVudSBpbmNsdWRlIGluZGV4aGVhZGluc2VydCBpbmRleGlnbm9yZSBpbmRleG9wdGlvbnMgJyArXG4gICAgICAgICdpbmRleG9yZGVyZGVmYXVsdCBpbmRleHN0eWxlc2hlZXQgaXNhcGlhcHBlbmRsb2d0b2Vycm9ycyBpc2FwaWFwcGVuZGxvZ3RvcXVlcnkgJyArXG4gICAgICAgICdpc2FwaWNhY2hlZmlsZSBpc2FwaWZha2Vhc3luYyBpc2FwaWxvZ25vdHN1cHBvcnRlZCBpc2FwaXJlYWRhaGVhZGJ1ZmZlciBrZWVwYWxpdmUgJyArXG4gICAgICAgICdrZWVwYWxpdmV0aW1lb3V0IGxhbmd1YWdlcHJpb3JpdHkgbGRhcGNhY2hlZW50cmllcyBsZGFwY2FjaGV0dGwgJyArXG4gICAgICAgICdsZGFwY29ubmVjdGlvbnRpbWVvdXQgbGRhcG9wY2FjaGVlbnRyaWVzIGxkYXBvcGNhY2hldHRsIGxkYXBzaGFyZWRjYWNoZWZpbGUgJyArXG4gICAgICAgICdsZGFwc2hhcmVkY2FjaGVzaXplIGxkYXB0cnVzdGVkY2xpZW50Y2VydCBsZGFwdHJ1c3RlZGdsb2JhbGNlcnQgbGRhcHRydXN0ZWRtb2RlICcgK1xuICAgICAgICAnbGRhcHZlcmlmeXNlcnZlcmNlcnQgbGltaXRpbnRlcm5hbHJlY3Vyc2lvbiBsaW1pdHJlcXVlc3Rib2R5IGxpbWl0cmVxdWVzdGZpZWxkcyAnICtcbiAgICAgICAgJ2xpbWl0cmVxdWVzdGZpZWxkc2l6ZSBsaW1pdHJlcXVlc3RsaW5lIGxpbWl0eG1scmVxdWVzdGJvZHkgbGlzdGVuIGxpc3RlbmJhY2tsb2cgJyArXG4gICAgICAgICdsb2FkZmlsZSBsb2FkbW9kdWxlIGxvY2tmaWxlIGxvZ2Zvcm1hdCBsb2dsZXZlbCBtYXhjbGllbnRzIG1heGtlZXBhbGl2ZXJlcXVlc3RzICcgK1xuICAgICAgICAnbWF4bWVtZnJlZSBtYXhyZXF1ZXN0c3BlcmNoaWxkIG1heHJlcXVlc3RzcGVydGhyZWFkIG1heHNwYXJlc2VydmVycyBtYXhzcGFyZXRocmVhZHMgJyArXG4gICAgICAgICdtYXh0aHJlYWRzIG1jYWNoZW1heG9iamVjdGNvdW50IG1jYWNoZW1heG9iamVjdHNpemUgbWNhY2hlbWF4c3RyZWFtaW5nYnVmZmVyICcgK1xuICAgICAgICAnbWNhY2hlbWlub2JqZWN0c2l6ZSBtY2FjaGVyZW1vdmFsYWxnb3JpdGhtIG1jYWNoZXNpemUgbWV0YWRpciBtZXRhZmlsZXMgbWV0YXN1ZmZpeCAnICtcbiAgICAgICAgJ21pbWVtYWdpY2ZpbGUgbWluc3BhcmVzZXJ2ZXJzIG1pbnNwYXJldGhyZWFkcyBtbWFwZmlsZSBtb2RfZ3ppcF9vbiAnICtcbiAgICAgICAgJ21vZF9nemlwX2FkZF9oZWFkZXJfY291bnQgbW9kX2d6aXBfa2VlcF93b3JrZmlsZXMgbW9kX2d6aXBfZGVjaHVuayAnICtcbiAgICAgICAgJ21vZF9nemlwX21pbl9odHRwIG1vZF9nemlwX21pbmltdW1fZmlsZV9zaXplIG1vZF9nemlwX21heGltdW1fZmlsZV9zaXplICcgK1xuICAgICAgICAnbW9kX2d6aXBfbWF4aW11bV9pbm1lbV9zaXplIG1vZF9nemlwX3RlbXBfZGlyIG1vZF9nemlwX2l0ZW1faW5jbHVkZSAnICtcbiAgICAgICAgJ21vZF9nemlwX2l0ZW1fZXhjbHVkZSBtb2RfZ3ppcF9jb21tYW5kX3ZlcnNpb24gbW9kX2d6aXBfY2FuX25lZ290aWF0ZSAnICtcbiAgICAgICAgJ21vZF9nemlwX2hhbmRsZV9tZXRob2RzIG1vZF9nemlwX3N0YXRpY19zdWZmaXggbW9kX2d6aXBfc2VuZF92YXJ5ICcgK1xuICAgICAgICAnbW9kX2d6aXBfdXBkYXRlX3N0YXRpYyBtb2RtaW1ldXNlcGF0aGluZm8gbXVsdGl2aWV3c21hdGNoIG5hbWV2aXJ0dWFsaG9zdCBub3Byb3h5ICcgK1xuICAgICAgICAnbndzc2x0cnVzdGVkY2VydHMgbndzc2x1cGdyYWRlYWJsZSBvcHRpb25zIG9yZGVyIHBhc3NlbnYgcGlkZmlsZSBwcm90b2NvbGVjaG8gJyArXG4gICAgICAgICdwcm94eWJhZGhlYWRlciBwcm94eWJsb2NrIHByb3h5ZG9tYWluIHByb3h5ZXJyb3JvdmVycmlkZSBwcm94eWZ0cGRpcmNoYXJzZXQgJyArXG4gICAgICAgICdwcm94eWlvYnVmZmVyc2l6ZSBwcm94eW1heGZvcndhcmRzIHByb3h5cGFzcyBwcm94eXBhc3NpbnRlcnBvbGF0ZWVudiAnICtcbiAgICAgICAgJ3Byb3h5cGFzc21hdGNoIHByb3h5cGFzc3JldmVyc2UgcHJveHlwYXNzcmV2ZXJzZWNvb2tpZWRvbWFpbiAnICtcbiAgICAgICAgJ3Byb3h5cGFzc3JldmVyc2Vjb29raWVwYXRoIHByb3h5cHJlc2VydmVob3N0IHByb3h5cmVjZWl2ZWJ1ZmZlcnNpemUgcHJveHlyZW1vdGUgJyArXG4gICAgICAgICdwcm94eXJlbW90ZW1hdGNoIHByb3h5cmVxdWVzdHMgcHJveHlzZXQgcHJveHlzdGF0dXMgcHJveHl0aW1lb3V0IHByb3h5dmlhICcgK1xuICAgICAgICAncmVhZG1lbmFtZSByZWNlaXZlYnVmZmVyc2l6ZSByZWRpcmVjdCByZWRpcmVjdG1hdGNoIHJlZGlyZWN0cGVybWFuZW50ICcgK1xuICAgICAgICAncmVkaXJlY3R0ZW1wIHJlbW92ZWNoYXJzZXQgcmVtb3ZlZW5jb2RpbmcgcmVtb3ZlaGFuZGxlciByZW1vdmVpbnB1dGZpbHRlciAnICtcbiAgICAgICAgJ3JlbW92ZWxhbmd1YWdlIHJlbW92ZW91dHB1dGZpbHRlciByZW1vdmV0eXBlIHJlcXVlc3RoZWFkZXIgcmVxdWlyZSByZXdyaXRlYmFzZSAnICtcbiAgICAgICAgJ3Jld3JpdGVjb25kIHJld3JpdGVlbmdpbmUgcmV3cml0ZWxvY2sgcmV3cml0ZWxvZyByZXdyaXRlbG9nbGV2ZWwgcmV3cml0ZW1hcCAnICtcbiAgICAgICAgJ3Jld3JpdGVvcHRpb25zIHJld3JpdGVydWxlIHJsaW1pdGNwdSBybGltaXRtZW0gcmxpbWl0bnByb2Mgc2F0aXNmeSBzY29yZWJvYXJkZmlsZSAnICtcbiAgICAgICAgJ3NjcmlwdCBzY3JpcHRhbGlhcyBzY3JpcHRhbGlhc21hdGNoIHNjcmlwdGludGVycHJldGVyc291cmNlIHNjcmlwdGxvZyAnICtcbiAgICAgICAgJ3NjcmlwdGxvZ2J1ZmZlciBzY3JpcHRsb2dsZW5ndGggc2NyaXB0c29jayBzZWN1cmVsaXN0ZW4gc2VlcmVxdWVzdHRhaWwgJyArXG4gICAgICAgICdzZW5kYnVmZmVyc2l6ZSBzZXJ2ZXJhZG1pbiBzZXJ2ZXJhbGlhcyBzZXJ2ZXJsaW1pdCBzZXJ2ZXJuYW1lIHNlcnZlcnBhdGggJyArXG4gICAgICAgICdzZXJ2ZXJyb290IHNlcnZlcnNpZ25hdHVyZSBzZXJ2ZXJ0b2tlbnMgc2V0ZW52IHNldGVudmlmIHNldGVudmlmbm9jYXNlIHNldGhhbmRsZXIgJyArXG4gICAgICAgICdzZXRpbnB1dGZpbHRlciBzZXRvdXRwdXRmaWx0ZXIgc3NpZW5hYmxlYWNjZXNzIHNzaWVuZHRhZyBzc2llcnJvcm1zZyBzc2lzdGFydHRhZyAnICtcbiAgICAgICAgJ3NzaXRpbWVmb3JtYXQgc3NpdW5kZWZpbmVkZWNobyBzc2xjYWNlcnRpZmljYXRlZmlsZSBzc2xjYWNlcnRpZmljYXRlcGF0aCAnICtcbiAgICAgICAgJ3NzbGNhZG5yZXF1ZXN0ZmlsZSBzc2xjYWRucmVxdWVzdHBhdGggc3NsY2FyZXZvY2F0aW9uZmlsZSBzc2xjYXJldm9jYXRpb25wYXRoICcgK1xuICAgICAgICAnc3NsY2VydGlmaWNhdGVjaGFpbmZpbGUgc3NsY2VydGlmaWNhdGVmaWxlIHNzbGNlcnRpZmljYXRla2V5ZmlsZSBzc2xjaXBoZXJzdWl0ZSAnICtcbiAgICAgICAgJ3NzbGNyeXB0b2RldmljZSBzc2xlbmdpbmUgc3NsaG9ub3JjaXBlcm9yZGVyIHNzbG11dGV4IHNzbG9wdGlvbnMgJyArXG4gICAgICAgICdzc2xwYXNzcGhyYXNlZGlhbG9nIHNzbHByb3RvY29sIHNzbHByb3h5Y2FjZXJ0aWZpY2F0ZWZpbGUgJyArXG4gICAgICAgICdzc2xwcm94eWNhY2VydGlmaWNhdGVwYXRoIHNzbHByb3h5Y2FyZXZvY2F0aW9uZmlsZSBzc2xwcm94eWNhcmV2b2NhdGlvbnBhdGggJyArXG4gICAgICAgICdzc2xwcm94eWNpcGhlcnN1aXRlIHNzbHByb3h5ZW5naW5lIHNzbHByb3h5bWFjaGluZWNlcnRpZmljYXRlZmlsZSAnICtcbiAgICAgICAgJ3NzbHByb3h5bWFjaGluZWNlcnRpZmljYXRlcGF0aCBzc2xwcm94eXByb3RvY29sIHNzbHByb3h5dmVyaWZ5ICcgK1xuICAgICAgICAnc3NscHJveHl2ZXJpZnlkZXB0aCBzc2xyYW5kb21zZWVkIHNzbHJlcXVpcmUgc3NscmVxdWlyZXNzbCBzc2xzZXNzaW9uY2FjaGUgJyArXG4gICAgICAgICdzc2xzZXNzaW9uY2FjaGV0aW1lb3V0IHNzbHVzZXJuYW1lIHNzbHZlcmlmeWNsaWVudCBzc2x2ZXJpZnlkZXB0aCBzdGFydHNlcnZlcnMgJyArXG4gICAgICAgICdzdGFydHRocmVhZHMgc3Vic3RpdHV0ZSBzdWV4ZWN1c2VyZ3JvdXAgdGhyZWFkbGltaXQgdGhyZWFkc3BlcmNoaWxkICcgK1xuICAgICAgICAndGhyZWFkc3RhY2tzaXplIHRpbWVvdXQgdHJhY2VlbmFibGUgdHJhbnNmZXJsb2cgdHlwZXNjb25maWcgdW5zZXRlbnYgJyArXG4gICAgICAgICd1c2VjYW5vbmljYWxuYW1lIHVzZWNhbm9uaWNhbHBoeXNpY2FscG9ydCB1c2VyIHVzZXJkaXIgdmlydHVhbGRvY3VtZW50cm9vdCAnICtcbiAgICAgICAgJ3ZpcnR1YWxkb2N1bWVudHJvb3RpcCB2aXJ0dWFsc2NyaXB0YWxpYXMgdmlydHVhbHNjcmlwdGFsaWFzaXAgJyArXG4gICAgICAgICd3aW4zMmRpc2FibGVhY2NlcHRleCB4Yml0aGFjaycsXG4gICAgICBsaXRlcmFsOiAnb24gb2ZmJ1xuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NxYnJhY2tldCcsXG4gICAgICAgIGJlZ2luOiAnXFxcXHNcXFxcWycsIGVuZDogJ1xcXFxdJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NicmFja2V0JyxcbiAgICAgICAgYmVnaW46ICdbXFxcXCQlXVxcXFx7JywgZW5kOiAnXFxcXH0nLFxuICAgICAgICBjb250YWluczogWydzZWxmJywgTlVNQkVSXVxuICAgICAgfSxcbiAgICAgIE5VTUJFUixcbiAgICAgIHtjbGFzc05hbWU6ICd0YWcnLCBiZWdpbjogJzwvPycsIGVuZDogJz4nfSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgU1RSSU5HID0gaGxqcy5pbmhlcml0KGhsanMuUVVPVEVfU1RSSU5HX01PREUsIHtpbGxlZ2FsOiAnJ30pO1xuICB2YXIgVElUTEUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFXG4gIH07XG4gIHZhciBQQVJBTVMgPSB7XG4gICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgIGNvbnRhaW5zOiBbJ3NlbGYnLCBobGpzLkNfTlVNQkVSX01PREUsIFNUUklOR11cbiAgfTtcbiAgdmFyIENPTU1FTlRTID0gW1xuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgYmVnaW46ICctLScsIGVuZDogJyQnLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICBiZWdpbjogJ1xcXFwoXFxcXConLCBlbmQ6ICdcXFxcKlxcXFwpJyxcbiAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnLCB7YmVnaW46ICctLScsIGVuZDogJyQnfV0gLy9hbGxvdyBuZXN0aW5nXG4gICAgfSxcbiAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFXG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICBrZXl3b3Jkczoge1xuICAgICAga2V5d29yZDpcbiAgICAgICAgJ2Fib3V0IGFib3ZlIGFmdGVyIGFnYWluc3QgYW5kIGFyb3VuZCBhcyBhdCBiYWNrIGJlZm9yZSBiZWdpbm5pbmcgJyArXG4gICAgICAgICdiZWhpbmQgYmVsb3cgYmVuZWF0aCBiZXNpZGUgYmV0d2VlbiBidXQgYnkgY29uc2lkZXJpbmcgJyArXG4gICAgICAgICdjb250YWluIGNvbnRhaW5zIGNvbnRpbnVlIGNvcHkgZGl2IGRvZXMgZWlnaHRoIGVsc2UgZW5kIGVxdWFsICcgK1xuICAgICAgICAnZXF1YWxzIGVycm9yIGV2ZXJ5IGV4aXQgZmlmdGggZmlyc3QgZm9yIGZvdXJ0aCBmcm9tIGZyb250ICcgK1xuICAgICAgICAnZ2V0IGdpdmVuIGdsb2JhbCBpZiBpZ25vcmluZyBpbiBpbnRvIGlzIGl0IGl0cyBsYXN0IGxvY2FsIG1lICcgK1xuICAgICAgICAnbWlkZGxlIG1vZCBteSBuaW50aCBub3Qgb2Ygb24gb250byBvciBvdmVyIHByb3AgcHJvcGVydHkgcHV0IHJlZiAnICtcbiAgICAgICAgJ3JlZmVyZW5jZSByZXBlYXQgcmV0dXJuaW5nIHNjcmlwdCBzZWNvbmQgc2V0IHNldmVudGggc2luY2UgJyArXG4gICAgICAgICdzaXh0aCBzb21lIHRlbGwgdGVudGggdGhhdCB0aGUgdGhlbiB0aGlyZCB0aHJvdWdoIHRocnUgJyArXG4gICAgICAgICd0aW1lb3V0IHRpbWVzIHRvIHRyYW5zYWN0aW9uIHRyeSB1bnRpbCB3aGVyZSB3aGlsZSB3aG9zZSB3aXRoICcgK1xuICAgICAgICAnd2l0aG91dCcsXG4gICAgICBjb25zdGFudDpcbiAgICAgICAgJ0FwcGxlU2NyaXB0IGZhbHNlIGxpbmVmZWVkIHJldHVybiBwaSBxdW90ZSByZXN1bHQgc3BhY2UgdGFiIHRydWUnLFxuICAgICAgdHlwZTpcbiAgICAgICAgJ2FsaWFzIGFwcGxpY2F0aW9uIGJvb2xlYW4gY2xhc3MgY29uc3RhbnQgZGF0ZSBmaWxlIGludGVnZXIgbGlzdCAnICtcbiAgICAgICAgJ251bWJlciByZWFsIHJlY29yZCBzdHJpbmcgdGV4dCcsXG4gICAgICBjb21tYW5kOlxuICAgICAgICAnYWN0aXZhdGUgYmVlcCBjb3VudCBkZWxheSBsYXVuY2ggbG9nIG9mZnNldCByZWFkIHJvdW5kICcgK1xuICAgICAgICAncnVuIHNheSBzdW1tYXJpemUgd3JpdGUnLFxuICAgICAgcHJvcGVydHk6XG4gICAgICAgICdjaGFyYWN0ZXIgY2hhcmFjdGVycyBjb250ZW50cyBkYXkgZnJvbnRtb3N0IGlkIGl0ZW0gbGVuZ3RoICcgK1xuICAgICAgICAnbW9udGggbmFtZSBwYXJhZ3JhcGggcGFyYWdyYXBocyByZXN0IHJldmVyc2UgcnVubmluZyB0aW1lIHZlcnNpb24gJyArXG4gICAgICAgICd3ZWVrZGF5IHdvcmQgd29yZHMgeWVhcidcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBTVFJJTkcsXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiUE9TSVggZmlsZVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWFuZCcsXG4gICAgICAgIGJlZ2luOlxuICAgICAgICAgICdcXFxcYihjbGlwYm9hcmQgaW5mb3x0aGUgY2xpcGJvYXJkfGluZm8gZm9yfGxpc3QgKGRpc2tzfGZvbGRlcil8JyArXG4gICAgICAgICAgJ21vdW50IHZvbHVtZXxwYXRoIHRvfChjbG9zZXxvcGVuIGZvcikgYWNjZXNzfChnZXR8c2V0KSBlb2Z8JyArXG4gICAgICAgICAgJ2N1cnJlbnQgZGF0ZXxkbyBzaGVsbCBzY3JpcHR8Z2V0IHZvbHVtZSBzZXR0aW5nc3xyYW5kb20gbnVtYmVyfCcgK1xuICAgICAgICAgICdzZXQgdm9sdW1lfHN5c3RlbSBhdHRyaWJ1dGV8c3lzdGVtIGluZm98dGltZSB0byBHTVR8JyArXG4gICAgICAgICAgJyhsb2FkfHJ1bnxzdG9yZSkgc2NyaXB0fHNjcmlwdGluZyBjb21wb25lbnRzfCcgK1xuICAgICAgICAgICdBU0NJSSAoY2hhcmFjdGVyfG51bWJlcil8bG9jYWxpemVkIHN0cmluZ3wnICtcbiAgICAgICAgICAnY2hvb3NlIChhcHBsaWNhdGlvbnxjb2xvcnxmaWxlfGZpbGUgbmFtZXwnICtcbiAgICAgICAgICAnZm9sZGVyfGZyb20gbGlzdHxyZW1vdGUgYXBwbGljYXRpb258VVJMKXwnICtcbiAgICAgICAgICAnZGlzcGxheSAoYWxlcnR8ZGlhbG9nKSlcXFxcYnxeXFxcXHMqcmV0dXJuXFxcXGInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb25zdGFudCcsXG4gICAgICAgIGJlZ2luOlxuICAgICAgICAgICdcXFxcYih0ZXh0IGl0ZW0gZGVsaW1pdGVyc3xjdXJyZW50IGFwcGxpY2F0aW9ufG1pc3NpbmcgdmFsdWUpXFxcXGInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgYmVnaW46XG4gICAgICAgICAgJ1xcXFxiKGFwYXJ0IGZyb218YXNpZGUgZnJvbXxpbnN0ZWFkIG9mfG91dCBvZnxncmVhdGVyIHRoYW58JyArXG4gICAgICAgICAgXCJpc24ndHwoZG9lc24ndHxkb2VzIG5vdCkgKGVxdWFsfGNvbWUgYmVmb3JlfGNvbWUgYWZ0ZXJ8Y29udGFpbil8XCIgK1xuICAgICAgICAgICcoZ3JlYXRlcnxsZXNzKSB0aGFuKCBvciBlcXVhbCk/fChzdGFydHM/fGVuZHN8YmVnaW5zPykgd2l0aHwnICtcbiAgICAgICAgICAnY29udGFpbmVkIGJ5fGNvbWVzIChiZWZvcmV8YWZ0ZXIpfGEgKHJlZnxyZWZlcmVuY2UpKVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJvcGVydHknLFxuICAgICAgICBiZWdpbjpcbiAgICAgICAgICAnXFxcXGIoUE9TSVggcGF0aHwoZGF0ZXx0aW1lKSBzdHJpbmd8cXVvdGVkIGZvcm0pXFxcXGInXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbl9zdGFydCcsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiAnb24nLFxuICAgICAgICBpbGxlZ2FsOiAnWyR7PTtcXFxcbl0nLFxuICAgICAgICBjb250YWluczogW1RJVExFLCBQQVJBTVNdXG4gICAgICB9XG4gICAgXS5jb25jYXQoQ09NTUVOVFMpXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAga2V5d29yZHM6IHtcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgIC8qIG1uZW1vbmljICovXG4gICAgICAgICdhZGMgYWRkIGFkaXcgYW5kIGFuZGkgYXNyIGJjbHIgYmxkIGJyYmMgYnJicyBicmNjIGJyY3MgYnJlYWsgYnJlcSBicmdlIGJyaGMgYnJocyAnICtcbiAgICAgICAgJ2JyaWQgYnJpZSBicmxvIGJybHQgYnJtaSBicm5lIGJycGwgYnJzaCBicnRjIGJydHMgYnJ2YyBicnZzIGJzZXQgYnN0IGNhbGwgY2JpIGNiciAnICtcbiAgICAgICAgJ2NsYyBjbGggY2xpIGNsbiBjbHIgY2xzIGNsdCBjbHYgY2x6IGNvbSBjcCBjcGMgY3BpIGNwc2UgZGVjIGVpY2FsbCBlaWptcCBlbHBtIGVvciAnICtcbiAgICAgICAgJ2ZtdWwgZm11bHMgZm11bHN1IGljYWxsIGlqbXAgaW4gaW5jIGptcCBsZCBsZGQgbGRpIGxkcyBscG0gbHNsIGxzciBtb3YgbW92dyBtdWwgJyArXG4gICAgICAgICdtdWxzIG11bHN1IG5lZyBub3Agb3Igb3JpIG91dCBwb3AgcHVzaCByY2FsbCByZXQgcmV0aSByam1wIHJvbCByb3Igc2JjIHNiciBzYnJjIHNicnMgJyArXG4gICAgICAgICdzZWMgc2VoIHNiaSBzYmNpIHNiaWMgc2JpcyBzYml3IHNlaSBzZW4gc2VyIHNlcyBzZXQgc2V2IHNleiBzbGVlcCBzcG0gc3Qgc3RkIHN0cyBzdWIgJyArXG4gICAgICAgICdzdWJpIHN3YXAgdHN0IHdkcicsXG4gICAgICBidWlsdF9pbjpcbiAgICAgICAgLyogZ2VuZXJhbCBwdXJwb3NlIHJlZ2lzdGVycyAqL1xuICAgICAgICAncjAgcjEgcjIgcjMgcjQgcjUgcjYgcjcgcjggcjkgcjEwIHIxMSByMTIgcjEzIHIxNCByMTUgcjE2IHIxNyByMTggcjE5IHIyMCByMjEgcjIyICcgK1xuICAgICAgICAncjIzIHIyNCByMjUgcjI2IHIyNyByMjggcjI5IHIzMCByMzEgeHwwIHhoIHhsIHl8MCB5aCB5bCB6fDAgemggemwgJyArXG4gICAgICAgIC8qIElPIFJlZ2lzdGVycyAoQVRNZWdhMTI4KSAqL1xuICAgICAgICAndWNzcjFjIHVkcjEgdWNzcjFhIHVjc3IxYiB1YnJyMWwgdWJycjFoIHVjc3IwYyB1YnJyMGggdGNjcjNjIHRjY3IzYSB0Y2NyM2IgdGNudDNoICcgK1xuICAgICAgICAndGNudDNsIG9jcjNhaCBvY3IzYWwgb2NyM2JoIG9jcjNibCBvY3IzY2ggb2NyM2NsIGljcjNoIGljcjNsIGV0aW1zayBldGlmciB0Y2NyMWMgJyArXG4gICAgICAgICdvY3IxY2ggb2NyMWNsIHR3Y3IgdHdkciB0d2FyIHR3c3IgdHdiciBvc2NjYWwgeG1jcmEgeG1jcmIgZWljcmEgc3BtY3NyIHNwbWNyIHBvcnRnICcgK1xuICAgICAgICAnZGRyZyBwaW5nIHBvcnRmIGRkcmYgc3JlZyBzcGggc3BsIHhkaXYgcmFtcHogZWljcmIgZWltc2sgZ2ltc2sgZ2ljciBlaWZyIGdpZnIgdGltc2sgJyArXG4gICAgICAgICd0aWZyIG1jdWNyIG1jdWNzciB0Y2NyMCB0Y250MCBvY3IwIGFzc3IgdGNjcjFhIHRjY3IxYiB0Y250MWggdGNudDFsIG9jcjFhaCBvY3IxYWwgJyArXG4gICAgICAgICdvY3IxYmggb2NyMWJsIGljcjFoIGljcjFsIHRjY3IyIHRjbnQyIG9jcjIgb2NkciB3ZHRjciBzZmlvciBlZWFyaCBlZWFybCBlZWRyIGVlY3IgJyArXG4gICAgICAgICdwb3J0YSBkZHJhIHBpbmEgcG9ydGIgZGRyYiBwaW5iIHBvcnRjIGRkcmMgcGluYyBwb3J0ZCBkZHJkIHBpbmQgc3BkciBzcHNyIHNwY3IgdWRyMCAnICtcbiAgICAgICAgJ3Vjc3IwYSB1Y3NyMGIgdWJycjBsIGFjc3IgYWRtdXggYWRjc3IgYWRjaCBhZGNsIHBvcnRlIGRkcmUgcGluZSBwaW5mJ1xuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICB7Y2xhc3NOYW1lOiAnY29tbWVudCcsIGJlZ2luOiAnOycsICBlbmQ6ICckJ30sXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsIC8vIDB4Li4uLCBkZWNpbWFsLCBmbG9hdFxuICAgICAgaGxqcy5CSU5BUllfTlVNQkVSX01PREUsIC8vIDBiLi4uXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXGIoXFxcXCRbYS16QS1aMC05XSt8MG9bMC03XSspJyAvLyAkLi4uLCAwby4uLlxuICAgICAgfSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnW15cXFxcXFxcXF1cXCcnLFxuICAgICAgICBpbGxlZ2FsOiAnW15cXFxcXFxcXF1bXlxcJ10nXG4gICAgICB9LFxuICAgICAge2NsYXNzTmFtZTogJ2xhYmVsJywgIGJlZ2luOiAnXltBLVphLXowLTlfLiRdKzonfSxcbiAgICAgIHtjbGFzc05hbWU6ICdwcmVwcm9jZXNzb3InLCBiZWdpbjogJyMnLCBlbmQ6ICckJ30sXG4gICAgICB7ICAvLyDQtNC40YDQtdC60YLQuNCy0YsgwqsuaW5jbHVkZcK7IMKrLm1hY3Jvwrsg0Lgg0YIu0LQuXG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXC5bYS16QS1aXSsnXG4gICAgICB9LFxuICAgICAgeyAgLy8g0L/QvtC00YHRgtCw0L3QvtCy0LrQsCDQsiDCqy5tYWNyb8K7XG4gICAgICAgIGNsYXNzTmFtZTogJ2xvY2FsdmFycycsXG4gICAgICAgIGJlZ2luOiAnQFswLTldKydcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiAnZmFsc2UgaW50IGFic3RyYWN0IHByaXZhdGUgY2hhciBpbnRlcmZhY2UgYm9vbGVhbiBzdGF0aWMgbnVsbCBpZiBmb3IgdHJ1ZSAnICtcbiAgICAgICd3aGlsZSBsb25nIHRocm93IGZpbmFsbHkgcHJvdGVjdGVkIGV4dGVuZHMgZmluYWwgaW1wbGVtZW50cyByZXR1cm4gdm9pZCBlbnVtIGVsc2UgJyArXG4gICAgICAnYnJlYWsgbmV3IGNhdGNoIGJ5dGUgc3VwZXIgY2xhc3MgY2FzZSBzaG9ydCBkZWZhdWx0IGRvdWJsZSBwdWJsaWMgdHJ5IHRoaXMgc3dpdGNoICcgK1xuICAgICAgJ2NvbnRpbnVlIHJldmVyc2UgZmlyc3RmYXN0IGZpcnN0b25seSBmb3J1cGRhdGUgbm9mZXRjaCBzdW0gYXZnIG1pbm9mIG1heG9mIGNvdW50ICcgK1xuICAgICAgJ29yZGVyIGdyb3VwIGJ5IGFzYyBkZXNjIGluZGV4IGhpbnQgbGlrZSBkaXNwYWx5IGVkaXQgY2xpZW50IHNlcnZlciB0dHNiZWdpbiAnICtcbiAgICAgICd0dHNjb21taXQgc3RyIHJlYWwgZGF0ZSBjb250YWluZXIgYW55dHlwZSBjb21tb24gZGl2IG1vZCcsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdwcmVwcm9jZXNzb3InLFxuICAgICAgICBiZWdpbjogJyMnLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBlbmQ6ICd7JyxcbiAgICAgICAgaWxsZWdhbDogJzonLFxuICAgICAgICBrZXl3b3JkczogJ2NsYXNzIGludGVyZmFjZScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaW5oZXJpdGFuY2UnLFxuICAgICAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSxcbiAgICAgICAgICAgIGtleXdvcmRzOiAnZXh0ZW5kcyBpbXBsZW1lbnRzJyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgQkFTSF9MSVRFUkFMID0gJ3RydWUgZmFsc2UnO1xuICB2YXIgQkFTSF9LRVlXT1JEID0gJ2lmIHRoZW4gZWxzZSBlbGlmIGZpIGZvciBicmVhayBjb250aW51ZSB3aGlsZSBpbiBkbyBkb25lIGVjaG8gZXhpdCByZXR1cm4gc2V0IGRlY2xhcmUnO1xuICB2YXIgVkFSMSA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsIGJlZ2luOiAnXFxcXCRbYS16QS1aMC05XyNdKydcbiAgfTtcbiAgdmFyIFZBUjIgPSB7XG4gICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLCBiZWdpbjogJ1xcXFwkeyhbXn1dfFxcXFxcXFxcfSkrfSdcbiAgfTtcbiAgdmFyIFFVT1RFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXCInLCBlbmQ6ICdcIicsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRSwgVkFSMSwgVkFSMl0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBBUE9TX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICBjb250YWluczogW3tiZWdpbjogJ1xcJ1xcJyd9XSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdmFyIFRFU1RfQ09ORElUSU9OID0ge1xuICAgIGNsYXNzTmFtZTogJ3Rlc3RfY29uZGl0aW9uJyxcbiAgICBiZWdpbjogJycsIGVuZDogJycsXG4gICAgY29udGFpbnM6IFtRVU9URV9TVFJJTkcsIEFQT1NfU1RSSU5HLCBWQVIxLCBWQVIyXSxcbiAgICBrZXl3b3Jkczoge1xuICAgICAgbGl0ZXJhbDogQkFTSF9MSVRFUkFMXG4gICAgfSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOiBCQVNIX0tFWVdPUkQsXG4gICAgICBsaXRlcmFsOiBCQVNIX0xJVEVSQUxcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NoZWJhbmcnLFxuICAgICAgICBiZWdpbjogJygjIVxcXFwvYmluXFxcXC9iYXNoKXwoIyFcXFxcL2JpblxcXFwvc2gpJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIFZBUjEsXG4gICAgICBWQVIyLFxuICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgIFFVT1RFX1NUUklORyxcbiAgICAgIEFQT1NfU1RSSU5HLFxuICAgICAgaGxqcy5pbmhlcml0KFRFU1RfQ09ORElUSU9OLCB7YmVnaW46ICdcXFxcWyAnLCBlbmQ6ICcgXFxcXF0nLCByZWxldmFuY2U6IDB9KSxcbiAgICAgIGhsanMuaW5oZXJpdChURVNUX0NPTkRJVElPTiwge2JlZ2luOiAnXFxcXFtcXFxcWyAnLCBlbmQ6ICcgXFxcXF1cXFxcXSd9KVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKXtcbiAgcmV0dXJuIHtcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICdbXlxcXFxbXFxcXF1cXFxcLixcXFxcK1xcXFwtPD4gXFxyXFxuXScsXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGVuZDogJ1tcXFxcW1xcXFxdXFxcXC4sXFxcXCtcXFxcLTw+IFxcclxcbl0nLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgYmVnaW46ICdbXFxcXFtcXFxcXV0nLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnW1xcXFwuLF0nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdsaXRlcmFsJyxcbiAgICAgICAgYmVnaW46ICdbXFxcXCtcXFxcLV0nXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIGJ1aWx0X2luOlxuICAgICAgLy8gQ2xvanVyZSBrZXl3b3Jkc1xuICAgICAgJ2RlZiBjb25kIGFwcGx5IGlmLW5vdCBpZi1sZXQgaWYgbm90IG5vdD0gPSAmbHQ7IDwgPiAmbHQ7PSA8PSA+PSA9PSArIC8gKiAtIHJlbSAnK1xuICAgICAgJ3F1b3QgbmVnPyBwb3M/IGRlbGF5PyBzeW1ib2w/IGtleXdvcmQ/IHRydWU/IGZhbHNlPyBpbnRlZ2VyPyBlbXB0eT8gY29sbD8gbGlzdD8gJytcbiAgICAgICdzZXQ/IGlmbj8gZm4/IGFzc29jaWF0aXZlPyBzZXF1ZW50aWFsPyBzb3J0ZWQ/IGNvdW50ZWQ/IHJldmVyc2libGU/IG51bWJlcj8gZGVjaW1hbD8gJytcbiAgICAgICdjbGFzcz8gZGlzdGluY3Q/IGlzYT8gZmxvYXQ/IHJhdGlvbmFsPyByZWR1Y2VkPyByYXRpbz8gb2RkPyBldmVuPyBjaGFyPyBzZXE/IHZlY3Rvcj8gJytcbiAgICAgICdzdHJpbmc/IG1hcD8gbmlsPyBjb250YWlucz8gemVybz8gaW5zdGFuY2U/IG5vdC1ldmVyeT8gbm90LWFueT8gbGlic3BlYz8gLT4gLT4+IC4uIC4gJytcbiAgICAgICdpbmMgY29tcGFyZSBkbyBkb3RpbWVzIG1hcGNhdCB0YWtlIHJlbW92ZSB0YWtlLXdoaWxlIGRyb3AgbGV0Zm4gZHJvcC1sYXN0IHRha2UtbGFzdCAnK1xuICAgICAgJ2Ryb3Atd2hpbGUgd2hpbGUgaW50ZXJuIGNvbmRwIGNhc2UgcmVkdWNlZCBjeWNsZSBzcGxpdC1hdCBzcGxpdC13aXRoIHJlcGVhdCByZXBsaWNhdGUgJytcbiAgICAgICdpdGVyYXRlIHJhbmdlIG1lcmdlIHppcG1hcCBkZWNsYXJlIGxpbmUtc2VxIHNvcnQgY29tcGFyYXRvciBzb3J0LWJ5IGRvcnVuIGRvYWxsIG50aG5leHQgJytcbiAgICAgICdudGhyZXN0IHBhcnRpdGlvbiBldmFsIGRvc2VxIGF3YWl0IGF3YWl0LWZvciBsZXQgYWdlbnQgYXRvbSBzZW5kIHNlbmQtb2ZmIHJlbGVhc2UtcGVuZGluZy1zZW5kcyAnK1xuICAgICAgJ2FkZC13YXRjaCBtYXB2IGZpbHRlcnYgcmVtb3ZlLXdhdGNoIGFnZW50LWVycm9yIHJlc3RhcnQtYWdlbnQgc2V0LWVycm9yLWhhbmRsZXIgZXJyb3ItaGFuZGxlciAnK1xuICAgICAgJ3NldC1lcnJvci1tb2RlISBlcnJvci1tb2RlIHNodXRkb3duLWFnZW50cyBxdW90ZSB2YXIgZm4gbG9vcCByZWN1ciB0aHJvdyB0cnkgbW9uaXRvci1lbnRlciAnK1xuICAgICAgJ21vbml0b3ItZXhpdCBkZWZtYWNybyBkZWZuIGRlZm4tIG1hY3JvZXhwYW5kIG1hY3JvZXhwYW5kLTEgZm9yIGRvc2VxIGRvc3luYyBkb3RpbWVzIGFuZCBvciAnK1xuICAgICAgJ3doZW4gd2hlbi1ub3Qgd2hlbi1sZXQgY29tcCBqdXh0IHBhcnRpYWwgc2VxdWVuY2UgbWVtb2l6ZSBjb25zdGFudGx5IGNvbXBsZW1lbnQgaWRlbnRpdHkgYXNzZXJ0ICcrXG4gICAgICAncGVlayBwb3AgZG90byBwcm94eSBkZWZzdHJ1Y3QgZmlyc3QgcmVzdCBjb25zIGRlZnByb3RvY29sIGNhc3QgY29sbCBkZWZ0eXBlIGRlZnJlY29yZCBsYXN0IGJ1dGxhc3QgJytcbiAgICAgICdzaWdzIHJlaWZ5IHNlY29uZCBmZmlyc3QgZm5leHQgbmZpcnN0IG5uZXh0IGRlZm11bHRpIGRlZm1ldGhvZCBtZXRhIHdpdGgtbWV0YSBucyBpbi1ucyBjcmVhdGUtbnMgaW1wb3J0ICcrXG4gICAgICAnaW50ZXJuIHJlZmVyIGtleXMgc2VsZWN0LWtleXMgdmFscyBrZXkgdmFsIHJzZXEgbmFtZSBuYW1lc3BhY2UgcHJvbWlzZSBpbnRvIHRyYW5zaWVudCBwZXJzaXN0ZW50ISBjb25qISAnK1xuICAgICAgJ2Fzc29jISBkaXNzb2MhIHBvcCEgZGlzaiEgaW1wb3J0IHVzZSBjbGFzcyB0eXBlIG51bSBmbG9hdCBkb3VibGUgc2hvcnQgYnl0ZSBib29sZWFuIGJpZ2ludCBiaWdpbnRlZ2VyICcrXG4gICAgICAnYmlnZGVjIHByaW50LW1ldGhvZCBwcmludC1kdXAgdGhyb3ctaWYgdGhyb3cgcHJpbnRmIGZvcm1hdCBsb2FkIGNvbXBpbGUgZ2V0LWluIHVwZGF0ZS1pbiBwciBwci1vbiBuZXdsaW5lICcrXG4gICAgICAnZmx1c2ggcmVhZCBzbHVycCByZWFkLWxpbmUgc3VidmVjIHdpdGgtb3BlbiBtZW1mbiB0aW1lIG5zIGFzc2VydCByZS1maW5kIHJlLWdyb3VwcyByYW5kLWludCByYW5kIG1vZCBsb2NraW5nICcrXG4gICAgICAnYXNzZXJ0LXZhbGlkLWZkZWNsIGFsaWFzIG5hbWVzcGFjZSByZXNvbHZlIHJlZiBkZXJlZiByZWZzZXQgc3dhcCEgcmVzZXQhIHNldC12YWxpZGF0b3IhIGNvbXBhcmUtYW5kLXNldCEgYWx0ZXItbWV0YSEgJytcbiAgICAgICdyZXNldC1tZXRhISBjb21tdXRlIGdldC12YWxpZGF0b3IgYWx0ZXIgcmVmLXNldCByZWYtaGlzdG9yeS1jb3VudCByZWYtbWluLWhpc3RvcnkgcmVmLW1heC1oaXN0b3J5IGVuc3VyZSBzeW5jIGlvISAnK1xuICAgICAgJ25ldyBuZXh0IGNvbmogc2V0ISBtZW1mbiB0by1hcnJheSBmdXR1cmUgZnV0dXJlLWNhbGwgaW50by1hcnJheSBhc2V0IGdlbi1jbGFzcyByZWR1Y2UgbWVyZ2UgbWFwIGZpbHRlciBmaW5kIGVtcHR5ICcrXG4gICAgICAnaGFzaC1tYXAgaGFzaC1zZXQgc29ydGVkLW1hcCBzb3J0ZWQtbWFwLWJ5IHNvcnRlZC1zZXQgc29ydGVkLXNldC1ieSB2ZWMgdmVjdG9yIHNlcSBmbGF0dGVuIHJldmVyc2UgYXNzb2MgZGlzc29jIGxpc3QgJytcbiAgICAgICdkaXNqIGdldCB1bmlvbiBkaWZmZXJlbmNlIGludGVyc2VjdGlvbiBleHRlbmQgZXh0ZW5kLXR5cGUgZXh0ZW5kLXByb3RvY29sIGludCBudGggZGVsYXkgY291bnQgY29uY2F0IGNodW5rIGNodW5rLWJ1ZmZlciAnK1xuICAgICAgJ2NodW5rLWFwcGVuZCBjaHVuay1maXJzdCBjaHVuay1yZXN0IG1heCBtaW4gZGVjIHVuY2hlY2tlZC1pbmMtaW50IHVuY2hlY2tlZC1pbmMgdW5jaGVja2VkLWRlYy1pbmMgdW5jaGVja2VkLWRlYyB1bmNoZWNrZWQtbmVnYXRlICcrXG4gICAgICAndW5jaGVja2VkLWFkZC1pbnQgdW5jaGVja2VkLWFkZCB1bmNoZWNrZWQtc3VidHJhY3QtaW50IHVuY2hlY2tlZC1zdWJ0cmFjdCBjaHVuay1uZXh0IGNodW5rLWNvbnMgY2h1bmtlZC1zZXE/IHBybiB2YXJ5LW1ldGEgJytcbiAgICAgICdsYXp5LXNlcSBzcHJlYWQgbGlzdCogc3RyIGZpbmQta2V5d29yZCBrZXl3b3JkIHN5bWJvbCBnZW5zeW0gZm9yY2UgcmF0aW9uYWxpemUnXG4gICB9O1xuXG4gIHZhciBDTEpfSURFTlRfUkUgPSAnW2EtekEtWl8wLTlcXFxcIVxcXFwuXFxcXD9cXFxcLVxcXFwrXFxcXCpcXFxcL1xcXFw8XFxcXD1cXFxcPlxcXFwmXFxcXCNcXFxcJFxcJztdKyc7XG4gIHZhciBTSU1QTEVfTlVNQkVSX1JFID0gJ1tcXFxcczpcXFxcKFxcXFx7XStcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG5cbiAgdmFyIE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogU0lNUExFX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdmFyIFNUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXCInLCBlbmQ6ICdcIicsXG4gICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgQ09NTUVOVCA9IHtcbiAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICBiZWdpbjogJzsnLCBlbmQ6ICckJyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdmFyIENPTExFQ1RJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAnY29sbGVjdGlvbicsXG4gICAgYmVnaW46ICdbXFxcXFtcXFxce10nLCBlbmQ6ICdbXFxcXF1cXFxcfV0nXG4gIH07XG4gIHZhciBISU5UID0ge1xuICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgIGJlZ2luOiAnXFxcXF4nICsgQ0xKX0lERU5UX1JFXG4gIH07XG4gIHZhciBISU5UX0NPTCA9IHtcbiAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICBiZWdpbjogJ1xcXFxeXFxcXHsnLCBlbmQ6ICdcXFxcfSdcbiAgfTtcbiAgdmFyIEtFWSA9IHtcbiAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgIGJlZ2luOiAnWzpdJyArIENMSl9JREVOVF9SRVxuICB9O1xuICB2YXIgTElTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdsaXN0JyxcbiAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgQk9EWSA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICBrZXl3b3Jkczoge2xpdGVyYWw6ICd0cnVlIGZhbHNlIG5pbCd9LFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgVElUTEUgPSB7XG4gICAga2V5d29yZHM6IGtleXdvcmRzLFxuICAgIGxleGVtczogQ0xKX0lERU5UX1JFLFxuICAgIGNsYXNzTmFtZTogJ3RpdGxlJywgYmVnaW46IENMSl9JREVOVF9SRSxcbiAgICBzdGFydHM6IEJPRFlcbiAgfTtcblxuICBMSVNULmNvbnRhaW5zID0gW3tjbGFzc05hbWU6ICdjb21tZW50JywgYmVnaW46ICdjb21tZW50J30sIFRJVExFXTtcbiAgQk9EWS5jb250YWlucyA9IFtMSVNULCBTVFJJTkcsIEhJTlQsIEhJTlRfQ09MLCBDT01NRU5ULCBLRVksIENPTExFQ1RJT04sIE5VTUJFUl07XG4gIENPTExFQ1RJT04uY29udGFpbnMgPSBbTElTVCwgU1RSSU5HLCBISU5ULCBDT01NRU5ULCBLRVksIENPTExFQ1RJT04sIE5VTUJFUl07XG5cbiAgcmV0dXJuIHtcbiAgICBpbGxlZ2FsOiAnXFxcXFMnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBDT01NRU5ULFxuICAgICAgTElTVFxuICAgIF1cbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGtleXdvcmRzOiAnYWRkX2N1c3RvbV9jb21tYW5kIGFkZF9jdXN0b21fdGFyZ2V0IGFkZF9kZWZpbml0aW9ucyBhZGRfZGVwZW5kZW5jaWVzICcgK1xuICAgICAgJ2FkZF9leGVjdXRhYmxlIGFkZF9saWJyYXJ5IGFkZF9zdWJkaXJlY3RvcnkgYWRkX3Rlc3QgYXV4X3NvdXJjZV9kaXJlY3RvcnkgJyArXG4gICAgICAnYnJlYWsgYnVpbGRfY29tbWFuZCBjbWFrZV9taW5pbXVtX3JlcXVpcmVkIGNtYWtlX3BvbGljeSBjb25maWd1cmVfZmlsZSAnICtcbiAgICAgICdjcmVhdGVfdGVzdF9zb3VyY2VsaXN0IGRlZmluZV9wcm9wZXJ0eSBlbHNlIGVsc2VpZiBlbmFibGVfbGFuZ3VhZ2UgZW5hYmxlX3Rlc3RpbmcgJyArXG4gICAgICAnZW5kZm9yZWFjaCBlbmRmdW5jdGlvbiBlbmRpZiBlbmRtYWNybyBlbmR3aGlsZSBleGVjdXRlX3Byb2Nlc3MgZXhwb3J0IGZpbmRfZmlsZSAnICtcbiAgICAgICdmaW5kX2xpYnJhcnkgZmluZF9wYWNrYWdlIGZpbmRfcGF0aCBmaW5kX3Byb2dyYW0gZmx0a193cmFwX3VpIGZvcmVhY2ggZnVuY3Rpb24gJyArXG4gICAgICAnZ2V0X2NtYWtlX3Byb3BlcnR5IGdldF9kaXJlY3RvcnlfcHJvcGVydHkgZ2V0X2ZpbGVuYW1lX2NvbXBvbmVudCBnZXRfcHJvcGVydHkgJyArXG4gICAgICAnZ2V0X3NvdXJjZV9maWxlX3Byb3BlcnR5IGdldF90YXJnZXRfcHJvcGVydHkgZ2V0X3Rlc3RfcHJvcGVydHkgaWYgaW5jbHVkZSAnICtcbiAgICAgICdpbmNsdWRlX2RpcmVjdG9yaWVzIGluY2x1ZGVfZXh0ZXJuYWxfbXNwcm9qZWN0IGluY2x1ZGVfcmVndWxhcl9leHByZXNzaW9uIGluc3RhbGwgJyArXG4gICAgICAnbGlua19kaXJlY3RvcmllcyBsb2FkX2NhY2hlIGxvYWRfY29tbWFuZCBtYWNybyBtYXJrX2FzX2FkdmFuY2VkIG1lc3NhZ2Ugb3B0aW9uICcgK1xuICAgICAgJ291dHB1dF9yZXF1aXJlZF9maWxlcyBwcm9qZWN0IHF0X3dyYXBfY3BwIHF0X3dyYXBfdWkgcmVtb3ZlX2RlZmluaXRpb25zIHJldHVybiAnICtcbiAgICAgICdzZXBhcmF0ZV9hcmd1bWVudHMgc2V0IHNldF9kaXJlY3RvcnlfcHJvcGVydGllcyBzZXRfcHJvcGVydHkgJyArXG4gICAgICAnc2V0X3NvdXJjZV9maWxlc19wcm9wZXJ0aWVzIHNldF90YXJnZXRfcHJvcGVydGllcyBzZXRfdGVzdHNfcHJvcGVydGllcyBzaXRlX25hbWUgJyArXG4gICAgICAnc291cmNlX2dyb3VwIHN0cmluZyB0YXJnZXRfbGlua19saWJyYXJpZXMgdHJ5X2NvbXBpbGUgdHJ5X3J1biB1bnNldCB2YXJpYWJsZV93YXRjaCAnICtcbiAgICAgICd3aGlsZSBidWlsZF9uYW1lIGV4ZWNfcHJvZ3JhbSBleHBvcnRfbGlicmFyeV9kZXBlbmRlbmNpZXMgaW5zdGFsbF9maWxlcyAnICtcbiAgICAgICdpbnN0YWxsX3Byb2dyYW1zIGluc3RhbGxfdGFyZ2V0cyBsaW5rX2xpYnJhcmllcyBtYWtlX2RpcmVjdG9yeSByZW1vdmUgc3ViZGlyX2RlcGVuZHMgJyArXG4gICAgICAnc3ViZGlycyB1c2VfbWFuZ2xlZF9tZXNhIHV0aWxpdHlfc291cmNlIHZhcmlhYmxlX3JlcXVpcmVzIHdyaXRlX2ZpbGUnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2VudnZhcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXCR7JywgZW5kOiAnfSdcbiAgICAgIH0sXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuTlVNQkVSX01PREVcbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgS0VZV09SRFMgPSB7XG4gICAga2V5d29yZDpcbiAgICAgIC8vIEpTIGtleXdvcmRzXG4gICAgICAnaW4gaWYgZm9yIHdoaWxlIGZpbmFsbHkgbmV3IGRvIHJldHVybiBlbHNlIGJyZWFrIGNhdGNoIGluc3RhbmNlb2YgdGhyb3cgdHJ5IHRoaXMgJyArXG4gICAgICAnc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgZGVidWdnZXIgc3VwZXIgJyArXG4gICAgICAvLyBDb2ZmZWUga2V5d29yZHNcbiAgICAgICd0aGVuIHVubGVzcyB1bnRpbCBsb29wIG9mIGJ5IHdoZW4gYW5kIG9yIGlzIGlzbnQgbm90JyxcbiAgICBsaXRlcmFsOlxuICAgICAgLy8gSlMgbGl0ZXJhbHNcbiAgICAgICd0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkICcgK1xuICAgICAgLy8gQ29mZmVlIGxpdGVyYWxzXG4gICAgICAneWVzIG5vIG9uIG9mZiAnLFxuICAgIHJlc2VydmVkOiAnY2FzZSBkZWZhdWx0IGZ1bmN0aW9uIHZhciB2b2lkIHdpdGggY29uc3QgbGV0IGVudW0gZXhwb3J0IGltcG9ydCBuYXRpdmUgJyArXG4gICAgICAnX19oYXNQcm9wIF9fZXh0ZW5kcyBfX3NsaWNlIF9fYmluZCBfX2luZGV4T2YnXG4gIH07XG4gIHZhciBKU19JREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuICB2YXIgVElUTEUgPSB7Y2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogSlNfSURFTlRfUkV9O1xuICB2YXIgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAnI1xcXFx7JywgZW5kOiAnfScsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CSU5BUllfTlVNQkVSX01PREUsIGhsanMuQ19OVU1CRVJfTU9ERV1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW1xuICAgICAgLy8gTnVtYmVyc1xuICAgICAgaGxqcy5CSU5BUllfTlVNQkVSX01PREUsXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICAvLyBTdHJpbmdzXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnXCJcIlwiJywgZW5kOiAnXCJcIlwiJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFNVQlNUXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFNVQlNUXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiAnIyMjJywgZW5kOiAnIyMjJ1xuICAgICAgfSxcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgIGJlZ2luOiAnLy8vJywgZW5kOiAnLy8vJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkhBU0hfQ09NTUVOVF9NT0RFXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncmVnZXhwJywgYmVnaW46ICcvL1tnaW1dKidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgIGJlZ2luOiAnL1xcXFxTKFxcXFxcXFxcLnxbXlxcXFxuXSkqL1tnaW1dKicgLy8gXFxTIGlzIHJlcXVpcmVkIHRvIHBhcnNlIHggLyAyIC8gMyBhcyB0d28gZGl2aXNpb25zXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ2AnLCBlbmQ6ICdgJyxcbiAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBzdWJMYW5ndWFnZTogJ2phdmFzY3JpcHQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luOiBKU19JREVOVF9SRSArICdcXFxccyo9XFxcXHMqKFxcXFwoLitcXFxcKSk/XFxcXHMqWy09XT4nLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBUSVRMRSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgYmVnaW46ICdcXFxcKCcsIGVuZDogJ1xcXFwpJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBrZXl3b3JkczogJ2NsYXNzJyxcbiAgICAgICAgZW5kOiAnJCcsXG4gICAgICAgIGlsbGVnYWw6ICc6JyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBrZXl3b3JkczogJ2V4dGVuZHMnLFxuICAgICAgICAgICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBpbGxlZ2FsOiAnOicsXG4gICAgICAgICAgICBjb250YWluczogW1RJVExFXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgVElUTEVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJvcGVydHknLFxuICAgICAgICBiZWdpbjogJ0AnICsgSlNfSURFTlRfUkVcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgQ1BQX0tFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6ICdmYWxzZSBpbnQgZmxvYXQgd2hpbGUgcHJpdmF0ZSBjaGFyIGNhdGNoIGV4cG9ydCB2aXJ0dWFsIG9wZXJhdG9yIHNpemVvZiAnICtcbiAgICAgICdkeW5hbWljX2Nhc3R8MTAgdHlwZWRlZiBjb25zdF9jYXN0fDEwIGNvbnN0IHN0cnVjdCBmb3Igc3RhdGljX2Nhc3R8MTAgdW5pb24gbmFtZXNwYWNlICcgK1xuICAgICAgJ3Vuc2lnbmVkIGxvbmcgdGhyb3cgdm9sYXRpbGUgc3RhdGljIHByb3RlY3RlZCBib29sIHRlbXBsYXRlIG11dGFibGUgaWYgcHVibGljIGZyaWVuZCAnICtcbiAgICAgICdkbyByZXR1cm4gZ290byBhdXRvIHZvaWQgZW51bSBlbHNlIGJyZWFrIG5ldyBleHRlcm4gdXNpbmcgdHJ1ZSBjbGFzcyBhc20gY2FzZSB0eXBlaWQgJyArXG4gICAgICAnc2hvcnQgcmVpbnRlcnByZXRfY2FzdHwxMCBkZWZhdWx0IGRvdWJsZSByZWdpc3RlciBleHBsaWNpdCBzaWduZWQgdHlwZW5hbWUgdHJ5IHRoaXMgJyArXG4gICAgICAnc3dpdGNoIGNvbnRpbnVlIHdjaGFyX3QgaW5saW5lIGRlbGV0ZSBhbGlnbm9mIGNoYXIxNl90IGNoYXIzMl90IGNvbnN0ZXhwciBkZWNsdHlwZSAnICtcbiAgICAgICdub2V4Y2VwdCBudWxscHRyIHN0YXRpY19hc3NlcnQgdGhyZWFkX2xvY2FsIHJlc3RyaWN0IF9Cb29sIGNvbXBsZXgnLFxuICAgIGJ1aWx0X2luOiAnc3RkIHN0cmluZyBjaW4gY291dCBjZXJyIGNsb2cgc3RyaW5nc3RyZWFtIGlzdHJpbmdzdHJlYW0gb3N0cmluZ3N0cmVhbSAnICtcbiAgICAgICdhdXRvX3B0ciBkZXF1ZSBsaXN0IHF1ZXVlIHN0YWNrIHZlY3RvciBtYXAgc2V0IGJpdHNldCBtdWx0aXNldCBtdWx0aW1hcCB1bm9yZGVyZWRfc2V0ICcgK1xuICAgICAgJ3Vub3JkZXJlZF9tYXAgdW5vcmRlcmVkX211bHRpc2V0IHVub3JkZXJlZF9tdWx0aW1hcCBhcnJheSBzaGFyZWRfcHRyJ1xuICB9O1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnXFwnXFxcXFxcXFw/LicsIGVuZDogJ1xcJycsXG4gICAgICAgIGlsbGVnYWw6ICcuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICAgICAgYmVnaW46ICdcXFxcYihcXFxcZCsoXFxcXC5cXFxcZCopP3xcXFxcLlxcXFxkKykodXxVfGx8THx1bHxVTHxmfEYpJ1xuICAgICAgfSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICcjJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0bF9jb250YWluZXInLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKGRlcXVlfGxpc3R8cXVldWV8c3RhY2t8dmVjdG9yfG1hcHxzZXR8Yml0c2V0fG11bHRpc2V0fG11bHRpbWFwfHVub3JkZXJlZF9tYXB8dW5vcmRlcmVkX3NldHx1bm9yZGVyZWRfbXVsdGlzZXR8dW5vcmRlcmVkX211bHRpbWFwfGFycmF5KVxcXFxzKjwnLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IENQUF9LRVlXT1JEUyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFsnc2VsZiddXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczpcbiAgICAgIC8vIE5vcm1hbCBrZXl3b3Jkcy5cbiAgICAgICdhYnN0cmFjdCBhcyBiYXNlIGJvb2wgYnJlYWsgYnl0ZSBjYXNlIGNhdGNoIGNoYXIgY2hlY2tlZCBjbGFzcyBjb25zdCBjb250aW51ZSBkZWNpbWFsICcgK1xuICAgICAgJ2RlZmF1bHQgZGVsZWdhdGUgZG8gZG91YmxlIGVsc2UgZW51bSBldmVudCBleHBsaWNpdCBleHRlcm4gZmFsc2UgZmluYWxseSBmaXhlZCBmbG9hdCAnICtcbiAgICAgICdmb3IgZm9yZWFjaCBnb3RvIGlmIGltcGxpY2l0IGluIGludCBpbnRlcmZhY2UgaW50ZXJuYWwgaXMgbG9jayBsb25nIG5hbWVzcGFjZSBuZXcgbnVsbCAnICtcbiAgICAgICdvYmplY3Qgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHJldHVybiBzYnl0ZSAnICtcbiAgICAgICdzZWFsZWQgc2hvcnQgc2l6ZW9mIHN0YWNrYWxsb2Mgc3RhdGljIHN0cmluZyBzdHJ1Y3Qgc3dpdGNoIHRoaXMgdGhyb3cgdHJ1ZSB0cnkgdHlwZW9mICcgK1xuICAgICAgJ3VpbnQgdWxvbmcgdW5jaGVja2VkIHVuc2FmZSB1c2hvcnQgdXNpbmcgdmlydHVhbCB2b2xhdGlsZSB2b2lkIHdoaWxlICcgK1xuICAgICAgLy8gQ29udGV4dHVhbCBrZXl3b3Jkcy5cbiAgICAgICdhc2NlbmRpbmcgZGVzY2VuZGluZyBmcm9tIGdldCBncm91cCBpbnRvIGpvaW4gbGV0IG9yZGVyYnkgcGFydGlhbCBzZWxlY3Qgc2V0IHZhbHVlIHZhciAnK1xuICAgICAgJ3doZXJlIHlpZWxkJyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICcvLy8nLCBlbmQ6ICckJywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAneG1sRG9jVGFnJyxcbiAgICAgICAgICAgIGJlZ2luOiAnLy8vfDwhLS18LS0+J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAneG1sRG9jVGFnJyxcbiAgICAgICAgICAgIGJlZ2luOiAnPC8/JywgZW5kOiAnPidcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdwcmVwcm9jZXNzb3InLFxuICAgICAgICBiZWdpbjogJyMnLCBlbmQ6ICckJyxcbiAgICAgICAga2V5d29yZHM6ICdpZiBlbHNlIGVsaWYgZW5kaWYgZGVmaW5lIHVuZGVmIHdhcm5pbmcgZXJyb3IgbGluZSByZWdpb24gZW5kcmVnaW9uIHByYWdtYSBjaGVja3N1bSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnQFwiJywgZW5kOiAnXCInLFxuICAgICAgICBjb250YWluczogW3tiZWdpbjogJ1wiXCInfV1cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIEZVTkNUSU9OID0ge1xuICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICBiZWdpbjogaGxqcy5JREVOVF9SRSArICdcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICBjb250YWluczogW2hsanMuTlVNQkVSX01PREUsIGhsanMuQVBPU19TVFJJTkdfTU9ERSwgaGxqcy5RVU9URV9TVFJJTkdfTU9ERV1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGlsbGVnYWw6ICdbPS98XFwnXScsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2lkJywgYmVnaW46ICdcXFxcI1tBLVphLXowLTlfLV0rJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLCBiZWdpbjogJ1xcXFwuW0EtWmEtejAtOV8tXSsnLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHJfc2VsZWN0b3InLFxuICAgICAgICBiZWdpbjogJ1xcXFxbJywgZW5kOiAnXFxcXF0nLFxuICAgICAgICBpbGxlZ2FsOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BzZXVkbycsXG4gICAgICAgIGJlZ2luOiAnOig6KT9bYS16QS1aMC05XFxcXF9cXFxcLVxcXFwrXFxcXChcXFxcKVxcXFxcIlxcXFxcXCddKydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0X3J1bGUnLFxuICAgICAgICBiZWdpbjogJ0AoZm9udC1mYWNlfHBhZ2UpJyxcbiAgICAgICAgbGV4ZW1zOiAnW2Etei1dKycsXG4gICAgICAgIGtleXdvcmRzOiAnZm9udC1mYWNlIHBhZ2UnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdF9ydWxlJyxcbiAgICAgICAgYmVnaW46ICdAJywgZW5kOiAnW3s7XScsIC8vIGF0X3J1bGUgZWF0aW5nIGZpcnN0IFwie1wiIGlzIGEgZ29vZCB0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzbuKAmXQgbGV0IGl0IHRvIGJlIHBhcnNlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBydWxlIHNldCBidXQgaW5zdGVhZCBkcm9wcyBwYXJzZXIgaW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgbW9kZSB3aGljaCBpcyBob3cgaXQgc2hvdWxkIGJlLlxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBrZXl3b3JkczogJ2ltcG9ydCBwYWdlIG1lZGlhIGNoYXJzZXQnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIEZVTkNUSU9OLFxuICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSwgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICBobGpzLk5VTUJFUl9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsIGJlZ2luOiBobGpzLklERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3J1bGVzJyxcbiAgICAgICAgYmVnaW46ICd7JywgZW5kOiAnfScsXG4gICAgICAgIGlsbGVnYWw6ICdbXlxcXFxzXScsXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3J1bGUnLFxuICAgICAgICAgICAgYmVnaW46ICdbXlxcXFxzXScsIHJldHVybkJlZ2luOiB0cnVlLCBlbmQ6ICc7JywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgICAgICAgICBiZWdpbjogJ1tBLVpcXFxcX1xcXFwuXFxcXC1dKycsIGVuZDogJzonLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaWxsZWdhbDogJ1teXFxcXHNdJyxcbiAgICAgICAgICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgRlVOQ1RJT04sXG4gICAgICAgICAgICAgICAgICAgIGhsanMuTlVNQkVSX01PREUsXG4gICAgICAgICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2hleGNvbG9yJywgYmVnaW46ICdcXFxcI1swLTlBLUZdKydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ltcG9ydGFudCcsIGJlZ2luOiAnIWltcG9ydGFudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSAvKipcbiAqIEtub3duIGlzc3VlczpcbiAqXG4gKiAtIGludmFsaWQgaGV4IHN0cmluZyBsaXRlcmFscyB3aWxsIGJlIHJlY29nbml6ZWQgYXMgYSBkb3VibGUgcXVvdGVkIHN0cmluZ3NcbiAqICAgYnV0ICd4JyBhdCB0aGUgYmVnaW5uaW5nIG9mIHN0cmluZyB3aWxsIG5vdCBiZSBtYXRjaGVkXG4gKlxuICogLSBkZWxpbWl0ZWQgc3RyaW5nIGxpdGVyYWxzIGFyZSBub3QgY2hlY2tlZCBmb3IgbWF0Y2hpbmcgZW5kIGRlbGltaXRlclxuICogICAobm90IHBvc3NpYmxlIHRvIGRvIHdpdGgganMgcmVnZXhwKVxuICpcbiAqIC0gY29udGVudCBvZiB0b2tlbiBzdHJpbmcgaXMgY29sb3JlZCBhcyBhIHN0cmluZyAoaS5lLiBubyBrZXl3b3JkIGNvbG9yaW5nIGluc2lkZSBhIHRva2VuIHN0cmluZylcbiAqICAgYWxzbywgY29udGVudCBvZiB0b2tlbiBzdHJpbmcgaXMgbm90IHZhbGlkYXRlZCB0byBjb250YWluIG9ubHkgdmFsaWQgRCB0b2tlbnNcbiAqXG4gKiAtIHNwZWNpYWwgdG9rZW4gc2VxdWVuY2UgcnVsZSBpcyBub3Qgc3RyaWN0bHkgZm9sbG93aW5nIEQgZ3JhbW1hciAoYW55dGhpbmcgZm9sbG93aW5nICNsaW5lXG4gKiAgIHVwIHRvIHRoZSBlbmQgb2YgbGluZSBpcyBtYXRjaGVkIGFzIHNwZWNpYWwgdG9rZW4gc2VxdWVuY2UpXG4gKi9cblxuZnVuY3Rpb24oaGxqcykge1xuXG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBrZXl3b3Jkc1xuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIERfS0VZV09SRFMgPSB7XG5cdFx0a2V5d29yZDpcblx0XHRcdCdhYnN0cmFjdCBhbGlhcyBhbGlnbiBhc20gYXNzZXJ0IGF1dG8gYm9keSBicmVhayBieXRlIGNhc2UgY2FzdCBjYXRjaCBjbGFzcyAnICtcblx0XHRcdCdjb25zdCBjb250aW51ZSBkZWJ1ZyBkZWZhdWx0IGRlbGV0ZSBkZXByZWNhdGVkIGRvIGVsc2UgZW51bSBleHBvcnQgZXh0ZXJuIGZpbmFsICcgK1xuXHRcdFx0J2ZpbmFsbHkgZm9yIGZvcmVhY2ggZm9yZWFjaF9yZXZlcnNlfDEwIGdvdG8gaWYgaW1tdXRhYmxlIGltcG9ydCBpbiBpbm91dCBpbnQgJyArXG5cdFx0XHQnaW50ZXJmYWNlIGludmFyaWFudCBpcyBsYXp5IG1hY3JvIG1peGluIG1vZHVsZSBuZXcgbm90aHJvdyBvdXQgb3ZlcnJpZGUgcGFja2FnZSAnICtcblx0XHRcdCdwcmFnbWEgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHB1cmUgcmVmIHJldHVybiBzY29wZSBzaGFyZWQgc3RhdGljIHN0cnVjdCAnICtcblx0XHRcdCdzdXBlciBzd2l0Y2ggc3luY2hyb25pemVkIHRlbXBsYXRlIHRoaXMgdGhyb3cgdHJ5IHR5cGVkZWYgdHlwZWlkIHR5cGVvZiB1bmlvbiAnICtcblx0XHRcdCd1bml0dGVzdCB2ZXJzaW9uIHZvaWQgdm9sYXRpbGUgd2hpbGUgd2l0aCBfX0ZJTEVfXyBfX0xJTkVfXyBfX2dzaGFyZWR8MTAgJyArXG5cdFx0XHQnX190aHJlYWQgX190cmFpdHMgX19EQVRFX18gX19FT0ZfXyBfX1RJTUVfXyBfX1RJTUVTVEFNUF9fIF9fVkVORE9SX18gX19WRVJTSU9OX18nLFxuXHRcdGJ1aWx0X2luOlxuXHRcdFx0J2Jvb2wgY2RvdWJsZSBjZW50IGNmbG9hdCBjaGFyIGNyZWFsIGRjaGFyIGRlbGVnYXRlIGRvdWJsZSBkc3RyaW5nIGZsb2F0IGZ1bmN0aW9uICcgK1xuXHRcdFx0J2lkb3VibGUgaWZsb2F0IGlyZWFsIGxvbmcgcmVhbCBzaG9ydCBzdHJpbmcgdWJ5dGUgdWNlbnQgdWludCB1bG9uZyB1c2hvcnQgd2NoYXIgJyArXG5cdFx0XHQnd3N0cmluZycsXG5cdFx0bGl0ZXJhbDpcblx0XHRcdCdmYWxzZSBudWxsIHRydWUnXG5cdH07XG5cblx0LyoqXG5cdCAqIE51bWJlciBsaXRlcmFsIHJlZ2V4cHNcblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICovXG5cdHZhciBkZWNpbWFsX2ludGVnZXJfcmUgPSAnKDB8WzEtOV1bXFxcXGRfXSopJyxcblx0XHRkZWNpbWFsX2ludGVnZXJfbm9zdXNfcmUgPSAnKDB8WzEtOV1bXFxcXGRfXSp8XFxcXGRbXFxcXGRfXSp8W1xcXFxkX10rP1xcXFxkKScsXG5cdFx0YmluYXJ5X2ludGVnZXJfcmUgPSAnMFtiQl1bMDFfXSsnLFxuXHRcdGhleGFkZWNpbWFsX2RpZ2l0c19yZSA9ICcoW1xcXFxkYS1mQS1GXVtcXFxcZGEtZkEtRl9dKnxfW1xcXFxkYS1mQS1GXVtcXFxcZGEtZkEtRl9dKiknLFxuXHRcdGhleGFkZWNpbWFsX2ludGVnZXJfcmUgPSAnMFt4WF0nICsgaGV4YWRlY2ltYWxfZGlnaXRzX3JlLFxuXG5cdFx0ZGVjaW1hbF9leHBvbmVudF9yZSA9ICcoW2VFXVsrLV0/JyArIGRlY2ltYWxfaW50ZWdlcl9ub3N1c19yZSArICcpJyxcblx0XHRkZWNpbWFsX2Zsb2F0X3JlID0gJygnICsgZGVjaW1hbF9pbnRlZ2VyX25vc3VzX3JlICsgJyhcXFxcLlxcXFxkKnwnICsgZGVjaW1hbF9leHBvbmVudF9yZSArICcpfCcgK1xuXHRcdFx0XHRcdFx0XHRcdCdcXFxcZCtcXFxcLicgKyBkZWNpbWFsX2ludGVnZXJfbm9zdXNfcmUgKyBkZWNpbWFsX2ludGVnZXJfbm9zdXNfcmUgKyAnfCcgK1xuXHRcdFx0XHRcdFx0XHRcdCdcXFxcLicgKyBkZWNpbWFsX2ludGVnZXJfcmUgKyBkZWNpbWFsX2V4cG9uZW50X3JlICsgJz8nICtcblx0XHRcdFx0XHRcdFx0JyknLFxuXHRcdGhleGFkZWNpbWFsX2Zsb2F0X3JlID0gJygwW3hYXSgnICtcblx0XHRcdFx0XHRcdFx0XHRcdGhleGFkZWNpbWFsX2RpZ2l0c19yZSArICdcXFxcLicgKyBoZXhhZGVjaW1hbF9kaWdpdHNfcmUgKyAnfCcrXG5cdFx0XHRcdFx0XHRcdFx0XHQnXFxcXC4/JyArIGhleGFkZWNpbWFsX2RpZ2l0c19yZSArXG5cdFx0XHRcdFx0XHRcdCAgICcpW3BQXVsrLV0/JyArIGRlY2ltYWxfaW50ZWdlcl9ub3N1c19yZSArICcpJyxcblxuXHRcdGludGVnZXJfcmUgPSAnKCcgK1xuXHRcdFx0ZGVjaW1hbF9pbnRlZ2VyX3JlICsgJ3wnICtcblx0XHRcdGJpbmFyeV9pbnRlZ2VyX3JlICArICd8JyArXG5cdFx0IFx0aGV4YWRlY2ltYWxfaW50ZWdlcl9yZSAgICtcblx0XHQnKScsXG5cblx0XHRmbG9hdF9yZSA9ICcoJyArXG5cdFx0XHRoZXhhZGVjaW1hbF9mbG9hdF9yZSArICd8JyArXG5cdFx0XHRkZWNpbWFsX2Zsb2F0X3JlICArXG5cdFx0JyknO1xuXG5cdC8qKlxuXHQgKiBFc2NhcGUgc2VxdWVuY2Ugc3VwcG9ydGVkIGluIEQgc3RyaW5nIGFuZCBjaGFyYWN0ZXIgbGl0ZXJhbHNcblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICovXG5cdHZhciBlc2NhcGVfc2VxdWVuY2VfcmUgPSAnXFxcXFxcXFwoJyArXG5cdFx0XHRcdFx0XHRcdCdbXFwnXCJcXFxcP1xcXFxcXFxcYWJmbnJ0dl18JyArXHQvLyBjb21tb24gZXNjYXBlc1xuXHRcdFx0XHRcdFx0XHQndVtcXFxcZEEtRmEtZl17NH18JyArIFx0XHQvLyBmb3VyIGhleCBkaWdpdCB1bmljb2RlIGNvZGVwb2ludFxuXHRcdFx0XHRcdFx0XHQnWzAtN117MSwzfXwnICsgXHRcdFx0Ly8gb25lIHRvIHRocmVlIG9jdGFsIGRpZ2l0IGFzY2lpIGNoYXIgY29kZVxuXHRcdFx0XHRcdFx0XHQneFtcXFxcZEEtRmEtZl17Mn18JyArXHRcdC8vIHR3byBoZXggZGlnaXQgYXNjaWkgY2hhciBjb2RlXG5cdFx0XHRcdFx0XHRcdCdVW1xcXFxkQS1GYS1mXXs4fScgK1x0XHRcdC8vIGVpZ2h0IGhleCBkaWdpdCB1bmljb2RlIGNvZGVwb2ludFxuXHRcdFx0XHRcdFx0ICAnKXwnICtcblx0XHRcdFx0XHRcdCAgJyZbYS16QS1aXFxcXGRdezIsfTsnO1x0XHRcdC8vIG5hbWVkIGNoYXJhY3RlciBlbnRpdHlcblxuXG5cdC8qKlxuXHQgKiBEIGludGVnZXIgbnVtYmVyIGxpdGVyYWxzXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9JTlRFR0VSX01PREUgPSB7XG5cdFx0Y2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBcdGJlZ2luOiAnXFxcXGInICsgaW50ZWdlcl9yZSArICcoTHx1fFV8THV8TFV8dUx8VUwpPycsXG4gICAgXHRyZWxldmFuY2U6IDBcblx0fTtcblxuXHQvKipcblx0ICogW0RfRkxPQVRfTU9ERSBkZXNjcmlwdGlvbl1cblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdHZhciBEX0ZMT0FUX01PREUgPSB7XG5cdFx0Y2xhc3NOYW1lOiAnbnVtYmVyJyxcblx0XHRiZWdpbjogJ1xcXFxiKCcgK1xuXHRcdFx0XHRmbG9hdF9yZSArICcoW2ZGXXxMfGl8W2ZGXWl8TGkpP3wnICtcblx0XHRcdFx0aW50ZWdlcl9yZSArICcoaXxbZkZdaXxMaSknICtcblx0XHRcdCcpJyxcblx0XHRyZWxldmFuY2U6IDBcblx0fTtcblxuXHQvKipcblx0ICogRCBjaGFyYWN0ZXIgbGl0ZXJhbFxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIERfQ0hBUkFDVEVSX01PREUgPSB7XG5cdFx0Y2xhc3NOYW1lOiAnc3RyaW5nJyxcblx0XHRiZWdpbjogJ1xcJygnICsgZXNjYXBlX3NlcXVlbmNlX3JlICsgJ3wuKScsIGVuZDogJ1xcJycsXG5cdFx0aWxsZWdhbDogJy4nXG5cdH07XG5cblx0LyoqXG5cdCAqIEQgc3RyaW5nIGVzY2FwZSBzZXF1ZW5jZVxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIERfRVNDQVBFX1NFUVVFTkNFID0ge1xuXHRcdGJlZ2luOiBlc2NhcGVfc2VxdWVuY2VfcmUsXG5cdFx0cmVsZXZhbmNlOiAwXG5cdH1cblxuXHQvKipcblx0ICogRCBkb3VibGUgcXVvdGVkIHN0cmluZyBsaXRlcmFsXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9TVFJJTkdfTU9ERSA9IHtcblx0XHRjbGFzc05hbWU6ICdzdHJpbmcnLFxuXHRcdGJlZ2luOiAnXCInLFxuXHRcdGNvbnRhaW5zOiBbRF9FU0NBUEVfU0VRVUVOQ0VdLFxuXHRcdGVuZDogJ1wiW2N3ZF0/Jyxcblx0XHRyZWxldmFuY2U6IDBcblx0fTtcblxuXHQvKipcblx0ICogRCB3eXNpd3lnIGFuZCBkZWxpbWl0ZWQgc3RyaW5nIGxpdGVyYWxzXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9XWVNJV1lHX0RFTElNSVRFRF9TVFJJTkdfTU9ERSA9IHtcblx0XHRjbGFzc05hbWU6ICdzdHJpbmcnLFxuXHRcdGJlZ2luOiAnW3JxXVwiJyxcblx0XHRlbmQ6ICdcIltjd2RdPycsXG5cdFx0cmVsZXZhbmNlOiA1XG5cdH07XG5cblx0LyoqXG5cdCAqIEQgYWx0ZXJuYXRlIHd5c2l3eWcgc3RyaW5nIGxpdGVyYWxcblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdHZhciBEX0FMVEVSTkFURV9XWVNJV1lHX1NUUklOR19NT0RFID0ge1xuXHRcdGNsYXNzTmFtZTogJ3N0cmluZycsXG5cdFx0YmVnaW46ICdgJyxcblx0XHRlbmQ6ICdgW2N3ZF0/J1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEIGhleGFkZWNpbWFsIHN0cmluZyBsaXRlcmFsXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9IRVhfU1RSSU5HX01PREUgPSB7XG5cdFx0Y2xhc3NOYW1lOiAnc3RyaW5nJyxcblx0XHRiZWdpbjogJ3hcIltcXFxcZGEtZkEtRlxcXFxzXFxcXG5cXFxccl0qXCJbY3dkXT8nLFxuXHRcdHJlbGV2YW5jZTogMTBcblx0fTtcblxuXHQvKipcblx0ICogRCBkZWxpbWl0ZWQgc3RyaW5nIGxpdGVyYWxcblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdHZhciBEX1RPS0VOX1NUUklOR19NT0RFID0ge1xuXHRcdGNsYXNzTmFtZTogJ3N0cmluZycsXG5cdFx0YmVnaW46ICdxXCJcXFxceycsXG5cdFx0ZW5kOiAnXFxcXH1cIidcblx0fTtcblxuXHQvKipcblx0ICogSGFzaGJhbmcgc3VwcG9ydFxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIERfSEFTSEJBTkdfTU9ERSA9IHtcblx0XHRjbGFzc05hbWU6ICdzaGViYW5nJyxcblx0XHRiZWdpbjogJ14jIScsXG5cdFx0ZW5kOiAnJCcsXG5cdFx0cmVsZXZhbmNlOiA1XG5cdH07XG5cblx0LyoqXG5cdCAqIEQgc3BlY2lhbCB0b2tlbiBzZXF1ZW5jZVxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIERfU1BFQ0lBTF9UT0tFTl9TRVFVRU5DRV9NT0RFID0ge1xuXHRcdGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG5cdFx0YmVnaW46ICcjKGxpbmUpJyxcblx0XHRlbmQ6ICckJyxcblx0XHRyZWxldmFuY2U6IDVcblx0fTtcblxuXHQvKipcblx0ICogRCBhdHRyaWJ1dGVzXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9BVFRSSUJVVEVfTU9ERSA9IHtcblx0XHRjbGFzc05hbWU6ICdrZXl3b3JkJyxcblx0XHRiZWdpbjogJ0BbYS16QS1aX11bYS16QS1aX1xcXFxkXSonXG5cdH07XG5cblx0LyoqXG5cdCAqIEQgbmVzdGluZyBjb21tZW50XG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgRF9ORVNUSU5HX0NPTU1FTlRfTU9ERSA9IHtcblx0XHRjbGFzc05hbWU6ICdjb21tZW50Jyxcblx0XHRiZWdpbjogJ1xcXFwvXFxcXCsnLFxuXHRcdGNvbnRhaW5zOiBbJ3NlbGYnXSxcblx0XHRlbmQ6ICdcXFxcK1xcXFwvJyxcblx0XHRyZWxldmFuY2U6IDEwXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxleGVtczogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuXHRcdGtleXdvcmRzOiBEX0tFWVdPUkRTLFxuXHRcdGNvbnRhaW5zOiBbXG5cdFx0XHRobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gIFx0XHRcdGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gIFx0XHRcdERfTkVTVElOR19DT01NRU5UX01PREUsXG4gIFx0XHRcdERfSEVYX1NUUklOR19NT0RFLFxuICBcdFx0XHREX1NUUklOR19NT0RFLFxuICBcdFx0XHREX1dZU0lXWUdfREVMSU1JVEVEX1NUUklOR19NT0RFLFxuICBcdFx0XHREX0FMVEVSTkFURV9XWVNJV1lHX1NUUklOR19NT0RFLFxuICBcdFx0XHREX1RPS0VOX1NUUklOR19NT0RFLFxuICBcdFx0XHREX0ZMT0FUX01PREUsXG4gIFx0XHRcdERfSU5URUdFUl9NT0RFLFxuICBcdFx0XHREX0NIQVJBQ1RFUl9NT0RFLFxuICBcdFx0XHREX0hBU0hCQU5HX01PREUsXG4gIFx0XHRcdERfU1BFQ0lBTF9UT0tFTl9TRVFVRU5DRV9NT0RFLFxuICBcdFx0XHREX0FUVFJJQlVURV9NT0RFXG5cdFx0XVxuXHR9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIERFTFBISV9LRVlXT1JEUyA9ICdhbmQgc2FmZWNhbGwgY2RlY2wgdGhlbiBzdHJpbmcgZXhwb3J0cyBsaWJyYXJ5IG5vdCBwYXNjYWwgc2V0ICcgK1xuICAgICd2aXJ0dWFsIGZpbGUgaW4gYXJyYXkgbGFiZWwgcGFja2VkIGVuZC4gaW5kZXggd2hpbGUgY29uc3QgcmFpc2UgZm9yIHRvIGltcGxlbWVudGF0aW9uICcgK1xuICAgICd3aXRoIGV4Y2VwdCBvdmVybG9hZCBkZXN0cnVjdG9yIGRvd250byBmaW5hbGx5IHByb2dyYW0gZXhpdCB1bml0IGluaGVyaXRlZCBvdmVycmlkZSBpZiAnICtcbiAgICAndHlwZSB1bnRpbCBmdW5jdGlvbiBkbyBiZWdpbiByZXBlYXQgZ290byBuaWwgZmFyIGluaXRpYWxpemF0aW9uIG9iamVjdCBlbHNlIHZhciB1c2VzICcgK1xuICAgICdleHRlcm5hbCByZXNvdXJjZXN0cmluZyBpbnRlcmZhY2UgZW5kIGZpbmFsaXphdGlvbiBjbGFzcyBhc20gbW9kIGNhc2Ugb24gc2hyIHNobCBvZiAnICtcbiAgICAncmVnaXN0ZXIgeG9yd3JpdGUgdGhyZWFkdmFyIHRyeSByZWNvcmQgbmVhciBzdG9yZWQgY29uc3RydWN0b3Igc3RkY2FsbCBpbmxpbmUgZGl2IG91dCBvciAnICtcbiAgICAncHJvY2VkdXJlJztcbiAgdmFyIERFTFBISV9DTEFTU19LRVlXT1JEUyA9ICdzYWZlY2FsbCBzdGRjYWxsIHBhc2NhbCBzdG9yZWQgY29uc3QgaW1wbGVtZW50YXRpb24gJyArXG4gICAgJ2ZpbmFsaXphdGlvbiBleGNlcHQgdG8gZmluYWxseSBwcm9ncmFtIGluaGVyaXRlZCBvdmVycmlkZSB0aGVuIGV4cG9ydHMgc3RyaW5nIHJlYWQgbm90ICcgK1xuICAgICdtb2Qgc2hyIHRyeSBkaXYgc2hsIHNldCBsaWJyYXJ5IG1lc3NhZ2UgcGFja2VkIGluZGV4IGZvciBuZWFyIG92ZXJsb2FkIGxhYmVsIGRvd250byBleGl0ICcgK1xuICAgICdwdWJsaWMgZ290byBpbnRlcmZhY2UgYXNtIG9uIG9mIGNvbnN0cnVjdG9yIG9yIHByaXZhdGUgYXJyYXkgdW5pdCByYWlzZSBkZXN0cnVjdG9yIHZhciAnICtcbiAgICAndHlwZSB1bnRpbCBmdW5jdGlvbiBlbHNlIGV4dGVybmFsIHdpdGggY2FzZSBkZWZhdWx0IHJlY29yZCB3aGlsZSBwcm90ZWN0ZWQgcHJvcGVydHkgJyArXG4gICAgJ3Byb2NlZHVyZSBwdWJsaXNoZWQgYW5kIGNkZWNsIGRvIHRocmVhZHZhciBmaWxlIGluIGlmIGVuZCB2aXJ0dWFsIHdyaXRlIGZhciBvdXQgYmVnaW4gJyArXG4gICAgJ3JlcGVhdCBuaWwgaW5pdGlhbGl6YXRpb24gb2JqZWN0IHVzZXMgcmVzb3VyY2VzdHJpbmcgY2xhc3MgcmVnaXN0ZXIgeG9yd3JpdGUgaW5saW5lIHN0YXRpYyc7XG4gIHZhciBDVVJMWV9DT01NRU5UID0gIHtcbiAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdmFyIFBBUkVOX0NPTU1FTlQgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgYmVnaW46ICdcXFxcKFxcXFwqJywgZW5kOiAnXFxcXCpcXFxcKScsXG4gICAgcmVsZXZhbmNlOiAxMFxuICB9O1xuICB2YXIgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcXCcnLCBlbmQ6ICdcXCcnLFxuICAgIGNvbnRhaW5zOiBbe2JlZ2luOiAnXFwnXFwnJ31dLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgQ0hBUl9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJywgYmVnaW46ICcoI1xcXFxkKykrJ1xuICB9O1xuICB2YXIgRlVOQ1RJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ1s6O10nLFxuICAgIGtleXdvcmRzOiAnZnVuY3Rpb24gY29uc3RydWN0b3J8MTAgZGVzdHJ1Y3RvcnwxMCBwcm9jZWR1cmV8MTAnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJywgYmVnaW46IGhsanMuSURFTlRfUkVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgIGtleXdvcmRzOiBERUxQSElfS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBbU1RSSU5HLCBDSEFSX1NUUklOR11cbiAgICAgIH0sXG4gICAgICBDVVJMWV9DT01NRU5ULCBQQVJFTl9DT01NRU5UXG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAga2V5d29yZHM6IERFTFBISV9LRVlXT1JEUyxcbiAgICBpbGxlZ2FsOiAnKFwifFxcXFwkW0ctWmctel18XFxcXC9cXFxcKnw8LyknLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBDVVJMWV9DT01NRU5ULCBQQVJFTl9DT01NRU5ULCBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBTVFJJTkcsIENIQVJfU1RSSU5HLFxuICAgICAgaGxqcy5OVU1CRVJfTU9ERSxcbiAgICAgIEZVTkNUSU9OLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luOiAnPVxcXFxiY2xhc3NcXFxcYicsIGVuZDogJ2VuZDsnLFxuICAgICAgICBrZXl3b3JkczogREVMUEhJX0NMQVNTX0tFWVdPUkRTLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFNUUklORywgQ0hBUl9TVFJJTkcsXG4gICAgICAgICAgQ1VSTFlfQ09NTUVOVCwgUEFSRU5fQ09NTUVOVCwgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIEZVTkNUSU9OXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NodW5rJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXEBcXFxcQCArXFxcXC1cXFxcZCssXFxcXGQrICtcXFxcK1xcXFxkKyxcXFxcZCsgK1xcXFxAXFxcXEAkJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2h1bmsnLFxuICAgICAgICBiZWdpbjogJ15cXFxcKlxcXFwqXFxcXCogK1xcXFxkKyxcXFxcZCsgK1xcXFwqXFxcXCpcXFxcKlxcXFwqJCcsXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NodW5rJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXC1cXFxcLVxcXFwtICtcXFxcZCssXFxcXGQrICtcXFxcLVxcXFwtXFxcXC1cXFxcLSQnLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdoZWFkZXInLFxuICAgICAgICBiZWdpbjogJ0luZGV4OiAnLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnaGVhZGVyJyxcbiAgICAgICAgYmVnaW46ICc9PT09PScsIGVuZDogJz09PT09JCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2hlYWRlcicsXG4gICAgICAgIGJlZ2luOiAnXlxcXFwtXFxcXC1cXFxcLScsIGVuZDogJyQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdoZWFkZXInLFxuICAgICAgICBiZWdpbjogJ15cXFxcKnszfSAnLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnaGVhZGVyJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXCtcXFxcK1xcXFwrJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2hlYWRlcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXCp7NX0nLCBlbmQ6ICdcXFxcKns1fSQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhZGRpdGlvbicsXG4gICAgICAgIGJlZ2luOiAnXlxcXFwrJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2RlbGV0aW9uJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXC0nLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXCEnLCBlbmQ6ICckJ1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG5cbiAgZnVuY3Rpb24gYWxsb3dzRGphbmdvU3ludGF4KG1vZGUsIHBhcmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICBwYXJlbnQgPT0gdW5kZWZpbmVkIHx8IC8vIGRlZmF1bHQgbW9kZVxuICAgICAgKCFtb2RlLmNsYXNzTmFtZSAmJiBwYXJlbnQuY2xhc3NOYW1lID09ICd0YWcnKSB8fCAvLyB0YWdfaW50ZXJuYWxcbiAgICAgIG1vZGUuY2xhc3NOYW1lID09ICd2YWx1ZScgLy8gdmFsdWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weShtb2RlLCBwYXJlbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG1vZGUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ2NvbnRhaW5zJykge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1vZGVba2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWlucyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IG1vZGUuY29udGFpbnMgJiYgaSA8IG1vZGUuY29udGFpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGFpbnMucHVzaChjb3B5KG1vZGUuY29udGFpbnNbaV0sIG1vZGUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd3NEamFuZ29TeW50YXgobW9kZSwgcGFyZW50KSkge1xuICAgICAgICBjb250YWlucyA9IERKQU5HT19DT05UQUlOUy5jb25jYXQoY29udGFpbnMpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5zLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQuY29udGFpbnMgPSBjb250YWlucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBGSUxURVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnZmlsdGVyJyxcbiAgICBiZWdpbjogJ1xcXFx8W0EtWmEtel0rXFxcXDo/JywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICBrZXl3b3JkczpcbiAgICAgICd0cnVuY2F0ZXdvcmRzIHJlbW92ZXRhZ3MgbGluZWJyZWFrc2JyIHllc25vIGdldF9kaWdpdCB0aW1lc2luY2UgcmFuZG9tIHN0cmlwdGFncyAnICtcbiAgICAgICdmaWxlc2l6ZWZvcm1hdCBlc2NhcGUgbGluZWJyZWFrcyBsZW5ndGhfaXMgbGp1c3Qgcmp1c3QgY3V0IHVybGl6ZSBmaXhfYW1wZXJzYW5kcyAnICtcbiAgICAgICd0aXRsZSBmbG9hdGZvcm1hdCBjYXBmaXJzdCBwcHJpbnQgZGl2aXNpYmxlYnkgYWRkIG1ha2VfbGlzdCB1bm9yZGVyZWRfbGlzdCB1cmxlbmNvZGUgJyArXG4gICAgICAndGltZXVudGlsIHVybGl6ZXRydW5jIHdvcmRjb3VudCBzdHJpbmdmb3JtYXQgbGluZW51bWJlcnMgc2xpY2UgZGF0ZSBkaWN0c29ydCAnICtcbiAgICAgICdkaWN0c29ydHJldmVyc2VkIGRlZmF1bHRfaWZfbm9uZSBwbHVyYWxpemUgbG93ZXIgam9pbiBjZW50ZXIgZGVmYXVsdCAnICtcbiAgICAgICd0cnVuY2F0ZXdvcmRzX2h0bWwgdXBwZXIgbGVuZ3RoIHBob25lMm51bWVyaWMgd29yZHdyYXAgdGltZSBhZGRzbGFzaGVzIHNsdWdpZnkgZmlyc3QgJyArXG4gICAgICAnZXNjYXBlanMgZm9yY2VfZXNjYXBlIGlyaWVuY29kZSBsYXN0IHNhZmUgc2FmZXNlcSB0cnVuY2F0ZWNoYXJzIGxvY2FsaXplIHVubG9jYWxpemUgJyArXG4gICAgICAnbG9jYWx0aW1lIHV0YyB0aW1lem9uZScsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtjbGFzc05hbWU6ICdhcmd1bWVudCcsIGJlZ2luOiAnXCInLCBlbmQ6ICdcIid9XG4gICAgXVxuICB9O1xuXG4gIHZhciBESkFOR09fQ09OVEFJTlMgPSBbXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAndGVtcGxhdGVfY29tbWVudCcsXG4gICAgICBiZWdpbjogJ3slXFxcXHMqY29tbWVudFxcXFxzKiV9JywgZW5kOiAneyVcXFxccyplbmRjb21tZW50XFxcXHMqJX0nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICd0ZW1wbGF0ZV9jb21tZW50JyxcbiAgICAgIGJlZ2luOiAneyMnLCBlbmQ6ICcjfSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3RlbXBsYXRlX3RhZycsXG4gICAgICBiZWdpbjogJ3slJywgZW5kOiAnJX0nLFxuICAgICAga2V5d29yZHM6XG4gICAgICAgICdjb21tZW50IGVuZGNvbW1lbnQgbG9hZCB0ZW1wbGF0ZXRhZyBpZmNoYW5nZWQgZW5kaWZjaGFuZ2VkIGlmIGVuZGlmIGZpcnN0b2YgZm9yICcgK1xuICAgICAgICAnZW5kZm9yIGluIGlmbm90ZXF1YWwgZW5kaWZub3RlcXVhbCB3aWR0aHJhdGlvIGV4dGVuZHMgaW5jbHVkZSBzcGFjZWxlc3MgJyArXG4gICAgICAgICdlbmRzcGFjZWxlc3MgcmVncm91cCBieSBhcyBpZmVxdWFsIGVuZGlmZXF1YWwgc3NpIG5vdyB3aXRoIGN5Y2xlIHVybCBmaWx0ZXIgJyArXG4gICAgICAgICdlbmRmaWx0ZXIgZGVidWcgYmxvY2sgZW5kYmxvY2sgZWxzZSBhdXRvZXNjYXBlIGVuZGF1dG9lc2NhcGUgY3NyZl90b2tlbiBlbXB0eSBlbGlmICcgK1xuICAgICAgICAnZW5kd2l0aCBzdGF0aWMgdHJhbnMgYmxvY2t0cmFucyBlbmRibG9ja3RyYW5zIGdldF9zdGF0aWNfcHJlZml4IGdldF9tZWRpYV9wcmVmaXggJyArXG4gICAgICAgICdwbHVyYWwgZ2V0X2N1cnJlbnRfbGFuZ3VhZ2UgbGFuZ3VhZ2UgZ2V0X2F2YWlsYWJsZV9sYW5ndWFnZXMgJyArXG4gICAgICAgICdnZXRfY3VycmVudF9sYW5ndWFnZV9iaWRpIGdldF9sYW5ndWFnZV9pbmZvIGdldF9sYW5ndWFnZV9pbmZvX2xpc3QgbG9jYWxpemUgJyArXG4gICAgICAgICdlbmRsb2NhbGl6ZSBsb2NhbHRpbWUgZW5kbG9jYWx0aW1lIHRpbWV6b25lIGVuZHRpbWV6b25lIGdldF9jdXJyZW50X3RpbWV6b25lJyxcbiAgICAgIGNvbnRhaW5zOiBbRklMVEVSXVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgYmVnaW46ICd7eycsIGVuZDogJ319JyxcbiAgICAgIGNvbnRhaW5zOiBbRklMVEVSXVxuICAgIH1cbiAgXTtcblxuICB2YXIgcmVzdWx0ID0gY29weShobGpzLkxBTkdVQUdFUy54bWwpO1xuICByZXN1bHQuY2FzZV9pbnNlbnNpdGl2ZSA9IHRydWU7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAga2V5d29yZHM6IHtcbiAgICAgIGZsb3c6ICdpZiBlbHNlIGdvdG8gZm9yIGluIGRvIGNhbGwgZXhpdCBub3QgZXhpc3QgZXJyb3JsZXZlbCBkZWZpbmVkIGVxdSBuZXEgbHNzIGxlcSBndHIgZ2VxJyxcbiAgICAgIGtleXdvcmQ6ICdzaGlmdCBjZCBkaXIgZWNobyBzZXRsb2NhbCBlbmRsb2NhbCBzZXQgcGF1c2UgY29weScsXG4gICAgICBzdHJlYW06ICdwcm4gbnVsIGxwdDMgbHB0MiBscHQxIGNvbiBjb200IGNvbTMgY29tMiBjb20xIGF1eCcsXG4gICAgICB3aW51dGlsczogJ3BpbmcgbmV0IGlwY29uZmlnIHRhc2traWxsIHhjb3B5IHJlbiBkZWwnXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdlbnZ2YXInLCBiZWdpbjogJyUlW14gXSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2VudnZhcicsIGJlZ2luOiAnJVteIF0rPyUnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdlbnZ2YXInLCBiZWdpbjogJyFbXiBdKz8hJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46ICdcXFxcYlxcXFxkKycsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiAnQD9yZW0nLCBlbmQ6ICckJ1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHJldHVybiB7XG4gICAga2V5d29yZHM6IHtcbiAgICAgIHNwZWNpYWxfZnVuY3Rpb25zOlxuICAgICAgICAnc3Bhd24gc3Bhd25fbGluayBzZWxmJyxcbiAgICAgIHJlc2VydmVkOlxuICAgICAgICAnYWZ0ZXIgYW5kIGFuZGFsc298MTAgYmFuZCBiZWdpbiBibm90IGJvciBic2wgYnNyIGJ4b3IgY2FzZSBjYXRjaCBjb25kIGRpdiBlbmQgZnVuIGlmICcgK1xuICAgICAgICAnbGV0IG5vdCBvZiBvciBvcmVsc2V8MTAgcXVlcnkgcmVjZWl2ZSByZW0gdHJ5IHdoZW4geG9yJ1xuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJvbXB0JywgYmVnaW46ICdeWzAtOV0rPiAnLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICclJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXGIoXFxcXGQrI1thLWZBLUYwLTldK3xcXFxcZCsoXFxcXC5cXFxcZCspPyhbZUVdWy0rXT9cXFxcZCspPyknLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb25zdGFudCcsIGJlZ2luOiAnXFxcXD8oOjopPyhbQS1aXVxcXFx3Kig6Oik/KSsnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhcnJvdycsIGJlZ2luOiAnLT4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdvaycsIGJlZ2luOiAnb2snXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdleGNsYW1hdGlvbl9tYXJrJywgYmVnaW46ICchJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb25fb3JfYXRvbScsXG4gICAgICAgIGJlZ2luOiAnKFxcXFxiW2EtelxcJ11bYS16QS1aMC05X1xcJ10qOlthLXpcXCddW2EtekEtWjAtOV9cXCddKil8KFxcXFxiW2EtelxcJ11bYS16QS1aMC05X1xcJ10qKScsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogJ1tBLVpdW2EtekEtWjAtOV9cXCddKicsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBCQVNJQ19BVE9NX1JFID0gJ1thLXpcXCddW2EtekEtWjAtOV9cXCddKic7XG4gIHZhciBGVU5DVElPTl9OQU1FX1JFID0gJygnICsgQkFTSUNfQVRPTV9SRSArICc6JyArIEJBU0lDX0FUT01fUkUgKyAnfCcgKyBCQVNJQ19BVE9NX1JFICsgJyknO1xuICB2YXIgRVJMQU5HX1JFU0VSVkVEID0ge1xuICAgIGtleXdvcmQ6XG4gICAgICAnYWZ0ZXIgYW5kIGFuZGFsc298MTAgYmFuZCBiZWdpbiBibm90IGJvciBic2wgYnpyIGJ4b3IgY2FzZSBjYXRjaCBjb25kIGRpdiBlbmQgZnVuIGxldCAnICtcbiAgICAgICdub3Qgb2Ygb3JlbHNlfDEwIHF1ZXJ5IHJlY2VpdmUgcmVtIHRyeSB3aGVuIHhvcicsXG4gICAgbGl0ZXJhbDpcbiAgICAgICdmYWxzZSB0cnVlJ1xuICB9O1xuXG4gIHZhciBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgIGJlZ2luOiAnJScsIGVuZDogJyQnLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46ICdcXFxcYihcXFxcZCsjW2EtZkEtRjAtOV0rfFxcXFxkKyhcXFxcLlxcXFxkKyk/KFtlRV1bLStdP1xcXFxkKyk/KScsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBOQU1FRF9GVU4gPSB7XG4gICAgYmVnaW46ICdmdW5cXFxccysnICsgQkFTSUNfQVRPTV9SRSArICcvXFxcXGQrJ1xuICB9O1xuICB2YXIgRlVOQ1RJT05fQ0FMTCA9IHtcbiAgICBiZWdpbjogRlVOQ1RJT05fTkFNRV9SRSArICdcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb25fbmFtZScsIGJlZ2luOiBGVU5DVElPTl9OQU1FX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgICAgICByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAvLyBcImNvbnRhaW5zXCIgZGVmaW5lZCBsYXRlclxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgdmFyIFRVUExFID0ge1xuICAgIGNsYXNzTmFtZTogJ3R1cGxlJyxcbiAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICByZWxldmFuY2U6IDBcbiAgICAvLyBcImNvbnRhaW5zXCIgZGVmaW5lZCBsYXRlclxuICB9O1xuICB2YXIgVkFSMSA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICdcXFxcYl8oW0EtWl1bQS1aYS16MC05X10qKT8nLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgVkFSMiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICdbQS1aXVthLXpBLVowLTlfXSonLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgUkVDT1JEX0FDQ0VTUyA9IHtcbiAgICBiZWdpbjogJyMnLCBlbmQ6ICd9JyxcbiAgICBpbGxlZ2FsOiAnLicsXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3JlY29yZF9uYW1lJyxcbiAgICAgICAgYmVnaW46ICcjJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ3snLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgIC8vIFwiY29udGFpbnNcIiBkZWZpbmVkIGxhdGVyXG4gICAgICB9XG4gICAgXVxuICB9O1xuXG4gIHZhciBCTE9DS19TVEFURU1FTlRTID0ge1xuICAgIGtleXdvcmRzOiBFUkxBTkdfUkVTRVJWRUQsXG4gICAgYmVnaW46ICcoZnVufHJlY2VpdmV8aWZ8dHJ5fGNhc2UpJywgZW5kOiAnZW5kJ1xuICB9O1xuICBCTE9DS19TVEFURU1FTlRTLmNvbnRhaW5zID0gW1xuICAgIENPTU1FTlQsXG4gICAgTkFNRURfRlVOLFxuICAgIGhsanMuaW5oZXJpdChobGpzLkFQT1NfU1RSSU5HX01PREUsIHtjbGFzc05hbWU6ICcnfSksXG4gICAgQkxPQ0tfU1RBVEVNRU5UUyxcbiAgICBGVU5DVElPTl9DQUxMLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgTlVNQkVSLFxuICAgIFRVUExFLFxuICAgIFZBUjEsIFZBUjIsXG4gICAgUkVDT1JEX0FDQ0VTU1xuICBdO1xuXG4gIHZhciBCQVNJQ19NT0RFUyA9IFtcbiAgICBDT01NRU5ULFxuICAgIE5BTUVEX0ZVTixcbiAgICBCTE9DS19TVEFURU1FTlRTLFxuICAgIEZVTkNUSU9OX0NBTEwsXG4gICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICBOVU1CRVIsXG4gICAgVFVQTEUsXG4gICAgVkFSMSwgVkFSMixcbiAgICBSRUNPUkRfQUNDRVNTXG4gIF07XG4gIEZVTkNUSU9OX0NBTEwuY29udGFpbnNbMV0uY29udGFpbnMgPSBCQVNJQ19NT0RFUztcbiAgVFVQTEUuY29udGFpbnMgPSBCQVNJQ19NT0RFUztcbiAgUkVDT1JEX0FDQ0VTUy5jb250YWluc1sxXS5jb250YWlucyA9IEJBU0lDX01PREVTO1xuXG4gIHZhciBQQVJBTVMgPSB7XG4gICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgIGNvbnRhaW5zOiBCQVNJQ19NT0RFU1xuICB9O1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiBFUkxBTkdfUkVTRVJWRUQsXG4gICAgaWxsZWdhbDogJyg8L3xcXFxcKj18XFxcXCs9fC09fC89fC9cXFxcKnxcXFxcKi98XFxcXChcXFxcKnxcXFxcKlxcXFwpKScsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbjogJ14nICsgQkFTSUNfQVRPTV9SRSArICdcXFxccypcXFxcKCcsIGVuZDogJy0+JyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGlsbGVnYWw6ICdcXFxcKHwjfC8vfC9cXFxcKnxcXFxcXFxcXHw6JyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBQQVJBTVMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogQkFTSUNfQVRPTV9SRVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnO3xcXFxcLicsXG4gICAgICAgICAga2V5d29yZHM6IEVSTEFOR19SRVNFUlZFRCxcbiAgICAgICAgICBjb250YWluczogQkFTSUNfTU9ERVNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENPTU1FTlQsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BwJyxcbiAgICAgICAgYmVnaW46ICdeLScsIGVuZDogJ1xcXFwuJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgbGV4ZW1zOiAnLScgKyBobGpzLklERU5UX1JFLFxuICAgICAgICBrZXl3b3JkczpcbiAgICAgICAgICAnLW1vZHVsZSAtcmVjb3JkIC11bmRlZiAtZXhwb3J0IC1pZmRlZiAtaWZuZGVmIC1hdXRob3IgLWNvcHlyaWdodCAtZG9jIC12c24gJyArXG4gICAgICAgICAgJy1pbXBvcnQgLWluY2x1ZGUgLWluY2x1ZGVfbGliIC1jb21waWxlIC1kZWZpbmUgLWVsc2UgLWVuZGlmIC1maWxlIC1iZWhhdmlvdXIgJyArXG4gICAgICAgICAgJy1iZWhhdmlvcicsXG4gICAgICAgIGNvbnRhaW5zOiBbUEFSQU1TXVxuICAgICAgfSxcbiAgICAgIE5VTUJFUixcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBSRUNPUkRfQUNDRVNTLFxuICAgICAgVkFSMSwgVkFSMixcbiAgICAgIFRVUExFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3Jkczoge1xuICAgICAga2V5d29yZDpcbiAgICAgICAgJ2F0b21pY191aW50IGF0dHJpYnV0ZSBib29sIGJyZWFrIGJ2ZWMyIGJ2ZWMzIGJ2ZWM0IGNhc2UgY2VudHJvaWQgY29oZXJlbnQgY29uc3QgY29udGludWUgZGVmYXVsdCAnICtcbiAgICAgICAgJ2Rpc2NhcmQgZG1hdDIgZG1hdDJ4MiBkbWF0MngzIGRtYXQyeDQgZG1hdDMgZG1hdDN4MiBkbWF0M3gzIGRtYXQzeDQgZG1hdDQgZG1hdDR4MiBkbWF0NHgzICcgK1xuICAgICAgICAnZG1hdDR4NCBkbyBkb3VibGUgZHZlYzIgZHZlYzMgZHZlYzQgZWxzZSBmbGF0IGZsb2F0IGZvciBoaWdocCBpZiBpaW1hZ2UxRCBpaW1hZ2UxREFycmF5ICcgK1xuICAgICAgICAnaWltYWdlMkQgaWltYWdlMkRBcnJheSBpaW1hZ2UyRE1TIGlpbWFnZTJETVNBcnJheSBpaW1hZ2UyRFJlY3QgaWltYWdlM0QgaWltYWdlQnVmZmVyIGlpbWFnZUN1YmUgJyArXG4gICAgICAgICdpaW1hZ2VDdWJlQXJyYXkgaW1hZ2UxRCBpbWFnZTFEQXJyYXkgaW1hZ2UyRCBpbWFnZTJEQXJyYXkgaW1hZ2UyRE1TIGltYWdlMkRNU0FycmF5IGltYWdlMkRSZWN0ICcgK1xuICAgICAgICAnaW1hZ2UzRCBpbWFnZUJ1ZmZlciBpbWFnZUN1YmUgaW1hZ2VDdWJlQXJyYXkgaW4gaW5vdXQgaW50IGludmFyaWFudCBpc2FtcGxlcjFEIGlzYW1wbGVyMURBcnJheSAnICtcbiAgICAgICAgJ2lzYW1wbGVyMkQgaXNhbXBsZXIyREFycmF5IGlzYW1wbGVyMkRNUyBpc2FtcGxlcjJETVNBcnJheSBpc2FtcGxlcjJEUmVjdCBpc2FtcGxlcjNEIGlzYW1wbGVyQnVmZmVyICcgK1xuICAgICAgICAnaXNhbXBsZXJDdWJlIGlzYW1wbGVyQ3ViZUFycmF5IGl2ZWMyIGl2ZWMzIGl2ZWM0IGxheW91dCBsb3dwIG1hdDIgbWF0MngyIG1hdDJ4MyBtYXQyeDQgbWF0MyBtYXQzeDIgJyArXG4gICAgICAgICdtYXQzeDMgbWF0M3g0IG1hdDQgbWF0NHgyIG1hdDR4MyBtYXQ0eDQgbWVkaXVtcCBub3BlcnNwZWN0aXZlIG91dCBwYXRjaCBwcmVjaXNpb24gcmVhZG9ubHkgcmVzdHJpY3QgJyArXG4gICAgICAgICdyZXR1cm4gc2FtcGxlIHNhbXBsZXIxRCBzYW1wbGVyMURBcnJheSBzYW1wbGVyMURBcnJheVNoYWRvdyBzYW1wbGVyMURTaGFkb3cgc2FtcGxlcjJEIHNhbXBsZXIyREFycmF5ICcgK1xuICAgICAgICAnc2FtcGxlcjJEQXJyYXlTaGFkb3cgc2FtcGxlcjJETVMgc2FtcGxlcjJETVNBcnJheSBzYW1wbGVyMkRSZWN0IHNhbXBsZXIyRFJlY3RTaGFkb3cgc2FtcGxlcjJEU2hhZG93ICcgK1xuICAgICAgICAnc2FtcGxlcjNEIHNhbXBsZXJCdWZmZXIgc2FtcGxlckN1YmUgc2FtcGxlckN1YmVBcnJheSBzYW1wbGVyQ3ViZUFycmF5U2hhZG93IHNhbXBsZXJDdWJlU2hhZG93IHNtb290aCAnICtcbiAgICAgICAgJ3N0cnVjdCBzdWJyb3V0aW5lIHN3aXRjaCB1aW1hZ2UxRCB1aW1hZ2UxREFycmF5IHVpbWFnZTJEIHVpbWFnZTJEQXJyYXkgdWltYWdlMkRNUyB1aW1hZ2UyRE1TQXJyYXkgJyArXG4gICAgICAgICd1aW1hZ2UyRFJlY3QgdWltYWdlM0QgdWltYWdlQnVmZmVyIHVpbWFnZUN1YmUgdWltYWdlQ3ViZUFycmF5IHVpbnQgdW5pZm9ybSB1c2FtcGxlcjFEIHVzYW1wbGVyMURBcnJheSAnICtcbiAgICAgICAgJ3VzYW1wbGVyMkQgdXNhbXBsZXIyREFycmF5IHVzYW1wbGVyMkRNUyB1c2FtcGxlcjJETVNBcnJheSB1c2FtcGxlcjJEUmVjdCB1c2FtcGxlcjNEIHVzYW1wbGVyQnVmZmVyICcgK1xuICAgICAgICAndXNhbXBsZXJDdWJlIHVzYW1wbGVyQ3ViZUFycmF5IHV2ZWMyIHV2ZWMzIHV2ZWM0IHZhcnlpbmcgdmVjMiB2ZWMzIHZlYzQgdm9pZCB2b2xhdGlsZSB3aGlsZSB3cml0ZW9ubHknLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgICdnbF9CYWNrQ29sb3IgZ2xfQmFja0xpZ2h0TW9kZWxQcm9kdWN0IGdsX0JhY2tMaWdodFByb2R1Y3QgZ2xfQmFja01hdGVyaWFsICcgK1xuICAgICAgICAnZ2xfQmFja1NlY29uZGFyeUNvbG9yIGdsX0NsaXBEaXN0YW5jZSBnbF9DbGlwUGxhbmUgZ2xfQ2xpcFZlcnRleCBnbF9Db2xvciAnICtcbiAgICAgICAgJ2dsX0RlcHRoUmFuZ2UgZ2xfRXllUGxhbmVRIGdsX0V5ZVBsYW5lUiBnbF9FeWVQbGFuZVMgZ2xfRXllUGxhbmVUIGdsX0ZvZyBnbF9Gb2dDb29yZCAnICtcbiAgICAgICAgJ2dsX0ZvZ0ZyYWdDb29yZCBnbF9GcmFnQ29sb3IgZ2xfRnJhZ0Nvb3JkIGdsX0ZyYWdEYXRhIGdsX0ZyYWdEZXB0aCBnbF9Gcm9udENvbG9yICcgK1xuICAgICAgICAnZ2xfRnJvbnRGYWNpbmcgZ2xfRnJvbnRMaWdodE1vZGVsUHJvZHVjdCBnbF9Gcm9udExpZ2h0UHJvZHVjdCBnbF9Gcm9udE1hdGVyaWFsICcgK1xuICAgICAgICAnZ2xfRnJvbnRTZWNvbmRhcnlDb2xvciBnbF9JbnN0YW5jZUlEIGdsX0ludm9jYXRpb25JRCBnbF9MYXllciBnbF9MaWdodE1vZGVsICcgK1xuICAgICAgICAnZ2xfTGlnaHRTb3VyY2UgZ2xfTWF4QXRvbWljQ291bnRlckJpbmRpbmdzIGdsX01heEF0b21pY0NvdW50ZXJCdWZmZXJTaXplICcgK1xuICAgICAgICAnZ2xfTWF4Q2xpcERpc3RhbmNlcyBnbF9NYXhDbGlwUGxhbmVzIGdsX01heENvbWJpbmVkQXRvbWljQ291bnRlckJ1ZmZlcnMgJyArXG4gICAgICAgICdnbF9NYXhDb21iaW5lZEF0b21pY0NvdW50ZXJzIGdsX01heENvbWJpbmVkSW1hZ2VVbmlmb3JtcyBnbF9NYXhDb21iaW5lZEltYWdlVW5pdHNBbmRGcmFnbWVudE91dHB1dHMgJyArXG4gICAgICAgICdnbF9NYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzIGdsX01heERyYXdCdWZmZXJzIGdsX01heEZyYWdtZW50QXRvbWljQ291bnRlckJ1ZmZlcnMgJyArXG4gICAgICAgICdnbF9NYXhGcmFnbWVudEF0b21pY0NvdW50ZXJzIGdsX01heEZyYWdtZW50SW1hZ2VVbmlmb3JtcyBnbF9NYXhGcmFnbWVudElucHV0Q29tcG9uZW50cyAnICtcbiAgICAgICAgJ2dsX01heEZyYWdtZW50VW5pZm9ybUNvbXBvbmVudHMgZ2xfTWF4RnJhZ21lbnRVbmlmb3JtVmVjdG9ycyBnbF9NYXhHZW9tZXRyeUF0b21pY0NvdW50ZXJCdWZmZXJzICcgK1xuICAgICAgICAnZ2xfTWF4R2VvbWV0cnlBdG9taWNDb3VudGVycyBnbF9NYXhHZW9tZXRyeUltYWdlVW5pZm9ybXMgZ2xfTWF4R2VvbWV0cnlJbnB1dENvbXBvbmVudHMgJyArXG4gICAgICAgICdnbF9NYXhHZW9tZXRyeU91dHB1dENvbXBvbmVudHMgZ2xfTWF4R2VvbWV0cnlPdXRwdXRWZXJ0aWNlcyBnbF9NYXhHZW9tZXRyeVRleHR1cmVJbWFnZVVuaXRzICcgK1xuICAgICAgICAnZ2xfTWF4R2VvbWV0cnlUb3RhbE91dHB1dENvbXBvbmVudHMgZ2xfTWF4R2VvbWV0cnlVbmlmb3JtQ29tcG9uZW50cyBnbF9NYXhHZW9tZXRyeVZhcnlpbmdDb21wb25lbnRzICcgK1xuICAgICAgICAnZ2xfTWF4SW1hZ2VTYW1wbGVzIGdsX01heEltYWdlVW5pdHMgZ2xfTWF4TGlnaHRzIGdsX01heFBhdGNoVmVydGljZXMgZ2xfTWF4UHJvZ3JhbVRleGVsT2Zmc2V0ICcgK1xuICAgICAgICAnZ2xfTWF4VGVzc0NvbnRyb2xBdG9taWNDb3VudGVyQnVmZmVycyBnbF9NYXhUZXNzQ29udHJvbEF0b21pY0NvdW50ZXJzIGdsX01heFRlc3NDb250cm9sSW1hZ2VVbmlmb3JtcyAnICtcbiAgICAgICAgJ2dsX01heFRlc3NDb250cm9sSW5wdXRDb21wb25lbnRzIGdsX01heFRlc3NDb250cm9sT3V0cHV0Q29tcG9uZW50cyBnbF9NYXhUZXNzQ29udHJvbFRleHR1cmVJbWFnZVVuaXRzICcgK1xuICAgICAgICAnZ2xfTWF4VGVzc0NvbnRyb2xUb3RhbE91dHB1dENvbXBvbmVudHMgZ2xfTWF4VGVzc0NvbnRyb2xVbmlmb3JtQ29tcG9uZW50cyAnICtcbiAgICAgICAgJ2dsX01heFRlc3NFdmFsdWF0aW9uQXRvbWljQ291bnRlckJ1ZmZlcnMgZ2xfTWF4VGVzc0V2YWx1YXRpb25BdG9taWNDb3VudGVycyAnICtcbiAgICAgICAgJ2dsX01heFRlc3NFdmFsdWF0aW9uSW1hZ2VVbmlmb3JtcyBnbF9NYXhUZXNzRXZhbHVhdGlvbklucHV0Q29tcG9uZW50cyBnbF9NYXhUZXNzRXZhbHVhdGlvbk91dHB1dENvbXBvbmVudHMgJyArXG4gICAgICAgICdnbF9NYXhUZXNzRXZhbHVhdGlvblRleHR1cmVJbWFnZVVuaXRzIGdsX01heFRlc3NFdmFsdWF0aW9uVW5pZm9ybUNvbXBvbmVudHMgJyArXG4gICAgICAgICdnbF9NYXhUZXNzR2VuTGV2ZWwgZ2xfTWF4VGVzc1BhdGNoQ29tcG9uZW50cyBnbF9NYXhUZXh0dXJlQ29vcmRzIGdsX01heFRleHR1cmVJbWFnZVVuaXRzICcgK1xuICAgICAgICAnZ2xfTWF4VGV4dHVyZVVuaXRzIGdsX01heFZhcnlpbmdDb21wb25lbnRzIGdsX01heFZhcnlpbmdGbG9hdHMgZ2xfTWF4VmFyeWluZ1ZlY3RvcnMgJyArXG4gICAgICAgICdnbF9NYXhWZXJ0ZXhBdG9taWNDb3VudGVyQnVmZmVycyBnbF9NYXhWZXJ0ZXhBdG9taWNDb3VudGVycyBnbF9NYXhWZXJ0ZXhBdHRyaWJzICcgK1xuICAgICAgICAnZ2xfTWF4VmVydGV4SW1hZ2VVbmlmb3JtcyBnbF9NYXhWZXJ0ZXhPdXRwdXRDb21wb25lbnRzIGdsX01heFZlcnRleFRleHR1cmVJbWFnZVVuaXRzICcgK1xuICAgICAgICAnZ2xfTWF4VmVydGV4VW5pZm9ybUNvbXBvbmVudHMgZ2xfTWF4VmVydGV4VW5pZm9ybVZlY3RvcnMgZ2xfTWF4Vmlld3BvcnRzIGdsX01pblByb2dyYW1UZXhlbE9mZnNldCcrXG4gICAgICAgICdnbF9Nb2RlbFZpZXdNYXRyaXggZ2xfTW9kZWxWaWV3TWF0cml4SW52ZXJzZSBnbF9Nb2RlbFZpZXdNYXRyaXhJbnZlcnNlVHJhbnNwb3NlICcgK1xuICAgICAgICAnZ2xfTW9kZWxWaWV3TWF0cml4VHJhbnNwb3NlIGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeEludmVyc2UgJyArXG4gICAgICAgICdnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4VHJhbnNwb3NlICcgK1xuICAgICAgICAnZ2xfTXVsdGlUZXhDb29yZDAgZ2xfTXVsdGlUZXhDb29yZDEgZ2xfTXVsdGlUZXhDb29yZDIgZ2xfTXVsdGlUZXhDb29yZDMgZ2xfTXVsdGlUZXhDb29yZDQgJyArXG4gICAgICAgICdnbF9NdWx0aVRleENvb3JkNSBnbF9NdWx0aVRleENvb3JkNiBnbF9NdWx0aVRleENvb3JkNyBnbF9Ob3JtYWwgZ2xfTm9ybWFsTWF0cml4ICcgK1xuICAgICAgICAnZ2xfTm9ybWFsU2NhbGUgZ2xfT2JqZWN0UGxhbmVRIGdsX09iamVjdFBsYW5lUiBnbF9PYmplY3RQbGFuZVMgZ2xfT2JqZWN0UGxhbmVUIGdsX1BhdGNoVmVydGljZXNJbiAnICtcbiAgICAgICAgJ2dsX1BlclZlcnRleCBnbF9Qb2ludCBnbF9Qb2ludENvb3JkIGdsX1BvaW50U2l6ZSBnbF9Qb3NpdGlvbiBnbF9QcmltaXRpdmVJRCBnbF9QcmltaXRpdmVJREluICcgK1xuICAgICAgICAnZ2xfUHJvamVjdGlvbk1hdHJpeCBnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZSBnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSAnICtcbiAgICAgICAgJ2dsX1Byb2plY3Rpb25NYXRyaXhUcmFuc3Bvc2UgZ2xfU2FtcGxlSUQgZ2xfU2FtcGxlTWFzayBnbF9TYW1wbGVNYXNrSW4gZ2xfU2FtcGxlUG9zaXRpb24gJyArXG4gICAgICAgICdnbF9TZWNvbmRhcnlDb2xvciBnbF9UZXNzQ29vcmQgZ2xfVGVzc0xldmVsSW5uZXIgZ2xfVGVzc0xldmVsT3V0ZXIgZ2xfVGV4Q29vcmQgZ2xfVGV4dHVyZUVudkNvbG9yICcgK1xuICAgICAgICAnZ2xfVGV4dHVyZU1hdHJpeEludmVyc2VUcmFuc3Bvc2UgZ2xfVGV4dHVyZU1hdHJpeFRyYW5zcG9zZSBnbF9WZXJ0ZXggZ2xfVmVydGV4SUQgJyArXG4gICAgICAgICdnbF9WaWV3cG9ydEluZGV4IGdsX2luIGdsX291dCBFbWl0U3RyZWFtVmVydGV4IEVtaXRWZXJ0ZXggRW5kUHJpbWl0aXZlIEVuZFN0cmVhbVByaW1pdGl2ZSAnICtcbiAgICAgICAgJ2FicyBhY29zIGFjb3NoIGFsbCBhbnkgYXNpbiBhc2luaCBhdGFuIGF0YW5oIGF0b21pY0NvdW50ZXIgYXRvbWljQ291bnRlckRlY3JlbWVudCAnICtcbiAgICAgICAgJ2F0b21pY0NvdW50ZXJJbmNyZW1lbnQgYmFycmllciBiaXRDb3VudCBiaXRmaWVsZEV4dHJhY3QgYml0ZmllbGRJbnNlcnQgYml0ZmllbGRSZXZlcnNlICcgK1xuICAgICAgICAnY2VpbCBjbGFtcCBjb3MgY29zaCBjcm9zcyBkRmR4IGRGZHkgZGVncmVlcyBkZXRlcm1pbmFudCBkaXN0YW5jZSBkb3QgZXF1YWwgZXhwIGV4cDIgZmFjZWZvcndhcmQgJyArXG4gICAgICAgICdmaW5kTFNCIGZpbmRNU0IgZmxvYXRCaXRzVG9JbnQgZmxvYXRCaXRzVG9VaW50IGZsb29yIGZtYSBmcmFjdCBmcmV4cCBmdHJhbnNmb3JtIGZ3aWR0aCBncmVhdGVyVGhhbiAnICtcbiAgICAgICAgJ2dyZWF0ZXJUaGFuRXF1YWwgaW1hZ2VBdG9taWNBZGQgaW1hZ2VBdG9taWNBbmQgaW1hZ2VBdG9taWNDb21wU3dhcCBpbWFnZUF0b21pY0V4Y2hhbmdlICcgK1xuICAgICAgICAnaW1hZ2VBdG9taWNNYXggaW1hZ2VBdG9taWNNaW4gaW1hZ2VBdG9taWNPciBpbWFnZUF0b21pY1hvciBpbWFnZUxvYWQgaW1hZ2VTdG9yZSBpbXVsRXh0ZW5kZWQgJyArXG4gICAgICAgICdpbnRCaXRzVG9GbG9hdCBpbnRlcnBvbGF0ZUF0Q2VudHJvaWQgaW50ZXJwb2xhdGVBdE9mZnNldCBpbnRlcnBvbGF0ZUF0U2FtcGxlIGludmVyc2UgaW52ZXJzZXNxcnQgJyArXG4gICAgICAgICdpc2luZiBpc25hbiBsZGV4cCBsZW5ndGggbGVzc1RoYW4gbGVzc1RoYW5FcXVhbCBsb2cgbG9nMiBtYXRyaXhDb21wTXVsdCBtYXggbWVtb3J5QmFycmllciAnICtcbiAgICAgICAgJ21pbiBtaXggbW9kIG1vZGYgbm9pc2UxIG5vaXNlMiBub2lzZTMgbm9pc2U0IG5vcm1hbGl6ZSBub3Qgbm90RXF1YWwgb3V0ZXJQcm9kdWN0IHBhY2tEb3VibGUyeDMyICcgK1xuICAgICAgICAncGFja0hhbGYyeDE2IHBhY2tTbm9ybTJ4MTYgcGFja1Nub3JtNHg4IHBhY2tVbm9ybTJ4MTYgcGFja1Vub3JtNHg4IHBvdyByYWRpYW5zIHJlZmxlY3QgcmVmcmFjdCAnICtcbiAgICAgICAgJ3JvdW5kIHJvdW5kRXZlbiBzaGFkb3cxRCBzaGFkb3cxRExvZCBzaGFkb3cxRFByb2ogc2hhZG93MURQcm9qTG9kIHNoYWRvdzJEIHNoYWRvdzJETG9kIHNoYWRvdzJEUHJvaiAnICtcbiAgICAgICAgJ3NoYWRvdzJEUHJvakxvZCBzaWduIHNpbiBzaW5oIHNtb290aHN0ZXAgc3FydCBzdGVwIHRhbiB0YW5oIHRleGVsRmV0Y2ggdGV4ZWxGZXRjaE9mZnNldCB0ZXh0dXJlICcgK1xuICAgICAgICAndGV4dHVyZTFEIHRleHR1cmUxRExvZCB0ZXh0dXJlMURQcm9qIHRleHR1cmUxRFByb2pMb2QgdGV4dHVyZTJEIHRleHR1cmUyRExvZCB0ZXh0dXJlMkRQcm9qICcgK1xuICAgICAgICAndGV4dHVyZTJEUHJvakxvZCB0ZXh0dXJlM0QgdGV4dHVyZTNETG9kIHRleHR1cmUzRFByb2ogdGV4dHVyZTNEUHJvakxvZCB0ZXh0dXJlQ3ViZSB0ZXh0dXJlQ3ViZUxvZCAnICtcbiAgICAgICAgJ3RleHR1cmVHYXRoZXIgdGV4dHVyZUdhdGhlck9mZnNldCB0ZXh0dXJlR2F0aGVyT2Zmc2V0cyB0ZXh0dXJlR3JhZCB0ZXh0dXJlR3JhZE9mZnNldCB0ZXh0dXJlTG9kICcgK1xuICAgICAgICAndGV4dHVyZUxvZE9mZnNldCB0ZXh0dXJlT2Zmc2V0IHRleHR1cmVQcm9qIHRleHR1cmVQcm9qR3JhZCB0ZXh0dXJlUHJvakdyYWRPZmZzZXQgdGV4dHVyZVByb2pMb2QgJyArXG4gICAgICAgICd0ZXh0dXJlUHJvakxvZE9mZnNldCB0ZXh0dXJlUHJvak9mZnNldCB0ZXh0dXJlUXVlcnlMb2QgdGV4dHVyZVNpemUgdHJhbnNwb3NlIHRydW5jIHVhZGRDYXJyeSAnICtcbiAgICAgICAgJ3VpbnRCaXRzVG9GbG9hdCB1bXVsRXh0ZW5kZWQgdW5wYWNrRG91YmxlMngzMiB1bnBhY2tIYWxmMngxNiB1bnBhY2tTbm9ybTJ4MTYgdW5wYWNrU25vcm00eDggJyArXG4gICAgICAgICd1bnBhY2tVbm9ybTJ4MTYgdW5wYWNrVW5vcm00eDggdXN1YkJvcnJvdyBnbF9UZXh0dXJlTWF0cml4IGdsX1RleHR1cmVNYXRyaXhJbnZlcnNlJyxcbiAgICAgIGxpdGVyYWw6ICd0cnVlIGZhbHNlJ1xuICAgIH0sXG4gICAgaWxsZWdhbDogJ1wiJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICcjJywgZW5kOiAnJCdcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgR09fS0VZV09SRFMgPSB7XG4gICAga2V5d29yZDpcbiAgICAgICdicmVhayBkZWZhdWx0IGZ1bmMgaW50ZXJmYWNlIHNlbGVjdCBjYXNlIG1hcCBzdHJ1Y3QgY2hhbiBlbHNlIGdvdG8gcGFja2FnZSBzd2l0Y2ggJyArXG4gICAgICAnY29uc3QgZmFsbHRocm91Z2ggaWYgcmFuZ2UgdHlwZSBjb250aW51ZSBmb3IgaW1wb3J0IHJldHVybiB2YXIgZ28gZGVmZXInLFxuICAgIGNvbnN0YW50OlxuICAgICAgICd0cnVlIGZhbHNlIGlvdGEgbmlsJyxcbiAgICB0eXBlbmFtZTpcbiAgICAgICdib29sIGJ5dGUgY29tcGxleDY0IGNvbXBsZXgxMjggZmxvYXQzMiBmbG9hdDY0IGludDggaW50MTYgaW50MzIgaW50NjQgc3RyaW5nIHVpbnQ4ICcgK1xuICAgICAgJ3VpbnQxNiB1aW50MzIgdWludDY0IGludCB1aW50IHVpbnRwdHIgcnVuZScsXG4gICAgYnVpbHRfaW46XG4gICAgICAnYXBwZW5kIGNhcCBjbG9zZSBjb21wbGV4IGNvcHkgaW1hZyBsZW4gbWFrZSBuZXcgcGFuaWMgcHJpbnQgcHJpbnRsbiByZWFsIHJlY292ZXIgZGVsZXRlJ1xuICB9O1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiBHT19LRVlXT1JEUyxcbiAgICBpbGxlZ2FsOiAnPC8nLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgYmVnaW46ICdcXCcnLCBlbmQ6ICdbXlxcXFxcXFxcXVxcJycsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgYmVnaW46ICdgJywgZW5kOiAnYCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgIGJlZ2luOiAnW15hLXpBLVpfMC05XShcXFxcLXxcXFxcKyk/XFxcXGQrKFxcXFwuXFxcXGQrfFxcXFwvXFxcXGQrKT8oKGR8ZXxmfGx8cykoXFxcXCt8XFxcXC0pP1xcXFxkKyk/JyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFRZUEUgPSB7XG4gICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgYmVnaW46ICdcXFxcYltBLVpdW1xcXFx3XFwnXSonLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgQ09OVEFJTkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ2NvbnRhaW5lcicsXG4gICAgYmVnaW46ICdcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICBjb250YWluczogW1xuICAgICAge2NsYXNzTmFtZTogJ3R5cGUnLCBiZWdpbjogJ1xcXFxiW0EtWl1bXFxcXHddKihcXFxcKChcXFxcLlxcXFwufCx8XFxcXHcrKVxcXFwpKT8nfSxcbiAgICAgIHtjbGFzc05hbWU6ICd0aXRsZScsIGJlZ2luOiAnW19hLXpdW1xcXFx3XFwnXSonfVxuICAgIF1cbiAgfTtcbiAgdmFyIENPTlRBSU5FUjIgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29udGFpbmVyJyxcbiAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICBjb250YWluczogQ09OVEFJTkVSLmNvbnRhaW5zXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOlxuICAgICAgJ2xldCBpbiBpZiB0aGVuIGVsc2UgY2FzZSBvZiB3aGVyZSBkbyBtb2R1bGUgaW1wb3J0IGhpZGluZyBxdWFsaWZpZWQgdHlwZSBkYXRhICcgK1xuICAgICAgJ25ld3R5cGUgZGVyaXZpbmcgY2xhc3MgaW5zdGFuY2Ugbm90IGFzIGZvcmVpZ24gY2NhbGwgc2FmZSB1bnNhZmUnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgICBiZWdpbjogJy0tJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAney0jJywgZW5kOiAnIy19J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXSxcbiAgICAgICAgYmVnaW46ICd7LScsIGVuZDogJy19J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgYmVnaW46ICdcXFxccytcXCcnLCBlbmQ6ICdcXCcnLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2ltcG9ydCcsXG4gICAgICAgIGJlZ2luOiAnXFxcXGJpbXBvcnQnLCBlbmQ6ICckJyxcbiAgICAgICAga2V5d29yZHM6ICdpbXBvcnQgcXVhbGlmaWVkIGFzIGhpZGluZycsXG4gICAgICAgIGNvbnRhaW5zOiBbQ09OVEFJTkVSXSxcbiAgICAgICAgaWxsZWdhbDogJ1xcXFxXXFxcXC58OydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21vZHVsZScsXG4gICAgICAgIGJlZ2luOiAnXFxcXGJtb2R1bGUnLCBlbmQ6ICd3aGVyZScsXG4gICAgICAgIGtleXdvcmRzOiAnbW9kdWxlIHdoZXJlJyxcbiAgICAgICAgY29udGFpbnM6IFtDT05UQUlORVJdLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXFdcXFxcLnw7J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKGNsYXNzfGluc3RhbmNlKScsIGVuZDogJ3doZXJlJyxcbiAgICAgICAga2V5d29yZHM6ICdjbGFzcyB3aGVyZSBpbnN0YW5jZScsXG4gICAgICAgIGNvbnRhaW5zOiBbVFlQRV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3R5cGVkZWYnLFxuICAgICAgICBiZWdpbjogJ1xcXFxiKGRhdGF8KG5ldyk/dHlwZSknLCBlbmQ6ICckJyxcbiAgICAgICAga2V5d29yZHM6ICdkYXRhIHR5cGUgbmV3dHlwZSBkZXJpdmluZycsXG4gICAgICAgIGNvbnRhaW5zOiBbVFlQRSwgQ09OVEFJTkVSLCBDT05UQUlORVIyXVxuICAgICAgfSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2hlYmFuZycsXG4gICAgICAgIGJlZ2luOiAnIyFcXFxcL3VzclxcXFwvYmluXFxcXC9lbnZcXCBydW5oYXNrZWxsJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICBUWVBFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0aXRsZScsIGJlZ2luOiAnXltfYS16XVtcXFxcd1xcJ10qJ1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwidmFyIGhsanMgPSBuZXcgZnVuY3Rpb24oKSB7XG5cbiAgLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuICBmdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nbSwgJyZhbXA7JykucmVwbGFjZSgvPC9nbSwgJyZsdDsnKS5yZXBsYWNlKC8+L2dtLCAnJmd0OycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENvZGUocHJlKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHByZS5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ0NPREUnKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIGlmICghKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBub2RlLm5vZGVWYWx1ZS5tYXRjaCgvXFxzKy8pKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tUZXh0KGJsb2NrLCBpZ25vcmVOZXdMaW5lcykge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYmxvY2suY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICByZXR1cm4gaWdub3JlTmV3TGluZXMgPyBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9cXG4vZywgJycpIDogbm9kZS5ub2RlVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSAnQlInKSB7XG4gICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9ja1RleHQobm9kZSwgaWdub3JlTmV3TGluZXMpO1xuICAgIH0pLmpvaW4oJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIHZhciBjbGFzc2VzID0gKGJsb2NrLmNsYXNzTmFtZSArICcgJyArIGJsb2NrLnBhcmVudE5vZGUuY2xhc3NOYW1lKS5zcGxpdCgvXFxzKy8pO1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLm1hcChmdW5jdGlvbihjKSB7cmV0dXJuIGMucmVwbGFjZSgvXmxhbmd1YWdlLS8sICcnKX0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxhbmd1YWdlc1tjbGFzc2VzW2ldXSB8fCBjbGFzc2VzW2ldID09ICduby1oaWdobGlnaHQnKSB7XG4gICAgICAgIHJldHVybiBjbGFzc2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qIFN0cmVhbSBtZXJnaW5nICovXG5cbiAgZnVuY3Rpb24gbm9kZVN0cmVhbShub2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIChmdW5jdGlvbiBfbm9kZVN0cmVhbShub2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZU5hbWUgPT0gJ0JSJylcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9mZnNldCA9IF9ub2RlU3RyZWFtKGNoaWxkLCBvZmZzZXQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RvcCcsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIG5vZGU6IGNoaWxkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSkobm9kZSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yLCB2YWx1ZSkge1xuICAgIHZhciBwcm9jZXNzZWQgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbm9kZVN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RTdHJlYW0oKSB7XG4gICAgICBpZiAoc3RyZWFtMS5sZW5ndGggJiYgc3RyZWFtMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0cmVhbTFbMF0ub2Zmc2V0ICE9IHN0cmVhbTJbMF0ub2Zmc2V0KVxuICAgICAgICAgIHJldHVybiAoc3RyZWFtMVswXS5vZmZzZXQgPCBzdHJlYW0yWzBdLm9mZnNldCkgPyBzdHJlYW0xIDogc3RyZWFtMjtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICBUbyBhdm9pZCBzdGFydGluZyB0aGUgc3RyZWFtIGp1c3QgYmVmb3JlIGl0IHNob3VsZCBzdG9wIHRoZSBvcmRlciBpc1xuICAgICAgICAgIGVuc3VyZWQgdGhhdCBzdHJlYW0xIGFsd2F5cyBzdGFydHMgZmlyc3QgYW5kIGNsb3NlcyBsYXN0OlxuXG4gICAgICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTE7XG4gICAgICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtMjtcbiAgICAgICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0xO1xuICAgICAgICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtMjtcblxuICAgICAgICAgIC4uLiB3aGljaCBpcyBjb2xsYXBzZWQgdG86XG4gICAgICAgICAgKi9cbiAgICAgICAgICByZXR1cm4gc3RyZWFtMlswXS5ldmVudCA9PSAnc3RhcnQnID8gc3RyZWFtMSA6IHN0cmVhbTI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0xLmxlbmd0aCA/IHN0cmVhbTEgOiBzdHJlYW0yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW4obm9kZSkge1xuICAgICAgZnVuY3Rpb24gYXR0cl9zdHIoYSkge3JldHVybiAnICcgKyBhLm5vZGVOYW1lICsgJz1cIicgKyBlc2NhcGUoYS52YWx1ZSkgKyAnXCInfTtcbiAgICAgIHJldHVybiAnPCcgKyBub2RlLm5vZGVOYW1lICsgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcywgYXR0cl9zdHIpLmpvaW4oJycpICsgJz4nO1xuICAgIH1cblxuICAgIHdoaWxlIChzdHJlYW0xLmxlbmd0aCB8fCBzdHJlYW0yLmxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzZWxlY3RTdHJlYW0oKS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICByZXN1bHQgKz0gZXNjYXBlKHZhbHVlLnN1YnN0cihwcm9jZXNzZWQsIGN1cnJlbnQub2Zmc2V0IC0gcHJvY2Vzc2VkKSk7XG4gICAgICBwcm9jZXNzZWQgPSBjdXJyZW50Lm9mZnNldDtcbiAgICAgIGlmICggY3VycmVudC5ldmVudCA9PSAnc3RhcnQnKSB7XG4gICAgICAgIHJlc3VsdCArPSBvcGVuKGN1cnJlbnQubm9kZSk7XG4gICAgICAgIG5vZGVTdGFjay5wdXNoKGN1cnJlbnQubm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuZXZlbnQgPT0gJ3N0b3AnKSB7XG4gICAgICAgIHZhciBub2RlLCBpID0gbm9kZVN0YWNrLmxlbmd0aDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBub2RlID0gbm9kZVN0YWNrW2ldO1xuICAgICAgICAgIHJlc3VsdCArPSAoJzwvJyArIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSArICc+Jyk7XG4gICAgICAgIH0gd2hpbGUgKG5vZGUgIT0gY3VycmVudC5ub2RlKTtcbiAgICAgICAgbm9kZVN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgd2hpbGUgKGkgPCBub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IG9wZW4obm9kZVN0YWNrW2ldKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZSh2YWx1ZS5zdWJzdHIocHJvY2Vzc2VkKSk7XG4gIH1cblxuICAvKiBJbml0aWFsaXphdGlvbiAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuXG4gICAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICAgIHJldHVybiBSZWdFeHAoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZU1vZGUobW9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAobW9kZS5jb21waWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbW9kZS5jb21waWxlZCA9IHRydWU7XG5cbiAgICAgIHZhciBrZXl3b3JkcyA9IFtdOyAvLyB1c2VkIGxhdGVyIHdpdGggYmVnaW5XaXRoS2V5d29yZCBidXQgZmlsbGVkIGFzIGEgc2lkZS1lZmZlY3Qgb2Yga2V5d29yZHMgY29tcGlsYXRpb25cbiAgICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICAgIHZhciBjb21waWxlZF9rZXl3b3JkcyA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4oY2xhc3NOYW1lLCBzdHIpIHtcbiAgICAgICAgICBzdHIuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGt3KSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IGt3LnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICBjb21waWxlZF9rZXl3b3Jkc1twYWlyWzBdXSA9IFtjbGFzc05hbWUsIHBhaXJbMV0gPyBOdW1iZXIocGFpclsxXSkgOiAxXTtcbiAgICAgICAgICAgIGtleXdvcmRzLnB1c2gocGFpclswXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlLmxleGVtc1JlID0gbGFuZ1JlKG1vZGUubGV4ZW1zIHx8IGhsanMuSURFTlRfUkUsIHRydWUpO1xuICAgICAgICBpZiAodHlwZW9mIG1vZGUua2V5d29yZHMgPT0gJ3N0cmluZycpIHsgLy8gc3RyaW5nXG4gICAgICAgICAgZmxhdHRlbigna2V5d29yZCcsIG1vZGUua2V5d29yZHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgY2xhc3NOYW1lIGluIG1vZGUua2V5d29yZHMpIHtcbiAgICAgICAgICAgIGlmICghbW9kZS5rZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShjbGFzc05hbWUpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZsYXR0ZW4oY2xhc3NOYW1lLCBtb2RlLmtleXdvcmRzW2NsYXNzTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZWRfa2V5d29yZHM7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChtb2RlLmJlZ2luV2l0aEtleXdvcmQpIHtcbiAgICAgICAgICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBrZXl3b3Jkcy5qb2luKCd8JykgKyAnKVxcXFxzJztcbiAgICAgICAgfVxuICAgICAgICBtb2RlLmJlZ2luUmUgPSBsYW5nUmUobW9kZS5iZWdpbiA/IG1vZGUuYmVnaW4gOiAnXFxcXEJ8XFxcXGInKTtcbiAgICAgICAgaWYgKCFtb2RlLmVuZCAmJiAhbW9kZS5lbmRzV2l0aFBhcmVudClcbiAgICAgICAgICBtb2RlLmVuZCA9ICdcXFxcQnxcXFxcYic7XG4gICAgICAgIGlmIChtb2RlLmVuZClcbiAgICAgICAgICBtb2RlLmVuZFJlID0gbGFuZ1JlKG1vZGUuZW5kKTtcbiAgICAgICAgbW9kZS50ZXJtaW5hdG9yX2VuZCA9IG1vZGUuZW5kIHx8ICcnO1xuICAgICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCAmJiBwYXJlbnQudGVybWluYXRvcl9lbmQpXG4gICAgICAgICAgbW9kZS50ZXJtaW5hdG9yX2VuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvcl9lbmQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5pbGxlZ2FsKVxuICAgICAgICBtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZShtb2RlLmlsbGVnYWwpO1xuICAgICAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpXG4gICAgICAgIG1vZGUucmVsZXZhbmNlID0gMTtcbiAgICAgIGlmICghbW9kZS5jb250YWlucykge1xuICAgICAgICBtb2RlLmNvbnRhaW5zID0gW107XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGUuY29udGFpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1vZGUuY29udGFpbnNbaV0gPT0gJ3NlbGYnKSB7XG4gICAgICAgICAgbW9kZS5jb250YWluc1tpXSA9IG1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZU1vZGUobW9kZS5jb250YWluc1tpXSwgbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXJtaW5hdG9ycyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlLmNvbnRhaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlcm1pbmF0b3JzLnB1c2gobW9kZS5jb250YWluc1tpXS5iZWdpbik7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS50ZXJtaW5hdG9yX2VuZCkge1xuICAgICAgICB0ZXJtaW5hdG9ycy5wdXNoKG1vZGUudGVybWluYXRvcl9lbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuaWxsZWdhbCkge1xuICAgICAgICB0ZXJtaW5hdG9ycy5wdXNoKG1vZGUuaWxsZWdhbCk7XG4gICAgICB9XG4gICAgICBtb2RlLnRlcm1pbmF0b3JzID0gdGVybWluYXRvcnMubGVuZ3RoID8gbGFuZ1JlKHRlcm1pbmF0b3JzLmpvaW4oJ3wnKSwgdHJ1ZSkgOiB7ZXhlYzogZnVuY3Rpb24ocykge3JldHVybiBudWxsO319O1xuICAgIH1cblxuICAgIGNvbXBpbGVNb2RlKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8qXG4gIENvcmUgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uLiBBY2NlcHRzIGEgbGFuZ3VhZ2UgbmFtZSBhbmQgYSBzdHJpbmcgd2l0aCB0aGVcbiAgY29kZSB0byBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0ga2V5d29yZF9jb3VudCAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG5cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0KGxhbmd1YWdlX25hbWUsIHZhbHVlKSB7XG5cbiAgICBmdW5jdGlvbiBzdWJNb2RlKGxleGVtLCBtb2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGUuY29udGFpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbW9kZS5jb250YWluc1tpXS5iZWdpblJlLmV4ZWMobGV4ZW0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBtb2RlLmNvbnRhaW5zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIGxleGVtKSB7XG4gICAgICBpZiAobW9kZS5lbmQgJiYgbW9kZS5lbmRSZS50ZXN0KGxleGVtKSkge1xuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIGxleGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lsbGVnYWwobGV4ZW0sIG1vZGUpIHtcbiAgICAgIHJldHVybiBtb2RlLmlsbGVnYWwgJiYgbW9kZS5pbGxlZ2FsUmUudGVzdChsZXhlbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5d29yZE1hdGNoKG1vZGUsIG1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hfc3RyID0gbGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/IG1hdGNoWzBdLnRvTG93ZXJDYXNlKCkgOiBtYXRjaFswXTtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzLmhhc093blByb3BlcnR5KG1hdGNoX3N0cikgJiYgbW9kZS5rZXl3b3Jkc1ttYXRjaF9zdHJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkcygpIHtcbiAgICAgIHZhciBidWZmZXIgPSBlc2NhcGUobW9kZV9idWZmZXIpO1xuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbGFzdF9pbmRleCA9IDA7XG4gICAgICB0b3AubGV4ZW1zUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBtYXRjaCA9IHRvcC5sZXhlbXNSZS5leGVjKGJ1ZmZlcik7XG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0ICs9IGJ1ZmZlci5zdWJzdHIobGFzdF9pbmRleCwgbWF0Y2guaW5kZXggLSBsYXN0X2luZGV4KTtcbiAgICAgICAgdmFyIGtleXdvcmRfbWF0Y2ggPSBrZXl3b3JkTWF0Y2godG9wLCBtYXRjaCk7XG4gICAgICAgIGlmIChrZXl3b3JkX21hdGNoKSB7XG4gICAgICAgICAga2V5d29yZF9jb3VudCArPSBrZXl3b3JkX21hdGNoWzFdO1xuICAgICAgICAgIHJlc3VsdCArPSAnPHNwYW4gY2xhc3M9XCInKyBrZXl3b3JkX21hdGNoWzBdICsnXCI+JyArIG1hdGNoWzBdICsgJzwvc3Bhbj4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBtYXRjaFswXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2luZGV4ID0gdG9wLmxleGVtc1JlLmxhc3RJbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1zUmUuZXhlYyhidWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIGJ1ZmZlci5zdWJzdHIobGFzdF9pbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1N1Ykxhbmd1YWdlKCkge1xuICAgICAgaWYgKHRvcC5zdWJMYW5ndWFnZSAmJiAhbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShtb2RlX2J1ZmZlcik7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdG9wLnN1Ykxhbmd1YWdlID8gaGlnaGxpZ2h0KHRvcC5zdWJMYW5ndWFnZSwgbW9kZV9idWZmZXIpIDogaGlnaGxpZ2h0QXV0byhtb2RlX2J1ZmZlcik7XG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2VjYXNlIGluIHBvaW50IGlzIE1hcmtkb3duIHRoYXRcbiAgICAgIC8vIGFsbG93cyBYTUwgZXZlcnl3aGVyZSBhbmQgbWFrZXMgZXZlcnkgWE1MIHNuaXBwZXQgdG8gaGF2ZSBhIG11Y2ggbGFyZ2VyIE1hcmtkb3duXG4gICAgICAvLyBzY29yZS5cbiAgICAgIGlmICh0b3AucmVsZXZhbmNlID4gMCkge1xuICAgICAgICBrZXl3b3JkX2NvdW50ICs9IHJlc3VsdC5rZXl3b3JkX2NvdW50O1xuICAgICAgICByZWxldmFuY2UgKz0gcmVzdWx0LnJlbGV2YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCInICsgcmVzdWx0Lmxhbmd1YWdlICArICdcIj4nICsgcmVzdWx0LnZhbHVlICsgJzwvc3Bhbj4nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICByZXR1cm4gdG9wLnN1Ykxhbmd1YWdlICE9PSB1bmRlZmluZWQgPyBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSA6IHByb2Nlc3NLZXl3b3JkcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlLCBsZXhlbSkge1xuICAgICAgdmFyIG1hcmt1cCA9IG1vZGUuY2xhc3NOYW1lPyAnPHNwYW4gY2xhc3M9XCInICsgbW9kZS5jbGFzc05hbWUgKyAnXCI+JzogJyc7XG4gICAgICBpZiAobW9kZS5yZXR1cm5CZWdpbikge1xuICAgICAgICByZXN1bHQgKz0gbWFya3VwO1xuICAgICAgICBtb2RlX2J1ZmZlciA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICByZXN1bHQgKz0gZXNjYXBlKGxleGVtKSArIG1hcmt1cDtcbiAgICAgICAgbW9kZV9idWZmZXIgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBtYXJrdXA7XG4gICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW07XG4gICAgICB9XG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHtwYXJlbnQ6IHt2YWx1ZTogdG9wfX0pO1xuICAgICAgcmVsZXZhbmNlICs9IG1vZGUucmVsZXZhbmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NMZXhlbShidWZmZXIsIGxleGVtKSB7XG4gICAgICBtb2RlX2J1ZmZlciArPSBidWZmZXI7XG4gICAgICBpZiAobGV4ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19tb2RlID0gc3ViTW9kZShsZXhlbSwgdG9wKTtcbiAgICAgIGlmIChuZXdfbW9kZSkge1xuICAgICAgICByZXN1bHQgKz0gcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBzdGFydE5ld01vZGUobmV3X21vZGUsIGxleGVtKTtcbiAgICAgICAgcmV0dXJuIG5ld19tb2RlLnJldHVybkJlZ2luID8gMCA6IGxleGVtLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZF9tb2RlID0gZW5kT2ZNb2RlKHRvcCwgbGV4ZW0pO1xuICAgICAgaWYgKGVuZF9tb2RlKSB7XG4gICAgICAgIGlmICghKGVuZF9tb2RlLnJldHVybkVuZCB8fCBlbmRfbW9kZS5leGNsdWRlRW5kKSkge1xuICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodG9wLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc8L3NwYW4+JztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAodG9wICE9IGVuZF9tb2RlLnBhcmVudCk7XG4gICAgICAgIGlmIChlbmRfbW9kZS5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZShsZXhlbSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZV9idWZmZXIgPSAnJztcbiAgICAgICAgaWYgKGVuZF9tb2RlLnN0YXJ0cykge1xuICAgICAgICAgIHN0YXJ0TmV3TW9kZShlbmRfbW9kZS5zdGFydHMsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kX21vZGUucmV0dXJuRW5kID8gMCA6IGxleGVtLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWxsZWdhbChsZXhlbSwgdG9wKSlcbiAgICAgICAgdGhyb3cgJ0lsbGVnYWwnO1xuXG4gICAgICAvKlxuICAgICAgUGFyc2VyIHNob3VsZCBub3QgcmVhY2ggdGhpcyBwb2ludCBhcyBhbGwgdHlwZXMgb2YgbGV4ZW1zIHNob3VsZCBiZSBjYXVnaHRcbiAgICAgIGVhcmxpZXIsIGJ1dCBpZiBpdCBkb2VzIGR1ZSB0byBzb21lIGJ1ZyBtYWtlIHN1cmUgaXQgYWR2YW5jZXMgYXQgbGVhc3Qgb25lXG4gICAgICBjaGFyYWN0ZXIgZm9yd2FyZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BpbmcuXG4gICAgICAqL1xuICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW07XG4gICAgICByZXR1cm4gbGV4ZW0ubGVuZ3RoIHx8IDE7XG4gICAgfVxuXG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzW2xhbmd1YWdlX25hbWVdO1xuICAgIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgdmFyIHRvcCA9IGxhbmd1YWdlO1xuICAgIHZhciBtb2RlX2J1ZmZlciA9ICcnO1xuICAgIHZhciByZWxldmFuY2UgPSAwO1xuICAgIHZhciBrZXl3b3JkX2NvdW50ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaCwgY291bnQsIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRvcC50ZXJtaW5hdG9ycy5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AudGVybWluYXRvcnMuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvdW50ID0gcHJvY2Vzc0xleGVtKHZhbHVlLnN1YnN0cihpbmRleCwgbWF0Y2guaW5kZXggLSBpbmRleCksIG1hdGNoWzBdKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIGNvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtKHZhbHVlLnN1YnN0cihpbmRleCkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxldmFuY2U6IHJlbGV2YW5jZSxcbiAgICAgICAga2V5d29yZF9jb3VudDoga2V5d29yZF9jb3VudCxcbiAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlX25hbWVcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgPT0gJ0lsbGVnYWwnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGtleXdvcmRfY291bnQ6IDAsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZSh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgSGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgZGV0ZWN0aW9uLiBBY2NlcHRzIGEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG9cbiAgaGlnaGxpZ2h0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblxuICAtIGxhbmd1YWdlIChkZXRlY3RlZCBsYW5ndWFnZSlcbiAgLSByZWxldmFuY2UgKGludClcbiAgLSBrZXl3b3JkX2NvdW50IChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcbiAgLSBzZWNvbmRfYmVzdCAob2JqZWN0IHdpdGggdGhlIHNhbWUgc3RydWN0dXJlIGZvciBzZWNvbmQtYmVzdCBoZXVyaXN0aWNhbGx5XG4gICAgZGV0ZWN0ZWQgbGFuZ3VhZ2UsIG1heSBiZSBhYnNlbnQpXG5cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QXV0byh0ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGtleXdvcmRfY291bnQ6IDAsXG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICB2YWx1ZTogZXNjYXBlKHRleHQpXG4gICAgfTtcbiAgICB2YXIgc2Vjb25kX2Jlc3QgPSByZXN1bHQ7XG4gICAgZm9yICh2YXIga2V5IGluIGxhbmd1YWdlcykge1xuICAgICAgaWYgKCFsYW5ndWFnZXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgY3VycmVudCA9IGhpZ2hsaWdodChrZXksIHRleHQpO1xuICAgICAgY3VycmVudC5sYW5ndWFnZSA9IGtleTtcbiAgICAgIGlmIChjdXJyZW50LmtleXdvcmRfY291bnQgKyBjdXJyZW50LnJlbGV2YW5jZSA+IHNlY29uZF9iZXN0LmtleXdvcmRfY291bnQgKyBzZWNvbmRfYmVzdC5yZWxldmFuY2UpIHtcbiAgICAgICAgc2Vjb25kX2Jlc3QgPSBjdXJyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQua2V5d29yZF9jb3VudCArIGN1cnJlbnQucmVsZXZhbmNlID4gcmVzdWx0LmtleXdvcmRfY291bnQgKyByZXN1bHQucmVsZXZhbmNlKSB7XG4gICAgICAgIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kX2Jlc3QubGFuZ3VhZ2UpIHtcbiAgICAgIHJlc3VsdC5zZWNvbmRfYmVzdCA9IHNlY29uZF9iZXN0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgUG9zdC1wcm9jZXNzaW5nIG9mIHRoZSBoaWdobGlnaHRlZCBtYXJrdXA6XG5cbiAgLSByZXBsYWNlIFRBQnMgd2l0aCBzb21ldGhpbmcgbW9yZSB1c2VmdWxcbiAgLSByZXBsYWNlIHJlYWwgbGluZS1icmVha3Mgd2l0aCAnPGJyPicgZm9yIG5vbi1wcmUgY29udGFpbmVyc1xuXG4gICovXG4gIGZ1bmN0aW9uIGZpeE1hcmt1cCh2YWx1ZSwgdGFiUmVwbGFjZSwgdXNlQlIpIHtcbiAgICBpZiAodGFiUmVwbGFjZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKCg8W14+XSs+fFxcdCkrKS9nbSwgZnVuY3Rpb24obWF0Y2gsIHAxLCBvZmZzZXQsIHMpIHtcbiAgICAgICAgcmV0dXJuIHAxLnJlcGxhY2UoL1xcdC9nLCB0YWJSZXBsYWNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodXNlQlIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuL2csICc8YnI+Jyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGEgRE9NIG5vZGUgY29udGFpbmluZyBjb2RlLiBBY2NlcHRzIGEgRE9NIG5vZGUgYW5kXG4gIHR3byBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaXhNYXJrdXAuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEJsb2NrKGJsb2NrLCB0YWJSZXBsYWNlLCB1c2VCUikge1xuICAgIHZhciB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLCB1c2VCUik7XG4gICAgdmFyIGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShibG9jayk7XG4gICAgaWYgKGxhbmd1YWdlID09ICduby1oaWdobGlnaHQnKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHJlc3VsdCA9IGxhbmd1YWdlID8gaGlnaGxpZ2h0KGxhbmd1YWdlLCB0ZXh0KSA6IGhpZ2hsaWdodEF1dG8odGV4dCk7XG4gICAgbGFuZ3VhZ2UgPSByZXN1bHQubGFuZ3VhZ2U7XG4gICAgdmFyIG9yaWdpbmFsID0gbm9kZVN0cmVhbShibG9jayk7XG4gICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgdmFyIHByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuICAgICAgcHJlLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IG1lcmdlU3RyZWFtcyhvcmlnaW5hbCwgbm9kZVN0cmVhbShwcmUpLCB0ZXh0KTtcbiAgICB9XG4gICAgcmVzdWx0LnZhbHVlID0gZml4TWFya3VwKHJlc3VsdC52YWx1ZSwgdGFiUmVwbGFjZSwgdXNlQlIpO1xuXG4gICAgdmFyIGNsYXNzX25hbWUgPSBibG9jay5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc19uYW1lLm1hdGNoKCcoXFxcXHN8XikobGFuZ3VhZ2UtKT8nICsgbGFuZ3VhZ2UgKyAnKFxcXFxzfCQpJykpIHtcbiAgICAgIGNsYXNzX25hbWUgPSBjbGFzc19uYW1lID8gKGNsYXNzX25hbWUgKyAnICcgKyBsYW5ndWFnZSkgOiBsYW5ndWFnZTtcbiAgICB9XG4gICAgYmxvY2suaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgIGJsb2NrLmNsYXNzTmFtZSA9IGNsYXNzX25hbWU7XG4gICAgYmxvY2sucmVzdWx0ID0ge1xuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAga3c6IHJlc3VsdC5rZXl3b3JkX2NvdW50LFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kX2Jlc3QpIHtcbiAgICAgIGJsb2NrLnNlY29uZF9iZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZF9iZXN0Lmxhbmd1YWdlLFxuICAgICAgICBrdzogcmVzdWx0LnNlY29uZF9iZXN0LmtleXdvcmRfY291bnQsXG4gICAgICAgIHJlOiByZXN1bHQuc2Vjb25kX2Jlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGFsbCA8cHJlPjxjb2RlPi4uPC9jb2RlPjwvcHJlPiBibG9ja3Mgb24gYSBwYWdlLlxuICAqL1xuICBmdW5jdGlvbiBpbml0SGlnaGxpZ2h0aW5nKCkge1xuICAgIGlmIChpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICBpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZCA9IHRydWU7XG4gICAgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwcmUnKSwgZmluZENvZGUpLlxuICAgICAgZmlsdGVyKEJvb2xlYW4pLlxuICAgICAgZm9yRWFjaChmdW5jdGlvbihjb2RlKXtoaWdobGlnaHRCbG9jayhjb2RlLCBobGpzLnRhYlJlcGxhY2UpfSk7XG4gIH1cblxuICAvKlxuICBBdHRhY2hlcyBoaWdobGlnaHRpbmcgdG8gdGhlIHBhZ2UgbG9hZCBldmVudC5cbiAgKi9cbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgfVxuXG4gIHZhciBsYW5ndWFnZXMgPSB7fTsgLy8gYSBzaG9ydGN1dCB0byBhdm9pZCB3cml0aW5nIFwidGhpcy5cIiBldmVyeXdoZXJlXG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cblxuICB0aGlzLkxBTkdVQUdFUyA9IGxhbmd1YWdlcztcbiAgdGhpcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gIHRoaXMuaGlnaGxpZ2h0QXV0byA9IGhpZ2hsaWdodEF1dG87XG4gIHRoaXMuZml4TWFya3VwID0gZml4TWFya3VwO1xuICB0aGlzLmhpZ2hsaWdodEJsb2NrID0gaGlnaGxpZ2h0QmxvY2s7XG4gIHRoaXMuaW5pdEhpZ2hsaWdodGluZyA9IGluaXRIaWdobGlnaHRpbmc7XG4gIHRoaXMuaW5pdEhpZ2hsaWdodGluZ09uTG9hZCA9IGluaXRIaWdobGlnaHRpbmdPbkxvYWQ7XG5cbiAgLy8gQ29tbW9uIHJlZ2V4cHNcbiAgdGhpcy5JREVOVF9SRSA9ICdbYS16QS1aXVthLXpBLVowLTlfXSonO1xuICB0aGlzLlVOREVSU0NPUkVfSURFTlRfUkUgPSAnW2EtekEtWl9dW2EtekEtWjAtOV9dKic7XG4gIHRoaXMuTlVNQkVSX1JFID0gJ1xcXFxiXFxcXGQrKFxcXFwuXFxcXGQrKT8nO1xuICB0aGlzLkNfTlVNQkVSX1JFID0gJyhcXFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKShbZUVdWy0rXT9cXFxcZCspPyknOyAvLyAweC4uLiwgMC4uLiwgZGVjaW1hbCwgZmxvYXRcbiAgdGhpcy5CSU5BUllfTlVNQkVSX1JFID0gJ1xcXFxiKDBiWzAxXSspJzsgLy8gMGIuLi5cbiAgdGhpcy5SRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfFxcXFwufC18LT18L3wvPXw6fDt8PHw8PHw8PD18PD18PXw9PXw9PT18Pnw+PXw+Pnw+Pj18Pj4+fD4+Pj18XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4gIC8vIENvbW1vbiBtb2Rlc1xuICB0aGlzLkJBQ0tTTEFTSF9FU0NBUEUgPSB7XG4gICAgYmVnaW46ICdcXFxcXFxcXFtcXFxcc1xcXFxTXScsIHJlbGV2YW5jZTogMFxuICB9O1xuICB0aGlzLkFQT1NfU1RSSU5HX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1xcJycsIGVuZDogJ1xcJycsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW3RoaXMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHRoaXMuUVVPVEVfU1RSSU5HX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCInLFxuICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgY29udGFpbnM6IFt0aGlzLkJBQ0tTTEFTSF9FU0NBUEVdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB0aGlzLkNfTElORV9DT01NRU5UX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgYmVnaW46ICcvLycsIGVuZDogJyQnXG4gIH07XG4gIHRoaXMuQ19CTE9DS19DT01NRU5UX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgYmVnaW46ICcvXFxcXConLCBlbmQ6ICdcXFxcKi8nXG4gIH07XG4gIHRoaXMuSEFTSF9DT01NRU5UX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgYmVnaW46ICcjJywgZW5kOiAnJCdcbiAgfTtcbiAgdGhpcy5OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiB0aGlzLk5VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdGhpcy5DX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IHRoaXMuQ19OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHRoaXMuQklOQVJZX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IHRoaXMuQklOQVJZX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuICB0aGlzLmluaGVyaXQgPSBmdW5jdGlvbihwYXJlbnQsIG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fVxuICAgIGZvciAodmFyIGtleSBpbiBwYXJlbnQpXG4gICAgICByZXN1bHRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgIGlmIChvYmopXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0oKTtcbmhsanMuTEFOR1VBR0VTWydiYXNoJ10gPSByZXF1aXJlKCcuL2Jhc2guanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydlcmxhbmcnXSA9IHJlcXVpcmUoJy4vZXJsYW5nLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snY3MnXSA9IHJlcXVpcmUoJy4vY3MuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydicmFpbmZ1Y2snXSA9IHJlcXVpcmUoJy4vYnJhaW5mdWNrLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sncnVieSddID0gcmVxdWlyZSgnLi9ydWJ5LmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sncnVzdCddID0gcmVxdWlyZSgnLi9ydXN0LmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sncmliJ10gPSByZXF1aXJlKCcuL3JpYi5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2RpZmYnXSA9IHJlcXVpcmUoJy4vZGlmZi5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2phdmFzY3JpcHQnXSA9IHJlcXVpcmUoJy4vamF2YXNjcmlwdC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2dsc2wnXSA9IHJlcXVpcmUoJy4vZ2xzbC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ3JzbCddID0gcmVxdWlyZSgnLi9yc2wuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydsdWEnXSA9IHJlcXVpcmUoJy4vbHVhLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sneG1sJ10gPSByZXF1aXJlKCcuL3htbC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ21hcmtkb3duJ10gPSByZXF1aXJlKCcuL21hcmtkb3duLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snY3NzJ10gPSByZXF1aXJlKCcuL2Nzcy5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2xpc3AnXSA9IHJlcXVpcmUoJy4vbGlzcC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ3Byb2ZpbGUnXSA9IHJlcXVpcmUoJy4vcHJvZmlsZS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2h0dHAnXSA9IHJlcXVpcmUoJy4vaHR0cC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2phdmEnXSA9IHJlcXVpcmUoJy4vamF2YS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ3BocCddID0gcmVxdWlyZSgnLi9waHAuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydoYXNrZWxsJ10gPSByZXF1aXJlKCcuL2hhc2tlbGwuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWycxYyddID0gcmVxdWlyZSgnLi8xYy5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ3B5dGhvbiddID0gcmVxdWlyZSgnLi9weXRob24uanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydzbWFsbHRhbGsnXSA9IHJlcXVpcmUoJy4vc21hbGx0YWxrLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sndGV4J10gPSByZXF1aXJlKCcuL3RleC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2FjdGlvbnNjcmlwdCddID0gcmVxdWlyZSgnLi9hY3Rpb25zY3JpcHQuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydzcWwnXSA9IHJlcXVpcmUoJy4vc3FsLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1sndmFsYSddID0gcmVxdWlyZSgnLi92YWxhLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snaW5pJ10gPSByZXF1aXJlKCcuL2luaS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2QnXSA9IHJlcXVpcmUoJy4vZC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2F4YXB0YSddID0gcmVxdWlyZSgnLi9heGFwdGEuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydwZXJsJ10gPSByZXF1aXJlKCcuL3BlcmwuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydzY2FsYSddID0gcmVxdWlyZSgnLi9zY2FsYS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2NtYWtlJ10gPSByZXF1aXJlKCcuL2NtYWtlLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snb2JqZWN0aXZlYyddID0gcmVxdWlyZSgnLi9vYmplY3RpdmVjLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snYXZyYXNtJ10gPSByZXF1aXJlKCcuL2F2cmFzbS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ3ZoZGwnXSA9IHJlcXVpcmUoJy4vdmhkbC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2NvZmZlZXNjcmlwdCddID0gcmVxdWlyZSgnLi9jb2ZmZWVzY3JpcHQuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWyduZ2lueCddID0gcmVxdWlyZSgnLi9uZ2lueC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2VybGFuZy1yZXBsJ10gPSByZXF1aXJlKCcuL2VybGFuZy1yZXBsLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snciddID0gcmVxdWlyZSgnLi9yLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snanNvbiddID0gcmVxdWlyZSgnLi9qc29uLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snZGphbmdvJ10gPSByZXF1aXJlKCcuL2RqYW5nby5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2RlbHBoaSddID0gcmVxdWlyZSgnLi9kZWxwaGkuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWyd2YnNjcmlwdCddID0gcmVxdWlyZSgnLi92YnNjcmlwdC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ21lbCddID0gcmVxdWlyZSgnLi9tZWwuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydkb3MnXSA9IHJlcXVpcmUoJy4vZG9zLmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snYXBhY2hlJ10gPSByZXF1aXJlKCcuL2FwYWNoZS5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ2FwcGxlc2NyaXB0J10gPSByZXF1aXJlKCcuL2FwcGxlc2NyaXB0LmpzJykoaGxqcyk7XG5obGpzLkxBTkdVQUdFU1snY3BwJ10gPSByZXF1aXJlKCcuL2NwcC5qcycpKGhsanMpO1xuaGxqcy5MQU5HVUFHRVNbJ21hdGxhYiddID0gcmVxdWlyZSgnLi9tYXRsYWIuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydwYXJzZXIzJ10gPSByZXF1aXJlKCcuL3BhcnNlcjMuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydjbG9qdXJlJ10gPSByZXF1aXJlKCcuL2Nsb2p1cmUuanMnKShobGpzKTtcbmhsanMuTEFOR1VBR0VTWydnbyddID0gcmVxdWlyZSgnLi9nby5qcycpKGhsanMpO1xubW9kdWxlLmV4cG9ydHMgPSBobGpzOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGlsbGVnYWw6ICdcXFxcUycsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RhdHVzJyxcbiAgICAgICAgYmVnaW46ICdeSFRUUC9bMC05XFxcXC5dKycsIGVuZDogJyQnLFxuICAgICAgICBjb250YWluczogW3tjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogJ1xcXFxiXFxcXGR7M31cXFxcYid9XVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncmVxdWVzdCcsXG4gICAgICAgIGJlZ2luOiAnXltBLVpdKyAoLio/KSBIVFRQL1swLTlcXFxcLl0rJCcsIHJldHVybkJlZ2luOiB0cnVlLCBlbmQ6ICckJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgYmVnaW46ICcgJywgZW5kOiAnICcsXG4gICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHJpYnV0ZScsXG4gICAgICAgIGJlZ2luOiAnXlxcXFx3JywgZW5kOiAnOiAnLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXG58XFxcXHN8PScsXG4gICAgICAgIHN0YXJ0czoge2NsYXNzTmFtZTogJ3N0cmluZycsIGVuZDogJyQnfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdcXFxcblxcXFxuJyxcbiAgICAgICAgc3RhcnRzOiB7c3ViTGFuZ3VhZ2U6ICcnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZX1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgaWxsZWdhbDogJ1teXFxcXHNdJyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICc7JywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgYmVnaW46ICdeXFxcXFsnLCBlbmQ6ICdcXFxcXSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NldHRpbmcnLFxuICAgICAgICBiZWdpbjogJ15bYS16MC05XFxcXFtcXFxcXV8tXStbIFxcXFx0XSo9WyBcXFxcdF0qJywgZW5kOiAnJCcsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBrZXl3b3JkczogJ29uIG9mZiB0cnVlIGZhbHNlIHllcyBubycsXG4gICAgICAgICAgICBjb250YWluczogW2hsanMuUVVPVEVfU1RSSU5HX01PREUsIGhsanMuTlVNQkVSX01PREVdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczpcbiAgICAgICdmYWxzZSBzeW5jaHJvbml6ZWQgaW50IGFic3RyYWN0IGZsb2F0IHByaXZhdGUgY2hhciBib29sZWFuIHN0YXRpYyBudWxsIGlmIGNvbnN0ICcgK1xuICAgICAgJ2ZvciB0cnVlIHdoaWxlIGxvbmcgdGhyb3cgc3RyaWN0ZnAgZmluYWxseSBwcm90ZWN0ZWQgaW1wb3J0IG5hdGl2ZSBmaW5hbCByZXR1cm4gdm9pZCAnICtcbiAgICAgICdlbnVtIGVsc2UgYnJlYWsgdHJhbnNpZW50IG5ldyBjYXRjaCBpbnN0YW5jZW9mIGJ5dGUgc3VwZXIgdm9sYXRpbGUgY2FzZSBhc3NlcnQgc2hvcnQgJyArXG4gICAgICAncGFja2FnZSBkZWZhdWx0IGRvdWJsZSBwdWJsaWMgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHRocm93cycsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnamF2YWRvYycsXG4gICAgICAgIGJlZ2luOiAnL1xcXFwqXFxcXConLCBlbmQ6ICdcXFxcKi8nLFxuICAgICAgICBjb250YWluczogW3tcbiAgICAgICAgICBjbGFzc05hbWU6ICdqYXZhZG9jdGFnJywgYmVnaW46ICdAW0EtWmEtel0rJ1xuICAgICAgICB9XSxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ3snLFxuICAgICAgICBrZXl3b3JkczogJ2NsYXNzIGludGVyZmFjZScsXG4gICAgICAgIGlsbGVnYWw6ICc6JyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLFxuICAgICAgICAgICAga2V5d29yZHM6ICdleHRlbmRzIGltcGxlbWVudHMnLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYW5ub3RhdGlvbicsIGJlZ2luOiAnQFtBLVphLXpdKydcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnaW4gaWYgZm9yIHdoaWxlIGZpbmFsbHkgdmFyIG5ldyBmdW5jdGlvbiBkbyByZXR1cm4gdm9pZCBlbHNlIGJyZWFrIGNhdGNoICcgK1xuICAgICAgICAnaW5zdGFuY2VvZiB3aXRoIHRocm93IGNhc2UgZGVmYXVsdCB0cnkgdGhpcyBzd2l0Y2ggY29udGludWUgdHlwZW9mIGRlbGV0ZSAnICtcbiAgICAgICAgJ2xldCB5aWVsZCBjb25zdCcsXG4gICAgICBsaXRlcmFsOlxuICAgICAgICAndHJ1ZSBmYWxzZSBudWxsIHVuZGVmaW5lZCBOYU4gSW5maW5pdHknXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7IC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgYmVnaW46ICcoJyArIGhsanMuUkVfU1RBUlRFUlNfUkUgKyAnfFxcXFxiKGNhc2V8cmV0dXJufHRocm93KVxcXFxiKVxcXFxzKicsXG4gICAgICAgIGtleXdvcmRzOiAncmV0dXJuIHRocm93IGNhc2UnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgICAgICBiZWdpbjogJy8nLCBlbmQ6ICcvW2dpbV0qJyxcbiAgICAgICAgICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgICAgICAgICBjb250YWluczogW3tiZWdpbjogJ1xcXFxcXFxcLyd9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBFNFhcbiAgICAgICAgICAgIGJlZ2luOiAnPCcsIGVuZDogJz47JyxcbiAgICAgICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJ1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ3snLFxuICAgICAgICBrZXl3b3JkczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0aXRsZScsIGJlZ2luOiAnW0EtWmEteiRfXVswLTlBLVphLXokX10qJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbGxlZ2FsOiAnW1wiXFwnXFxcXChdJ1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaWxsZWdhbDogJ1xcXFxbfCUnXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIExJVEVSQUxTID0ge2xpdGVyYWw6ICd0cnVlIGZhbHNlIG51bGwnfTtcbiAgdmFyIFRZUEVTID0gW1xuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gIF07XG4gIHZhciBWQUxVRV9DT05UQUlORVIgPSB7XG4gICAgY2xhc3NOYW1lOiAndmFsdWUnLFxuICAgIGVuZDogJywnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICBjb250YWluczogVFlQRVMsXG4gICAga2V5d29yZHM6IExJVEVSQUxTXG4gIH07XG4gIHZhciBPQkpFQ1QgPSB7XG4gICAgYmVnaW46ICd7JywgZW5kOiAnfScsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46ICdcXFxccypcIicsIGVuZDogJ1wiXFxcXHMqOlxcXFxzKicsIGV4Y2x1ZGVCZWdpbjogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgICAgICBzdGFydHM6IFZBTFVFX0NPTlRBSU5FUlxuICAgICAgfVxuICAgIF0sXG4gICAgaWxsZWdhbDogJ1xcXFxTJ1xuICB9O1xuICB2YXIgQVJSQVkgPSB7XG4gICAgYmVnaW46ICdcXFxcWycsIGVuZDogJ1xcXFxdJyxcbiAgICBjb250YWluczogW2hsanMuaW5oZXJpdChWQUxVRV9DT05UQUlORVIsIHtjbGFzc05hbWU6IG51bGx9KV0sIC8vIGluaGVyaXQgaXMgYWxzbyBhIHdvcmthcm91bmQgZm9yIGEgYnVnIHRoYXQgbWFrZXMgc2hhcmVkIG1vZGVzIHdpdGggZW5kc1dpdGhQYXJlbnQgY29tcGlsZSBvbmx5IHRoZSBlbmRpbmcgb2Ygb25lIG9mIHRoZSBwYXJlbnRzXG4gICAgaWxsZWdhbDogJ1xcXFxTJ1xuICB9O1xuICBUWVBFUy5zcGxpY2UoVFlQRVMubGVuZ3RoLCAwLCBPQkpFQ1QsIEFSUkFZKTtcbiAgcmV0dXJuIHtcbiAgICBjb250YWluczogVFlQRVMsXG4gICAga2V5d29yZHM6IExJVEVSQUxTLFxuICAgIGlsbGVnYWw6ICdcXFxcUydcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBMSVNQX0lERU5UX1JFID0gJ1thLXpBLVpfXFxcXC1cXFxcK1xcXFwqXFxcXC9cXFxcPFxcXFw9XFxcXD5cXFxcJlxcXFwjXVthLXpBLVowLTlfXFxcXC1cXFxcK1xcXFwqXFxcXC9cXFxcPFxcXFw9XFxcXD5cXFxcJlxcXFwjXSonO1xuICB2YXIgTElTUF9TSU1QTEVfTlVNQkVSX1JFID0gJyhcXFxcLXxcXFxcKyk/XFxcXGQrKFxcXFwuXFxcXGQrfFxcXFwvXFxcXGQrKT8oKGR8ZXxmfGx8cykoXFxcXCt8XFxcXC0pP1xcXFxkKyk/JztcbiAgdmFyIExJVEVSQUwgPSB7XG4gICAgY2xhc3NOYW1lOiAnbGl0ZXJhbCcsXG4gICAgYmVnaW46ICdcXFxcYih0ezF9fG5pbClcXFxcYidcbiAgfTtcbiAgdmFyIE5VTUJFUlMgPSBbXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46IExJU1BfU0lNUExFX05VTUJFUl9SRVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46ICcjYlswLTFdKygvWzAtMV0rKT8nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogJyNvWzAtN10rKC9bMC03XSspPydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsIGJlZ2luOiAnI3hbMC05YS1mXSsoL1swLTlhLWZdKyk/J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46ICcjY1xcXFwoJyArIExJU1BfU0lNUExFX05VTUJFUl9SRSArICcgKycgKyBMSVNQX1NJTVBMRV9OVU1CRVJfUkUsIGVuZDogJ1xcXFwpJ1xuICAgIH1cbiAgXVxuICB2YXIgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgIGJlZ2luOiAnOycsIGVuZDogJyQnXG4gIH07XG4gIHZhciBWQVJJQUJMRSA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICdcXFxcKicsIGVuZDogJ1xcXFwqJ1xuICB9O1xuICB2YXIgS0VZV09SRCA9IHtcbiAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICBiZWdpbjogJ1s6Jl0nICsgTElTUF9JREVOVF9SRVxuICB9O1xuICB2YXIgUVVPVEVEX0xJU1QgPSB7XG4gICAgYmVnaW46ICdcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICBjb250YWluczogWydzZWxmJywgTElURVJBTCwgU1RSSU5HXS5jb25jYXQoTlVNQkVSUylcbiAgfTtcbiAgdmFyIFFVT1RFRDEgPSB7XG4gICAgY2xhc3NOYW1lOiAncXVvdGVkJyxcbiAgICBiZWdpbjogJ1tcXCdgXVxcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgIGNvbnRhaW5zOiBOVU1CRVJTLmNvbmNhdChbU1RSSU5HLCBWQVJJQUJMRSwgS0VZV09SRCwgUVVPVEVEX0xJU1RdKVxuICB9O1xuICB2YXIgUVVPVEVEMiA9IHtcbiAgICBjbGFzc05hbWU6ICdxdW90ZWQnLFxuICAgIGJlZ2luOiAnXFxcXChxdW90ZSAnLCBlbmQ6ICdcXFxcKScsXG4gICAga2V5d29yZHM6IHt0aXRsZTogJ3F1b3RlJ30sXG4gICAgY29udGFpbnM6IE5VTUJFUlMuY29uY2F0KFtTVFJJTkcsIFZBUklBQkxFLCBLRVlXT1JELCBRVU9URURfTElTVF0pXG4gIH07XG4gIHZhciBMSVNUID0ge1xuICAgIGNsYXNzTmFtZTogJ2xpc3QnLFxuICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKSdcbiAgfTtcbiAgdmFyIEJPRFkgPSB7XG4gICAgY2xhc3NOYW1lOiAnYm9keScsXG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgfTtcbiAgTElTVC5jb250YWlucyA9IFt7Y2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogTElTUF9JREVOVF9SRX0sIEJPRFldO1xuICBCT0RZLmNvbnRhaW5zID0gW1FVT1RFRDEsIFFVT1RFRDIsIExJU1QsIExJVEVSQUxdLmNvbmNhdChOVU1CRVJTKS5jb25jYXQoW1NUUklORywgQ09NTUVOVCwgVkFSSUFCTEUsIEtFWVdPUkRdKTtcblxuICByZXR1cm4ge1xuICAgIGlsbGVnYWw6ICdbXlxcXFxzXScsXG4gICAgY29udGFpbnM6IE5VTUJFUlMuY29uY2F0KFtcbiAgICAgIExJVEVSQUwsXG4gICAgICBTVFJJTkcsXG4gICAgICBDT01NRU5ULFxuICAgICAgUVVPVEVEMSwgUVVPVEVEMixcbiAgICAgIExJU1RcbiAgICBdKVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIE9QRU5JTkdfTE9OR19CUkFDS0VUID0gJ1xcXFxbPSpcXFxcWyc7XG4gIHZhciBDTE9TSU5HX0xPTkdfQlJBQ0tFVCA9ICdcXFxcXT0qXFxcXF0nO1xuICB2YXIgTE9OR19CUkFDS0VUUyA9IHtcbiAgICBiZWdpbjogT1BFTklOR19MT05HX0JSQUNLRVQsIGVuZDogQ0xPU0lOR19MT05HX0JSQUNLRVQsXG4gICAgY29udGFpbnM6IFsnc2VsZiddXG4gIH07XG4gIHZhciBDT01NRU5UUyA9IFtcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgIGJlZ2luOiAnLS0oPyEnICsgT1BFTklOR19MT05HX0JSQUNLRVQgKyAnKScsIGVuZDogJyQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgIGJlZ2luOiAnLS0nICsgT1BFTklOR19MT05HX0JSQUNLRVQsIGVuZDogQ0xPU0lOR19MT05HX0JSQUNLRVQsXG4gICAgICBjb250YWluczogW0xPTkdfQlJBQ0tFVFNdLFxuICAgICAgcmVsZXZhbmNlOiAxMFxuICAgIH1cbiAgXVxuICByZXR1cm4ge1xuICAgIGxleGVtczogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnYW5kIGJyZWFrIGRvIGVsc2UgZWxzZWlmIGVuZCBmYWxzZSBmb3IgaWYgaW4gbG9jYWwgbmlsIG5vdCBvciByZXBlYXQgcmV0dXJuIHRoZW4gJyArXG4gICAgICAgICd0cnVlIHVudGlsIHdoaWxlJyxcbiAgICAgIGJ1aWx0X2luOlxuICAgICAgICAnX0cgX1ZFUlNJT04gYXNzZXJ0IGNvbGxlY3RnYXJiYWdlIGRvZmlsZSBlcnJvciBnZXRmZW52IGdldG1ldGF0YWJsZSBpcGFpcnMgbG9hZCAnICtcbiAgICAgICAgJ2xvYWRmaWxlIGxvYWRzdHJpbmcgbW9kdWxlIG5leHQgcGFpcnMgcGNhbGwgcHJpbnQgcmF3ZXF1YWwgcmF3Z2V0IHJhd3NldCByZXF1aXJlICcgK1xuICAgICAgICAnc2VsZWN0IHNldGZlbnYgc2V0bWV0YXRhYmxlIHRvbnVtYmVyIHRvc3RyaW5nIHR5cGUgdW5wYWNrIHhwY2FsbCBjb3JvdXRpbmUgZGVidWcgJyArXG4gICAgICAgICdpbyBtYXRoIG9zIHBhY2thZ2Ugc3RyaW5nIHRhYmxlJ1xuICAgIH0sXG4gICAgY29udGFpbnM6IENPTU1FTlRTLmNvbmNhdChbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSwgZW5kOiAnXFxcXCknLFxuICAgICAgICBrZXl3b3JkczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgICAgICAgICBiZWdpbjogJyhbX2EtekEtWl1cXFxcdypcXFxcLikqKFtfYS16QS1aXVxcXFx3KjopP1tfYS16QS1aXVxcXFx3KidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogJ1xcXFwoJywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogQ09NTUVOVFNcbiAgICAgICAgICB9XG4gICAgICAgIF0uY29uY2F0KENPTU1FTlRTKVxuICAgICAgfSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiBPUEVOSU5HX0xPTkdfQlJBQ0tFVCwgZW5kOiBDTE9TSU5HX0xPTkdfQlJBQ0tFVCxcbiAgICAgICAgY29udGFpbnM6IFtMT05HX0JSQUNLRVRTXSxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfVxuICAgIF0pXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5zOiBbXG4gICAgICAvLyBoaWdobGlnaHQgaGVhZGVyc1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdoZWFkZXInLFxuICAgICAgICBiZWdpbjogJ14jezEsM30nLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnaGVhZGVyJyxcbiAgICAgICAgYmVnaW46ICdeLis/XFxcXG5bPS1dezIsfSQnXG4gICAgICB9LFxuICAgICAgLy8gaW5saW5lIGh0bWxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICc8JywgZW5kOiAnPicsXG4gICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgLy8gbGlzdHMgKGluZGljYXRvcnMgb25seSlcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYnVsbGV0JyxcbiAgICAgICAgYmVnaW46ICdeKFsqKy1dfChcXFxcZCtcXFxcLikpXFxcXHMrJ1xuICAgICAgfSxcbiAgICAgIC8vIHN0cm9uZyBzZWdtZW50c1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJvbmcnLFxuICAgICAgICBiZWdpbjogJ1sqX117Mn0uKz9bKl9dezJ9J1xuICAgICAgfSxcbiAgICAgIC8vIGVtcGhhc2lzIHNlZ21lbnRzXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2VtcGhhc2lzJyxcbiAgICAgICAgYmVnaW46ICdcXFxcKi4rP1xcXFwqJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZW1waGFzaXMnLFxuICAgICAgICBiZWdpbjogJ18uKz9fJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgLy8gYmxvY2txdW90ZXNcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYmxvY2txdW90ZScsXG4gICAgICAgIGJlZ2luOiAnXj5cXFxccysnLCBlbmQ6ICckJ1xuICAgICAgfSxcbiAgICAgIC8vIGNvZGUgc25pcHBldHNcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29kZScsXG4gICAgICAgIGJlZ2luOiAnYC4rP2AnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb2RlJyxcbiAgICAgICAgYmVnaW46ICdeICAgICcsIGVuZDogJyQnLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICAvLyBob3Jpem9udGFsIHJ1bGVzXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2hvcml6b250YWxfcnVsZScsXG4gICAgICAgIGJlZ2luOiAnXi17Myx9JywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICAvLyB1c2luZyBsaW5rcyAtIHRpdGxlIGFuZCBsaW5rXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnXFxcXFsuKz9cXFxcXVxcXFwoLis/XFxcXCknLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsaW5rX2xhYmVsJyxcbiAgICAgICAgICAgIGJlZ2luOiAnXFxcXFsuK1xcXFxdJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGlua191cmwnLFxuICAgICAgICAgICAgYmVnaW46ICdcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG5cbiAgdmFyIENPTU1PTl9DT05UQUlOUyA9IFtcbiAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFLCB7YmVnaW46ICdcXCdcXCcnfV0sXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9XG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICBrZXl3b3Jkczoge1xuICAgICAga2V5d29yZDpcbiAgICAgICAgJ2JyZWFrIGNhc2UgY2F0Y2ggY2xhc3NkZWYgY29udGludWUgZWxzZSBlbHNlaWYgZW5kIGVudW1lcmF0ZWQgZXZlbnRzIGZvciBmdW5jdGlvbiAnICtcbiAgICAgICAgJ2dsb2JhbCBpZiBtZXRob2RzIG90aGVyd2lzZSBwYXJmb3IgcGVyc2lzdGVudCBwcm9wZXJ0aWVzIHJldHVybiBzcG1kIHN3aXRjaCB0cnkgd2hpbGUnLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgICdzaW4gc2luZCBzaW5oIGFzaW4gYXNpbmQgYXNpbmggY29zIGNvc2QgY29zaCBhY29zIGFjb3NkIGFjb3NoIHRhbiB0YW5kIHRhbmggYXRhbiAnICtcbiAgICAgICAgJ2F0YW5kIGF0YW4yIGF0YW5oIHNlYyBzZWNkIHNlY2ggYXNlYyBhc2VjZCBhc2VjaCBjc2MgY3NjZCBjc2NoIGFjc2MgYWNzY2QgYWNzY2ggY290ICcgK1xuICAgICAgICAnY290ZCBjb3RoIGFjb3QgYWNvdGQgYWNvdGggaHlwb3QgZXhwIGV4cG0xIGxvZyBsb2cxcCBsb2cxMCBsb2cyIHBvdzIgcmVhbHBvdyByZWFsbG9nICcgK1xuICAgICAgICAncmVhbHNxcnQgc3FydCBudGhyb290IG5leHRwb3cyIGFicyBhbmdsZSBjb21wbGV4IGNvbmogaW1hZyByZWFsIHVud3JhcCBpc3JlYWwgJyArXG4gICAgICAgICdjcGx4cGFpciBmaXggZmxvb3IgY2VpbCByb3VuZCBtb2QgcmVtIHNpZ24gYWlyeSBiZXNzZWxqIGJlc3NlbHkgYmVzc2VsaCBiZXNzZWxpICcgK1xuICAgICAgICAnYmVzc2VsayBiZXRhIGJldGFpbmMgYmV0YWxuIGVsbGlwaiBlbGxpcGtlIGVyZiBlcmZjIGVyZmN4IGVyZmludiBleHBpbnQgZ2FtbWEgJyArXG4gICAgICAgICdnYW1tYWluYyBnYW1tYWxuIHBzaSBsZWdlbmRyZSBjcm9zcyBkb3QgZmFjdG9yIGlzcHJpbWUgcHJpbWVzIGdjZCBsY20gcmF0IHJhdHMgcGVybXMgJyArXG4gICAgICAgICduY2hvb3NlayBmYWN0b3JpYWwgY2FydDJzcGggY2FydDJwb2wgcG9sMmNhcnQgc3BoMmNhcnQgaHN2MnJnYiByZ2IyaHN2IHplcm9zIG9uZXMgJyArXG4gICAgICAgICdleWUgcmVwbWF0IHJhbmQgcmFuZG4gbGluc3BhY2UgbG9nc3BhY2UgZnJlcXNwYWNlIG1lc2hncmlkIGFjY3VtYXJyYXkgc2l6ZSBsZW5ndGggJyArXG4gICAgICAgICduZGltcyBudW1lbCBkaXNwIGlzZW1wdHkgaXNlcXVhbCBpc2VxdWFsd2l0aGVxdWFsbmFucyBjYXQgcmVzaGFwZSBkaWFnIGJsa2RpYWcgdHJpbCAnICtcbiAgICAgICAgJ3RyaXUgZmxpcGxyIGZsaXB1ZCBmbGlwZGltIHJvdDkwIGZpbmQgc3ViMmluZCBpbmQyc3ViIGJzeGZ1biBuZGdyaWQgcGVybXV0ZSBpcGVybXV0ZSAnICtcbiAgICAgICAgJ3NoaWZ0ZGltIGNpcmNzaGlmdCBzcXVlZXplIGlzc2NhbGFyIGlzdmVjdG9yIGFucyBlcHMgcmVhbG1heCByZWFsbWluIHBpIGkgaW5mIG5hbiAnICtcbiAgICAgICAgJ2lzbmFuIGlzaW5mIGlzZmluaXRlIGogd2h5IGNvbXBhbiBnYWxsZXJ5IGhhZGFtYXJkIGhhbmtlbCBoaWxiIGludmhpbGIgbWFnaWMgcGFzY2FsICcgK1xuICAgICAgICAncm9zc2VyIHRvZXBsaXR6IHZhbmRlciB3aWxraW5zb24nXG4gICAgfSxcbiAgICBpbGxlZ2FsOiAnKC8vfFwifCN8L1xcXFwqfFxcXFxzKy9cXFxcdyspJyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyQnLFxuICAgICAgICBrZXl3b3JkczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgIGJlZ2luOiAnXFxcXFsnLCBlbmQ6ICdcXFxcXSdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RyYW5zcG9zZWRfdmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogJ1thLXpBLVpfXVthLXpBLVpfMC05XSooXFwnK1tcXFxcLlxcJ10qfFtcXFxcLlxcJ10rKScsIGVuZDogJydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21hdHJpeCcsXG4gICAgICAgIGJlZ2luOiAnXFxcXFsnLCBlbmQ6ICdcXFxcXVxcJypbXFxcXC5cXCddKicsXG4gICAgICAgIGNvbnRhaW5zOiBDT01NT05fQ09OVEFJTlNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NlbGwnLFxuICAgICAgICBiZWdpbjogJ1xcXFx7JywgZW5kOiAnXFxcXH1cXCcqW1xcXFwuXFwnXSonLFxuICAgICAgICBjb250YWluczogQ09NTU9OX0NPTlRBSU5TXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICdcXFxcJScsIGVuZDogJyQnXG4gICAgICB9XG4gICAgXS5jb25jYXQoQ09NTU9OX0NPTlRBSU5TKVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczpcbiAgICAgICdpbnQgZmxvYXQgc3RyaW5nIHZlY3RvciBtYXRyaXggaWYgZWxzZSBzd2l0Y2ggY2FzZSBkZWZhdWx0IHdoaWxlIGRvIGZvciBpbiBicmVhayAnICtcbiAgICAgICdjb250aW51ZSBnbG9iYWwgcHJvYyByZXR1cm4gYWJvdXQgYWJzIGFkZEF0dHIgYWRkQXR0cmlidXRlRWRpdG9yTm9kZUhlbHAgYWRkRHluYW1pYyAnICtcbiAgICAgICdhZGROZXdTaGVsZlRhYiBhZGRQUCBhZGRQYW5lbENhdGVnb3J5IGFkZFByZWZpeFRvTmFtZSBhZHZhbmNlVG9OZXh0RHJpdmVuS2V5ICcgK1xuICAgICAgJ2FmZmVjdGVkTmV0IGFmZmVjdHMgYWltQ29uc3RyYWludCBhaXIgYWxpYXMgYWxpYXNBdHRyIGFsaWduIGFsaWduQ3R4IGFsaWduQ3VydmUgJyArXG4gICAgICAnYWxpZ25TdXJmYWNlIGFsbFZpZXdGaXQgYW1iaWVudExpZ2h0IGFuZ2xlIGFuZ2xlQmV0d2VlbiBhbmltQ29uZSBhbmltQ3VydmVFZGl0b3IgJyArXG4gICAgICAnYW5pbURpc3BsYXkgYW5pbVZpZXcgYW5ub3RhdGUgYXBwZW5kU3RyaW5nQXJyYXkgYXBwbGljYXRpb25OYW1lIGFwcGx5QXR0clByZXNldCAnICtcbiAgICAgICdhcHBseVRha2UgYXJjTGVuRGltQ29udGV4dCBhcmNMZW5ndGhEaW1lbnNpb24gYXJjbGVuIGFycmF5TWFwcGVyIGFydDNkUGFpbnRDdHggJyArXG4gICAgICAnYXJ0QXR0ckN0eCBhcnRBdHRyUGFpbnRWZXJ0ZXhDdHggYXJ0QXR0clNraW5QYWludEN0eCBhcnRBdHRyVG9vbCBhcnRCdWlsZFBhaW50TWVudSAnICtcbiAgICAgICdhcnRGbHVpZEF0dHJDdHggYXJ0UHV0dHlDdHggYXJ0U2VsZWN0Q3R4IGFydFNldFBhaW50Q3R4IGFydFVzZXJQYWludEN0eCBhc3NpZ25Db21tYW5kICcgK1xuICAgICAgJ2Fzc2lnbklucHV0RGV2aWNlIGFzc2lnblZpZXdwb3J0RmFjdG9yaWVzIGF0dGFjaEN1cnZlIGF0dGFjaERldmljZUF0dHIgYXR0YWNoU3VyZmFjZSAnICtcbiAgICAgICdhdHRyQ29sb3JTbGlkZXJHcnAgYXR0ckNvbXBhdGliaWxpdHkgYXR0ckNvbnRyb2xHcnAgYXR0ckVudW1PcHRpb25NZW51ICcgK1xuICAgICAgJ2F0dHJFbnVtT3B0aW9uTWVudUdycCBhdHRyRmllbGRHcnAgYXR0ckZpZWxkU2xpZGVyR3JwIGF0dHJOYXZpZ2F0aW9uQ29udHJvbEdycCAnICtcbiAgICAgICdhdHRyUHJlc2V0RWRpdFdpbiBhdHRyaWJ1dGVFeGlzdHMgYXR0cmlidXRlSW5mbyBhdHRyaWJ1dGVNZW51IGF0dHJpYnV0ZVF1ZXJ5ICcgK1xuICAgICAgJ2F1dG9LZXlmcmFtZSBhdXRvUGxhY2UgYmFrZUNsaXAgYmFrZUZsdWlkU2hhZGluZyBiYWtlUGFydGlhbEhpc3RvcnkgYmFrZVJlc3VsdHMgJyArXG4gICAgICAnYmFrZVNpbXVsYXRpb24gYmFzZW5hbWUgYmFzZW5hbWVFeCBiYXRjaFJlbmRlciBiZXNzZWwgYmV2ZWwgYmV2ZWxQbHVzIGJpbk1lbWJlcnNoaXAgJyArXG4gICAgICAnYmluZFNraW4gYmxlbmQyIGJsZW5kU2hhcGUgYmxlbmRTaGFwZUVkaXRvciBibGVuZFNoYXBlUGFuZWwgYmxlbmRUd29BdHRyIGJsaW5kRGF0YVR5cGUgJyArXG4gICAgICAnYm9uZUxhdHRpY2UgYm91bmRhcnkgYm94RG9sbHlDdHggYm94Wm9vbUN0eCBidWZmZXJDdXJ2ZSBidWlsZEJvb2ttYXJrTWVudSAnICtcbiAgICAgICdidWlsZEtleWZyYW1lTWVudSBidXR0b24gYnV0dG9uTWFuaXAgQ0JHIGNhY2hlRmlsZSBjYWNoZUZpbGVDb21iaW5lIGNhY2hlRmlsZU1lcmdlICcgK1xuICAgICAgJ2NhY2hlRmlsZVRyYWNrIGNhbWVyYSBjYW1lcmFWaWV3IGNhbkNyZWF0ZU1hbmlwIGNhbnZhcyBjYXBpdGFsaXplU3RyaW5nIGNhdGNoICcgK1xuICAgICAgJ2NhdGNoUXVpZXQgY2VpbCBjaGFuZ2VTdWJkaXZDb21wb25lbnREaXNwbGF5TGV2ZWwgY2hhbmdlU3ViZGl2UmVnaW9uIGNoYW5uZWxCb3ggJyArXG4gICAgICAnY2hhcmFjdGVyIGNoYXJhY3Rlck1hcCBjaGFyYWN0ZXJPdXRsaW5lRWRpdG9yIGNoYXJhY3Rlcml6ZSBjaGRpciBjaGVja0JveCBjaGVja0JveEdycCAnICtcbiAgICAgICdjaGVja0RlZmF1bHRSZW5kZXJHbG9iYWxzIGNob2ljZSBjaXJjbGUgY2lyY3VsYXJGaWxsZXQgY2xhbXAgY2xlYXIgY2xlYXJDYWNoZSBjbGlwICcgK1xuICAgICAgJ2NsaXBFZGl0b3IgY2xpcEVkaXRvckN1cnJlbnRUaW1lQ3R4IGNsaXBTY2hlZHVsZSBjbGlwU2NoZWR1bGVyT3V0bGluZXIgY2xpcFRyaW1CZWZvcmUgJyArXG4gICAgICAnY2xvc2VDdXJ2ZSBjbG9zZVN1cmZhY2UgY2x1c3RlciBjbWRGaWxlT3V0cHV0IGNtZFNjcm9sbEZpZWxkRXhlY3V0ZXIgJyArXG4gICAgICAnY21kU2Nyb2xsRmllbGRSZXBvcnRlciBjbWRTaGVsbCBjb2Fyc2VuU3ViZGl2U2VsZWN0aW9uTGlzdCBjb2xsaXNpb24gY29sb3IgJyArXG4gICAgICAnY29sb3JBdFBvaW50IGNvbG9yRWRpdG9yIGNvbG9ySW5kZXggY29sb3JJbmRleFNsaWRlckdycCBjb2xvclNsaWRlckJ1dHRvbkdycCAnICtcbiAgICAgICdjb2xvclNsaWRlckdycCBjb2x1bW5MYXlvdXQgY29tbWFuZEVjaG8gY29tbWFuZExpbmUgY29tbWFuZFBvcnQgY29tcGFjdEhhaXJTeXN0ZW0gJyArXG4gICAgICAnY29tcG9uZW50RWRpdG9yIGNvbXBvc2l0aW5nSW50ZXJvcCBjb21wdXRlUG9seXNldFZvbHVtZSBjb25kaXRpb24gY29uZSBjb25maXJtRGlhbG9nICcgK1xuICAgICAgJ2Nvbm5lY3RBdHRyIGNvbm5lY3RDb250cm9sIGNvbm5lY3REeW5hbWljIGNvbm5lY3RKb2ludCBjb25uZWN0aW9uSW5mbyBjb25zdHJhaW4gJyArXG4gICAgICAnY29uc3RyYWluVmFsdWUgY29uc3RydWN0aW9uSGlzdG9yeSBjb250YWluZXIgY29udGFpbnNNdWx0aWJ5dGUgY29udGV4dEluZm8gY29udHJvbCAnICtcbiAgICAgICdjb252ZXJ0RnJvbU9sZExheWVycyBjb252ZXJ0SWZmVG9Qc2QgY29udmVydExpZ2h0bWFwIGNvbnZlcnRTb2xpZFR4IGNvbnZlcnRUZXNzZWxsYXRpb24gJyArXG4gICAgICAnY29udmVydFVuaXQgY29weUFycmF5IGNvcHlGbGV4b3IgY29weUtleSBjb3B5U2tpbldlaWdodHMgY29zIGNwQnV0dG9uIGNwQ2FjaGUgJyArXG4gICAgICAnY3BDbG90aFNldCBjcENvbGxpc2lvbiBjcENvbnN0cmFpbnQgY3BDb252Q2xvdGhUb01lc2ggY3BGb3JjZXMgY3BHZXRTb2x2ZXJBdHRyIGNwUGFuZWwgJyArXG4gICAgICAnY3BQcm9wZXJ0eSBjcFJpZ2lkQ29sbGlzaW9uRmlsdGVyIGNwU2VhbSBjcFNldEVkaXQgY3BTZXRTb2x2ZXJBdHRyIGNwU29sdmVyICcgK1xuICAgICAgJ2NwU29sdmVyVHlwZXMgY3BUb29sIGNwVXBkYXRlQ2xvdGhVVnMgY3JlYXRlRGlzcGxheUxheWVyIGNyZWF0ZURyYXdDdHggY3JlYXRlRWRpdG9yICcgK1xuICAgICAgJ2NyZWF0ZUxheWVyZWRQc2RGaWxlIGNyZWF0ZU1vdGlvbkZpZWxkIGNyZWF0ZU5ld1NoZWxmIGNyZWF0ZU5vZGUgY3JlYXRlUmVuZGVyTGF5ZXIgJyArXG4gICAgICAnY3JlYXRlU3ViZGl2UmVnaW9uIGNyb3NzIGNyb3NzUHJvZHVjdCBjdHhBYm9ydCBjdHhDb21wbGV0aW9uIGN0eEVkaXRNb2RlIGN0eFRyYXZlcnNlICcgK1xuICAgICAgJ2N1cnJlbnRDdHggY3VycmVudFRpbWUgY3VycmVudFRpbWVDdHggY3VycmVudFVuaXQgY3VycmVudFVuaXQgY3VydmUgY3VydmVBZGRQdEN0eCAnICtcbiAgICAgICdjdXJ2ZUNWQ3R4IGN1cnZlRVBDdHggY3VydmVFZGl0b3JDdHggY3VydmVJbnRlcnNlY3QgY3VydmVNb3ZlRVBDdHggY3VydmVPblN1cmZhY2UgJyArXG4gICAgICAnY3VydmVTa2V0Y2hDdHggY3V0S2V5IGN5Y2xlQ2hlY2sgY3lsaW5kZXIgZGFnUG9zZSBkYXRlIGRlZmF1bHRMaWdodExpc3RDaGVja0JveCAnICtcbiAgICAgICdkZWZhdWx0TmF2aWdhdGlvbiBkZWZpbmVEYXRhU2VydmVyIGRlZmluZVZpcnR1YWxEZXZpY2UgZGVmb3JtZXIgZGVnX3RvX3JhZCBkZWxldGUgJyArXG4gICAgICAnZGVsZXRlQXR0ciBkZWxldGVTaGFkaW5nR3JvdXBzQW5kTWF0ZXJpYWxzIGRlbGV0ZVNoZWxmVGFiIGRlbGV0ZVVJIGRlbGV0ZVVudXNlZEJydXNoZXMgJyArXG4gICAgICAnZGVscmFuZHN0ciBkZXRhY2hDdXJ2ZSBkZXRhY2hEZXZpY2VBdHRyIGRldGFjaFN1cmZhY2UgZGV2aWNlRWRpdG9yIGRldmljZVBhbmVsIGRnSW5mbyAnICtcbiAgICAgICdkZ2RpcnR5IGRnZXZhbCBkZ3RpbWVyIGRpbVdoZW4gZGlyZWN0S2V5Q3R4IGRpcmVjdGlvbmFsTGlnaHQgZGlybWFwIGRpcm5hbWUgZGlzYWJsZSAnICtcbiAgICAgICdkaXNjb25uZWN0QXR0ciBkaXNjb25uZWN0Sm9pbnQgZGlza0NhY2hlIGRpc3BsYWNlbWVudFRvUG9seSBkaXNwbGF5QWZmZWN0ZWQgJyArXG4gICAgICAnZGlzcGxheUNvbG9yIGRpc3BsYXlDdWxsIGRpc3BsYXlMZXZlbE9mRGV0YWlsIGRpc3BsYXlQcmVmIGRpc3BsYXlSR0JDb2xvciAnICtcbiAgICAgICdkaXNwbGF5U21vb3RobmVzcyBkaXNwbGF5U3RhdHMgZGlzcGxheVN0cmluZyBkaXNwbGF5U3VyZmFjZSBkaXN0YW5jZURpbUNvbnRleHQgJyArXG4gICAgICAnZGlzdGFuY2VEaW1lbnNpb24gZG9CbHVyIGRvbGx5IGRvbGx5Q3R4IGRvcGVTaGVldEVkaXRvciBkb3QgZG90UHJvZHVjdCAnICtcbiAgICAgICdkb3VibGVQcm9maWxlQmlyYWlsU3VyZmFjZSBkcmFnIGRyYWdBdHRyQ29udGV4dCBkcmFnZ2VyQ29udGV4dCBkcm9wb2ZmTG9jYXRvciAnICtcbiAgICAgICdkdXBsaWNhdGUgZHVwbGljYXRlQ3VydmUgZHVwbGljYXRlU3VyZmFjZSBkeW5DYWNoZSBkeW5Db250cm9sIGR5bkV4cG9ydCBkeW5FeHByZXNzaW9uICcgK1xuICAgICAgJ2R5bkdsb2JhbHMgZHluUGFpbnRFZGl0b3IgZHluUGFydGljbGVDdHggZHluUHJlZiBkeW5SZWxFZFBhbmVsIGR5blJlbEVkaXRvciAnICtcbiAgICAgICdkeW5hbWljTG9hZCBlZGl0QXR0ckxpbWl0cyBlZGl0RGlzcGxheUxheWVyR2xvYmFscyBlZGl0RGlzcGxheUxheWVyTWVtYmVycyAnICtcbiAgICAgICdlZGl0UmVuZGVyTGF5ZXJBZGp1c3RtZW50IGVkaXRSZW5kZXJMYXllckdsb2JhbHMgZWRpdFJlbmRlckxheWVyTWVtYmVycyBlZGl0b3IgJyArXG4gICAgICAnZWRpdG9yVGVtcGxhdGUgZWZmZWN0b3IgZW1pdCBlbWl0dGVyIGVuYWJsZURldmljZSBlbmNvZGVTdHJpbmcgZW5kU3RyaW5nIGVuZHNXaXRoIGVudiAnICtcbiAgICAgICdlcXVpdmFsZW50IGVxdWl2YWxlbnRUb2wgZXJmIGVycm9yIGV2YWwgZXZhbCBldmFsRGVmZXJyZWQgZXZhbEVjaG8gZXZlbnQgJyArXG4gICAgICAnZXhhY3RXb3JsZEJvdW5kaW5nQm94IGV4Y2x1c2l2ZUxpZ2h0Q2hlY2tCb3ggZXhlYyBleGVjdXRlRm9yRWFjaE9iamVjdCBleGlzdHMgZXhwICcgK1xuICAgICAgJ2V4cHJlc3Npb24gZXhwcmVzc2lvbkVkaXRvckxpc3RlbiBleHRlbmRDdXJ2ZSBleHRlbmRTdXJmYWNlIGV4dHJ1ZGUgZmNoZWNrIGZjbG9zZSBmZW9mICcgK1xuICAgICAgJ2ZmbHVzaCBmZ2V0bGluZSBmZ2V0d29yZCBmaWxlIGZpbGVCcm93c2VyRGlhbG9nIGZpbGVEaWFsb2cgZmlsZUV4dGVuc2lvbiBmaWxlSW5mbyAnICtcbiAgICAgICdmaWxldGVzdCBmaWxsZXRDdXJ2ZSBmaWx0ZXIgZmlsdGVyQ3VydmUgZmlsdGVyRXhwYW5kIGZpbHRlclN0dWRpb0ltcG9ydCAnICtcbiAgICAgICdmaW5kQWxsSW50ZXJzZWN0aW9ucyBmaW5kQW5pbUN1cnZlcyBmaW5kS2V5ZnJhbWUgZmluZE1lbnVJdGVtIGZpbmRSZWxhdGVkU2tpbkNsdXN0ZXIgJyArXG4gICAgICAnZmluZGVyIGZpcnN0UGFyZW50T2YgZml0QnNwbGluZSBmbGV4b3IgZmxvYXRFcSBmbG9hdEZpZWxkIGZsb2F0RmllbGRHcnAgZmxvYXRTY3JvbGxCYXIgJyArXG4gICAgICAnZmxvYXRTbGlkZXIgZmxvYXRTbGlkZXIyIGZsb2F0U2xpZGVyQnV0dG9uR3JwIGZsb2F0U2xpZGVyR3JwIGZsb29yIGZsb3cgZmx1aWRDYWNoZUluZm8gJyArXG4gICAgICAnZmx1aWRFbWl0dGVyIGZsdWlkVm94ZWxJbmZvIGZsdXNoVW5kbyBmbW9kIGZvbnREaWFsb2cgZm9wZW4gZm9ybUxheW91dCBmb3JtYXQgZnByaW50ICcgK1xuICAgICAgJ2ZyYW1lTGF5b3V0IGZyZWFkIGZyZWVGb3JtRmlsbGV0IGZyZXdpbmQgZnJvbU5hdGl2ZVBhdGggZndyaXRlIGdhbW1hIGdhdXNzICcgK1xuICAgICAgJ2dlb21ldHJ5Q29uc3RyYWludCBnZXRBcHBsaWNhdGlvblZlcnNpb25Bc0Zsb2F0IGdldEF0dHIgZ2V0Q2xhc3NpZmljYXRpb24gJyArXG4gICAgICAnZ2V0RGVmYXVsdEJydXNoIGdldEZpbGVMaXN0IGdldEZsdWlkQXR0ciBnZXRJbnB1dERldmljZVJhbmdlIGdldE1heWFQYW5lbFR5cGVzICcgK1xuICAgICAgJ2dldE1vZGlmaWVycyBnZXRQYW5lbCBnZXRQYXJ0aWNsZUF0dHIgZ2V0UGx1Z2luUmVzb3VyY2UgZ2V0ZW52IGdldHBpZCBnbFJlbmRlciAnICtcbiAgICAgICdnbFJlbmRlckVkaXRvciBnbG9iYWxTdGl0Y2ggZ21hdGNoIGdvYWwgZ290b0JpbmRQb3NlIGdyYWJDb2xvciBncmFkaWVudENvbnRyb2wgJyArXG4gICAgICAnZ3JhZGllbnRDb250cm9sTm9BdHRyIGdyYXBoRG9sbHlDdHggZ3JhcGhTZWxlY3RDb250ZXh0IGdyYXBoVHJhY2tDdHggZ3Jhdml0eSBncmlkICcgK1xuICAgICAgJ2dyaWRMYXlvdXQgZ3JvdXAgZ3JvdXBPYmplY3RzQnlOYW1lIEhmQWRkQXR0cmFjdG9yVG9BUyBIZkFzc2lnbkFTIEhmQnVpbGRFcXVhbE1hcCAnICtcbiAgICAgICdIZkJ1aWxkRnVyRmlsZXMgSGZCdWlsZEZ1ckltYWdlcyBIZkNhbmNlbEFGUiBIZkNvbm5lY3RBU1RvSEYgSGZDcmVhdGVBdHRyYWN0b3IgJyArXG4gICAgICAnSGZEZWxldGVBUyBIZkVkaXRBUyBIZlBlcmZvcm1DcmVhdGVBUyBIZlJlbW92ZUF0dHJhY3RvckZyb21BUyBIZlNlbGVjdEF0dGFjaGVkICcgK1xuICAgICAgJ0hmU2VsZWN0QXR0cmFjdG9ycyBIZlVuQXNzaWduQVMgaGFyZGVuUG9pbnRDdXJ2ZSBoYXJkd2FyZSBoYXJkd2FyZVJlbmRlclBhbmVsICcgK1xuICAgICAgJ2hlYWRzVXBEaXNwbGF5IGhlYWRzVXBNZXNzYWdlIGhlbHAgaGVscExpbmUgaGVybWl0ZSBoaWRlIGhpbGl0ZSBoaXRUZXN0IGhvdEJveCBob3RrZXkgJyArXG4gICAgICAnaG90a2V5Q2hlY2sgaHN2X3RvX3JnYiBodWRCdXR0b24gaHVkU2xpZGVyIGh1ZFNsaWRlckJ1dHRvbiBod1JlZmxlY3Rpb25NYXAgaHdSZW5kZXIgJyArXG4gICAgICAnaHdSZW5kZXJMb2FkIGh5cGVyR3JhcGggaHlwZXJQYW5lbCBoeXBlclNoYWRlIGh5cG90IGljb25UZXh0QnV0dG9uIGljb25UZXh0Q2hlY2tCb3ggJyArXG4gICAgICAnaWNvblRleHRSYWRpb0J1dHRvbiBpY29uVGV4dFJhZGlvQ29sbGVjdGlvbiBpY29uVGV4dFNjcm9sbExpc3QgaWNvblRleHRTdGF0aWNMYWJlbCAnICtcbiAgICAgICdpa0hhbmRsZSBpa0hhbmRsZUN0eCBpa0hhbmRsZURpc3BsYXlTY2FsZSBpa1NvbHZlciBpa1NwbGluZUhhbmRsZUN0eCBpa1N5c3RlbSAnICtcbiAgICAgICdpa1N5c3RlbUluZm8gaWtma0Rpc3BsYXlNZXRob2QgaWxsdXN0cmF0b3JDdXJ2ZXMgaW1hZ2UgaW1mUGx1Z2lucyBpbmhlcml0VHJhbnNmb3JtICcgK1xuICAgICAgJ2luc2VydEpvaW50IGluc2VydEpvaW50Q3R4IGluc2VydEtleUN0eCBpbnNlcnRLbm90Q3VydmUgaW5zZXJ0S25vdFN1cmZhY2UgaW5zdGFuY2UgJyArXG4gICAgICAnaW5zdGFuY2VhYmxlIGluc3RhbmNlciBpbnRGaWVsZCBpbnRGaWVsZEdycCBpbnRTY3JvbGxCYXIgaW50U2xpZGVyIGludFNsaWRlckdycCAnICtcbiAgICAgICdpbnRlclRvVUkgaW50ZXJuYWxWYXIgaW50ZXJzZWN0IGlwckVuZ2luZSBpc0FuaW1DdXJ2ZSBpc0Nvbm5lY3RlZCBpc0RpcnR5IGlzUGFyZW50T2YgJyArXG4gICAgICAnaXNTYW1lT2JqZWN0IGlzVHJ1ZSBpc1ZhbGlkT2JqZWN0TmFtZSBpc1ZhbGlkU3RyaW5nIGlzVmFsaWRVaU5hbWUgaXNvbGF0ZVNlbGVjdCAnICtcbiAgICAgICdpdGVtRmlsdGVyIGl0ZW1GaWx0ZXJBdHRyIGl0ZW1GaWx0ZXJSZW5kZXIgaXRlbUZpbHRlclR5cGUgam9pbnQgam9pbnRDbHVzdGVyIGpvaW50Q3R4ICcgK1xuICAgICAgJ2pvaW50RGlzcGxheVNjYWxlIGpvaW50TGF0dGljZSBrZXlUYW5nZW50IGtleWZyYW1lIGtleWZyYW1lT3V0bGluZXIgJyArXG4gICAgICAna2V5ZnJhbWVSZWdpb25DdXJyZW50VGltZUN0eCBrZXlmcmFtZVJlZ2lvbkRpcmVjdEtleUN0eCBrZXlmcmFtZVJlZ2lvbkRvbGx5Q3R4ICcgK1xuICAgICAgJ2tleWZyYW1lUmVnaW9uSW5zZXJ0S2V5Q3R4IGtleWZyYW1lUmVnaW9uTW92ZUtleUN0eCBrZXlmcmFtZVJlZ2lvblNjYWxlS2V5Q3R4ICcgK1xuICAgICAgJ2tleWZyYW1lUmVnaW9uU2VsZWN0S2V5Q3R4IGtleWZyYW1lUmVnaW9uU2V0S2V5Q3R4IGtleWZyYW1lUmVnaW9uVHJhY2tDdHggJyArXG4gICAgICAna2V5ZnJhbWVTdGF0cyBsYXNzb0NvbnRleHQgbGF0dGljZSBsYXR0aWNlRGVmb3JtS2V5Q3R4IGxhdW5jaCBsYXVuY2hJbWFnZUVkaXRvciAnICtcbiAgICAgICdsYXllckJ1dHRvbiBsYXllcmVkU2hhZGVyUG9ydCBsYXllcmVkVGV4dHVyZVBvcnQgbGF5b3V0IGxheW91dERpYWxvZyBsaWdodExpc3QgJyArXG4gICAgICAnbGlnaHRMaXN0RWRpdG9yIGxpZ2h0TGlzdFBhbmVsIGxpZ2h0bGluayBsaW5lSW50ZXJzZWN0aW9uIGxpbmVhclByZWNpc2lvbiBsaW5zdGVwICcgK1xuICAgICAgJ2xpc3RBbmltYXRhYmxlIGxpc3RBdHRyIGxpc3RDYW1lcmFzIGxpc3RDb25uZWN0aW9ucyBsaXN0RGV2aWNlQXR0YWNobWVudHMgbGlzdEhpc3RvcnkgJyArXG4gICAgICAnbGlzdElucHV0RGV2aWNlQXhlcyBsaXN0SW5wdXREZXZpY2VCdXR0b25zIGxpc3RJbnB1dERldmljZXMgbGlzdE1lbnVBbm5vdGF0aW9uICcgK1xuICAgICAgJ2xpc3ROb2RlVHlwZXMgbGlzdFBhbmVsQ2F0ZWdvcmllcyBsaXN0UmVsYXRpdmVzIGxpc3RTZXRzIGxpc3RUcmFuc2Zvcm1zICcgK1xuICAgICAgJ2xpc3RVbnNlbGVjdGVkIGxpc3RlckVkaXRvciBsb2FkRmx1aWQgbG9hZE5ld1NoZWxmIGxvYWRQbHVnaW4gJyArXG4gICAgICAnbG9hZFBsdWdpbkxhbmd1YWdlUmVzb3VyY2VzIGxvYWRQcmVmT2JqZWN0cyBsb2NhbGl6ZWRQYW5lbExhYmVsIGxvY2tOb2RlIGxvZnQgbG9nICcgK1xuICAgICAgJ2xvbmdOYW1lT2YgbG9va1RocnUgbHMgbHNUaHJvdWdoRmlsdGVyIGxzVHlwZSBsc1VJIE1heWF0b21yIG1hZyBtYWtlSWRlbnRpdHkgbWFrZUxpdmUgJyArXG4gICAgICAnbWFrZVBhaW50YWJsZSBtYWtlUm9sbCBtYWtlU2luZ2xlU3VyZmFjZSBtYWtlVHViZU9uIG1ha2Vib3QgbWFuaXBNb3ZlQ29udGV4dCAnICtcbiAgICAgICdtYW5pcE1vdmVMaW1pdHNDdHggbWFuaXBPcHRpb25zIG1hbmlwUm90YXRlQ29udGV4dCBtYW5pcFJvdGF0ZUxpbWl0c0N0eCAnICtcbiAgICAgICdtYW5pcFNjYWxlQ29udGV4dCBtYW5pcFNjYWxlTGltaXRzQ3R4IG1hcmtlciBtYXRjaCBtYXggbWVtb3J5IG1lbnUgbWVudUJhckxheW91dCAnICtcbiAgICAgICdtZW51RWRpdG9yIG1lbnVJdGVtIG1lbnVJdGVtVG9TaGVsZiBtZW51U2V0IG1lbnVTZXRQcmVmIG1lc3NhZ2VMaW5lIG1pbiBtaW5pbWl6ZUFwcCAnICtcbiAgICAgICdtaXJyb3JKb2ludCBtb2RlbEN1cnJlbnRUaW1lQ3R4IG1vZGVsRWRpdG9yIG1vZGVsUGFuZWwgbW91c2UgbW92SW4gbW92T3V0IG1vdmUgJyArXG4gICAgICAnbW92ZUlLdG9GSyBtb3ZlS2V5Q3R4IG1vdmVWZXJ0ZXhBbG9uZ0RpcmVjdGlvbiBtdWx0aVByb2ZpbGVCaXJhaWxTdXJmYWNlIG11dGUgJyArXG4gICAgICAnblBhcnRpY2xlIG5hbWVDb21tYW5kIG5hbWVGaWVsZCBuYW1lc3BhY2UgbmFtZXNwYWNlSW5mbyBuZXdQYW5lbEl0ZW1zIG5ld3RvbiBub2RlQ2FzdCAnICtcbiAgICAgICdub2RlSWNvbkJ1dHRvbiBub2RlT3V0bGluZXIgbm9kZVByZXNldCBub2RlVHlwZSBub2lzZSBub25MaW5lYXIgbm9ybWFsQ29uc3RyYWludCAnICtcbiAgICAgICdub3JtYWxpemUgbnVyYnNCb29sZWFuIG51cmJzQ29weVVWU2V0IG51cmJzQ3ViZSBudXJic0VkaXRVViBudXJic1BsYW5lIG51cmJzU2VsZWN0ICcgK1xuICAgICAgJ251cmJzU3F1YXJlIG51cmJzVG9Qb2x5IG51cmJzVG9Qb2x5Z29uc1ByZWYgbnVyYnNUb1N1YmRpdiBudXJic1RvU3ViZGl2UHJlZiAnICtcbiAgICAgICdudXJic1VWU2V0IG51cmJzVmlld0RpcmVjdGlvblZlY3RvciBvYmpFeGlzdHMgb2JqZWN0Q2VudGVyIG9iamVjdExheWVyIG9iamVjdFR5cGUgJyArXG4gICAgICAnb2JqZWN0VHlwZVVJIG9ic29sZXRlUHJvYyBvY2Vhbk51cmJzUHJldmlld1BsYW5lIG9mZnNldEN1cnZlIG9mZnNldEN1cnZlT25TdXJmYWNlICcgK1xuICAgICAgJ29mZnNldFN1cmZhY2Ugb3BlbkdMRXh0ZW5zaW9uIG9wZW5NYXlhUHJlZiBvcHRpb25NZW51IG9wdGlvbk1lbnVHcnAgb3B0aW9uVmFyIG9yYml0ICcgK1xuICAgICAgJ29yYml0Q3R4IG9yaWVudENvbnN0cmFpbnQgb3V0bGluZXJFZGl0b3Igb3V0bGluZXJQYW5lbCBvdmVycmlkZU1vZGlmaWVyICcgK1xuICAgICAgJ3BhaW50RWZmZWN0c0Rpc3BsYXkgcGFpckJsZW5kIHBhbGV0dGVQb3J0IHBhbmVMYXlvdXQgcGFuZWwgcGFuZWxDb25maWd1cmF0aW9uICcgK1xuICAgICAgJ3BhbmVsSGlzdG9yeSBwYXJhbURpbUNvbnRleHQgcGFyYW1EaW1lbnNpb24gcGFyYW1Mb2NhdG9yIHBhcmVudCBwYXJlbnRDb25zdHJhaW50ICcgK1xuICAgICAgJ3BhcnRpY2xlIHBhcnRpY2xlRXhpc3RzIHBhcnRpY2xlSW5zdGFuY2VyIHBhcnRpY2xlUmVuZGVySW5mbyBwYXJ0aXRpb24gcGFzdGVLZXkgJyArXG4gICAgICAncGF0aEFuaW1hdGlvbiBwYXVzZSBwY2xvc2UgcGVyY2VudCBwZXJmb3JtYW5jZU9wdGlvbnMgcGZ4c3Ryb2tlcyBwaWNrV2FsayBwaWN0dXJlICcgK1xuICAgICAgJ3BpeGVsTW92ZSBwbGFuYXJTcmYgcGxhbmUgcGxheSBwbGF5YmFja09wdGlvbnMgcGxheWJsYXN0IHBsdWdBdHRyIHBsdWdOb2RlIHBsdWdpbkluZm8gJyArXG4gICAgICAncGx1Z2luUmVzb3VyY2VVdGlsIHBvaW50Q29uc3RyYWludCBwb2ludEN1cnZlQ29uc3RyYWludCBwb2ludExpZ2h0IHBvaW50TWF0cml4TXVsdCAnICtcbiAgICAgICdwb2ludE9uQ3VydmUgcG9pbnRPblN1cmZhY2UgcG9pbnRQb3NpdGlvbiBwb2xlVmVjdG9yQ29uc3RyYWludCBwb2x5QXBwZW5kICcgK1xuICAgICAgJ3BvbHlBcHBlbmRGYWNldEN0eCBwb2x5QXBwZW5kVmVydGV4IHBvbHlBdXRvUHJvamVjdGlvbiBwb2x5QXZlcmFnZU5vcm1hbCAnICtcbiAgICAgICdwb2x5QXZlcmFnZVZlcnRleCBwb2x5QmV2ZWwgcG9seUJsZW5kQ29sb3IgcG9seUJsaW5kRGF0YSBwb2x5Qm9vbE9wIHBvbHlCcmlkZ2VFZGdlICcgK1xuICAgICAgJ3BvbHlDYWNoZU1vbml0b3IgcG9seUNoZWNrIHBvbHlDaGlwT2ZmIHBvbHlDbGlwYm9hcmQgcG9seUNsb3NlQm9yZGVyIHBvbHlDb2xsYXBzZUVkZ2UgJyArXG4gICAgICAncG9seUNvbGxhcHNlRmFjZXQgcG9seUNvbG9yQmxpbmREYXRhIHBvbHlDb2xvckRlbCBwb2x5Q29sb3JQZXJWZXJ0ZXggcG9seUNvbG9yU2V0ICcgK1xuICAgICAgJ3BvbHlDb21wYXJlIHBvbHlDb25lIHBvbHlDb3B5VVYgcG9seUNyZWFzZSBwb2x5Q3JlYXNlQ3R4IHBvbHlDcmVhdGVGYWNldCAnICtcbiAgICAgICdwb2x5Q3JlYXRlRmFjZXRDdHggcG9seUN1YmUgcG9seUN1dCBwb2x5Q3V0Q3R4IHBvbHlDeWxpbmRlciBwb2x5Q3lsaW5kcmljYWxQcm9qZWN0aW9uICcgK1xuICAgICAgJ3BvbHlEZWxFZGdlIHBvbHlEZWxGYWNldCBwb2x5RGVsVmVydGV4IHBvbHlEdXBsaWNhdGVBbmRDb25uZWN0IHBvbHlEdXBsaWNhdGVFZGdlICcgK1xuICAgICAgJ3BvbHlFZGl0VVYgcG9seUVkaXRVVlNoZWxsIHBvbHlFdmFsdWF0ZSBwb2x5RXh0cnVkZUVkZ2UgcG9seUV4dHJ1ZGVGYWNldCAnICtcbiAgICAgICdwb2x5RXh0cnVkZVZlcnRleCBwb2x5RmxpcEVkZ2UgcG9seUZsaXBVViBwb2x5Rm9yY2VVViBwb2x5R2VvU2FtcGxlciBwb2x5SGVsaXggJyArXG4gICAgICAncG9seUluZm8gcG9seUluc3RhbGxBY3Rpb24gcG9seUxheW91dFVWIHBvbHlMaXN0Q29tcG9uZW50Q29udmVyc2lvbiBwb2x5TWFwQ3V0ICcgK1xuICAgICAgJ3BvbHlNYXBEZWwgcG9seU1hcFNldyBwb2x5TWFwU2V3TW92ZSBwb2x5TWVyZ2VFZGdlIHBvbHlNZXJnZUVkZ2VDdHggcG9seU1lcmdlRmFjZXQgJyArXG4gICAgICAncG9seU1lcmdlRmFjZXRDdHggcG9seU1lcmdlVVYgcG9seU1lcmdlVmVydGV4IHBvbHlNaXJyb3JGYWNlIHBvbHlNb3ZlRWRnZSAnICtcbiAgICAgICdwb2x5TW92ZUZhY2V0IHBvbHlNb3ZlRmFjZXRVViBwb2x5TW92ZVVWIHBvbHlNb3ZlVmVydGV4IHBvbHlOb3JtYWwgcG9seU5vcm1hbFBlclZlcnRleCAnICtcbiAgICAgICdwb2x5Tm9ybWFsaXplVVYgcG9seU9wdFV2cyBwb2x5T3B0aW9ucyBwb2x5T3V0cHV0IHBvbHlQaXBlIHBvbHlQbGFuYXJQcm9qZWN0aW9uICcgK1xuICAgICAgJ3BvbHlQbGFuZSBwb2x5UGxhdG9uaWNTb2xpZCBwb2x5UG9rZSBwb2x5UHJpbWl0aXZlIHBvbHlQcmlzbSBwb2x5UHJvamVjdGlvbiAnICtcbiAgICAgICdwb2x5UHlyYW1pZCBwb2x5UXVhZCBwb2x5UXVlcnlCbGluZERhdGEgcG9seVJlZHVjZSBwb2x5U2VsZWN0IHBvbHlTZWxlY3RDb25zdHJhaW50ICcgK1xuICAgICAgJ3BvbHlTZWxlY3RDb25zdHJhaW50TW9uaXRvciBwb2x5U2VsZWN0Q3R4IHBvbHlTZWxlY3RFZGl0Q3R4IHBvbHlTZXBhcmF0ZSAnICtcbiAgICAgICdwb2x5U2V0VG9GYWNlTm9ybWFsIHBvbHlTZXdFZGdlIHBvbHlTaG9ydGVzdFBhdGhDdHggcG9seVNtb290aCBwb2x5U29mdEVkZ2UgJyArXG4gICAgICAncG9seVNwaGVyZSBwb2x5U3BoZXJpY2FsUHJvamVjdGlvbiBwb2x5U3BsaXQgcG9seVNwbGl0Q3R4IHBvbHlTcGxpdEVkZ2UgcG9seVNwbGl0UmluZyAnICtcbiAgICAgICdwb2x5U3BsaXRWZXJ0ZXggcG9seVN0cmFpZ2h0ZW5VVkJvcmRlciBwb2x5U3ViZGl2aWRlRWRnZSBwb2x5U3ViZGl2aWRlRmFjZXQgJyArXG4gICAgICAncG9seVRvU3ViZGl2IHBvbHlUb3J1cyBwb2x5VHJhbnNmZXIgcG9seVRyaWFuZ3VsYXRlIHBvbHlVVlNldCBwb2x5VW5pdGUgcG9seVdlZGdlRmFjZSAnICtcbiAgICAgICdwb3BlbiBwb3B1cE1lbnUgcG9zZSBwb3cgcHJlbG9hZFJlZkVkIHByaW50IHByb2dyZXNzQmFyIHByb2dyZXNzV2luZG93IHByb2pGaWxlVmlld2VyICcgK1xuICAgICAgJ3Byb2plY3RDdXJ2ZSBwcm9qZWN0VGFuZ2VudCBwcm9qZWN0aW9uQ29udGV4dCBwcm9qZWN0aW9uTWFuaXAgcHJvbXB0RGlhbG9nIHByb3BNb2RDdHggJyArXG4gICAgICAncHJvcE1vdmUgcHNkQ2hhbm5lbE91dGxpbmVyIHBzZEVkaXRUZXh0dXJlRmlsZSBwc2RFeHBvcnQgcHNkVGV4dHVyZUZpbGUgcHV0ZW52IHB3ZCAnICtcbiAgICAgICdweXRob24gcXVlcnlTdWJkaXYgcXVpdCByYWRfdG9fZGVnIHJhZGlhbCByYWRpb0J1dHRvbiByYWRpb0J1dHRvbkdycCByYWRpb0NvbGxlY3Rpb24gJyArXG4gICAgICAncmFkaW9NZW51SXRlbUNvbGxlY3Rpb24gcmFtcENvbG9yUG9ydCByYW5kIHJhbmRvbWl6ZUZvbGxpY2xlcyByYW5kc3RhdGUgcmFuZ2VDb250cm9sICcgK1xuICAgICAgJ3JlYWRUYWtlIHJlYnVpbGRDdXJ2ZSByZWJ1aWxkU3VyZmFjZSByZWNvcmRBdHRyIHJlY29yZERldmljZSByZWRvIHJlZmVyZW5jZSAnICtcbiAgICAgICdyZWZlcmVuY2VFZGl0IHJlZmVyZW5jZVF1ZXJ5IHJlZmluZVN1YmRpdlNlbGVjdGlvbkxpc3QgcmVmcmVzaCByZWZyZXNoQUUgJyArXG4gICAgICAncmVnaXN0ZXJQbHVnaW5SZXNvdXJjZSByZWhhc2ggcmVsb2FkSW1hZ2UgcmVtb3ZlSm9pbnQgcmVtb3ZlTXVsdGlJbnN0YW5jZSAnICtcbiAgICAgICdyZW1vdmVQYW5lbENhdGVnb3J5IHJlbmFtZSByZW5hbWVBdHRyIHJlbmFtZVNlbGVjdGlvbkxpc3QgcmVuYW1lVUkgcmVuZGVyICcgK1xuICAgICAgJ3JlbmRlckdsb2JhbHNOb2RlIHJlbmRlckluZm8gcmVuZGVyTGF5ZXJCdXR0b24gcmVuZGVyTGF5ZXJQYXJlbnQgJyArXG4gICAgICAncmVuZGVyTGF5ZXJQb3N0UHJvY2VzcyByZW5kZXJMYXllclVucGFyZW50IHJlbmRlck1hbmlwIHJlbmRlclBhcnRpdGlvbiAnICtcbiAgICAgICdyZW5kZXJRdWFsaXR5Tm9kZSByZW5kZXJTZXR0aW5ncyByZW5kZXJUaHVtYm5haWxVcGRhdGUgcmVuZGVyV2luZG93RWRpdG9yICcgK1xuICAgICAgJ3JlbmRlcldpbmRvd1NlbGVjdENvbnRleHQgcmVuZGVyZXIgcmVvcmRlciByZW9yZGVyRGVmb3JtZXJzIHJlcXVpcmVzIHJlcm9vdCAnICtcbiAgICAgICdyZXNhbXBsZUZsdWlkIHJlc2V0QUUgcmVzZXRQZnhUb1BvbHlDYW1lcmEgcmVzZXRUb29sIHJlc29sdXRpb25Ob2RlIHJldGFyZ2V0ICcgK1xuICAgICAgJ3JldmVyc2VDdXJ2ZSByZXZlcnNlU3VyZmFjZSByZXZvbHZlIHJnYl90b19oc3YgcmlnaWRCb2R5IHJpZ2lkU29sdmVyIHJvbGwgcm9sbEN0eCAnICtcbiAgICAgICdyb290T2Ygcm90IHJvdGF0ZSByb3RhdGlvbkludGVycG9sYXRpb24gcm91bmRDb25zdGFudFJhZGl1cyByb3dDb2x1bW5MYXlvdXQgcm93TGF5b3V0ICcgK1xuICAgICAgJ3J1blRpbWVDb21tYW5kIHJ1bnVwIHNhbXBsZUltYWdlIHNhdmVBbGxTaGVsdmVzIHNhdmVBdHRyUHJlc2V0IHNhdmVGbHVpZCBzYXZlSW1hZ2UgJyArXG4gICAgICAnc2F2ZUluaXRpYWxTdGF0ZSBzYXZlTWVudSBzYXZlUHJlZk9iamVjdHMgc2F2ZVByZWZzIHNhdmVTaGVsZiBzYXZlVG9vbFNldHRpbmdzIHNjYWxlICcgK1xuICAgICAgJ3NjYWxlQnJ1c2hCcmlnaHRuZXNzIHNjYWxlQ29tcG9uZW50cyBzY2FsZUNvbnN0cmFpbnQgc2NhbGVLZXkgc2NhbGVLZXlDdHggc2NlbmVFZGl0b3IgJyArXG4gICAgICAnc2NlbmVVSVJlcGxhY2VtZW50IHNjbWggc2NyaXB0Q3R4IHNjcmlwdEVkaXRvckluZm8gc2NyaXB0Sm9iIHNjcmlwdE5vZGUgc2NyaXB0VGFibGUgJyArXG4gICAgICAnc2NyaXB0VG9TaGVsZiBzY3JpcHRlZFBhbmVsIHNjcmlwdGVkUGFuZWxUeXBlIHNjcm9sbEZpZWxkIHNjcm9sbExheW91dCBzY3VscHQgJyArXG4gICAgICAnc2VhcmNoUGF0aEFycmF5IHNlZWQgc2VsTG9hZFNldHRpbmdzIHNlbGVjdCBzZWxlY3RDb250ZXh0IHNlbGVjdEN1cnZlQ1Ygc2VsZWN0S2V5ICcgK1xuICAgICAgJ3NlbGVjdEtleUN0eCBzZWxlY3RLZXlmcmFtZVJlZ2lvbkN0eCBzZWxlY3RNb2RlIHNlbGVjdFByZWYgc2VsZWN0UHJpb3JpdHkgc2VsZWN0VHlwZSAnICtcbiAgICAgICdzZWxlY3RlZE5vZGVzIHNlbGVjdGlvbkNvbm5lY3Rpb24gc2VwYXJhdG9yIHNldEF0dHIgc2V0QXR0ckVudW1SZXNvdXJjZSAnICtcbiAgICAgICdzZXRBdHRyTWFwcGluZyBzZXRBdHRyTmljZU5hbWVSZXNvdXJjZSBzZXRDb25zdHJhaW50UmVzdFBvc2l0aW9uICcgK1xuICAgICAgJ3NldERlZmF1bHRTaGFkaW5nR3JvdXAgc2V0RHJpdmVuS2V5ZnJhbWUgc2V0RHluYW1pYyBzZXRFZGl0Q3R4IHNldEVkaXRvciBzZXRGbHVpZEF0dHIgJyArXG4gICAgICAnc2V0Rm9jdXMgc2V0SW5maW5pdHkgc2V0SW5wdXREZXZpY2VNYXBwaW5nIHNldEtleUN0eCBzZXRLZXlQYXRoIHNldEtleWZyYW1lICcgK1xuICAgICAgJ3NldEtleWZyYW1lQmxlbmRzaGFwZVRhcmdldFd0cyBzZXRNZW51TW9kZSBzZXROb2RlTmljZU5hbWVSZXNvdXJjZSBzZXROb2RlVHlwZUZsYWcgJyArXG4gICAgICAnc2V0UGFyZW50IHNldFBhcnRpY2xlQXR0ciBzZXRQZnhUb1BvbHlDYW1lcmEgc2V0UGx1Z2luUmVzb3VyY2Ugc2V0UHJvamVjdCAnICtcbiAgICAgICdzZXRTdGFtcERlbnNpdHkgc2V0U3RhcnR1cE1lc3NhZ2Ugc2V0U3RhdGUgc2V0VG9vbFRvIHNldFVJVGVtcGxhdGUgc2V0WGZvcm1NYW5pcCBzZXRzICcgK1xuICAgICAgJ3NoYWRpbmdDb25uZWN0aW9uIHNoYWRpbmdHZW9tZXRyeVJlbEN0eCBzaGFkaW5nTGlnaHRSZWxDdHggc2hhZGluZ05ldHdvcmtDb21wYXJlICcgK1xuICAgICAgJ3NoYWRpbmdOb2RlIHNoYXBlQ29tcGFyZSBzaGVsZkJ1dHRvbiBzaGVsZkxheW91dCBzaGVsZlRhYkxheW91dCBzaGVsbEZpZWxkICcgK1xuICAgICAgJ3Nob3J0TmFtZU9mIHNob3dIZWxwIHNob3dIaWRkZW4gc2hvd01hbmlwQ3R4IHNob3dTZWxlY3Rpb25JblRpdGxlICcgK1xuICAgICAgJ3Nob3dTaGFkaW5nR3JvdXBBdHRyRWRpdG9yIHNob3dXaW5kb3cgc2lnbiBzaW1wbGlmeSBzaW4gc2luZ2xlUHJvZmlsZUJpcmFpbFN1cmZhY2UgJyArXG4gICAgICAnc2l6ZSBzaXplQnl0ZXMgc2tpbkNsdXN0ZXIgc2tpblBlcmNlbnQgc21vb3RoQ3VydmUgc21vb3RoVGFuZ2VudFN1cmZhY2Ugc21vb3Roc3RlcCAnICtcbiAgICAgICdzbmFwMnRvMiBzbmFwS2V5IHNuYXBNb2RlIHNuYXBUb2dldGhlckN0eCBzbmFwc2hvdCBzb2Z0IHNvZnRNb2Qgc29mdE1vZEN0eCBzb3J0IHNvdW5kICcgK1xuICAgICAgJ3NvdW5kQ29udHJvbCBzb3VyY2Ugc3BhY2VMb2NhdG9yIHNwaGVyZSBzcGhyYW5kIHNwb3RMaWdodCBzcG90TGlnaHRQcmV2aWV3UG9ydCAnICtcbiAgICAgICdzcHJlYWRTaGVldEVkaXRvciBzcHJpbmcgc3FydCBzcXVhcmVTdXJmYWNlIHNydENvbnRleHQgc3RhY2tUcmFjZSBzdGFydFN0cmluZyAnICtcbiAgICAgICdzdGFydHNXaXRoIHN0aXRjaEFuZEV4cGxvZGVTaGVsbCBzdGl0Y2hTdXJmYWNlIHN0aXRjaFN1cmZhY2VQb2ludHMgc3RyY21wICcgK1xuICAgICAgJ3N0cmluZ0FycmF5Q2F0ZW5hdGUgc3RyaW5nQXJyYXlDb250YWlucyBzdHJpbmdBcnJheUNvdW50IHN0cmluZ0FycmF5SW5zZXJ0QXRJbmRleCAnICtcbiAgICAgICdzdHJpbmdBcnJheUludGVyc2VjdG9yIHN0cmluZ0FycmF5UmVtb3ZlIHN0cmluZ0FycmF5UmVtb3ZlQXRJbmRleCAnICtcbiAgICAgICdzdHJpbmdBcnJheVJlbW92ZUR1cGxpY2F0ZXMgc3RyaW5nQXJyYXlSZW1vdmVFeGFjdCBzdHJpbmdBcnJheVRvU3RyaW5nICcgK1xuICAgICAgJ3N0cmluZ1RvU3RyaW5nQXJyYXkgc3RyaXAgc3RyaXBQcmVmaXhGcm9tTmFtZSBzdHJva2Ugc3ViZEF1dG9Qcm9qZWN0aW9uICcgK1xuICAgICAgJ3N1YmRDbGVhblRvcG9sb2d5IHN1YmRDb2xsYXBzZSBzdWJkRHVwbGljYXRlQW5kQ29ubmVjdCBzdWJkRWRpdFVWICcgK1xuICAgICAgJ3N1YmRMaXN0Q29tcG9uZW50Q29udmVyc2lvbiBzdWJkTWFwQ3V0IHN1YmRNYXBTZXdNb3ZlIHN1YmRNYXRjaFRvcG9sb2d5IHN1YmRNaXJyb3IgJyArXG4gICAgICAnc3ViZFRvQmxpbmQgc3ViZFRvUG9seSBzdWJkVHJhbnNmZXJVVnNUb0NhY2hlIHN1YmRpdiBzdWJkaXZDcmVhc2UgJyArXG4gICAgICAnc3ViZGl2RGlzcGxheVNtb290aG5lc3Mgc3Vic3RpdHV0ZSBzdWJzdGl0dXRlQWxsU3RyaW5nIHN1YnN0aXR1dGVHZW9tZXRyeSBzdWJzdHJpbmcgJyArXG4gICAgICAnc3VyZmFjZSBzdXJmYWNlU2FtcGxlciBzdXJmYWNlU2hhZGVyTGlzdCBzd2F0Y2hEaXNwbGF5UG9ydCBzd2l0Y2hUYWJsZSBzeW1ib2xCdXR0b24gJyArXG4gICAgICAnc3ltYm9sQ2hlY2tCb3ggc3lzRmlsZSBzeXN0ZW0gdGFiTGF5b3V0IHRhbiB0YW5nZW50Q29uc3RyYWludCB0ZXhMYXR0aWNlRGVmb3JtQ29udGV4dCAnICtcbiAgICAgICd0ZXhNYW5pcENvbnRleHQgdGV4TW92ZUNvbnRleHQgdGV4TW92ZVVWU2hlbGxDb250ZXh0IHRleFJvdGF0ZUNvbnRleHQgdGV4U2NhbGVDb250ZXh0ICcgK1xuICAgICAgJ3RleFNlbGVjdENvbnRleHQgdGV4U2VsZWN0U2hvcnRlc3RQYXRoQ3R4IHRleFNtdWRnZVVWQ29udGV4dCB0ZXhXaW5Ub29sQ3R4IHRleHQgJyArXG4gICAgICAndGV4dEN1cnZlcyB0ZXh0RmllbGQgdGV4dEZpZWxkQnV0dG9uR3JwIHRleHRGaWVsZEdycCB0ZXh0TWFuaXAgdGV4dFNjcm9sbExpc3QgJyArXG4gICAgICAndGV4dFRvU2hlbGYgdGV4dHVyZURpc3BsYWNlUGxhbmUgdGV4dHVyZUhhaXJDb2xvciB0ZXh0dXJlUGxhY2VtZW50Q29udGV4dCAnICtcbiAgICAgICd0ZXh0dXJlV2luZG93IHRocmVhZENvdW50IHRocmVlUG9pbnRBcmNDdHggdGltZUNvbnRyb2wgdGltZVBvcnQgdGltZXJYIHRvTmF0aXZlUGF0aCAnICtcbiAgICAgICd0b2dnbGUgdG9nZ2xlQXhpcyB0b2dnbGVXaW5kb3dWaXNpYmlsaXR5IHRva2VuaXplIHRva2VuaXplTGlzdCB0b2xlcmFuY2UgdG9sb3dlciAnICtcbiAgICAgICd0b29sQnV0dG9uIHRvb2xDb2xsZWN0aW9uIHRvb2xEcm9wcGVkIHRvb2xIYXNPcHRpb25zIHRvb2xQcm9wZXJ0eVdpbmRvdyB0b3J1cyB0b3VwcGVyICcgK1xuICAgICAgJ3RyYWNlIHRyYWNrIHRyYWNrQ3R4IHRyYW5zZmVyQXR0cmlidXRlcyB0cmFuc2Zvcm1Db21wYXJlIHRyYW5zZm9ybUxpbWl0cyB0cmFuc2xhdG9yICcgK1xuICAgICAgJ3RyaW0gdHJ1bmMgdHJ1bmNhdGVGbHVpZENhY2hlIHRydW5jYXRlSGFpckNhY2hlIHR1bWJsZSB0dW1ibGVDdHggdHVyYnVsZW5jZSAnICtcbiAgICAgICd0d29Qb2ludEFyY0N0eCB1aVJlcyB1aVRlbXBsYXRlIHVuYXNzaWduSW5wdXREZXZpY2UgdW5kbyB1bmRvSW5mbyB1bmdyb3VwIHVuaWZvcm0gdW5pdCAnICtcbiAgICAgICd1bmxvYWRQbHVnaW4gdW50YW5nbGVVViB1bnRpdGxlZEZpbGVOYW1lIHVudHJpbSB1cEF4aXMgdXBkYXRlQUUgdXNlckN0eCB1dkxpbmsgJyArXG4gICAgICAndXZTbmFwc2hvdCB2YWxpZGF0ZVNoZWxmTmFtZSB2ZWN0b3JpemUgdmlldzJkVG9vbEN0eCB2aWV3Q2FtZXJhIHZpZXdDbGlwUGxhbmUgJyArXG4gICAgICAndmlld0ZpdCB2aWV3SGVhZE9uIHZpZXdMb29rQXQgdmlld01hbmlwIHZpZXdQbGFjZSB2aWV3U2V0IHZpc29yIHZvbHVtZUF4aXMgdm9ydGV4ICcgK1xuICAgICAgJ3dhaXRDdXJzb3Igd2FybmluZyB3ZWJCcm93c2VyIHdlYkJyb3dzZXJQcmVmcyB3aGF0SXMgd2luZG93IHdpbmRvd1ByZWYgd2lyZSAnICtcbiAgICAgICd3aXJlQ29udGV4dCB3b3Jrc3BhY2Ugd3JpbmtsZSB3cmlua2xlQ29udGV4dCB3cml0ZVRha2UgeGJtTGFuZ1BhdGhMaXN0IHhmb3JtJyxcbiAgICBpbGxlZ2FsOiAnPC8nLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogJ2AnLCBlbmQ6ICdgJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgICAgIGJlZ2luOiAnXFxcXCRcXFxcZCcsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogJ1tcXFxcJFxcXFwlXFxcXEBcXFxcKl0oXFxcXF5cXFxcd1xcXFxifCNcXFxcdyt8W15cXFxcc1xcXFx3e118e1xcXFx3K318XFxcXHcrKSdcbiAgICAgIH0sXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFZBUlMgPSBbXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLCBiZWdpbjogJ1xcXFwkXFxcXGQrJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLCBiZWdpbjogJ1xcXFwkeycsIGVuZDogJ30nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsIGJlZ2luOiAnW1xcXFwkXFxcXEBdJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRVxuICAgIH1cbiAgXTtcbiAgdmFyIERFRkFVTFQgPSB7XG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgbGV4ZW1zOiAnW2Etei9fXSsnLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBidWlsdF9pbjpcbiAgICAgICAgJ29uIG9mZiB5ZXMgbm8gdHJ1ZSBmYWxzZSBub25lIGJsb2NrZWQgZGVidWcgaW5mbyBub3RpY2Ugd2FybiBlcnJvciBjcml0ICcgK1xuICAgICAgICAnc2VsZWN0IGJyZWFrIGxhc3QgcGVybWFuZW50IHJlZGlyZWN0IGtxdWV1ZSBydHNpZyBlcG9sbCBwb2xsIC9kZXYvcG9sbCdcbiAgICB9LFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBpbGxlZ2FsOiAnPT4nLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCInLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0uY29uY2F0KFZBUlMpLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiBcIidcIiwgZW5kOiBcIidcIixcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdLmNvbmNhdChWQVJTKSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd1cmwnLFxuICAgICAgICBiZWdpbjogJyhbYS16XSspOi8nLCBlbmQ6ICdcXFxccycsIGVuZHNXaXRoUGFyZW50OiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgICAgICBiZWdpbjogXCJcXFxcc1xcXFxeXCIsIGVuZDogXCJcXFxcc3x7fDtcIiwgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0uY29uY2F0KFZBUlMpXG4gICAgICB9LFxuICAgICAgLy8gcmVnZXhwIGxvY2F0aW9ucyAofiwgfiopXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgIGJlZ2luOiBcIn5cXFxcKj9cXFxccytcIiwgZW5kOiBcIlxcXFxzfHt8O1wiLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXS5jb25jYXQoVkFSUylcbiAgICAgIH0sXG4gICAgICAvLyAqLmV4YW1wbGUuY29tXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgIGJlZ2luOiBcIlxcXFwqKFxcXFwuW2EtelxcXFwtXSspK1wiLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0uY29uY2F0KFZBUlMpXG4gICAgICB9LFxuICAgICAgLy8gc3ViLmV4YW1wbGUuKlxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgICAgICBiZWdpbjogXCIoW2EtelxcXFwtXStcXFxcLikrXFxcXCpcIixcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdLmNvbmNhdChWQVJTKVxuICAgICAgfSxcbiAgICAgIC8vIElQXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgIGJlZ2luOiAnXFxcXGJcXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9KDpcXFxcZHsxLDV9KT9cXFxcYidcbiAgICAgIH0sXG4gICAgICAvLyB1bml0c1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgICBiZWdpbjogJ1xcXFxiXFxcXGQrW2tLbU1nR2RzaGR3eV0qXFxcXGInLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH1cbiAgICBdLmNvbmNhdChWQVJTKVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnXFxcXHMnLCBlbmQ6ICc7fHsnLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgICAgICAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgICAgICAgICAgc3RhcnRzOiBERUZBVUxUXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBpbGxlZ2FsOiAnW15cXFxcc1xcXFx9XSdcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBPQkpDX0tFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6XG4gICAgICAnaW50IGZsb2F0IHdoaWxlIHByaXZhdGUgY2hhciBjYXRjaCBleHBvcnQgc2l6ZW9mIHR5cGVkZWYgY29uc3Qgc3RydWN0IGZvciB1bmlvbiAnICtcbiAgICAgICd1bnNpZ25lZCBsb25nIHZvbGF0aWxlIHN0YXRpYyBwcm90ZWN0ZWQgYm9vbCBtdXRhYmxlIGlmIHB1YmxpYyBkbyByZXR1cm4gZ290byB2b2lkICcgK1xuICAgICAgJ2VudW0gZWxzZSBicmVhayBleHRlcm4gY2xhc3MgYXNtIGNhc2Ugc2hvcnQgZGVmYXVsdCBkb3VibGUgdGhyb3cgcmVnaXN0ZXIgZXhwbGljaXQgJyArXG4gICAgICAnc2lnbmVkIHR5cGVuYW1lIHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB3Y2hhcl90IGlubGluZSByZWFkb25seSBhc3NpZ24gcHJvcGVydHkgJyArXG4gICAgICAncHJvdG9jb2wgc2VsZiBzeW5jaHJvbml6ZWQgZW5kIHN5bnRoZXNpemUgaWQgb3B0aW9uYWwgcmVxdWlyZWQgaW1wbGVtZW50YXRpb24gJyArXG4gICAgICAnbm9uYXRvbWljIGludGVyZmFjZSBzdXBlciB1bmljaGFyIGZpbmFsbHkgZHluYW1pYyBJQk91dGxldCBJQkFjdGlvbiBzZWxlY3RvciBzdHJvbmcgJyArXG4gICAgICAnd2VhayByZWFkb25seScsXG4gICAgbGl0ZXJhbDpcbiAgICBcdCdmYWxzZSB0cnVlIEZBTFNFIFRSVUUgbmlsIFlFUyBOTyBOVUxMJyxcbiAgICBidWlsdF9pbjpcbiAgICAgICdOU1N0cmluZyBOU0RpY3Rpb25hcnkgQ0dSZWN0IENHUG9pbnQgVUlCdXR0b24gVUlMYWJlbCBVSVRleHRWaWV3IFVJV2ViVmlldyBNS01hcFZpZXcgJyArXG4gICAgICAnVUlTZWdtZW50ZWRDb250cm9sIE5TT2JqZWN0IFVJVGFibGVWaWV3RGVsZWdhdGUgVUlUYWJsZVZpZXdEYXRhU291cmNlIE5TVGhyZWFkICcgK1xuICAgICAgJ1VJQWN0aXZpdHlJbmRpY2F0b3IgVUlUYWJiYXIgVUlUb29sQmFyIFVJQmFyQnV0dG9uSXRlbSBVSUltYWdlVmlldyBOU0F1dG9yZWxlYXNlUG9vbCAnICtcbiAgICAgICdVSVRhYmxlVmlldyBCT09MIE5TSW50ZWdlciBDR0Zsb2F0IE5TRXhjZXB0aW9uIE5TTG9nIE5TTXV0YWJsZVN0cmluZyBOU011dGFibGVBcnJheSAnICtcbiAgICAgICdOU011dGFibGVEaWN0aW9uYXJ5IE5TVVJMIE5TSW5kZXhQYXRoIENHU2l6ZSBVSVRhYmxlVmlld0NlbGwgVUlWaWV3IFVJVmlld0NvbnRyb2xsZXIgJyArXG4gICAgICAnVUlOYXZpZ2F0aW9uQmFyIFVJTmF2aWdhdGlvbkNvbnRyb2xsZXIgVUlUYWJCYXJDb250cm9sbGVyIFVJUG9wb3ZlckNvbnRyb2xsZXIgJyArXG4gICAgICAnVUlQb3BvdmVyQ29udHJvbGxlckRlbGVnYXRlIFVJSW1hZ2UgTlNOdW1iZXIgVUlTZWFyY2hCYXIgTlNGZXRjaGVkUmVzdWx0c0NvbnRyb2xsZXIgJyArXG4gICAgICAnTlNGZXRjaGVkUmVzdWx0c0NoYW5nZVR5cGUgVUlTY3JvbGxWaWV3IFVJU2Nyb2xsVmlld0RlbGVnYXRlIFVJRWRnZUluc2V0cyBVSUNvbG9yICcgK1xuICAgICAgJ1VJRm9udCBVSUFwcGxpY2F0aW9uIE5TTm90Rm91bmQgTlNOb3RpZmljYXRpb25DZW50ZXIgTlNOb3RpZmljYXRpb24gJyArXG4gICAgICAnVUlMb2NhbE5vdGlmaWNhdGlvbiBOU0J1bmRsZSBOU0ZpbGVNYW5hZ2VyIE5TVGltZUludGVydmFsIE5TRGF0ZSBOU0NhbGVuZGFyICcgK1xuICAgICAgJ05TVXNlckRlZmF1bHRzIFVJV2luZG93IE5TUmFuZ2UgTlNBcnJheSBOU0Vycm9yIE5TVVJMUmVxdWVzdCBOU1VSTENvbm5lY3Rpb24gY2xhc3MgJyArXG4gICAgICAnVUlJbnRlcmZhY2VPcmllbnRhdGlvbiBNUE1vdmllUGxheWVyQ29udHJvbGxlciBkaXNwYXRjaF9vbmNlX3QgJyArXG4gICAgICAnZGlzcGF0Y2hfcXVldWVfdCBkaXNwYXRjaF9zeW5jIGRpc3BhdGNoX2FzeW5jIGRpc3BhdGNoX29uY2UnXG4gIH07XG4gIHJldHVybiB7XG4gICAga2V5d29yZHM6IE9CSkNfS0VZV09SRFMsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnXFwnJyxcbiAgICAgICAgZW5kOiAnW15cXFxcXFxcXF1cXCcnLFxuICAgICAgICBpbGxlZ2FsOiAnW15cXFxcXFxcXF1bXlxcJ10nXG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAnI2ltcG9ydCcsXG4gICAgICAgIGVuZDogJyQnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgICAgICAgIGJlZ2luOiAnXFxcIicsXG4gICAgICAgICAgZW5kOiAnXFxcIidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICBiZWdpbjogJzwnLFxuICAgICAgICAgIGVuZDogJz4nXG4gICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICcjJyxcbiAgICAgICAgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSxcbiAgICAgICAgZW5kOiAnKHt8JCknLFxuICAgICAgICBrZXl3b3JkczogJ2ludGVyZmFjZSBjbGFzcyBwcm90b2NvbCBpbXBsZW1lbnRhdGlvbicsXG4gICAgICAgIGNvbnRhaW5zOiBbe1xuICAgICAgICAgIGNsYXNzTmFtZTogJ2lkJyxcbiAgICAgICAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFXG4gICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogJ1xcXFwuJytobGpzLlVOREVSU0NPUkVfSURFTlRfUkVcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICdeIycsIGVuZDogJyQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICdcXFxcXnJlbXsnLCBlbmQ6ICd9JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICdeQCg/OkJBU0V8VVNFfENMQVNTfE9QVElPTlMpJCcsXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgYmVnaW46ICdAW1xcXFx3XFxcXC1dK1xcXFxbW1xcXFx3XjtcXFxcLV0qXFxcXF0oPzpcXFxcW1tcXFxcd147XFxcXC1dKlxcXFxdKT8oPzouKikkJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogJ1xcXFwkXFxcXHs/W1xcXFx3XFxcXC1cXFxcLlxcXFw6XStcXFxcfT8nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgYmVnaW46ICdcXFxcXltcXFxcd1xcXFwtXFxcXC5cXFxcOl0rJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICAgICAgYmVnaW46ICdcXFxcXiNbMC05YS1mQS1GXSsnXG4gICAgICB9LFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFBFUkxfS0VZV09SRFMgPSAnZ2V0cHdlbnQgZ2V0c2VydmVudCBxdW90ZW1ldGEgbXNncmN2IHNjYWxhciBraWxsIGRibWNsb3NlIHVuZGVmIGxjICcgK1xuICAgICdtYSBzeXN3cml0ZSB0ciBzZW5kIHVtYXNrIHN5c29wZW4gc2htd3JpdGUgdmVjIHF4IHV0aW1lIGxvY2FsIG9jdCBzZW1jdGwgbG9jYWx0aW1lICcgK1xuICAgICdyZWFkcGlwZSBkbyByZXR1cm4gZm9ybWF0IHJlYWQgc3ByaW50ZiBkYm1vcGVuIHBvcCBnZXRwZ3JwIG5vdCBnZXRwd25hbSByZXdpbmRkaXIgcXEnICtcbiAgICAnZmlsZW5vIHF3IGVuZHByb3RvZW50IHdhaXQgc2V0aG9zdGVudCBibGVzcyBzfDAgb3BlbmRpciBjb250aW51ZSBlYWNoIHNsZWVwIGVuZGdyZW50ICcgK1xuICAgICdzaHV0ZG93biBkdW1wIGNob21wIGNvbm5lY3QgZ2V0c29ja25hbWUgZGllIHNvY2tldHBhaXIgY2xvc2UgZmxvY2sgZXhpc3RzIGluZGV4IHNobWdldCcgK1xuICAgICdzdWIgZm9yIGVuZHB3ZW50IHJlZG8gbHN0YXQgbXNnY3RsIHNldHBncnAgYWJzIGV4aXQgc2VsZWN0IHByaW50IHJlZiBnZXRob3N0YnlhZGRyICcgK1xuICAgICd1bnNoaWZ0IGZjbnRsIHN5c2NhbGwgZ290byBnZXRuZXRieWFkZHIgam9pbiBnbXRpbWUgc3ltbGluayBzZW1nZXQgc3BsaWNlIHh8MCAnICtcbiAgICAnZ2V0cGVlcm5hbWUgcmVjdiBsb2cgc2V0c29ja29wdCBjb3MgbGFzdCByZXZlcnNlIGdldGhvc3RieW5hbWUgZ2V0Z3JuYW0gc3R1ZHkgZm9ybWxpbmUgJyArXG4gICAgJ2VuZGhvc3RlbnQgdGltZXMgY2hvcCBsZW5ndGggZ2V0aG9zdGVudCBnZXRuZXRlbnQgcGFjayBnZXRwcm90b2VudCBnZXRzZXJ2YnluYW1lIHJhbmQgJyArXG4gICAgJ21rZGlyIHBvcyBjaG1vZCB5fDAgc3Vic3RyIGVuZG5ldGVudCBwcmludGYgbmV4dCBvcGVuIG1zZ3NuZCByZWFkZGlyIHVzZSB1bmxpbmsgJyArXG4gICAgJ2dldHNvY2tvcHQgZ2V0cHJpb3JpdHkgcmluZGV4IHdhbnRhcnJheSBoZXggc3lzdGVtIGdldHNlcnZieXBvcnQgZW5kc2VydmVudCBpbnQgY2hyICcgK1xuICAgICd1bnRpZSBybWRpciBwcm90b3R5cGUgdGVsbCBsaXN0ZW4gZm9yayBzaG1yZWFkIHVjZmlyc3Qgc2V0cHJvdG9lbnQgZWxzZSBzeXNzZWVrIGxpbmsgJyArXG4gICAgJ2dldGdyZ2lkIHNobWN0bCB3YWl0cGlkIHVucGFjayBnZXRuZXRieW5hbWUgcmVzZXQgY2hkaXIgZ3JlcCBzcGxpdCByZXF1aXJlIGNhbGxlciAnICtcbiAgICAnbGNmaXJzdCB1bnRpbCB3YXJuIHdoaWxlIHZhbHVlcyBzaGlmdCB0ZWxsZGlyIGdldHB3dWlkIG15IGdldHByb3RvYnludW1iZXIgZGVsZXRlIGFuZCAnICtcbiAgICAnc29ydCB1YyBkZWZpbmVkIHNyYW5kIGFjY2VwdCBwYWNrYWdlIHNlZWtkaXIgZ2V0cHJvdG9ieW5hbWUgc2Vtb3Agb3VyIHJlbmFtZSBzZWVrIGlmIHF8MCAnICtcbiAgICAnY2hyb290IHN5c3JlYWQgc2V0cHdlbnQgbm8gY3J5cHQgZ2V0YyBjaG93biBzcXJ0IHdyaXRlIHNldG5ldGVudCBzZXRwcmlvcml0eSBmb3JlYWNoICcgK1xuICAgICd0aWUgc2luIG1zZ2dldCBtYXAgc3RhdCBnZXRsb2dpbiB1bmxlc3MgZWxzaWYgdHJ1bmNhdGUgZXhlYyBrZXlzIGdsb2IgdGllZCBjbG9zZWRpcicgK1xuICAgICdpb2N0bCBzb2NrZXQgcmVhZGxpbmsgZXZhbCB4b3IgcmVhZGxpbmUgYmlubW9kZSBzZXRzZXJ2ZW50IGVvZiBvcmQgYmluZCBhbGFybSBwaXBlICcgK1xuICAgICdhdGFuMiBnZXRncmVudCBleHAgdGltZSBwdXNoIHNldGdyZW50IGd0IGx0IG9yIG5lIG18MCBicmVhayBnaXZlbiBzYXkgc3RhdGUgd2hlbic7XG4gIHZhciBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdbJEBdXFxcXHsnLCBlbmQ6ICdcXFxcfScsXG4gICAga2V5d29yZHM6IFBFUkxfS0VZV09SRFMsXG4gICAgcmVsZXZhbmNlOiAxMFxuICB9O1xuICB2YXIgVkFSMSA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICdcXFxcJFxcXFxkJ1xuICB9O1xuICB2YXIgVkFSMiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46ICdbXFxcXCRcXFxcJVxcXFxAXFxcXCpdKFxcXFxeXFxcXHdcXFxcYnwjXFxcXHcrKFxcXFw6XFxcXDpcXFxcdyspKnxbXlxcXFxzXFxcXHd7XXx7XFxcXHcrfXxcXFxcdysoXFxcXDpcXFxcOlxcXFx3KikqKSdcbiAgfTtcbiAgdmFyIFNUUklOR19DT05UQUlOUyA9IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFNVQlNULCBWQVIxLCBWQVIyXTtcbiAgdmFyIE1FVEhPRCA9IHtcbiAgICBiZWdpbjogJy0+JyxcbiAgICBjb250YWluczogW1xuICAgICAge2JlZ2luOiBobGpzLklERU5UX1JFfSxcbiAgICAgIHtiZWdpbjogJ3snLCBlbmQ6ICd9J31cbiAgICBdXG4gIH07XG4gIHZhciBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgIGJlZ2luOiAnXihfX0VORF9ffF9fREFUQV9fKScsIGVuZDogJ1xcXFxuJCcsXG4gICAgcmVsZXZhbmNlOiA1XG4gIH1cbiAgdmFyIFBFUkxfREVGQVVMVF9DT05UQUlOUyA9IFtcbiAgICBWQVIxLCBWQVIyLFxuICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgQ09NTUVOVCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgIGJlZ2luOiAnXlxcXFw9XFxcXHcnLCBlbmQ6ICdcXFxcPWN1dCcsIGVuZHNXaXRoUGFyZW50OiB0cnVlXG4gICAgfSxcbiAgICBNRVRIT0QsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAncVtxd3hyXT9cXFxccypcXFxcKCcsIGVuZDogJ1xcXFwpJyxcbiAgICAgIGNvbnRhaW5zOiBTVFJJTkdfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ3FbcXd4cl0/XFxcXHMqXFxcXFsnLCBlbmQ6ICdcXFxcXScsXG4gICAgICBjb250YWluczogU1RSSU5HX0NPTlRBSU5TLFxuICAgICAgcmVsZXZhbmNlOiA1XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICdxW3F3eHJdP1xcXFxzKlxcXFx7JywgZW5kOiAnXFxcXH0nLFxuICAgICAgY29udGFpbnM6IFNUUklOR19DT05UQUlOUyxcbiAgICAgIHJlbGV2YW5jZTogNVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAncVtxd3hyXT9cXFxccypcXFxcfCcsIGVuZDogJ1xcXFx8JyxcbiAgICAgIGNvbnRhaW5zOiBTVFJJTkdfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ3FbcXd4cl0/XFxcXHMqXFxcXDwnLCBlbmQ6ICdcXFxcPicsXG4gICAgICBjb250YWluczogU1RSSU5HX0NPTlRBSU5TLFxuICAgICAgcmVsZXZhbmNlOiA1XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICdxd1xcXFxzK3EnLCBlbmQ6ICdxJyxcbiAgICAgIGNvbnRhaW5zOiBTVFJJTkdfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ1xcJycsIGVuZDogJ1xcJycsXG4gICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCInLFxuICAgICAgY29udGFpbnM6IFNUUklOR19DT05UQUlOUyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnYCcsIGVuZDogJ2AnLFxuICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICd7XFxcXHcrfScsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ1xcLT9cXFxcdytcXFxccypcXFxcPVxcXFw+JyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICAgIGJlZ2luOiAnKFxcXFxiMFswLTdfXSspfChcXFxcYjB4WzAtOWEtZkEtRl9dKyl8KFxcXFxiWzEtOV1bMC05X10qKFxcXFwuWzAtOV9dKyk/KXxbMF9dXFxcXGInLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSxcbiAgICB7IC8vIHJlZ2V4cCBjb250YWluZXJcbiAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihzcGxpdHxyZXR1cm58cHJpbnR8cmV2ZXJzZXxncmVwKVxcXFxiKVxcXFxzKicsXG4gICAgICBrZXl3b3JkczogJ3NwbGl0IHJldHVybiBwcmludCByZXZlcnNlIGdyZXAnLFxuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgQ09NTUVOVCxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgICAgYmVnaW46ICcoc3x0cnx5KS8oXFxcXFxcXFwufFteL10pKi8oXFxcXFxcXFwufFteL10pKi9bYS16XSonLFxuICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgICAgICAgYmVnaW46ICcobXxxcik/LycsIGVuZDogJy9bYS16XSonLFxuICAgICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXSxcbiAgICAgICAgICByZWxldmFuY2U6IDAgLy8gYWxsb3dzIGVtcHR5IFwiLy9cIiB3aGljaCBpcyBhIGNvbW1vbiBjb21tZW50IGRlbGltaXRlciBpbiBvdGhlciBsYW5ndWFnZXNcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3ViJyxcbiAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyhcXFxccypcXFxcKC4qP1xcXFwpKT9bO3tdJyxcbiAgICAgIGtleXdvcmRzOiAnc3ViJyxcbiAgICAgIHJlbGV2YW5jZTogNVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnb3BlcmF0b3InLFxuICAgICAgYmVnaW46ICctXFxcXHdcXFxcYicsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9XG4gIF07XG4gIFNVQlNULmNvbnRhaW5zID0gUEVSTF9ERUZBVUxUX0NPTlRBSU5TO1xuICBNRVRIT0QuY29udGFpbnNbMV0uY29udGFpbnMgPSBQRVJMX0RFRkFVTFRfQ09OVEFJTlM7XG5cbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczogUEVSTF9LRVlXT1JEUyxcbiAgICBjb250YWluczogUEVSTF9ERUZBVUxUX0NPTlRBSU5TXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgVkFSSUFCTEUgPSB7XG4gICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLCBiZWdpbjogJ1xcXFwkK1thLXpBLVpfXFx4N2YtXFx4ZmZdW2EtekEtWjAtOV9cXHg3Zi1cXHhmZl0qJ1xuICB9O1xuICB2YXIgU1RSSU5HUyA9IFtcbiAgICBobGpzLmluaGVyaXQoaGxqcy5BUE9TX1NUUklOR19NT0RFLCB7aWxsZWdhbDogbnVsbH0pLFxuICAgIGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7aWxsZWdhbDogbnVsbH0pLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ2JcIicsIGVuZDogJ1wiJyxcbiAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnYlxcJycsIGVuZDogJ1xcJycsXG4gICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICB9XG4gIF07XG4gIHZhciBOVU1CRVJTID0gW2hsanMuQklOQVJZX05VTUJFUl9NT0RFLCBobGpzLkNfTlVNQkVSX01PREVdO1xuICB2YXIgVElUTEUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFXG4gIH07XG4gIHJldHVybiB7XG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBrZXl3b3JkczpcbiAgICAgICdhbmQgaW5jbHVkZV9vbmNlIGxpc3QgYWJzdHJhY3QgZ2xvYmFsIHByaXZhdGUgZWNobyBpbnRlcmZhY2UgYXMgc3RhdGljIGVuZHN3aXRjaCAnICtcbiAgICAgICdhcnJheSBudWxsIGlmIGVuZHdoaWxlIG9yIGNvbnN0IGZvciBlbmRmb3JlYWNoIHNlbGYgdmFyIHdoaWxlIGlzc2V0IHB1YmxpYyAnICtcbiAgICAgICdwcm90ZWN0ZWQgZXhpdCBmb3JlYWNoIHRocm93IGVsc2VpZiBpbmNsdWRlIF9fRklMRV9fIGVtcHR5IHJlcXVpcmVfb25jZSBkbyB4b3IgJyArXG4gICAgICAncmV0dXJuIGltcGxlbWVudHMgcGFyZW50IGNsb25lIHVzZSBfX0NMQVNTX18gX19MSU5FX18gZWxzZSBicmVhayBwcmludCBldmFsIG5ldyAnICtcbiAgICAgICdjYXRjaCBfX01FVEhPRF9fIGNhc2UgZXhjZXB0aW9uIHBocF91c2VyX2ZpbHRlciBkZWZhdWx0IGRpZSByZXF1aXJlIF9fRlVOQ1RJT05fXyAnICtcbiAgICAgICdlbmRkZWNsYXJlIGZpbmFsIHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSBlbmRmb3IgZW5kaWYgZGVjbGFyZSB1bnNldCB0cnVlIGZhbHNlICcgK1xuICAgICAgJ25hbWVzcGFjZSB0cmFpdCBnb3RvIGluc3RhbmNlb2YgaW5zdGVhZG9mIF9fRElSX18gX19OQU1FU1BBQ0VfXyBfX2hhbHRfY29tcGlsZXInLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICcvXFxcXConLCBlbmQ6ICdcXFxcKi8nLFxuICAgICAgICBjb250YWluczogW3tcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BocGRvYycsXG4gICAgICAgICAgICBiZWdpbjogJ1xcXFxzQFtBLVphLXpdKydcbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgIGJlZ2luOiAnX19oYWx0X2NvbXBpbGVyLis/OycsIGVuZHNXaXRoUGFyZW50OiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogJzw8PFtcXCdcIl0/XFxcXHcrW1xcJ1wiXT8kJywgZW5kOiAnXlxcXFx3KzsnLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAnPFxcXFw/cGhwJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICdcXFxcPz4nXG4gICAgICB9LFxuICAgICAgVkFSSUFCTEUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSwgZW5kOiAneycsXG4gICAgICAgIGtleXdvcmRzOiAnZnVuY3Rpb24nLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXCR8XFxcXFt8JScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgVElUTEUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgICAgIFZBUklBQkxFLFxuICAgICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgICAgICAgICBdLmNvbmNhdChTVFJJTkdTKS5jb25jYXQoTlVNQkVSUylcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSwgZW5kOiAneycsXG4gICAgICAgIGtleXdvcmRzOiAnY2xhc3MnLFxuICAgICAgICBpbGxlZ2FsOiAnWzpcXFxcKFxcXFwkXScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSwgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBrZXl3b3JkczogJ2V4dGVuZHMnLFxuICAgICAgICAgICAgY29udGFpbnM6IFtUSVRMRV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFRJVExFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnPT4nIC8vIE5vIG1hcmt1cCwganVzdCBhIHJlbGV2YW5jZSBib29zdGVyXG4gICAgICB9XG4gICAgXS5jb25jYXQoU1RSSU5HUykuY29uY2F0KE5VTUJFUlMpXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2J1aWx0aW4nLFxuICAgICAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JCcsXG4gICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkFQT1NfU1RSSU5HX01PREUsIGhsanMuUVVPVEVfU1RSSU5HX01PREVdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVuYW1lJyxcbiAgICAgICAgYmVnaW46ICdbYS16QS1aX11bXFxcXGRhLXpBLVpfXStcXFxcLltcXFxcZGEtekEtWl9dezEsM30nLCBlbmQ6ICc6JyxcbiAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnaGVhZGVyJyxcbiAgICAgICAgYmVnaW46ICcobmNhbGxzfHRvdHRpbWV8Y3VtdGltZSknLCBlbmQ6ICckJyxcbiAgICAgICAga2V5d29yZHM6ICduY2FsbHMgdG90dGltZXwxMCBjdW10aW1lfDEwIGZpbGVuYW1lJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3VtbWFyeScsXG4gICAgICAgIGJlZ2luOiAnZnVuY3Rpb24gY2FsbHMnLCBlbmQ6ICckJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkNfTlVNQkVSX01PREVdLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCkkJyxcbiAgICAgICAgY29udGFpbnM6IFt7XG4gICAgICAgICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgIH1dLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgUFJPTVBUID0ge1xuICAgIGNsYXNzTmFtZTogJ3Byb21wdCcsICBiZWdpbjogJ14oPj4+fFxcXFwuXFxcXC5cXFxcLikgJ1xuICB9XG4gIHZhciBTVFJJTkdTID0gW1xuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyh1fGIpP3I/XFwnXFwnXFwnJywgZW5kOiAnXFwnXFwnXFwnJyxcbiAgICAgIGNvbnRhaW5zOiBbUFJPTVBUXSxcbiAgICAgIHJlbGV2YW5jZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyh1fGIpP3I/XCJcIlwiJywgZW5kOiAnXCJcIlwiJyxcbiAgICAgIGNvbnRhaW5zOiBbUFJPTVBUXSxcbiAgICAgIHJlbGV2YW5jZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyh1fHJ8dXIpXFwnJywgZW5kOiAnXFwnJyxcbiAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXSxcbiAgICAgIHJlbGV2YW5jZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyh1fHJ8dXIpXCInLCBlbmQ6ICdcIicsXG4gICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgICByZWxldmFuY2U6IDEwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICcoYnxicilcXCcnLCBlbmQ6ICdcXCcnLFxuICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICcoYnxicilcIicsIGVuZDogJ1wiJyxcbiAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgIH1cbiAgXS5jb25jYXQoW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFXG4gIF0pO1xuICB2YXIgVElUTEUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLCBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFXG4gIH07XG4gIHZhciBQQVJBTVMgPSB7XG4gICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgIGNvbnRhaW5zOiBbJ3NlbGYnLCBobGpzLkNfTlVNQkVSX01PREUsIFBST01QVF0uY29uY2F0KFNUUklOR1MpXG4gIH07XG4gIHZhciBGVU5DX0NMQVNTX1BST1RPID0ge1xuICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJzonLFxuICAgIGlsbGVnYWw6ICdbJHs9O1xcXFxuXScsXG4gICAgY29udGFpbnM6IFtUSVRMRSwgUEFSQU1TXSxcbiAgICByZWxldmFuY2U6IDEwXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBrZXl3b3Jkczoge1xuICAgICAga2V5d29yZDpcbiAgICAgICAgJ2FuZCBlbGlmIGlzIGdsb2JhbCBhcyBpbiBpZiBmcm9tIHJhaXNlIGZvciBleGNlcHQgZmluYWxseSBwcmludCBpbXBvcnQgcGFzcyByZXR1cm4gJyArXG4gICAgICAgICdleGVjIGVsc2UgYnJlYWsgbm90IHdpdGggY2xhc3MgYXNzZXJ0IHlpZWxkIHRyeSB3aGlsZSBjb250aW51ZSBkZWwgb3IgZGVmIGxhbWJkYSAnICtcbiAgICAgICAgJ25vbmxvY2FsfDEwJyxcbiAgICAgIGJ1aWx0X2luOlxuICAgICAgICAnTm9uZSBUcnVlIEZhbHNlIEVsbGlwc2lzIE5vdEltcGxlbWVudGVkJ1xuICAgIH0sXG4gICAgaWxsZWdhbDogJyg8L3wtPnxcXFxcPyknLFxuICAgIGNvbnRhaW5zOiBTVFJJTkdTLmNvbmNhdChbXG4gICAgICBQUk9NUFQsXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5pbmhlcml0KEZVTkNfQ0xBU1NfUFJPVE8sIHtjbGFzc05hbWU6ICdmdW5jdGlvbicsIGtleXdvcmRzOiAnZGVmJ30pLFxuICAgICAgaGxqcy5pbmhlcml0KEZVTkNfQ0xBU1NfUFJPVE8sIHtjbGFzc05hbWU6ICdjbGFzcycsIGtleXdvcmRzOiAnY2xhc3MnfSksXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2RlY29yYXRvcicsXG4gICAgICAgIGJlZ2luOiAnQCcsIGVuZDogJyQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ1xcXFxiKHByaW50fGV4ZWMpXFxcXCgnIC8vIGRvbuKAmXQgaGlnaGxpZ2h0IGtleXdvcmRzLXR1cm5lZC1mdW5jdGlvbnMgaW4gUHl0aG9uIDNcbiAgICAgIH1cbiAgICBdKVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIElERU5UX1JFID0gJyhbYS16QS1aXXxcXFxcLlthLXpBLVouXSlbYS16QS1aMC05Ll9dKic7XG5cbiAgcmV0dXJuIHtcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IElERU5UX1JFLFxuICAgICAgICBsZXhlbXM6IElERU5UX1JFLFxuICAgICAgICBrZXl3b3Jkczoge1xuICAgICAgICAgIGtleXdvcmQ6XG4gICAgICAgICAgICAnZnVuY3Rpb24gaWYgaW4gYnJlYWsgbmV4dCByZXBlYXQgZWxzZSBmb3IgcmV0dXJuIHN3aXRjaCB3aGlsZSB0cnkgdHJ5Q2F0Y2h8MTAgJyArXG4gICAgICAgICAgICAnc3RvcCB3YXJuaW5nIHJlcXVpcmUgbGlicmFyeSBhdHRhY2ggZGV0YWNoIHNvdXJjZSBzZXRNZXRob2Qgc2V0R2VuZXJpYyAnICtcbiAgICAgICAgICAgICdzZXRHcm91cEdlbmVyaWMgc2V0Q2xhc3MgLi4ufDEwJyxcbiAgICAgICAgICBsaXRlcmFsOlxuICAgICAgICAgICAgJ05VTEwgTkEgVFJVRSBGQUxTRSBUIEYgSW5mIE5hTiBOQV9pbnRlZ2VyX3wxMCBOQV9yZWFsX3wxMCBOQV9jaGFyYWN0ZXJffDEwICcgK1xuICAgICAgICAgICAgJ05BX2NvbXBsZXhffDEwJ1xuICAgICAgICB9LFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGhleCB2YWx1ZVxuICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgICBiZWdpbjogXCIwW3hYXVswLTlhLWZBLUZdK1tMaV0/XFxcXGJcIixcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBleHBsaWNpdCBpbnRlZ2VyXG4gICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgIGJlZ2luOiBcIlxcXFxkKyg/OltlRV1bK1xcXFwtXT9cXFxcZCopP0xcXFxcYlwiLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIG51bWJlciB3aXRoIHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICAgICAgYmVnaW46IFwiXFxcXGQrXFxcXC4oPyFcXFxcZCkoPzppXFxcXGIpP1wiLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIG51bWJlclxuICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgICBiZWdpbjogXCJcXFxcZCsoPzpcXFxcLlxcXFxkKik/KD86W2VFXVsrXFxcXC1dP1xcXFxkKik/aT9cXFxcYlwiLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIG51bWJlciB3aXRoIGxlYWRpbmcgZGVjaW1hbFxuICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgICBiZWdpbjogXCJcXFxcLlxcXFxkKyg/OltlRV1bK1xcXFwtXT9cXFxcZCopP2k/XFxcXGJcIixcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIC8vIGVzY2FwZWQgaWRlbnRpZmllclxuICAgICAgICBiZWdpbjogJ2AnLFxuICAgICAgICBlbmQ6ICdgJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgIGJlZ2luOiAnXCInLFxuICAgICAgICBlbmQ6ICdcIicsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogXCInXCIsXG4gICAgICAgIGVuZDogXCInXCIsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczpcbiAgICAgICdBcmNoaXZlUmVjb3JkIEFyZWFMaWdodFNvdXJjZSBBdG1vc3BoZXJlIEF0dHJpYnV0ZSBBdHRyaWJ1dGVCZWdpbiBBdHRyaWJ1dGVFbmQgQmFzaXMgJyArXG4gICAgICAnQmVnaW4gQmxvYmJ5IEJvdW5kIENsaXBwaW5nIENsaXBwaW5nUGxhbmUgQ29sb3IgQ29sb3JTYW1wbGVzIENvbmNhdFRyYW5zZm9ybSBDb25lICcgK1xuICAgICAgJ0Nvb3JkaW5hdGVTeXN0ZW0gQ29vcmRTeXNUcmFuc2Zvcm0gQ3JvcFdpbmRvdyBDdXJ2ZXMgQ3lsaW5kZXIgRGVwdGhPZkZpZWxkIERldGFpbCAnICtcbiAgICAgICdEZXRhaWxSYW5nZSBEaXNrIERpc3BsYWNlbWVudCBEaXNwbGF5IEVuZCBFcnJvckhhbmRsZXIgRXhwb3N1cmUgRXh0ZXJpb3IgRm9ybWF0ICcgK1xuICAgICAgJ0ZyYW1lQXNwZWN0UmF0aW8gRnJhbWVCZWdpbiBGcmFtZUVuZCBHZW5lcmFsUG9seWdvbiBHZW9tZXRyaWNBcHByb3hpbWF0aW9uIEdlb21ldHJ5ICcgK1xuICAgICAgJ0hpZGVyIEh5cGVyYm9sb2lkIElkZW50aXR5IElsbHVtaW5hdGUgSW1hZ2VyIEludGVyaW9yIExpZ2h0U291cmNlICcgK1xuICAgICAgJ01ha2VDdWJlRmFjZUVudmlyb25tZW50IE1ha2VMYXRMb25nRW52aXJvbm1lbnQgTWFrZVNoYWRvdyBNYWtlVGV4dHVyZSBNYXR0ZSAnICtcbiAgICAgICdNb3Rpb25CZWdpbiBNb3Rpb25FbmQgTnVQYXRjaCBPYmplY3RCZWdpbiBPYmplY3RFbmQgT2JqZWN0SW5zdGFuY2UgT3BhY2l0eSBPcHRpb24gJyArXG4gICAgICAnT3JpZW50YXRpb24gUGFyYWJvbG9pZCBQYXRjaCBQYXRjaE1lc2ggUGVyc3BlY3RpdmUgUGl4ZWxGaWx0ZXIgUGl4ZWxTYW1wbGVzICcgK1xuICAgICAgJ1BpeGVsVmFyaWFuY2UgUG9pbnRzIFBvaW50c0dlbmVyYWxQb2x5Z29ucyBQb2ludHNQb2x5Z29ucyBQb2x5Z29uIFByb2NlZHVyYWwgUHJvamVjdGlvbiAnICtcbiAgICAgICdRdWFudGl6ZSBSZWFkQXJjaGl2ZSBSZWxhdGl2ZURldGFpbCBSZXZlcnNlT3JpZW50YXRpb24gUm90YXRlIFNjYWxlIFNjcmVlbldpbmRvdyAnICtcbiAgICAgICdTaGFkaW5nSW50ZXJwb2xhdGlvbiBTaGFkaW5nUmF0ZSBTaHV0dGVyIFNpZGVzIFNrZXcgU29saWRCZWdpbiBTb2xpZEVuZCBTcGhlcmUgJyArXG4gICAgICAnU3ViZGl2aXNpb25NZXNoIFN1cmZhY2UgVGV4dHVyZUNvb3JkaW5hdGVzIFRvcnVzIFRyYW5zZm9ybSBUcmFuc2Zvcm1CZWdpbiBUcmFuc2Zvcm1FbmQgJyArXG4gICAgICAnVHJhbnNmb3JtUG9pbnRzIFRyYW5zbGF0ZSBUcmltQ3VydmUgV29ybGRCZWdpbiBXb3JsZEVuZCcsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICByZXR1cm4ge1xuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnZmxvYXQgY29sb3IgcG9pbnQgbm9ybWFsIHZlY3RvciBtYXRyaXggd2hpbGUgZm9yIGlmIGRvIHJldHVybiBlbHNlIGJyZWFrIGV4dGVybiBjb250aW51ZScsXG4gICAgICBidWlsdF9pbjpcbiAgICAgICAgJ2FicyBhY29zIGFtYmllbnQgYXJlYSBhc2luIGF0YW4gYXRtb3NwaGVyZSBhdHRyaWJ1dGUgY2FsY3VsYXRlbm9ybWFsIGNlaWwgY2VsbG5vaXNlICcgK1xuICAgICAgICAnY2xhbXAgY29tcCBjb25jYXQgY29zIGRlZ3JlZXMgZGVwdGggRGVyaXYgZGlmZnVzZSBkaXN0YW5jZSBEdSBEdiBlbnZpcm9ubWVudCBleHAgJyArXG4gICAgICAgICdmYWNlZm9yd2FyZCBmaWx0ZXJzdGVwIGZsb29yIGZvcm1hdCBmcmVzbmVsIGluY2lkZW50IGxlbmd0aCBsaWdodHNvdXJjZSBsb2cgbWF0Y2ggJyArXG4gICAgICAgICdtYXggbWluIG1vZCBub2lzZSBub3JtYWxpemUgbnRyYW5zZm9ybSBvcHBvc2l0ZSBvcHRpb24gcGhvbmcgcG5vaXNlIHBvdyBwcmludGYgJyArXG4gICAgICAgICdwdGxpbmVkIHJhZGlhbnMgcmFuZG9tIHJlZmxlY3QgcmVmcmFjdCByZW5kZXJpbmZvIHJvdW5kIHNldGNvbXAgc2V0eGNvbXAgc2V0eWNvbXAgJyArXG4gICAgICAgICdzZXR6Y29tcCBzaGFkb3cgc2lnbiBzaW4gc21vb3Roc3RlcCBzcGVjdWxhciBzcGVjdWxhcmJyZGYgc3BsaW5lIHNxcnQgc3RlcCB0YW4gJyArXG4gICAgICAgICd0ZXh0dXJlIHRleHR1cmVpbmZvIHRyYWNlIHRyYW5zZm9ybSB2dHJhbnNmb3JtIHhjb21wIHljb21wIHpjb21wJ1xuICAgIH0sXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAnIycsIGVuZDogJyQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzaGFkZXInLFxuICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBlbmQ6ICdcXFxcKCcsXG4gICAgICAgIGtleXdvcmRzOiAnc3VyZmFjZSBkaXNwbGFjZW1lbnQgbGlnaHQgdm9sdW1lIGltYWdlcidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NoYWRpbmcnLFxuICAgICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBlbmQ6ICdcXFxcKCcsXG4gICAgICAgIGtleXdvcmRzOiAnaWxsdW1pbmF0ZSBpbGx1bWluYW5jZSBnYXRoZXInXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFJVQllfSURFTlRfUkUgPSAnW2EtekEtWl9dW2EtekEtWjAtOV9dKihcXFxcIXxcXFxcPyk/JztcbiAgdmFyIFJVQllfTUVUSE9EX1JFID0gJ1thLXpBLVpfXVxcXFx3KlshPz1dP3xbLSt+XVxcXFxAfDw8fD4+fD1+fD09PT98PD0+fFs8Pl09P3xcXFxcKlxcXFwqfFstLyslXiYqfmB8XXxcXFxcW1xcXFxdPT8nO1xuICB2YXIgUlVCWV9LRVlXT1JEUyA9IHtcbiAgICBrZXl3b3JkOlxuICAgICAgJ2FuZCBmYWxzZSB0aGVuIGRlZmluZWQgbW9kdWxlIGluIHJldHVybiByZWRvIGlmIEJFR0lOIHJldHJ5IGVuZCBmb3IgdHJ1ZSBzZWxmIHdoZW4gJyArXG4gICAgICAnbmV4dCB1bnRpbCBkbyBiZWdpbiB1bmxlc3MgRU5EIHJlc2N1ZSBuaWwgZWxzZSBicmVhayB1bmRlZiBub3Qgc3VwZXIgY2xhc3MgY2FzZSAnICtcbiAgICAgICdyZXF1aXJlIHlpZWxkIGFsaWFzIHdoaWxlIGVuc3VyZSBlbHNpZiBvciBpbmNsdWRlJ1xuICB9O1xuICB2YXIgWUFSRE9DVEFHID0ge1xuICAgIGNsYXNzTmFtZTogJ3lhcmRvY3RhZycsXG4gICAgYmVnaW46ICdAW0EtWmEtel0rJ1xuICB9O1xuICB2YXIgQ09NTUVOVFMgPSBbXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICBiZWdpbjogJyMnLCBlbmQ6ICckJyxcbiAgICAgIGNvbnRhaW5zOiBbWUFSRE9DVEFHXVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICBiZWdpbjogJ15cXFxcPWJlZ2luJywgZW5kOiAnXlxcXFw9ZW5kJyxcbiAgICAgIGNvbnRhaW5zOiBbWUFSRE9DVEFHXSxcbiAgICAgIHJlbGV2YW5jZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgYmVnaW46ICdeX19FTkRfXycsIGVuZDogJ1xcXFxuJCdcbiAgICB9XG4gIF07XG4gIHZhciBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICcjXFxcXHsnLCBlbmQ6ICd9JyxcbiAgICBsZXhlbXM6IFJVQllfSURFTlRfUkUsXG4gICAga2V5d29yZHM6IFJVQllfS0VZV09SRFNcbiAgfTtcbiAgdmFyIFNUUl9DT05UQUlOUyA9IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFNVQlNUXTtcbiAgdmFyIFNUUklOR1MgPSBbXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCInLFxuICAgICAgY29udGFpbnM6IFNUUl9DT05UQUlOUyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnJVtxd10/XFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICBjb250YWluczogU1RSX0NPTlRBSU5TXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICclW3F3XT9cXFxcWycsIGVuZDogJ1xcXFxdJyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlNcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyVbcXddP3snLCBlbmQ6ICd9JyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlNcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyVbcXddPzwnLCBlbmQ6ICc+JyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDEwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICclW3F3XT8vJywgZW5kOiAnLycsXG4gICAgICBjb250YWluczogU1RSX0NPTlRBSU5TLFxuICAgICAgcmVsZXZhbmNlOiAxMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgIGJlZ2luOiAnJVtxd10/JScsIGVuZDogJyUnLFxuICAgICAgY29udGFpbnM6IFNUUl9DT05UQUlOUyxcbiAgICAgIHJlbGV2YW5jZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICBiZWdpbjogJyVbcXddPy0nLCBlbmQ6ICctJyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDEwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICclW3F3XT9cXFxcfCcsIGVuZDogJ1xcXFx8JyxcbiAgICAgIGNvbnRhaW5zOiBTVFJfQ09OVEFJTlMsXG4gICAgICByZWxldmFuY2U6IDEwXG4gICAgfVxuICBdO1xuICB2YXIgRlVOQ1RJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyB8JHw7JyxcbiAgICBrZXl3b3JkczogJ2RlZicsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgICAgICBiZWdpbjogUlVCWV9NRVRIT0RfUkUsXG4gICAgICAgIGxleGVtczogUlVCWV9JREVOVF9SRSxcbiAgICAgICAga2V5d29yZHM6IFJVQllfS0VZV09SRFNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgIGJlZ2luOiAnXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgIGxleGVtczogUlVCWV9JREVOVF9SRSxcbiAgICAgICAga2V5d29yZHM6IFJVQllfS0VZV09SRFNcbiAgICAgIH1cbiAgICBdLmNvbmNhdChDT01NRU5UUylcbiAgfTtcblxuICB2YXIgUlVCWV9ERUZBVUxUX0NPTlRBSU5TID0gQ09NTUVOVFMuY29uY2F0KFNUUklOR1MuY29uY2F0KFtcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICBiZWdpbldpdGhLZXl3b3JkOiB0cnVlLCBlbmQ6ICckfDsnLFxuICAgICAga2V5d29yZHM6ICdjbGFzcyBtb2R1bGUnLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICBiZWdpbjogJ1tBLVphLXpfXVxcXFx3Kig6OlxcXFx3KykqKFxcXFw/fFxcXFwhKT8nLFxuICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnaW5oZXJpdGFuY2UnLFxuICAgICAgICAgIGJlZ2luOiAnPFxcXFxzKicsXG4gICAgICAgICAgY29udGFpbnM6IFt7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJlbnQnLFxuICAgICAgICAgICAgYmVnaW46ICcoJyArIGhsanMuSURFTlRfUkUgKyAnOjopPycgKyBobGpzLklERU5UX1JFXG4gICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgICAgXS5jb25jYXQoQ09NTUVOVFMpXG4gICAgfSxcbiAgICBGVU5DVElPTixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjb25zdGFudCcsXG4gICAgICBiZWdpbjogJyg6Oik/KFxcXFxiW0EtWl1cXFxcdyooOjopPykrJyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnc3ltYm9sJyxcbiAgICAgIGJlZ2luOiAnOicsXG4gICAgICBjb250YWluczogU1RSSU5HUy5jb25jYXQoW3tiZWdpbjogUlVCWV9NRVRIT0RfUkV9XSksXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogJ3N5bWJvbCcsXG4gICAgICBiZWdpbjogUlVCWV9JREVOVF9SRSArICc6JyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICAgIGJlZ2luOiAnKFxcXFxiMFswLTdfXSspfChcXFxcYjB4WzAtOWEtZkEtRl9dKyl8KFxcXFxiWzEtOV1bMC05X10qKFxcXFwuWzAtOV9dKyk/KXxbMF9dXFxcXGInLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgYmVnaW46ICdcXFxcP1xcXFx3J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgYmVnaW46ICcoXFxcXCRcXFxcVyl8KChcXFxcJHxcXFxcQFxcXFxAPykoXFxcXHcrKSknXG4gICAgfSxcbiAgICB7IC8vIHJlZ2V4cCBjb250YWluZXJcbiAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJylcXFxccyonLFxuICAgICAgY29udGFpbnM6IENPTU1FTlRTLmNvbmNhdChbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgICAgICAgIGJlZ2luOiAnLycsIGVuZDogJy9bYS16XSonLFxuICAgICAgICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFNVQlNUXVxuICAgICAgICB9XG4gICAgICBdKSxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH1cbiAgXSkpO1xuICBTVUJTVC5jb250YWlucyA9IFJVQllfREVGQVVMVF9DT05UQUlOUztcbiAgRlVOQ1RJT04uY29udGFpbnNbMV0uY29udGFpbnMgPSBSVUJZX0RFRkFVTFRfQ09OVEFJTlM7XG5cbiAgcmV0dXJuIHtcbiAgICBsZXhlbXM6IFJVQllfSURFTlRfUkUsXG4gICAga2V5d29yZHM6IFJVQllfS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFJVQllfREVGQVVMVF9DT05UQUlOU1xuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFRJVExFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFXG4gIH07XG4gIHZhciBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogJ1xcXFxiKDBbeGJdW0EtWmEtejAtOV9dK3xbMC05X10rKFxcXFwuWzAtOV9dKyk/KFt1aWZdKDh8MTZ8MzJ8NjQpPyk/KScsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBLRVlXT1JEUyA9XG4gICAgJ2FsdCBhbnkgYXMgYXNzZXJ0IGJlIGJpbmQgYmxvY2sgYm9vbCBicmVhayBjaGFyIGNoZWNrIGNsYWltIGNvbnN0IGNvbnQgZGlyIGRvIGVsc2UgZW51bSAnICtcbiAgICAnZXhwb3J0IGYzMiBmNjQgZmFpbCBmYWxzZSBmbG9hdCBmbiBmb3IgaTE2IGkzMiBpNjQgaTggaWYgaWZhY2UgaW1wbCBpbXBvcnQgaW4gaW50IGxldCAnICtcbiAgICAnbG9nIG1vZCBtdXRhYmxlIG5hdGl2ZSBub3RlIG9mIHByb3ZlIHB1cmUgcmVzb3VyY2UgcmV0IHNlbGYgc3RyIHN5bnRheCB0cnVlIHR5cGUgdTE2IHUzMiAnICtcbiAgICAndTY0IHU4IHVpbnQgdW5jaGVja2VkIHVuc2FmZSB1c2UgdmVjIHdoaWxlJztcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7aWxsZWdhbDogbnVsbH0pLFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgTlVNQkVSLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyhcXFxcKHw8KScsXG4gICAgICAgIGtleXdvcmRzOiAnZm4nLFxuICAgICAgICBjb250YWluczogW1RJVExFXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncHJlcHJvY2Vzc29yJyxcbiAgICAgICAgYmVnaW46ICcjXFxcXFsnLCBlbmQ6ICdcXFxcXSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyg9fDwpJyxcbiAgICAgICAga2V5d29yZHM6ICd0eXBlJyxcbiAgICAgICAgY29udGFpbnM6IFtUSVRMRV0sXG4gICAgICAgIGlsbGVnYWw6ICdcXFxcUydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJyh7fDwpJyxcbiAgICAgICAga2V5d29yZHM6ICdpZmFjZSBlbnVtJyxcbiAgICAgICAgY29udGFpbnM6IFtUSVRMRV0sXG4gICAgICAgIGlsbGVnYWw6ICdcXFxcUydcbiAgICAgIH1cbiAgICBdXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgQU5OT1RBVElPTiA9IHtcbiAgICBjbGFzc05hbWU6ICdhbm5vdGF0aW9uJywgYmVnaW46ICdAW0EtWmEtel0rJ1xuICB9O1xuICB2YXIgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICd1P3I/XCJcIlwiJywgZW5kOiAnXCJcIlwiJyxcbiAgICByZWxldmFuY2U6IDEwXG4gIH07XG4gIHJldHVybiB7XG4gICAga2V5d29yZHM6XG4gICAgICAndHlwZSB5aWVsZCBsYXp5IG92ZXJyaWRlIGRlZiB3aXRoIHZhbCB2YXIgZmFsc2UgdHJ1ZSBzZWFsZWQgYWJzdHJhY3QgcHJpdmF0ZSB0cmFpdCAnICtcbiAgICAgICdvYmplY3QgbnVsbCBpZiBmb3Igd2hpbGUgdGhyb3cgZmluYWxseSBwcm90ZWN0ZWQgZXh0ZW5kcyBpbXBvcnQgZmluYWwgcmV0dXJuIGVsc2UgJyArXG4gICAgICAnYnJlYWsgbmV3IGNhdGNoIHN1cGVyIGNsYXNzIGNhc2UgcGFja2FnZSBkZWZhdWx0IHRyeSB0aGlzIG1hdGNoIGNvbnRpbnVlIHRocm93cycsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnamF2YWRvYycsXG4gICAgICAgIGJlZ2luOiAnL1xcXFwqXFxcXConLCBlbmQ6ICdcXFxcKi8nLFxuICAgICAgICBjb250YWluczogW3tcbiAgICAgICAgICBjbGFzc05hbWU6ICdqYXZhZG9jdGFnJyxcbiAgICAgICAgICBiZWdpbjogJ0BbQS1aYS16XSsnXG4gICAgICAgIH1dLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLCBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLCBobGpzLlFVT1RFX1NUUklOR19NT0RFLCBTVFJJTkcsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW46ICcoKGNhc2UgKT9jbGFzcyB8b2JqZWN0IHx0cmFpdCApJywgZW5kOiAnKHt8JCknLCAvLyBiZWdpbldpdGhLZXl3b3JkIHdvbid0IHdvcmsgYmVjYXVzZSBhIHNpbmdsZSBcImNhc2VcIiBzaG91bGRuJ3Qgc3RhcnQgdGhpcyBtb2RlXG4gICAgICAgIGlsbGVnYWw6ICc6JyxcbiAgICAgICAga2V5d29yZHM6ICdjYXNlIGNsYXNzIHRyYWl0IG9iamVjdCcsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW5XaXRoS2V5d29yZDogdHJ1ZSxcbiAgICAgICAgICAgIGtleXdvcmRzOiAnZXh0ZW5kcyB3aXRoJyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogJ1xcXFwoJywgZW5kOiAnXFxcXCknLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLCBobGpzLlFVT1RFX1NUUklOR19NT0RFLCBTVFJJTkcsXG4gICAgICAgICAgICAgIEFOTk9UQVRJT05cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICBBTk5PVEFUSU9OXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFZBUl9JREVOVF9SRSA9ICdbYS16XVthLXpBLVowLTlfXSonO1xuICB2YXIgQ0hBUiA9IHtcbiAgICBjbGFzc05hbWU6ICdjaGFyJyxcbiAgICBiZWdpbjogJ1xcXFwkLnsxfSdcbiAgfTtcbiAgdmFyIFNZTUJPTCA9IHtcbiAgICBjbGFzc05hbWU6ICdzeW1ib2wnLFxuICAgIGJlZ2luOiAnIycgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBrZXl3b3JkczogJ3NlbGYgc3VwZXIgbmlsIHRydWUgZmFsc2UgdGhpc0NvbnRleHQnLCAvLyBvbmx5IDZcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luOiAnXFxcXGJbQS1aXVtBLVphLXowLTlfXSonLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGhvZCcsXG4gICAgICAgIGJlZ2luOiBWQVJfSURFTlRfUkUgKyAnOidcbiAgICAgIH0sXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICBTWU1CT0wsXG4gICAgICBDSEFSLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdsb2NhbHZhcnMnLFxuICAgICAgICBiZWdpbjogJ1xcXFx8XFxcXHMqKCgnICsgVkFSX0lERU5UX1JFICsgJylcXFxccyopK1xcXFx8J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXJyYXknLFxuICAgICAgICBiZWdpbjogJ1xcXFwjXFxcXCgnLCBlbmQ6ICdcXFxcKScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIENIQVIsXG4gICAgICAgICAgaGxqcy5DX05VTUJFUl9NT0RFLFxuICAgICAgICAgIFNZTUJPTFxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ29wZXJhdG9yJyxcbiAgICAgICAgYmVnaW46ICcoYmVnaW58c3RhcnR8Y29tbWl0fHJvbGxiYWNrfHNhdmVwb2ludHxsb2NrfGFsdGVyfGNyZWF0ZXxkcm9wfHJlbmFtZXxjYWxsfGRlbGV0ZXxkb3xoYW5kbGVyfGluc2VydHxsb2FkfHJlcGxhY2V8c2VsZWN0fHRydW5jYXRlfHVwZGF0ZXxzZXR8c2hvd3xwcmFnbWF8Z3JhbnQpXFxcXGIoPyE6KScsIC8vIG5lZ2F0aXZlIGxvb2stYWhlYWQgaGVyZSBpcyBzcGVjaWZpY2FsbHkgdG8gcHJldmVudCBzdG9tcGluZyBvbiBTbWFsbFRhbGtcbiAgICAgICAgZW5kOiAnOycsIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgICAgICBrZXl3b3Jkczoge1xuICAgICAgICAgIGtleXdvcmQ6ICdhbGwgcGFydGlhbCBnbG9iYWwgbW9udGggY3VycmVudF90aW1lc3RhbXAgdXNpbmcgZ28gcmV2b2tlIHNtYWxsaW50ICcgK1xuICAgICAgICAgICAgJ2luZGljYXRvciBlbmQtZXhlYyBkaXNjb25uZWN0IHpvbmUgd2l0aCBjaGFyYWN0ZXIgYXNzZXJ0aW9uIHRvIGFkZCBjdXJyZW50X3VzZXIgJyArXG4gICAgICAgICAgICAndXNhZ2UgaW5wdXQgbG9jYWwgYWx0ZXIgbWF0Y2ggY29sbGF0ZSByZWFsIHRoZW4gcm9sbGJhY2sgZ2V0IHJlYWQgdGltZXN0YW1wICcgK1xuICAgICAgICAgICAgJ3Nlc3Npb25fdXNlciBub3QgaW50ZWdlciBiaXQgdW5pcXVlIGRheSBtaW51dGUgZGVzYyBpbnNlcnQgZXhlY3V0ZSBsaWtlIGlsaWtlfDIgJyArXG4gICAgICAgICAgICAnbGV2ZWwgZGVjaW1hbCBkcm9wIGNvbnRpbnVlIGlzb2xhdGlvbiBmb3VuZCB3aGVyZSBjb25zdHJhaW50cyBkb21haW4gcmlnaHQgJyArXG4gICAgICAgICAgICAnbmF0aW9uYWwgc29tZSBtb2R1bGUgdHJhbnNhY3Rpb24gcmVsYXRpdmUgc2Vjb25kIGNvbm5lY3QgZXNjYXBlIGNsb3NlIHN5c3RlbV91c2VyICcgK1xuICAgICAgICAgICAgJ2ZvciBkZWZlcnJlZCBzZWN0aW9uIGNhc3QgY3VycmVudCBzcWxzdGF0ZSBhbGxvY2F0ZSBpbnRlcnNlY3QgZGVhbGxvY2F0ZSBudW1lcmljICcgK1xuICAgICAgICAgICAgJ3B1YmxpYyBwcmVzZXJ2ZSBmdWxsIGdvdG8gaW5pdGlhbGx5IGFzYyBubyBrZXkgb3V0cHV0IGNvbGxhdGlvbiBncm91cCBieSB1bmlvbiAnICtcbiAgICAgICAgICAgICdzZXNzaW9uIGJvdGggbGFzdCBsYW5ndWFnZSBjb25zdHJhaW50IGNvbHVtbiBvZiBzcGFjZSBmb3JlaWduIGRlZmVycmFibGUgcHJpb3IgJyArXG4gICAgICAgICAgICAnY29ubmVjdGlvbiB1bmtub3duIGFjdGlvbiBjb21taXQgdmlldyBvciBmaXJzdCBpbnRvIGZsb2F0IHllYXIgcHJpbWFyeSBjYXNjYWRlZCAnICtcbiAgICAgICAgICAgICdleGNlcHQgcmVzdHJpY3Qgc2V0IHJlZmVyZW5jZXMgbmFtZXMgdGFibGUgb3V0ZXIgb3BlbiBzZWxlY3Qgc2l6ZSBhcmUgcm93cyBmcm9tICcgK1xuICAgICAgICAgICAgJ3ByZXBhcmUgZGlzdGluY3QgbGVhZGluZyBjcmVhdGUgb25seSBuZXh0IGlubmVyIGF1dGhvcml6YXRpb24gc2NoZW1hICcgK1xuICAgICAgICAgICAgJ2NvcnJlc3BvbmRpbmcgb3B0aW9uIGRlY2xhcmUgcHJlY2lzaW9uIGltbWVkaWF0ZSBlbHNlIHRpbWV6b25lX21pbnV0ZSBleHRlcm5hbCAnICtcbiAgICAgICAgICAgICd2YXJ5aW5nIHRyYW5zbGF0aW9uIHRydWUgY2FzZSBleGNlcHRpb24gam9pbiBob3VyIGRlZmF1bHQgZG91YmxlIHNjcm9sbCB2YWx1ZSAnICtcbiAgICAgICAgICAgICdjdXJzb3IgZGVzY3JpcHRvciB2YWx1ZXMgZGVjIGZldGNoIHByb2NlZHVyZSBkZWxldGUgYW5kIGZhbHNlIGludCBpcyBkZXNjcmliZSAnICtcbiAgICAgICAgICAgICdjaGFyIGFzIGF0IGluIHZhcmNoYXIgbnVsbCB0cmFpbGluZyBhbnkgYWJzb2x1dGUgY3VycmVudF90aW1lIGVuZCBncmFudCAnICtcbiAgICAgICAgICAgICdwcml2aWxlZ2VzIHdoZW4gY3Jvc3MgY2hlY2sgd3JpdGUgY3VycmVudF9kYXRlIHBhZCBiZWdpbiB0ZW1wb3JhcnkgZXhlYyB0aW1lICcgK1xuICAgICAgICAgICAgJ3VwZGF0ZSBjYXRhbG9nIHVzZXIgc3FsIGRhdGUgb24gaWRlbnRpdHkgdGltZXpvbmVfaG91ciBuYXR1cmFsIHdoZW5ldmVyIGludGVydmFsICcgK1xuICAgICAgICAgICAgJ3dvcmsgb3JkZXIgY2FzY2FkZSBkaWFnbm9zdGljcyBuY2hhciBoYXZpbmcgbGVmdCBjYWxsIGRvIGhhbmRsZXIgbG9hZCByZXBsYWNlICcgK1xuICAgICAgICAgICAgJ3RydW5jYXRlIHN0YXJ0IGxvY2sgc2hvdyBwcmFnbWEgZXhpc3RzIG51bWJlcicsXG4gICAgICAgICAgYWdncmVnYXRlOiAnY291bnQgc3VtIG1pbiBtYXggYXZnJ1xuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgICAgICBiZWdpbjogJ1xcJycsIGVuZDogJ1xcJycsXG4gICAgICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRSwge2JlZ2luOiAnXFwnXFwnJ31dLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFLCB7YmVnaW46ICdcIlwiJ31dLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgYmVnaW46ICdgJywgZW5kOiAnYCcsXG4gICAgICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhsanMuQ19OVU1CRVJfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiAnLS0nLCBlbmQ6ICckJ1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBDT01NQU5EMSA9IHtcbiAgICBjbGFzc05hbWU6ICdjb21tYW5kJyxcbiAgICBiZWdpbjogJ1xcXFxcXFxcW2EtekEtWtCwLdGP0JAt0Y9dK1tcXFxcKl0/J1xuICB9O1xuICB2YXIgQ09NTUFORDIgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29tbWFuZCcsXG4gICAgYmVnaW46ICdcXFxcXFxcXFteYS16QS1a0LAt0Y/QkC3RjzAtOV0nXG4gIH07XG4gIHZhciBTUEVDSUFMID0ge1xuICAgIGNsYXNzTmFtZTogJ3NwZWNpYWwnLFxuICAgIGJlZ2luOiAnW3t9XFxcXFtcXFxcXVxcXFwmI35dJyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7IC8vIHBhcmFtZXRlclxuICAgICAgICBiZWdpbjogJ1xcXFxcXFxcW2EtekEtWtCwLdGP0JAt0Y9dK1tcXFxcKl0/ICo9ICotP1xcXFxkKlxcXFwuP1xcXFxkKyhwdHxwY3xtbXxjbXxpbnxkZHxjY3xleHxlbSk/JyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgQ09NTUFORDEsIENPTU1BTkQyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgICAgICAgICBiZWdpbjogJyAqPScsIGVuZDogJy0/XFxcXGQqXFxcXC4/XFxcXGQrKHB0fHBjfG1tfGNtfGlufGRkfGNjfGV4fGVtKT8nLFxuICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgQ09NTUFORDEsIENPTU1BTkQyLFxuICAgICAgU1BFQ0lBTCxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZm9ybXVsYScsXG4gICAgICAgIGJlZ2luOiAnXFxcXCRcXFxcJCcsIGVuZDogJ1xcXFwkXFxcXCQnLFxuICAgICAgICBjb250YWluczogW0NPTU1BTkQxLCBDT01NQU5EMiwgU1BFQ0lBTF0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZm9ybXVsYScsXG4gICAgICAgIGJlZ2luOiAnXFxcXCQnLCBlbmQ6ICdcXFxcJCcsXG4gICAgICAgIGNvbnRhaW5zOiBbQ09NTUFORDEsIENPTU1BTkQyLCBTUEVDSUFMXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICclJywgZW5kOiAnJCcsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHJldHVybiB7XG4gICAga2V5d29yZHM6IHtcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgIC8vIFZhbHVlIHR5cGVzXG4gICAgICAgICdjaGFyIHVjaGFyIHVuaWNoYXIgaW50IHVpbnQgbG9uZyB1bG9uZyBzaG9ydCB1c2hvcnQgaW50OCBpbnQxNiBpbnQzMiBpbnQ2NCB1aW50OCAnICtcbiAgICAgICAgJ3VpbnQxNiB1aW50MzIgdWludDY0IGZsb2F0IGRvdWJsZSBib29sIHN0cnVjdCBlbnVtIHN0cmluZyB2b2lkICcgK1xuICAgICAgICAvLyBSZWZlcmVuY2UgdHlwZXNcbiAgICAgICAgJ3dlYWsgdW5vd25lZCBvd25lZCAnICtcbiAgICAgICAgLy8gTW9kaWZpZXJzXG4gICAgICAgICdhc3luYyBzaWduYWwgc3RhdGljIGFic3RyYWN0IGludGVyZmFjZSBvdmVycmlkZSAnICtcbiAgICAgICAgLy8gQ29udHJvbCBTdHJ1Y3R1cmVzXG4gICAgICAgICd3aGlsZSBkbyBmb3IgZm9yZWFjaCBlbHNlIHN3aXRjaCBjYXNlIGJyZWFrIGRlZmF1bHQgcmV0dXJuIHRyeSBjYXRjaCAnICtcbiAgICAgICAgLy8gVmlzaWJpbGl0eVxuICAgICAgICAncHVibGljIHByaXZhdGUgcHJvdGVjdGVkIGludGVybmFsICcgK1xuICAgICAgICAvLyBPdGhlclxuICAgICAgICAndXNpbmcgbmV3IHRoaXMgZ2V0IHNldCBjb25zdCBzdGRvdXQgc3RkaW4gc3RkZXJyIHZhcicsXG4gICAgICBidWlsdF9pbjpcbiAgICAgICAgJ0RCdXMgR0xpYiBDQ29kZSBHZWUgT2JqZWN0JyxcbiAgICAgIGxpdGVyYWw6XG4gICAgICAgICdmYWxzZSB0cnVlIG51bGwnXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsIGVuZDogJ3snLFxuICAgICAgICBrZXl3b3JkczogJ2NsYXNzIGludGVyZmFjZSBkZWxlZ2F0ZSBuYW1lc3BhY2UnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luV2l0aEtleXdvcmQ6IHRydWUsXG4gICAgICAgICAgICBrZXl3b3JkczogJ2V4dGVuZHMgaW1wbGVtZW50cydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogJ1wiXCJcIicsIGVuZDogJ1wiXCJcIicsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBobGpzLkNfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ByZXByb2Nlc3NvcicsXG4gICAgICAgIGJlZ2luOiAnXiMnLCBlbmQ6ICckJyxcbiAgICAgICAgcmVsZXZhbmNlOiAyXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb25zdGFudCcsXG4gICAgICAgIGJlZ2luOiAnIFtBLVpfXSsgJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnY2FsbCBjbGFzcyBjb25zdCBkaW0gZG8gbG9vcCBlcmFzZSBleGVjdXRlIGV4ZWN1dGVnbG9iYWwgZXhpdCBmb3IgZWFjaCBuZXh0IGZ1bmN0aW9uICcgK1xuICAgICAgICAnaWYgdGhlbiBlbHNlIG9uIGVycm9yIG9wdGlvbiBleHBsaWNpdCBuZXcgcHJpdmF0ZSBwcm9wZXJ0eSBsZXQgZ2V0IHB1YmxpYyByYW5kb21pemUgJyArXG4gICAgICAgICdyZWRpbSByZW0gc2VsZWN0IGNhc2Ugc2V0IHN0b3Agc3ViIHdoaWxlIHdlbmQgd2l0aCBlbmQgdG8gZWxzZWlmIGlzIG9yIHhvciBhbmQgbm90ICcgK1xuICAgICAgICAnY2xhc3NfaW5pdGlhbGl6ZSBjbGFzc190ZXJtaW5hdGUgZGVmYXVsdCBwcmVzZXJ2ZSBpbiBtZSBieXZhbCBieXJlZiBzdGVwIHJlc3VtZSBnb3RvJyxcbiAgICAgIGJ1aWx0X2luOlxuICAgICAgICAnbGNhc2UgbW9udGggdmFydHlwZSBpbnN0cnJldiB1Ym91bmQgc2V0bG9jYWxlIGdldG9iamVjdCByZ2IgZ2V0cmVmIHN0cmluZyAnICtcbiAgICAgICAgJ3dlZWtkYXluYW1lIHJuZCBkYXRlYWRkIG1vbnRobmFtZSBub3cgZGF5IG1pbnV0ZSBpc2FycmF5IGNib29sIHJvdW5kIGZvcm1hdGN1cnJlbmN5ICcgK1xuICAgICAgICAnY29udmVyc2lvbnMgY3NuZyB0aW1ldmFsdWUgc2Vjb25kIHllYXIgc3BhY2UgYWJzIGNsbmcgdGltZXNlcmlhbCBmaXhzIGxlbiBhc2MgJyArXG4gICAgICAgICdpc2VtcHR5IG1hdGhzIGRhdGVzZXJpYWwgYXRuIHRpbWVyIGlzb2JqZWN0IGZpbHRlciB3ZWVrZGF5IGRhdGV2YWx1ZSBjY3VyIGlzZGF0ZSAnICtcbiAgICAgICAgJ2luc3RyIGRhdGVkaWZmIGZvcm1hdGRhdGV0aW1lIHJlcGxhY2UgaXNudWxsIHJpZ2h0IHNnbiBhcnJheSBzbnVtZXJpYyBsb2cgY2RibCBoZXggJyArXG4gICAgICAgICdjaHIgbGJvdW5kIG1zZ2JveCB1Y2FzZSBnZXRsb2NhbGUgY29zIGNkYXRlIGNieXRlIHJ0cmltIGpvaW4gaG91ciBvY3QgdHlwZW5hbWUgdHJpbSAnICtcbiAgICAgICAgJ3N0cmNvbXAgaW50IGNyZWF0ZW9iamVjdCBsb2FkcGljdHVyZSB0YW4gZm9ybWF0bnVtYmVyIG1pZCBzY3JpcHRlbmdpbmVidWlsZHZlcnNpb24gJyArXG4gICAgICAgICdzY3JpcHRlbmdpbmUgc3BsaXQgc2NyaXB0ZW5naW5lbWlub3J2ZXJzaW9uIGNpbnQgc2luIGRhdGVwYXJ0IGx0cmltIHNxciAnICtcbiAgICAgICAgJ3NjcmlwdGVuZ2luZW1ham9ydmVyc2lvbiB0aW1lIGRlcml2ZWQgZXZhbCBkYXRlIGZvcm1hdHBlcmNlbnQgZXhwIGlucHV0Ym94IGxlZnQgYXNjdyAnICtcbiAgICAgICAgJ2NocncgcmVnZXhwIHNlcnZlciByZXNwb25zZSByZXF1ZXN0IGNzdHIgZXJyJyxcbiAgICAgIGxpdGVyYWw6XG4gICAgICAgICd0cnVlIGZhbHNlIG51bGwgbm90aGluZyBlbXB0eSdcbiAgICB9LFxuICAgIGlsbGVnYWw6ICcvLycsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7Y29udGFpbnM6IFt7YmVnaW46ICdcIlwiJ31dfSksXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgICBiZWdpbjogJ1xcJycsIGVuZDogJyQnXG4gICAgICB9LFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gICAgXVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnYWJzIGFjY2VzcyBhZnRlciBhbGlhcyBhbGwgYW5kIGFyY2hpdGVjdHVyZSBhcnJheSBhc3NlcnQgYXR0cmlidXRlIGJlZ2luIGJsb2NrICcgK1xuICAgICAgICAnYm9keSBidWZmZXIgYnVzIGNhc2UgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gY29uc3RhbnQgY29udGV4dCBjb3ZlciBkaXNjb25uZWN0ICcgK1xuICAgICAgICAnZG93bnRvIGRlZmF1bHQgZWxzZSBlbHNpZiBlbmQgZW50aXR5IGV4aXQgZmFpcm5lc3MgZmlsZSBmb3IgZm9yY2UgZnVuY3Rpb24gZ2VuZXJhdGUgJyArXG4gICAgICAgICdnZW5lcmljIGdyb3VwIGd1YXJkZWQgaWYgaW1wdXJlIGluIGluZXJ0aWFsIGlub3V0IGlzIGxhYmVsIGxpYnJhcnkgbGlua2FnZSBsaXRlcmFsICcgK1xuICAgICAgICAnbG9vcCBtYXAgbW9kIG5hbmQgbmV3IG5leHQgbm9yIG5vdCBudWxsIG9mIG9uIG9wZW4gb3Igb3RoZXJzIG91dCBwYWNrYWdlIHBvcnQgJyArXG4gICAgICAgICdwb3N0cG9uZWQgcHJvY2VkdXJlIHByb2Nlc3MgcHJvcGVydHkgcHJvdGVjdGVkIHB1cmUgcmFuZ2UgcmVjb3JkIHJlZ2lzdGVyIHJlamVjdCAnICtcbiAgICAgICAgJ3JlbGVhc2UgcmVtIHJlcG9ydCByZXN0cmljdCByZXN0cmljdF9ndWFyYW50ZWUgcmV0dXJuIHJvbCByb3Igc2VsZWN0IHNlcXVlbmNlICcgK1xuICAgICAgICAnc2V2ZXJpdHkgc2hhcmVkIHNpZ25hbCBzbGEgc2xsIHNyYSBzcmwgc3Ryb25nIHN1YnR5cGUgdGhlbiB0byB0cmFuc3BvcnQgdHlwZSAnICtcbiAgICAgICAgJ3VuYWZmZWN0ZWQgdW5pdHMgdW50aWwgdXNlIHZhcmlhYmxlIHZtb2RlIHZwcm9wIHZ1bml0IHdhaXQgd2hlbiB3aGlsZSB3aXRoIHhub3IgeG9yJyxcbiAgICAgIHR5cGVuYW1lOlxuICAgICAgICAnYm9vbGVhbiBiaXQgY2hhcmFjdGVyIHNldmVyaXR5X2xldmVsIGludGVnZXIgdGltZSBkZWxheV9sZW5ndGggbmF0dXJhbCBwb3NpdGl2ZSAnICtcbiAgICAgICAgJ3N0cmluZyBiaXRfdmVjdG9yIGZpbGVfb3Blbl9raW5kIGZpbGVfb3Blbl9zdGF0dXMgc3RkX3Vsb2dpYyBzdGRfdWxvZ2ljX3ZlY3RvciAnICtcbiAgICAgICAgJ3N0ZF9sb2dpYyBzdGRfbG9naWNfdmVjdG9yIHVuc2lnbmVkIHNpZ25lZCBib29sZWFuX3ZlY3RvciBpbnRlZ2VyX3ZlY3RvciAnICtcbiAgICAgICAgJ3JlYWxfdmVjdG9yIHRpbWVfdmVjdG9yJ1xuICAgIH0sXG4gICAgaWxsZWdhbDogJ3snLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLCAgICAgICAgLy8gVkhETC0yMDA4IGJsb2NrIGNvbW1lbnRpbmcuXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgICBiZWdpbjogJy0tJywgZW5kOiAnJCdcbiAgICAgIH0sXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5DX05VTUJFUl9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdsaXRlcmFsJyxcbiAgICAgICAgYmVnaW46ICdcXCcoVXxYfDB8MXxafFd8THxIfC0pXFwnJyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogJ1xcJ1tBLVphLXpdKF8/W0EtWmEtejAtOV0pKicsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgICAgfVxuICAgIF1cbiAgfTsgLy8gcmV0dXJuXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgWE1MX0lERU5UX1JFID0gJ1tBLVphLXowLTlcXFxcLl86LV0rJztcbiAgdmFyIFRBR19JTlRFUk5BTFMgPSB7XG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46IFhNTF9JREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJz1cIicsIHJldHVybkJlZ2luOiB0cnVlLCBlbmQ6ICdcIicsXG4gICAgICAgIGNvbnRhaW5zOiBbe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgYmVnaW46ICdcIicsIGVuZHNXaXRoUGFyZW50OiB0cnVlXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJz1cXCcnLCByZXR1cm5CZWdpbjogdHJ1ZSwgZW5kOiAnXFwnJyxcbiAgICAgICAgY29udGFpbnM6IFt7XG4gICAgICAgICAgY2xhc3NOYW1lOiAndmFsdWUnLFxuICAgICAgICAgIGJlZ2luOiAnXFwnJywgZW5kc1dpdGhQYXJlbnQ6IHRydWVcbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnPScsXG4gICAgICAgIGNvbnRhaW5zOiBbe1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICBiZWdpbjogJ1teXFxcXHMvPl0rJ1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BpJyxcbiAgICAgICAgYmVnaW46ICc8XFxcXD8nLCBlbmQ6ICdcXFxcPz4nLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdkb2N0eXBlJyxcbiAgICAgICAgYmVnaW46ICc8IURPQ1RZUEUnLCBlbmQ6ICc+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICdcXFxcWycsIGVuZDogJ1xcXFxdJ31dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46ICc8IS0tJywgZW5kOiAnLS0+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2RhdGEnLFxuICAgICAgICBiZWdpbjogJzxcXFxcIVxcXFxbQ0RBVEFcXFxcWycsIGVuZDogJ1xcXFxdXFxcXF0+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLypcbiAgICAgICAgVGhlIGxvb2thaGVhZCBwYXR0ZXJuICg/PS4uLikgZW5zdXJlcyB0aGF0ICdiZWdpbicgb25seSBtYXRjaGVzXG4gICAgICAgICc8c3R5bGUnIGFzIGEgc2luZ2xlIHdvcmQsIGZvbGxvd2VkIGJ5IGEgd2hpdGVzcGFjZSBvciBhblxuICAgICAgICBlbmRpbmcgYnJha2V0LiBUaGUgJyQnIGlzIG5lZWRlZCBmb3IgdGhlIGxleGVtIHRvIGJlIHJlY29nbml6ZWRcbiAgICAgICAgYnkgaGxqcy5zdWJNb2RlKCkgdGhhdCB0ZXN0cyBsZXhlbXMgb3V0c2lkZSB0aGUgc3RyZWFtLlxuICAgICAgICAqL1xuICAgICAgICBiZWdpbjogJzxzdHlsZSg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHt0aXRsZTogJ3N0eWxlJ30sXG4gICAgICAgIGNvbnRhaW5zOiBbVEFHX0lOVEVSTkFMU10sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogJzwvc3R5bGU+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiAnY3NzJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIDxzdHlsZSB0YWcgYWJvdXQgdGhlIGxvb2thaGVhZCBwYXR0ZXJuXG4gICAgICAgIGJlZ2luOiAnPHNjcmlwdCg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHt0aXRsZTogJ3NjcmlwdCd9LFxuICAgICAgICBjb250YWluczogW1RBR19JTlRFUk5BTFNdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6ICc8L3NjcmlwdD4nLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6ICdqYXZhc2NyaXB0J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJzwlJywgZW5kOiAnJT4nLFxuICAgICAgICBzdWJMYW5ndWFnZTogJ3Zic2NyaXB0J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46ICc8Lz8nLCBlbmQ6ICcvPz4nLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJywgYmVnaW46ICdbXiAvPl0rJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgVEFHX0lOVEVSTkFMU1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTsiLCIvKiFcclxuICogSmFkZSAtIENvbXBpbGVyXHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuXHJcbnZhciBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKVxyXG4gICwgZmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycycpXHJcbiAgLCBkb2N0eXBlcyA9IHJlcXVpcmUoJy4vZG9jdHlwZXMnKVxyXG4gICwgc2VsZkNsb3NpbmcgPSByZXF1aXJlKCcuL3NlbGYtY2xvc2luZycpXHJcbiAgLCBydW50aW1lID0gcmVxdWlyZSgnLi9ydW50aW1lJylcclxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXHJcbiAgLCBwYXJzZUpTRXhwcmVzc2lvbiA9IHJlcXVpcmUoJ2NoYXJhY3Rlci1wYXJzZXInKS5wYXJzZU1heFxyXG4gICwgaXNDb25zdGFudCA9IHJlcXVpcmUoJ2NvbnN0YW50aW5vcGxlJylcclxuICAsIHRvQ29uc3RhbnQgPSByZXF1aXJlKCdjb25zdGFudGlub3BsZScpLnRvQ29uc3RhbnRcclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBgQ29tcGlsZXJgIHdpdGggdGhlIGdpdmVuIGBub2RlYC5cclxuICpcclxuICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxudmFyIENvbXBpbGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDb21waWxlcihub2RlLCBvcHRpb25zKSB7XHJcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgdGhpcy5ub2RlID0gbm9kZTtcclxuICB0aGlzLmhhc0NvbXBpbGVkRG9jdHlwZSA9IGZhbHNlO1xyXG4gIHRoaXMuaGFzQ29tcGlsZWRUYWcgPSBmYWxzZTtcclxuICB0aGlzLnBwID0gb3B0aW9ucy5wcmV0dHkgfHwgZmFsc2U7XHJcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXBpbGVEZWJ1ZztcclxuICB0aGlzLmluZGVudHMgPSAwO1xyXG4gIHRoaXMucGFyZW50SW5kZW50cyA9IDA7XHJcbiAgaWYgKG9wdGlvbnMuZG9jdHlwZSkgdGhpcy5zZXREb2N0eXBlKG9wdGlvbnMuZG9jdHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGlsZXIgcHJvdG90eXBlLlxyXG4gKi9cclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZSBwYXJzZSB0cmVlIHRvIEphdmFTY3JpcHQuXHJcbiAgICpcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICBjb21waWxlOiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5idWYgPSBbXTtcclxuICAgIGlmICh0aGlzLnBwKSB0aGlzLmJ1Zi5wdXNoKFwiamFkZS5pbmRlbnQgPSBbXTtcIik7XHJcbiAgICB0aGlzLmxhc3RCdWZmZXJlZElkeCA9IC0xO1xyXG4gICAgdGhpcy52aXNpdCh0aGlzLm5vZGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmLmpvaW4oJ1xcbicpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgZG9jdHlwZSBgbmFtZWAuIFNldHMgdGVyc2UgbW9kZSB0byBgdHJ1ZWAgd2hlblxyXG4gICAqIGh0bWwgNSBpcyB1c2VkLCBjYXVzaW5nIHNlbGYtY2xvc2luZyB0YWdzIHRvIGVuZCB3aXRoIFwiPlwiIHZzIFwiLz5cIixcclxuICAgKiBhbmQgYm9vbGVhbiBhdHRyaWJ1dGVzIGFyZSBub3QgbWlycm9yZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHNldERvY3R5cGU6IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgbmFtZSA9IG5hbWUgfHwgJ2RlZmF1bHQnO1xyXG4gICAgdGhpcy5kb2N0eXBlID0gZG9jdHlwZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCAnPCFET0NUWVBFICcgKyBuYW1lICsgJz4nO1xyXG4gICAgdGhpcy50ZXJzZSA9IHRoaXMuZG9jdHlwZS50b0xvd2VyQ2FzZSgpID09ICc8IWRvY3R5cGUgaHRtbD4nO1xyXG4gICAgdGhpcy54bWwgPSAwID09IHRoaXMuZG9jdHlwZS5pbmRleE9mKCc8P3htbCcpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1ZmZlciB0aGUgZ2l2ZW4gYHN0cmAgZXhhY3RseSBhcyBpcyBvciB3aXRoIGludGVycG9sYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGludGVycG9sYXRlXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgYnVmZmVyOiBmdW5jdGlvbiAoc3RyLCBpbnRlcnBvbGF0ZSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IC8oXFxcXCk/KFsjIV0peygoPzoufFxcbikqKSQvLmV4ZWMoc3RyKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIoc3RyLnN1YnN0cigwLCBtYXRjaC5pbmRleCksIGZhbHNlKTtcclxuICAgICAgICBpZiAobWF0Y2hbMV0pIHsgLy8gZXNjYXBlXHJcbiAgICAgICAgICB0aGlzLmJ1ZmZlcihtYXRjaFsyXSArICd7JywgZmFsc2UpO1xyXG4gICAgICAgICAgdGhpcy5idWZmZXIobWF0Y2hbM10sIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IG1hdGNoWzNdO1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBwYXJzZUpTRXhwcmVzc2lvbihyZXN0KTtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSAoJyEnID09IG1hdGNoWzJdID8gJycgOiAnamFkZS5lc2NhcGUnKSArIFwiKChqYWRlLmludGVycCA9IFwiICsgcmFuZ2Uuc3JjICsgXCIpID09IG51bGwgPyAnJyA6IGphZGUuaW50ZXJwKVwiO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXg7XHJcbiAgICAgICAgICAgIC8vZGlkbid0IG1hdGNoLCBqdXN0IGFzIGlmIGVzY2FwZWRcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIobWF0Y2hbMl0gKyAneycsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIobWF0Y2hbM10sIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmJ1ZmZlckV4cHJlc3Npb24oY29kZSk7XHJcbiAgICAgICAgICB0aGlzLmJ1ZmZlcihyZXN0LnN1YnN0cihyYW5nZS5lbmQgKyAxKSwgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyKTtcclxuICAgIHN0ciA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xyXG5cclxuICAgIGlmICh0aGlzLmxhc3RCdWZmZXJlZElkeCA9PSB0aGlzLmJ1Zi5sZW5ndGgpIHtcclxuICAgICAgaWYgKHRoaXMubGFzdEJ1ZmZlcmVkVHlwZSA9PT0gJ2NvZGUnKSB0aGlzLmxhc3RCdWZmZXJlZCArPSAnICsgXCInO1xyXG4gICAgICB0aGlzLmxhc3RCdWZmZXJlZFR5cGUgPSAndGV4dCc7XHJcbiAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkICs9IHN0cjtcclxuICAgICAgdGhpcy5idWZbdGhpcy5sYXN0QnVmZmVyZWRJZHggLSAxXSA9ICdidWYucHVzaCgnICsgdGhpcy5idWZmZXJTdGFydENoYXIgKyB0aGlzLmxhc3RCdWZmZXJlZCArICdcIik7J1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5idWYucHVzaCgnYnVmLnB1c2goXCInICsgc3RyICsgJ1wiKTsnKTtcclxuICAgICAgdGhpcy5sYXN0QnVmZmVyZWRUeXBlID0gJ3RleHQnO1xyXG4gICAgICB0aGlzLmJ1ZmZlclN0YXJ0Q2hhciA9ICdcIic7XHJcbiAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkID0gc3RyO1xyXG4gICAgICB0aGlzLmxhc3RCdWZmZXJlZElkeCA9IHRoaXMuYnVmLmxlbmd0aDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBCdWZmZXIgdGhlIGdpdmVuIGBzcmNgIHNvIGl0IGlzIGV2YWx1YXRlZCBhdCBydW4gdGltZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIGJ1ZmZlckV4cHJlc3Npb246IGZ1bmN0aW9uIChzcmMpIHtcclxuICAgIGlmIChpc0NvbnN0YW50KHNyYykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyKHRvQ29uc3RhbnQoc3JjKSwgZmFsc2UpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sYXN0QnVmZmVyZWRJZHggPT0gdGhpcy5idWYubGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RCdWZmZXJlZFR5cGUgPT09ICd0ZXh0JykgdGhpcy5sYXN0QnVmZmVyZWQgKz0gJ1wiJztcclxuICAgICAgdGhpcy5sYXN0QnVmZmVyZWRUeXBlID0gJ2NvZGUnO1xyXG4gICAgICB0aGlzLmxhc3RCdWZmZXJlZCArPSAnICsgKCcgKyBzcmMgKyAnKSc7XHJcbiAgICAgIHRoaXMuYnVmW3RoaXMubGFzdEJ1ZmZlcmVkSWR4IC0gMV0gPSAnYnVmLnB1c2goJyArIHRoaXMuYnVmZmVyU3RhcnRDaGFyICsgdGhpcy5sYXN0QnVmZmVyZWQgKyAnKTsnXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKCdidWYucHVzaCgnICsgc3JjICsgJyk7Jyk7XHJcbiAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkVHlwZSA9ICdjb2RlJztcclxuICAgICAgdGhpcy5idWZmZXJTdGFydENoYXIgPSAnJztcclxuICAgICAgdGhpcy5sYXN0QnVmZmVyZWQgPSAnKCcgKyBzcmMgKyAnKSc7XHJcbiAgICAgIHRoaXMubGFzdEJ1ZmZlcmVkSWR4ID0gdGhpcy5idWYubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1ZmZlciBhbiBpbmRlbnQgYmFzZWQgb24gdGhlIGN1cnJlbnQgYGluZGVudGBcclxuICAgKiBwcm9wZXJ0eSBhbmQgYW4gYWRkaXRpb25hbCBgb2Zmc2V0YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5ld2xpbmVcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICBwcmV0dHlJbmRlbnQ6IGZ1bmN0aW9uKG9mZnNldCwgbmV3bGluZSl7XHJcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcclxuICAgIG5ld2xpbmUgPSBuZXdsaW5lID8gJ1xcbicgOiAnJztcclxuICAgIHRoaXMuYnVmZmVyKG5ld2xpbmUgKyBBcnJheSh0aGlzLmluZGVudHMgKyBvZmZzZXQpLmpvaW4oJyAgJykpO1xyXG4gICAgaWYgKHRoaXMucGFyZW50SW5kZW50cylcclxuICAgICAgdGhpcy5idWYucHVzaChcImJ1Zi5wdXNoLmFwcGx5KGJ1ZiwgamFkZS5pbmRlbnQpO1wiKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCBgbm9kZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICB2aXNpdDogZnVuY3Rpb24obm9kZSl7XHJcbiAgICB2YXIgZGVidWcgPSB0aGlzLmRlYnVnO1xyXG5cclxuICAgIGlmIChkZWJ1Zykge1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKCdqYWRlLmRlYnVnLnVuc2hpZnQoeyBsaW5lbm86ICcgKyBub2RlLmxpbmVcclxuICAgICAgICArICcsIGZpbGVuYW1lOiAnICsgKG5vZGUuZmlsZW5hbWVcclxuICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkobm9kZS5maWxlbmFtZSlcclxuICAgICAgICAgIDogJ2phZGUuZGVidWdbMF0uZmlsZW5hbWUnKVxyXG4gICAgICAgICsgJyB9KTsnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXNzaXZlIGhhY2sgdG8gZml4IG91ciBjb250ZXh0XHJcbiAgICAvLyBzdGFjayBmb3IgLSBlbHNlWyBpZl0gZXRjXHJcbiAgICBpZiAoZmFsc2UgPT09IG5vZGUuZGVidWcgJiYgdGhpcy5kZWJ1Zykge1xyXG4gICAgICB0aGlzLmJ1Zi5wb3AoKTtcclxuICAgICAgdGhpcy5idWYucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52aXNpdE5vZGUobm9kZSk7XHJcblxyXG4gICAgaWYgKGRlYnVnKSB0aGlzLmJ1Zi5wdXNoKCdqYWRlLmRlYnVnLnNoaWZ0KCk7Jyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYG5vZGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXROb2RlOiBmdW5jdGlvbihub2RlKXtcclxuICAgIHZhciBuYW1lID0gbm9kZS5jb25zdHJ1Y3Rvci5uYW1lXHJcbiAgICAgIHx8IG5vZGUuY29uc3RydWN0b3IudG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb24gKFteKFxcc10rKSgpLylbMV07XHJcbiAgICByZXR1cm4gdGhpc1sndmlzaXQnICsgbmFtZV0obm9kZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgY2FzZSBgbm9kZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0xpdGVyYWx9IG5vZGVcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICB2aXNpdENhc2U6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgdmFyIF8gPSB0aGlzLndpdGhpbkNhc2U7XHJcbiAgICB0aGlzLndpdGhpbkNhc2UgPSB0cnVlO1xyXG4gICAgdGhpcy5idWYucHVzaCgnc3dpdGNoICgnICsgbm9kZS5leHByICsgJyl7Jyk7XHJcbiAgICB0aGlzLnZpc2l0KG5vZGUuYmxvY2spO1xyXG4gICAgdGhpcy5idWYucHVzaCgnfScpO1xyXG4gICAgdGhpcy53aXRoaW5DYXNlID0gXztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCB3aGVuIGBub2RlYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TGl0ZXJhbH0gbm9kZVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHZpc2l0V2hlbjogZnVuY3Rpb24obm9kZSl7XHJcbiAgICBpZiAoJ2RlZmF1bHQnID09IG5vZGUuZXhwcikge1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKCdkZWZhdWx0OicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5idWYucHVzaCgnY2FzZSAnICsgbm9kZS5leHByICsgJzonKTtcclxuICAgIH1cclxuICAgIHRoaXMudmlzaXQobm9kZS5ibG9jayk7XHJcbiAgICB0aGlzLmJ1Zi5wdXNoKCcgIGJyZWFrOycpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFZpc2l0IGxpdGVyYWwgYG5vZGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtMaXRlcmFsfSBub2RlXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXRMaXRlcmFsOiBmdW5jdGlvbihub2RlKXtcclxuICAgIHRoaXMuYnVmZmVyKG5vZGUuc3RyKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCBhbGwgbm9kZXMgaW4gYGJsb2NrYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXRCbG9jazogZnVuY3Rpb24oYmxvY2spe1xyXG4gICAgdmFyIGxlbiA9IGJsb2NrLm5vZGVzLmxlbmd0aFxyXG4gICAgICAsIGVzY2FwZSA9IHRoaXMuZXNjYXBlXHJcbiAgICAgICwgcHAgPSB0aGlzLnBwXHJcblxyXG4gICAgLy8gQmxvY2sga2V5d29yZCBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgaW4gbWl4aW5zXHJcbiAgICBpZiAodGhpcy5wYXJlbnRJbmRlbnRzICYmIGJsb2NrLm1vZGUpIHtcclxuICAgICAgaWYgKHBwKSB0aGlzLmJ1Zi5wdXNoKFwiamFkZS5pbmRlbnQucHVzaCgnXCIgKyBBcnJheSh0aGlzLmluZGVudHMgKyAxKS5qb2luKCcgICcpICsgXCInKTtcIilcclxuICAgICAgdGhpcy5idWYucHVzaCgnYmxvY2sgJiYgYmxvY2soKTsnKTtcclxuICAgICAgaWYgKHBwKSB0aGlzLmJ1Zi5wdXNoKFwiamFkZS5pbmRlbnQucG9wKCk7XCIpXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmV0dHkgcHJpbnQgbXVsdGktbGluZSB0ZXh0XHJcbiAgICBpZiAocHAgJiYgbGVuID4gMSAmJiAhZXNjYXBlICYmIGJsb2NrLm5vZGVzWzBdLmlzVGV4dCAmJiBibG9jay5ub2Rlc1sxXS5pc1RleHQpXHJcbiAgICAgIHRoaXMucHJldHR5SW5kZW50KDEsIHRydWUpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgLy8gUHJldHR5IHByaW50IHRleHRcclxuICAgICAgaWYgKHBwICYmIGkgPiAwICYmICFlc2NhcGUgJiYgYmxvY2subm9kZXNbaV0uaXNUZXh0ICYmIGJsb2NrLm5vZGVzW2ktMV0uaXNUZXh0KVxyXG4gICAgICAgIHRoaXMucHJldHR5SW5kZW50KDEsIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMudmlzaXQoYmxvY2subm9kZXNbaV0pO1xyXG4gICAgICAvLyBNdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBzZXBhcmF0ZWQgYnkgbmV3bGluZXNcclxuICAgICAgaWYgKGJsb2NrLm5vZGVzW2krMV0gJiYgYmxvY2subm9kZXNbaV0uaXNUZXh0ICYmIGJsb2NrLm5vZGVzW2krMV0uaXNUZXh0KVxyXG4gICAgICAgIHRoaXMuYnVmZmVyKCdcXG4nKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCBgZG9jdHlwZWAuIFNldHMgdGVyc2UgbW9kZSB0byBgdHJ1ZWAgd2hlbiBodG1sIDVcclxuICAgKiBpcyB1c2VkLCBjYXVzaW5nIHNlbGYtY2xvc2luZyB0YWdzIHRvIGVuZCB3aXRoIFwiPlwiIHZzIFwiLz5cIixcclxuICAgKiBhbmQgYm9vbGVhbiBhdHRyaWJ1dGVzIGFyZSBub3QgbWlycm9yZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RvY3R5cGV9IGRvY3R5cGVcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICB2aXNpdERvY3R5cGU6IGZ1bmN0aW9uKGRvY3R5cGUpe1xyXG4gICAgaWYgKGRvY3R5cGUgJiYgKGRvY3R5cGUudmFsIHx8ICF0aGlzLmRvY3R5cGUpKSB7XHJcbiAgICAgIHRoaXMuc2V0RG9jdHlwZShkb2N0eXBlLnZhbCB8fCAnZGVmYXVsdCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRvY3R5cGUpIHRoaXMuYnVmZmVyKHRoaXMuZG9jdHlwZSk7XHJcbiAgICB0aGlzLmhhc0NvbXBpbGVkRG9jdHlwZSA9IHRydWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYG1peGluYCwgZ2VuZXJhdGluZyBhIGZ1bmN0aW9uIHRoYXRcclxuICAgKiBtYXkgYmUgY2FsbGVkIHdpdGhpbiB0aGUgdGVtcGxhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01peGlufSBtaXhpblxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHZpc2l0TWl4aW46IGZ1bmN0aW9uKG1peGluKXtcclxuICAgIHZhciBuYW1lID0gbWl4aW4ubmFtZS5yZXBsYWNlKC8tL2csICdfJykgKyAnX21peGluJ1xyXG4gICAgICAsIGFyZ3MgPSBtaXhpbi5hcmdzIHx8ICcnXHJcbiAgICAgICwgYmxvY2sgPSBtaXhpbi5ibG9ja1xyXG4gICAgICAsIGF0dHJzID0gbWl4aW4uYXR0cnNcclxuICAgICAgLCBwcCA9IHRoaXMucHA7XHJcblxyXG4gICAgaWYgKG1peGluLmNhbGwpIHtcclxuICAgICAgaWYgKHBwKSB0aGlzLmJ1Zi5wdXNoKFwiamFkZS5pbmRlbnQucHVzaCgnXCIgKyBBcnJheSh0aGlzLmluZGVudHMgKyAxKS5qb2luKCcgICcpICsgXCInKTtcIilcclxuICAgICAgaWYgKGJsb2NrIHx8IGF0dHJzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICB0aGlzLmJ1Zi5wdXNoKG5hbWUgKyAnLmNhbGwoeycpO1xyXG5cclxuICAgICAgICBpZiAoYmxvY2spIHtcclxuICAgICAgICAgIHRoaXMuYnVmLnB1c2goJ2Jsb2NrOiBmdW5jdGlvbigpeycpO1xyXG5cclxuICAgICAgICAgIC8vIFJlbmRlciBibG9jayB3aXRoIG5vIGluZGVudHMsIGR5bmFtaWNhbGx5IGFkZGVkIHdoZW4gcmVuZGVyZWRcclxuICAgICAgICAgIHRoaXMucGFyZW50SW5kZW50cysrO1xyXG4gICAgICAgICAgdmFyIF9pbmRlbnRzID0gdGhpcy5pbmRlbnRzO1xyXG4gICAgICAgICAgdGhpcy5pbmRlbnRzID0gMDtcclxuICAgICAgICAgIHRoaXMudmlzaXQobWl4aW4uYmxvY2spO1xyXG4gICAgICAgICAgdGhpcy5pbmRlbnRzID0gX2luZGVudHM7XHJcbiAgICAgICAgICB0aGlzLnBhcmVudEluZGVudHMtLTtcclxuXHJcbiAgICAgICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJ30sJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCd9Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gdGhpcy5hdHRycyhhdHRycyk7XHJcbiAgICAgICAgICBpZiAodmFsLmluaGVyaXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJ2F0dHJpYnV0ZXM6IGphZGUubWVyZ2UoeycgKyB2YWwuYnVmXHJcbiAgICAgICAgICAgICAgICArICd9LCBhdHRyaWJ1dGVzKSwgZXNjYXBlZDogamFkZS5tZXJnZSgnICsgdmFsLmVzY2FwZWQgKyAnLCBlc2NhcGVkLCB0cnVlKScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnYXR0cmlidXRlczogeycgKyB2YWwuYnVmICsgJ30sIGVzY2FwZWQ6ICcgKyB2YWwuZXNjYXBlZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXJncykge1xyXG4gICAgICAgICAgdGhpcy5idWYucHVzaCgnfSwgJyArIGFyZ3MgKyAnKTsnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5idWYucHVzaCgnfSk7Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmJ1Zi5wdXNoKG5hbWUgKyAnKCcgKyBhcmdzICsgJyk7Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBwKSB0aGlzLmJ1Zi5wdXNoKFwiamFkZS5pbmRlbnQucG9wKCk7XCIpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKCd2YXIgJyArIG5hbWUgKyAnID0gZnVuY3Rpb24oJyArIGFyZ3MgKyAnKXsnKTtcclxuICAgICAgdGhpcy5idWYucHVzaCgndmFyIGJsb2NrID0gdGhpcy5ibG9jaywgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcyB8fCB7fSwgZXNjYXBlZCA9IHRoaXMuZXNjYXBlZCB8fCB7fTsnKTtcclxuICAgICAgdGhpcy5wYXJlbnRJbmRlbnRzKys7XHJcbiAgICAgIHRoaXMudmlzaXQoYmxvY2spO1xyXG4gICAgICB0aGlzLnBhcmVudEluZGVudHMtLTtcclxuICAgICAgdGhpcy5idWYucHVzaCgnfTsnKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCBgdGFnYCBidWZmZXJpbmcgdGFnIG1hcmt1cCwgZ2VuZXJhdGluZ1xyXG4gICAqIGF0dHJpYnV0ZXMsIHZpc2l0aW5nIHRoZSBgdGFnYCdzIGNvZGUgYW5kIGJsb2NrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUYWd9IHRhZ1xyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHZpc2l0VGFnOiBmdW5jdGlvbih0YWcpe1xyXG4gICAgdGhpcy5pbmRlbnRzKys7XHJcbiAgICB2YXIgbmFtZSA9IHRhZy5uYW1lXHJcbiAgICAgICwgcHAgPSB0aGlzLnBwXHJcbiAgICAgICwgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgZnVuY3Rpb24gYnVmZmVyTmFtZSgpIHtcclxuICAgICAgaWYgKHRhZy5idWZmZXIpIHNlbGYuYnVmZmVyRXhwcmVzc2lvbihuYW1lKTtcclxuICAgICAgZWxzZSBzZWxmLmJ1ZmZlcihuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuaGFzQ29tcGlsZWRUYWcpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhc0NvbXBpbGVkRG9jdHlwZSAmJiAnaHRtbCcgPT0gbmFtZSkge1xyXG4gICAgICAgIHRoaXMudmlzaXREb2N0eXBlKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5oYXNDb21waWxlZFRhZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJldHR5IHByaW50XHJcbiAgICBpZiAocHAgJiYgIXRhZy5pc0lubGluZSgpKVxyXG4gICAgICB0aGlzLnByZXR0eUluZGVudCgwLCB0cnVlKTtcclxuXHJcbiAgICBpZiAoKH5zZWxmQ2xvc2luZy5pbmRleE9mKG5hbWUpIHx8IHRhZy5zZWxmQ2xvc2luZykgJiYgIXRoaXMueG1sKSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyKCc8Jyk7XHJcbiAgICAgIGJ1ZmZlck5hbWUoKTtcclxuICAgICAgdGhpcy52aXNpdEF0dHJpYnV0ZXModGFnLmF0dHJzKTtcclxuICAgICAgdGhpcy50ZXJzZVxyXG4gICAgICAgID8gdGhpcy5idWZmZXIoJz4nKVxyXG4gICAgICAgIDogdGhpcy5idWZmZXIoJy8+Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPcHRpbWl6ZSBhdHRyaWJ1dGVzIGJ1ZmZlcmluZ1xyXG4gICAgICBpZiAodGFnLmF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyKCc8Jyk7XHJcbiAgICAgICAgYnVmZmVyTmFtZSgpO1xyXG4gICAgICAgIGlmICh0YWcuYXR0cnMubGVuZ3RoKSB0aGlzLnZpc2l0QXR0cmlidXRlcyh0YWcuYXR0cnMpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyKCc+Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIoJzwnKTtcclxuICAgICAgICBidWZmZXJOYW1lKCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIoJz4nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGFnLmNvZGUpIHRoaXMudmlzaXRDb2RlKHRhZy5jb2RlKTtcclxuICAgICAgdGhpcy5lc2NhcGUgPSAncHJlJyA9PSB0YWcubmFtZTtcclxuICAgICAgdGhpcy52aXNpdCh0YWcuYmxvY2spO1xyXG5cclxuICAgICAgLy8gcHJldHR5IHByaW50XHJcbiAgICAgIGlmIChwcCAmJiAhdGFnLmlzSW5saW5lKCkgJiYgJ3ByZScgIT0gdGFnLm5hbWUgJiYgIXRhZy5jYW5JbmxpbmUoKSlcclxuICAgICAgICB0aGlzLnByZXR0eUluZGVudCgwLCB0cnVlKTtcclxuXHJcbiAgICAgIHRoaXMuYnVmZmVyKCc8LycpO1xyXG4gICAgICBidWZmZXJOYW1lKCk7XHJcbiAgICAgIHRoaXMuYnVmZmVyKCc+Jyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmluZGVudHMtLTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBWaXNpdCBgZmlsdGVyYCwgdGhyb3dpbmcgd2hlbiB0aGUgZmlsdGVyIGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlclxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHZpc2l0RmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIpe1xyXG4gICAgdmFyIHRleHQgPSBmaWx0ZXIuYmxvY2subm9kZXMubWFwKFxyXG4gICAgICBmdW5jdGlvbihub2RlKXsgcmV0dXJuIG5vZGUudmFsOyB9XHJcbiAgICApLmpvaW4oJ1xcbicpO1xyXG4gICAgZmlsdGVyLmF0dHJzID0gZmlsdGVyLmF0dHJzIHx8IHt9O1xyXG4gICAgZmlsdGVyLmF0dHJzLmZpbGVuYW1lID0gdGhpcy5vcHRpb25zLmZpbGVuYW1lO1xyXG4gICAgdGhpcy5idWZmZXIoZmlsdGVycyhmaWx0ZXIubmFtZSwgdGV4dCwgZmlsdGVyLmF0dHJzKSwgdHJ1ZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYHRleHRgIG5vZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHR9IHRleHRcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICB2aXNpdFRleHQ6IGZ1bmN0aW9uKHRleHQpe1xyXG4gICAgdGhpcy5idWZmZXIodGV4dC52YWwsIHRydWUpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFZpc2l0IGEgYGNvbW1lbnRgLCBvbmx5IGJ1ZmZlcmluZyB3aGVuIHRoZSBidWZmZXIgZmxhZyBpcyBzZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbW1lbnR9IGNvbW1lbnRcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xyXG5cclxuICB2aXNpdENvbW1lbnQ6IGZ1bmN0aW9uKGNvbW1lbnQpe1xyXG4gICAgaWYgKCFjb21tZW50LmJ1ZmZlcikgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMucHApIHRoaXMucHJldHR5SW5kZW50KDEsIHRydWUpO1xyXG4gICAgdGhpcy5idWZmZXIoJzwhLS0nICsgY29tbWVudC52YWwgKyAnLS0+Jyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYSBgQmxvY2tDb21tZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tbWVudH0gY29tbWVudFxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXHJcblxyXG4gIHZpc2l0QmxvY2tDb21tZW50OiBmdW5jdGlvbihjb21tZW50KXtcclxuICAgIGlmICghY29tbWVudC5idWZmZXIpIHJldHVybjtcclxuICAgIGlmICh0aGlzLnBwKSB0aGlzLnByZXR0eUluZGVudCgxLCB0cnVlKTtcclxuICAgIGlmICgwID09IGNvbW1lbnQudmFsLnRyaW0oKS5pbmRleE9mKCdpZicpKSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyKCc8IS0tWycgKyBjb21tZW50LnZhbC50cmltKCkgKyAnXT4nKTtcclxuICAgICAgdGhpcy52aXNpdChjb21tZW50LmJsb2NrKTtcclxuICAgICAgaWYgKHRoaXMucHApIHRoaXMucHJldHR5SW5kZW50KDEsIHRydWUpO1xyXG4gICAgICB0aGlzLmJ1ZmZlcignPCFbZW5kaWZdLS0+Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmJ1ZmZlcignPCEtLScgKyBjb21tZW50LnZhbCk7XHJcbiAgICAgIHRoaXMudmlzaXQoY29tbWVudC5ibG9jayk7XHJcbiAgICAgIGlmICh0aGlzLnBwKSB0aGlzLnByZXR0eUluZGVudCgxLCB0cnVlKTtcclxuICAgICAgdGhpcy5idWZmZXIoJy0tPicpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFZpc2l0IGBjb2RlYCwgcmVzcGVjdGluZyBidWZmZXIgLyBlc2NhcGUgZmxhZ3MuXHJcbiAgICogSWYgdGhlIGNvZGUgaXMgZm9sbG93ZWQgYnkgYSBibG9jaywgd3JhcCBpdCBpblxyXG4gICAqIGEgc2VsZi1jYWxsaW5nIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDb2RlfSBjb2RlXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXRDb2RlOiBmdW5jdGlvbihjb2RlKXtcclxuICAgIC8vIFdyYXAgY29kZSBibG9ja3Mgd2l0aCB7fS5cclxuICAgIC8vIHdlIG9ubHkgd3JhcCB1bmJ1ZmZlcmVkIGNvZGUgYmxvY2tzIEFUTVxyXG4gICAgLy8gc2luY2UgdGhleSBhcmUgdXN1YWxseSBmbG93IGNvbnRyb2xcclxuXHJcbiAgICAvLyBCdWZmZXIgY29kZVxyXG4gICAgaWYgKGNvZGUuYnVmZmVyKSB7XHJcbiAgICAgIHZhciB2YWwgPSBjb2RlLnZhbC50cmltTGVmdCgpO1xyXG4gICAgICB2YWwgPSAnbnVsbCA9PSAoamFkZS5pbnRlcnAgPSAnK3ZhbCsnKSA/IFwiXCIgOiBqYWRlLmludGVycCc7XHJcbiAgICAgIGlmIChjb2RlLmVzY2FwZSkgdmFsID0gJ2phZGUuZXNjYXBlKCcgKyB2YWwgKyAnKSc7XHJcbiAgICAgIHRoaXMuYnVmZmVyRXhwcmVzc2lvbih2YWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5idWYucHVzaChjb2RlLnZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmxvY2sgc3VwcG9ydFxyXG4gICAgaWYgKGNvZGUuYmxvY2spIHtcclxuICAgICAgaWYgKCFjb2RlLmJ1ZmZlcikgdGhpcy5idWYucHVzaCgneycpO1xyXG4gICAgICB0aGlzLnZpc2l0KGNvZGUuYmxvY2spO1xyXG4gICAgICBpZiAoIWNvZGUuYnVmZmVyKSB0aGlzLmJ1Zi5wdXNoKCd9Jyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYGVhY2hgIGJsb2NrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFYWNofSBlYWNoXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXRFYWNoOiBmdW5jdGlvbihlYWNoKXtcclxuICAgIHRoaXMuYnVmLnB1c2goJydcclxuICAgICAgKyAnLy8gaXRlcmF0ZSAnICsgZWFjaC5vYmogKyAnXFxuJ1xyXG4gICAgICArICc7KGZ1bmN0aW9uKCl7XFxuJ1xyXG4gICAgICArICcgIHZhciAkJG9iaiA9ICcgKyBlYWNoLm9iaiArICc7XFxuJ1xyXG4gICAgICArICcgIGlmIChcXCdudW1iZXJcXCcgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xcbicpO1xyXG5cclxuICAgIGlmIChlYWNoLmFsdGVybmF0aXZlKSB7XHJcbiAgICAgIHRoaXMuYnVmLnB1c2goJyAgaWYgKCQkb2JqLmxlbmd0aCkgeycpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYnVmLnB1c2goJydcclxuICAgICAgKyAnICAgIGZvciAodmFyICcgKyBlYWNoLmtleSArICcgPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7ICcgKyBlYWNoLmtleSArICcgPCAkJGw7ICcgKyBlYWNoLmtleSArICcrKykge1xcbidcclxuICAgICAgKyAnICAgICAgdmFyICcgKyBlYWNoLnZhbCArICcgPSAkJG9ialsnICsgZWFjaC5rZXkgKyAnXTtcXG4nKTtcclxuXHJcbiAgICB0aGlzLnZpc2l0KGVhY2guYmxvY2spO1xyXG5cclxuICAgIHRoaXMuYnVmLnB1c2goJyAgICB9XFxuJyk7XHJcblxyXG4gICAgaWYgKGVhY2guYWx0ZXJuYXRpdmUpIHtcclxuICAgICAgdGhpcy5idWYucHVzaCgnICB9IGVsc2UgeycpO1xyXG4gICAgICB0aGlzLnZpc2l0KGVhY2guYWx0ZXJuYXRpdmUpO1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKCcgIH0nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJ1Zi5wdXNoKCcnXHJcbiAgICAgICsgJyAgfSBlbHNlIHtcXG4nXHJcbiAgICAgICsgJyAgICB2YXIgJCRsID0gMDtcXG4nXHJcbiAgICAgICsgJyAgICBmb3IgKHZhciAnICsgZWFjaC5rZXkgKyAnIGluICQkb2JqKSB7XFxuJ1xyXG4gICAgICArICcgICAgICAkJGwrKzsnXHJcbiAgICAgICsgJyAgICAgIHZhciAnICsgZWFjaC52YWwgKyAnID0gJCRvYmpbJyArIGVhY2gua2V5ICsgJ107XFxuJyk7XHJcblxyXG4gICAgdGhpcy52aXNpdChlYWNoLmJsb2NrKTtcclxuXHJcbiAgICB0aGlzLmJ1Zi5wdXNoKCcgICAgfVxcbicpO1xyXG4gICAgaWYgKGVhY2guYWx0ZXJuYXRpdmUpIHtcclxuICAgICAgdGhpcy5idWYucHVzaCgnICAgIGlmICgkJGwgPT09IDApIHsnKTtcclxuICAgICAgdGhpcy52aXNpdChlYWNoLmFsdGVybmF0aXZlKTtcclxuICAgICAgdGhpcy5idWYucHVzaCgnICAgIH0nKTtcclxuICAgIH1cclxuICAgIHRoaXMuYnVmLnB1c2goJyAgfVxcbn0pLmNhbGwodGhpcyk7XFxuJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVmlzaXQgYGF0dHJzYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJzXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgdmlzaXRBdHRyaWJ1dGVzOiBmdW5jdGlvbihhdHRycyl7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5hdHRycyhhdHRycyk7XHJcbiAgICBpZiAodmFsLmluaGVyaXRzKSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyRXhwcmVzc2lvbihcImphZGUuYXR0cnMoamFkZS5tZXJnZSh7IFwiICsgdmFsLmJ1ZiArXHJcbiAgICAgICAgICBcIiB9LCBhdHRyaWJ1dGVzKSwgamFkZS5tZXJnZShcIiArIHZhbC5lc2NhcGVkICsgXCIsIGVzY2FwZWQsIHRydWUpKVwiKTtcclxuICAgIH0gZWxzZSBpZiAodmFsLmNvbnN0YW50KSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyKHJ1bnRpbWUuYXR0cnModG9Db25zdGFudCgneycgKyB2YWwuYnVmICsgJ30nKSwgSlNPTi5wYXJzZSh2YWwuZXNjYXBlZCkpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyRXhwcmVzc2lvbihcImphZGUuYXR0cnMoeyBcIiArIHZhbC5idWYgKyBcIiB9LCBcIiArIHZhbC5lc2NhcGVkICsgXCIpXCIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgYXR0cmlidXRlcy5cclxuICAgKi9cclxuXHJcbiAgYXR0cnM6IGZ1bmN0aW9uKGF0dHJzKXtcclxuICAgIHZhciBidWYgPSBbXVxyXG4gICAgICAsIGNsYXNzZXMgPSBbXVxyXG4gICAgICAsIGVzY2FwZWQgPSB7fVxyXG4gICAgICAsIGNvbnN0YW50ID0gYXR0cnMuZXZlcnkoZnVuY3Rpb24oYXR0cil7IHJldHVybiBpc0NvbnN0YW50KGF0dHIudmFsKSB9KVxyXG4gICAgICAsIGluaGVyaXRzID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHRoaXMudGVyc2UpIGJ1Zi5wdXNoKCd0ZXJzZTogdHJ1ZScpO1xyXG5cclxuICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XHJcbiAgICAgIGlmIChhdHRyLm5hbWUgPT0gJ2F0dHJpYnV0ZXMnKSByZXR1cm4gaW5oZXJpdHMgPSB0cnVlO1xyXG4gICAgICBlc2NhcGVkW2F0dHIubmFtZV0gPSBhdHRyLmVzY2FwZWQ7XHJcbiAgICAgIGlmIChhdHRyLm5hbWUgPT0gJ2NsYXNzJykge1xyXG4gICAgICAgIGNsYXNzZXMucHVzaCgnKCcgKyBhdHRyLnZhbCArICcpJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHBhaXIgPSBcIidcIiArIGF0dHIubmFtZSArIFwiJzooXCIgKyBhdHRyLnZhbCArICcpJztcclxuICAgICAgICBidWYucHVzaChwYWlyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XHJcbiAgICAgIGJ1Zi5wdXNoKCdcImNsYXNzXCI6IFsnICsgY2xhc3Nlcy5qb2luKCcsJykgKyAnXScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJ1ZjogYnVmLmpvaW4oJywgJyksXHJcbiAgICAgIGVzY2FwZWQ6IEpTT04uc3RyaW5naWZ5KGVzY2FwZWQpLFxyXG4gICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgIGNvbnN0YW50OiBjb25zdGFudFxyXG4gICAgfTtcclxuICB9XHJcbn07IiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gZG9jdHlwZXNcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAnNSc6ICc8IURPQ1RZUEUgaHRtbD4nXHJcbiAgLCAnZGVmYXVsdCc6ICc8IURPQ1RZUEUgaHRtbD4nXHJcbiAgLCAneG1sJzogJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCIgPz4nXHJcbiAgLCAndHJhbnNpdGlvbmFsJzogJzwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBUcmFuc2l0aW9uYWwvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS10cmFuc2l0aW9uYWwuZHRkXCI+J1xyXG4gICwgJ3N0cmljdCc6ICc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTlwiIFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFwiPidcclxuICAsICdmcmFtZXNldCc6ICc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XM0MvL0RURCBYSFRNTCAxLjAgRnJhbWVzZXQvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1mcmFtZXNldC5kdGRcIj4nXHJcbiAgLCAnMS4xJzogJzwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMTEvRFREL3hodG1sMTEuZHRkXCI+J1xyXG4gICwgJ2Jhc2ljJzogJzwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIEJhc2ljIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sLWJhc2ljL3hodG1sLWJhc2ljMTEuZHRkXCI+J1xyXG4gICwgJ21vYmlsZSc6ICc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XQVBGT1JVTS8vRFREIFhIVE1MIE1vYmlsZSAxLjIvL0VOXCIgXCJodHRwOi8vd3d3Lm9wZW5tb2JpbGVhbGxpYW5jZS5vcmcvdGVjaC9EVEQveGh0bWwtbW9iaWxlMTIuZHRkXCI+J1xyXG59OyIsIi8qIVxyXG4gKiBKYWRlIC0gZmlsdGVyc1xyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcclxuZnVuY3Rpb24gZmlsdGVyKG5hbWUsIHN0ciwgb3B0aW9ucykge1xyXG4gIGlmICh0eXBlb2YgZmlsdGVyW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB2YXIgcmVzID0gZmlsdGVyW25hbWVdKHN0ciwgb3B0aW9ucyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmaWx0ZXIgXCI6JyArIG5hbWUgKyAnXCInKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5maWx0ZXIuZXhpc3RzID0gZnVuY3Rpb24gKG5hbWUsIHN0ciwgb3B0aW9ucykge1xyXG4gIHJldHVybiB0eXBlb2YgZmlsdGVyW25hbWVdID09PSAnZnVuY3Rpb24nO1xyXG59O1xyXG4iLCJcclxuLyohXHJcbiAqIEphZGUgLSBpbmxpbmUgdGFnc1xyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICdhJ1xyXG4gICwgJ2FiYnInXHJcbiAgLCAnYWNyb255bSdcclxuICAsICdiJ1xyXG4gICwgJ2JyJ1xyXG4gICwgJ2NvZGUnXHJcbiAgLCAnZW0nXHJcbiAgLCAnZm9udCdcclxuICAsICdpJ1xyXG4gICwgJ2ltZydcclxuICAsICdpbnMnXHJcbiAgLCAna2JkJ1xyXG4gICwgJ21hcCdcclxuICAsICdzYW1wJ1xyXG4gICwgJ3NtYWxsJ1xyXG4gICwgJ3NwYW4nXHJcbiAgLCAnc3Ryb25nJ1xyXG4gICwgJ3N1YidcclxuICAsICdzdXAnXHJcbl07IiwiLyohXHJcbiAqIEphZGVcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJylcclxuICAsIExleGVyID0gcmVxdWlyZSgnLi9sZXhlcicpXHJcbiAgLCBDb21waWxlciA9IHJlcXVpcmUoJy4vY29tcGlsZXInKVxyXG4gICwgcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpXHJcbiAgLCBhZGRXaXRoID0gcmVxdWlyZSgnd2l0aCcpXHJcbiAgLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcblxyXG4vKipcclxuICogRXhwb3NlIHNlbGYgY2xvc2luZyB0YWdzLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuc2VsZkNsb3NpbmcgPSByZXF1aXJlKCcuL3NlbGYtY2xvc2luZycpO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgc3VwcG9ydGVkIGRvY3R5cGVzLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZG9jdHlwZXMgPSByZXF1aXJlKCcuL2RvY3R5cGVzJyk7XHJcblxyXG4vKipcclxuICogVGV4dCBmaWx0ZXJzLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycycpO1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdGllcy5cclxuICovXHJcblxyXG5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBgQ29tcGlsZXJgLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcclxuXHJcbi8qKlxyXG4gKiBFeHBvc2UgYFBhcnNlcmAuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XHJcblxyXG4vKipcclxuICogRXhwb3NlIGBMZXhlcmAuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xyXG5cclxuLyoqXHJcbiAqIE5vZGVzLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMubm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XHJcblxyXG4vKipcclxuICogSmFkZSBydW50aW1lIGhlbHBlcnMuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5ydW50aW1lID0gcnVudGltZTtcclxuXHJcbi8qKlxyXG4gKiBUZW1wbGF0ZSBmdW5jdGlvbiBjYWNoZS5cclxuICovXHJcblxyXG5leHBvcnRzLmNhY2hlID0ge307XHJcblxyXG4vKipcclxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIG9mIGphZGUgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGJvZHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpe1xyXG4gIHRyeSB7XHJcbiAgICAvLyBQYXJzZVxyXG4gICAgdmFyIHBhcnNlciA9IG5ldyAob3B0aW9ucy5wYXJzZXIgfHwgUGFyc2VyKShzdHIsIG9wdGlvbnMuZmlsZW5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIENvbXBpbGVcclxuICAgIHZhciBjb21waWxlciA9IG5ldyAob3B0aW9ucy5jb21waWxlciB8fCBDb21waWxlcikocGFyc2VyLnBhcnNlKCksIG9wdGlvbnMpXHJcbiAgICAgICwganMgPSBjb21waWxlci5jb21waWxlKCk7XHJcblxyXG4gICAgLy8gRGVidWcgY29tcGlsZXJcclxuICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1xcbkNvbXBpbGVkIEZ1bmN0aW9uOlxcblxcblxcMDMzWzkwbSVzXFwwMzNbMG0nLCBqcy5yZXBsYWNlKC9eL2dtLCAnICAnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnXHJcbiAgICAgICsgJ3ZhciBidWYgPSBbXTtcXG4nXHJcbiAgICAgICsgKG9wdGlvbnMuc2VsZlxyXG4gICAgICAgID8gJ3ZhciBzZWxmID0gbG9jYWxzIHx8IHt9O1xcbicgKyBqc1xyXG4gICAgICAgIDogYWRkV2l0aCgnbG9jYWxzIHx8IHt9JywganMsIFsnamFkZScsICdidWYnXSkpICsgJzsnXHJcbiAgICAgICsgJ3JldHVybiBidWYuam9pbihcIlwiKTsnO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcGFyc2VyID0gcGFyc2VyLmNvbnRleHQoKTtcclxuICAgIHJ1bnRpbWUucmV0aHJvdyhlcnIsIHBhcnNlci5maWxlbmFtZSwgcGFyc2VyLmxleGVyLmxpbmVubywgc3RyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdHJpcCBhbnkgVVRGLTggQk9NIG9mZiBvZiB0aGUgc3RhcnQgb2YgYHN0cmAsIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHN0cmlwQk9NKHN0cil7XHJcbiAgcmV0dXJuIDB4RkVGRiA9PSBzdHIuY2hhckNvZGVBdCgwKVxyXG4gICAgPyBzdHIuc3Vic3RyaW5nKDEpXHJcbiAgICA6IHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXBpbGUgYSBgRnVuY3Rpb25gIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBqYWRlIGBzdHJgLlxyXG4gKlxyXG4gKiBPcHRpb25zOlxyXG4gKlxyXG4gKiAgIC0gYGNvbXBpbGVEZWJ1Z2Agd2hlbiBgZmFsc2VgIGRlYnVnZ2luZyBjb2RlIGlzIHN0cmlwcGVkIGZyb20gdGhlIGNvbXBpbGVkXHJcbiAgICAgICB0ZW1wbGF0ZSwgd2hlbiBpdCBpcyBleHBsaWNpdGx5IGB0cnVlYCwgdGhlIHNvdXJjZSBjb2RlIGlzIGluY2x1ZGVkIGluXHJcbiAgICAgICB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZm9yIGJldHRlciBhY2N1cmFjeS5cclxuICogICAtIGBmaWxlbmFtZWAgdXNlZCB0byBpbXByb3ZlIGVycm9ycyB3aGVuIGBjb21waWxlRGVidWdgIGlzIG5vdCBgZmFsc2VgXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucyl7XHJcbiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XHJcbiAgICAsIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZVxyXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZmlsZW5hbWUpXHJcbiAgICAgIDogJ3VuZGVmaW5lZCdcclxuICAgICwgZm47XHJcblxyXG4gIHN0ciA9IHN0cmlwQk9NKFN0cmluZyhzdHIpKTtcclxuXHJcbiAgaWYgKG9wdGlvbnMuY29tcGlsZURlYnVnICE9PSBmYWxzZSkge1xyXG4gICAgZm4gPSBbXHJcbiAgICAgICAgJ2phZGUuZGVidWcgPSBbeyBsaW5lbm86IDEsIGZpbGVuYW1lOiAnICsgZmlsZW5hbWUgKyAnIH1dOydcclxuICAgICAgLCAndHJ5IHsnXHJcbiAgICAgICwgcGFyc2Uoc3RyLCBvcHRpb25zKVxyXG4gICAgICAsICd9IGNhdGNoIChlcnIpIHsnXHJcbiAgICAgICwgJyAgamFkZS5yZXRocm93KGVyciwgamFkZS5kZWJ1Z1swXS5maWxlbmFtZSwgamFkZS5kZWJ1Z1swXS5saW5lbm8nICsgKG9wdGlvbnMuY29tcGlsZURlYnVnID09PSB0cnVlID8gJywnICsgSlNPTi5zdHJpbmdpZnkoc3RyKSA6ICcnKSArICcpOydcclxuICAgICAgLCAnfSdcclxuICAgIF0uam9pbignXFxuJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZuID0gcGFyc2Uoc3RyLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGlmIChvcHRpb25zLmNsaWVudCkgcmV0dXJuIG5ldyBGdW5jdGlvbignbG9jYWxzJywgZm4pXHJcbiAgZm4gPSBuZXcgRnVuY3Rpb24oJ2xvY2FscywgamFkZScsIGZuKVxyXG4gIHJldHVybiBmdW5jdGlvbihsb2NhbHMpeyByZXR1cm4gZm4obG9jYWxzLCBPYmplY3QuY3JlYXRlKHJ1bnRpbWUpKSB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVyIHRoZSBnaXZlbiBgc3RyYCBvZiBqYWRlLlxyXG4gKlxyXG4gKiBPcHRpb25zOlxyXG4gKlxyXG4gKiAgIC0gYGNhY2hlYCBlbmFibGUgdGVtcGxhdGUgY2FjaGluZ1xyXG4gKiAgIC0gYGZpbGVuYW1lYCBmaWxlbmFtZSByZXF1aXJlZCBmb3IgYGluY2x1ZGVgIC8gYGV4dGVuZHNgIGFuZCBjYWNoaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgZm5cclxuICogQHBhcmFtIHtGdW5jdGlvbnx1bmRlZmluZWR9IGZuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5yZW5kZXIgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMsIGZuKXtcclxuICAvLyBzdXBwb3J0IGNhbGxiYWNrIEFQSVxyXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XHJcbiAgICBmbiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHZhciByZXNcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlcyA9IGV4cG9ydHMucmVuZGVyKHN0ciwgb3B0aW9ucyk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICByZXR1cm4gZm4oZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZuKG51bGwsIHJlcyk7XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgLy8gY2FjaGUgcmVxdWlyZXMgLmZpbGVuYW1lXHJcbiAgaWYgKG9wdGlvbnMuY2FjaGUgJiYgIW9wdGlvbnMuZmlsZW5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndGhlIFwiZmlsZW5hbWVcIiBvcHRpb24gaXMgcmVxdWlyZWQgZm9yIGNhY2hpbmcnKTtcclxuICB9XHJcblxyXG4gIHZhciBwYXRoID0gb3B0aW9ucy5maWxlbmFtZTtcclxuICB2YXIgdG1wbCA9IG9wdGlvbnMuY2FjaGVcclxuICAgID8gZXhwb3J0cy5jYWNoZVtwYXRoXSB8fCAoZXhwb3J0cy5jYWNoZVtwYXRoXSA9IGV4cG9ydHMuY29tcGlsZShzdHIsIG9wdGlvbnMpKVxyXG4gICAgOiBleHBvcnRzLmNvbXBpbGUoc3RyLCBvcHRpb25zKTtcclxuICByZXR1cm4gdG1wbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgYSBKYWRlIGZpbGUgYXQgdGhlIGdpdmVuIGBwYXRoYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcclxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdGlvbnMgb3IgY2FsbGJhY2tcclxuICogQHBhcmFtIHtGdW5jdGlvbnx1bmRlZmluZWR9IGZuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5yZW5kZXJGaWxlID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgZm4pe1xyXG4gIC8vIHN1cHBvcnQgY2FsbGJhY2sgQVBJXHJcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcclxuICAgIGZuID0gb3B0aW9ucywgb3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIHJlc1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzID0gZXhwb3J0cy5yZW5kZXJGaWxlKHBhdGgsIG9wdGlvbnMpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgcmV0dXJuIGZuKGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmbihudWxsLCByZXMpO1xyXG4gIH1cclxuXHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBrZXkgPSBwYXRoICsgJzpzdHJpbmcnO1xyXG5cclxuICBvcHRpb25zLmZpbGVuYW1lID0gcGF0aDtcclxuICB2YXIgc3RyID0gb3B0aW9ucy5jYWNoZVxyXG4gICAgPyBleHBvcnRzLmNhY2hlW2tleV0gfHwgKGV4cG9ydHMuY2FjaGVba2V5XSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpKVxyXG4gICAgOiBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcclxuICByZXR1cm4gZXhwb3J0cy5yZW5kZXIoc3RyLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHByZXNzIHN1cHBvcnQuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5fX2V4cHJlc3MgPSBleHBvcnRzLnJlbmRlckZpbGU7XHJcbiIsIi8qIVxyXG4gKiBKYWRlIC0gTGV4ZXJcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgcGFyc2VKU0V4cHJlc3Npb24gPSByZXF1aXJlKCdjaGFyYWN0ZXItcGFyc2VyJykucGFyc2VNYXg7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBgTGV4ZXJgIHdpdGggdGhlIGdpdmVuIGBzdHJgLlxyXG4gKlxyXG4gKiBPcHRpb25zOlxyXG4gKlxyXG4gKiAgIC0gYGNvbG9uc2AgYWxsb3cgY29sb25zIGZvciBhdHRyIGRlbGltaXRlcnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgTGV4ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIExleGVyKHN0ciwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHRoaXMuaW5wdXQgPSBzdHIucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XHJcbiAgdGhpcy5jb2xvbnMgPSBvcHRpb25zLmNvbG9ucztcclxuICB0aGlzLmRlZmVycmVkVG9rZW5zID0gW107XHJcbiAgdGhpcy5sYXN0SW5kZW50cyA9IDA7XHJcbiAgdGhpcy5saW5lbm8gPSAxO1xyXG4gIHRoaXMuc3Rhc2ggPSBbXTtcclxuICB0aGlzLmluZGVudFN0YWNrID0gW107XHJcbiAgdGhpcy5pbmRlbnRSZSA9IG51bGw7XHJcbiAgdGhpcy5waXBlbGVzcyA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExleGVyIHByb3RvdHlwZS5cclxuICovXHJcblxyXG5MZXhlci5wcm90b3R5cGUgPSB7XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgdG9rZW4gd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgIGFuZCBgdmFsYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbFxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuICBcclxuICB0b2s6IGZ1bmN0aW9uKHR5cGUsIHZhbCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgLCBsaW5lOiB0aGlzLmxpbmVub1xyXG4gICAgICAsIHZhbDogdmFsXHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBDb25zdW1lIHRoZSBnaXZlbiBgbGVuYCBvZiBpbnB1dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuICBcclxuICBjb25zdW1lOiBmdW5jdGlvbihsZW4pe1xyXG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQuc3Vic3RyKGxlbik7XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBTY2FuIGZvciBgdHlwZWAgd2l0aCB0aGUgZ2l2ZW4gYHJlZ2V4cGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcbiAgXHJcbiAgc2NhbjogZnVuY3Rpb24ocmVnZXhwLCB0eXBlKXtcclxuICAgIHZhciBjYXB0dXJlcztcclxuICAgIGlmIChjYXB0dXJlcyA9IHJlZ2V4cC5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xyXG4gICAgICByZXR1cm4gdGhpcy50b2sodHlwZSwgY2FwdHVyZXNbMV0pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogRGVmZXIgdGhlIGdpdmVuIGB0b2tgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRva1xyXG4gICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFxyXG4gIGRlZmVyOiBmdW5jdGlvbih0b2spe1xyXG4gICAgdGhpcy5kZWZlcnJlZFRva2Vucy5wdXNoKHRvayk7XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBMb29rYWhlYWQgYG5gIHRva2Vucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFxyXG4gIGxvb2thaGVhZDogZnVuY3Rpb24obil7XHJcbiAgICB2YXIgZmV0Y2ggPSBuIC0gdGhpcy5zdGFzaC5sZW5ndGg7XHJcbiAgICB3aGlsZSAoZmV0Y2gtLSA+IDApIHRoaXMuc3Rhc2gucHVzaCh0aGlzLm5leHQoKSk7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFzaFstLW5dO1xyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBpbmRleE9mIGAoYCBvciBge2Agb3IgYFtgIC8gYClgIG9yIGB9YCBvciBgXWAgZGVsaW1pdGVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuICBcclxuICBicmFja2V0RXhwcmVzc2lvbjogZnVuY3Rpb24oc2tpcCl7XHJcbiAgICBza2lwID0gc2tpcCB8fCAwO1xyXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dFtza2lwXTtcclxuICAgIGlmIChzdGFydCAhPSAnKCcgJiYgc3RhcnQgIT0gJ3snICYmIHN0YXJ0ICE9ICdbJykgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhcnQgY2hhcmFjdGVyJyk7XHJcbiAgICB2YXIgZW5kID0gKHsnKCc6ICcpJywgJ3snOiAnfScsICdbJzogJ10nfSlbc3RhcnRdO1xyXG4gICAgdmFyIHJhbmdlID0gcGFyc2VKU0V4cHJlc3Npb24odGhpcy5pbnB1dCwge3N0YXJ0OiBza2lwICsgMX0pO1xyXG4gICAgaWYgKHRoaXMuaW5wdXRbcmFuZ2UuZW5kXSAhPT0gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IGNoYXJhY3RlciAnICsgc3RhcnQgKyAnIGRvZXMgbm90IG1hdGNoIGVuZCBjaGFyYWN0ZXIgJyArIHRoaXMuaW5wdXRbcmFuZ2UuZW5kXSk7XHJcbiAgICByZXR1cm4gcmFuZ2U7XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBTdGFzaGVkIHRva2VuLlxyXG4gICAqL1xyXG4gIFxyXG4gIHN0YXNoZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Rhc2gubGVuZ3RoXHJcbiAgICAgICYmIHRoaXMuc3Rhc2guc2hpZnQoKTtcclxuICB9LFxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIERlZmVycmVkIHRva2VuLlxyXG4gICAqL1xyXG4gIFxyXG4gIGRlZmVycmVkOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRlZmVycmVkVG9rZW5zLmxlbmd0aCBcclxuICAgICAgJiYgdGhpcy5kZWZlcnJlZFRva2Vucy5zaGlmdCgpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogZW5kLW9mLXNvdXJjZS5cclxuICAgKi9cclxuICBcclxuICBlb3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuaW5wdXQubGVuZ3RoKSByZXR1cm47XHJcbiAgICBpZiAodGhpcy5pbmRlbnRTdGFjay5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5pbmRlbnRTdGFjay5zaGlmdCgpO1xyXG4gICAgICByZXR1cm4gdGhpcy50b2soJ291dGRlbnQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvaygnZW9zJyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQmxhbmsgbGluZS5cclxuICAgKi9cclxuICBcclxuICBibGFuazogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXlxcbiAqXFxuLy5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGggLSAxKTtcclxuICAgICAgKyt0aGlzLmxpbmVubztcclxuICAgICAgaWYgKHRoaXMucGlwZWxlc3MpIHJldHVybiB0aGlzLnRvaygndGV4dCcsICcnKTtcclxuICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbW1lbnQuXHJcbiAgICovXHJcbiAgXHJcbiAgY29tbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXiAqXFwvXFwvKC0pPyhbXlxcbl0qKS8uZXhlYyh0aGlzLmlucHV0KSkge1xyXG4gICAgICB0aGlzLmNvbnN1bWUoY2FwdHVyZXNbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIHRvayA9IHRoaXMudG9rKCdjb21tZW50JywgY2FwdHVyZXNbMl0pO1xyXG4gICAgICB0b2suYnVmZmVyID0gJy0nICE9IGNhcHR1cmVzWzFdO1xyXG4gICAgICByZXR1cm4gdG9rO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycG9sYXRlZCB0YWcuXHJcbiAgICovXHJcblxyXG4gIGludGVycG9sYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKC9eI1xcey8udGVzdCh0aGlzLmlucHV0KSkge1xyXG4gICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbWF0Y2ggPSB0aGlzLmJyYWNrZXRFeHByZXNzaW9uKDEpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIHJldHVybjsvL25vdCBhbiBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24sIGp1c3QgYW4gdW5tYXRjaGVkIG9wZW4gaW50ZXJwb2xhdGlvblxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbnN1bWUobWF0Y2guZW5kICsgMSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvaygnaW50ZXJwb2xhdGlvbicsIG1hdGNoLnNyYyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVGFnLlxyXG4gICAqL1xyXG4gIFxyXG4gIHRhZzogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXihcXHdbLTpcXHddKikoXFwvPykvLmV4ZWModGhpcy5pbnB1dCkpIHtcclxuICAgICAgdGhpcy5jb25zdW1lKGNhcHR1cmVzWzBdLmxlbmd0aCk7XHJcbiAgICAgIHZhciB0b2ssIG5hbWUgPSBjYXB0dXJlc1sxXTtcclxuICAgICAgaWYgKCc6JyA9PSBuYW1lW25hbWUubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgdG9rID0gdGhpcy50b2soJ3RhZycsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuZGVmZXIodGhpcy50b2soJzonKSk7XHJcbiAgICAgICAgd2hpbGUgKCcgJyA9PSB0aGlzLmlucHV0WzBdKSB0aGlzLmlucHV0ID0gdGhpcy5pbnB1dC5zdWJzdHIoMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9rID0gdGhpcy50b2soJ3RhZycsIG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRvay5zZWxmQ2xvc2luZyA9ICEhIGNhcHR1cmVzWzJdO1xyXG4gICAgICByZXR1cm4gdG9rO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogRmlsdGVyLlxyXG4gICAqL1xyXG4gIFxyXG4gIGZpbHRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eOihcXHcrKS8sICdmaWx0ZXInKTtcclxuICB9LFxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIERvY3R5cGUuXHJcbiAgICovXHJcbiAgXHJcbiAgZG9jdHlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eKD86ISEhfGRvY3R5cGUpICooW15cXG5dKyk/LywgJ2RvY3R5cGUnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBJZC5cclxuICAgKi9cclxuICBcclxuICBpZDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eIyhbXFx3LV0rKS8sICdpZCcpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MuXHJcbiAgICovXHJcbiAgXHJcbiAgY2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYW4oL15cXC4oW1xcdy1dKykvLCAnY2xhc3MnKTtcclxuICB9LFxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFRleHQuXHJcbiAgICovXHJcbiAgXHJcbiAgdGV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eKD86XFx8ID98ID8pPyhbXlxcbl0rKS8sICd0ZXh0Jyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRXh0ZW5kcy5cclxuICAgKi9cclxuICBcclxuICBcImV4dGVuZHNcIjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eZXh0ZW5kcz8gKyhbXlxcbl0rKS8sICdleHRlbmRzJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQmxvY2sgcHJlcGVuZC5cclxuICAgKi9cclxuICBcclxuICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjYXB0dXJlcztcclxuICAgIGlmIChjYXB0dXJlcyA9IC9ecHJlcGVuZCArKFteXFxuXSspLy5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xyXG4gICAgICB2YXIgbW9kZSA9ICdwcmVwZW5kJ1xyXG4gICAgICAgICwgbmFtZSA9IGNhcHR1cmVzWzFdXHJcbiAgICAgICAgLCB0b2sgPSB0aGlzLnRvaygnYmxvY2snLCBuYW1lKTtcclxuICAgICAgdG9rLm1vZGUgPSBtb2RlO1xyXG4gICAgICByZXR1cm4gdG9rO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQmxvY2sgYXBwZW5kLlxyXG4gICAqL1xyXG4gIFxyXG4gIGFwcGVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXmFwcGVuZCArKFteXFxuXSspLy5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xyXG4gICAgICB2YXIgbW9kZSA9ICdhcHBlbmQnXHJcbiAgICAgICAgLCBuYW1lID0gY2FwdHVyZXNbMV1cclxuICAgICAgICAsIHRvayA9IHRoaXMudG9rKCdibG9jaycsIG5hbWUpO1xyXG4gICAgICB0b2subW9kZSA9IG1vZGU7XHJcbiAgICAgIHJldHVybiB0b2s7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQmxvY2suXHJcbiAgICovXHJcbiAgXHJcbiAgYmxvY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhcHR1cmVzO1xyXG4gICAgaWYgKGNhcHR1cmVzID0gL15ibG9ja1xcYiAqKD86KHByZXBlbmR8YXBwZW5kKSArKT8oW15cXG5dKikvLmV4ZWModGhpcy5pbnB1dCkpIHtcclxuICAgICAgdGhpcy5jb25zdW1lKGNhcHR1cmVzWzBdLmxlbmd0aCk7XHJcbiAgICAgIHZhciBtb2RlID0gY2FwdHVyZXNbMV0gfHwgJ3JlcGxhY2UnXHJcbiAgICAgICAgLCBuYW1lID0gY2FwdHVyZXNbMl1cclxuICAgICAgICAsIHRvayA9IHRoaXMudG9rKCdibG9jaycsIG5hbWUpO1xyXG5cclxuICAgICAgdG9rLm1vZGUgPSBtb2RlO1xyXG4gICAgICByZXR1cm4gdG9rO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFlpZWxkLlxyXG4gICAqL1xyXG4gIFxyXG4gIHlpZWxkOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYW4oL155aWVsZCAqLywgJ3lpZWxkJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSW5jbHVkZS5cclxuICAgKi9cclxuICBcclxuICBpbmNsdWRlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYW4oL15pbmNsdWRlICsoW15cXG5dKykvLCAnaW5jbHVkZScpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhc2UuXHJcbiAgICovXHJcbiAgXHJcbiAgXCJjYXNlXCI6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NhbigvXmNhc2UgKyhbXlxcbl0rKS8sICdjYXNlJyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbi5cclxuICAgKi9cclxuICBcclxuICB3aGVuOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYW4oL153aGVuICsoW146XFxuXSspLywgJ3doZW4nKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0LlxyXG4gICAqL1xyXG4gIFxyXG4gIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYW4oL15kZWZhdWx0ICovLCAnZGVmYXVsdCcpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2lnbm1lbnQuXHJcbiAgICovXHJcbiAgXHJcbiAgYXNzaWdubWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXihcXHcrKSArPSAqKFteO1xcbl0rKSggKjs/ICopLy5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xyXG4gICAgICB2YXIgbmFtZSA9IGNhcHR1cmVzWzFdXHJcbiAgICAgICAgLCB2YWwgPSBjYXB0dXJlc1syXTtcclxuICAgICAgcmV0dXJuIHRoaXMudG9rKCdjb2RlJywgJ3ZhciAnICsgbmFtZSArICcgPSAoJyArIHZhbCArICcpOycpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGwgbWl4aW4uXHJcbiAgICovXHJcbiAgXHJcbiAgY2FsbDogZnVuY3Rpb24oKXtcclxuICAgIHZhciBjYXB0dXJlcztcclxuICAgIGlmIChjYXB0dXJlcyA9IC9eXFwrKFstXFx3XSspLy5leGVjKHRoaXMuaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuY29uc3VtZShjYXB0dXJlc1swXS5sZW5ndGgpO1xyXG4gICAgICB2YXIgdG9rID0gdGhpcy50b2soJ2NhbGwnLCBjYXB0dXJlc1sxXSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgYXJncyAobm90IGF0dHJpYnV0ZXMpXHJcbiAgICAgIGlmIChjYXB0dXJlcyA9IC9eICpcXCgvLmV4ZWModGhpcy5pbnB1dCkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5icmFja2V0RXhwcmVzc2lvbihjYXB0dXJlc1swXS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgIGlmICghL14gKlstXFx3XSsgKj0vLnRlc3QocmFuZ2Uuc3JjKSkgeyAvLyBub3QgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUocmFuZ2UuZW5kICsgMSk7XHJcbiAgICAgICAgICAgIHRvay5hcmdzID0gcmFuZ2Uuc3JjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAvL25vdCBhIGJyYWNrZXQgZXhwY2V0aW9uLCBqdXN0IHVubWF0Y2hlZCBvcGVuIHBhcmVuc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRvaztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBNaXhpbi5cclxuICAgKi9cclxuXHJcbiAgbWl4aW46IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXm1peGluICsoWy1cXHddKykoPzogKlxcKCguKilcXCkpPy8uZXhlYyh0aGlzLmlucHV0KSkge1xyXG4gICAgICB0aGlzLmNvbnN1bWUoY2FwdHVyZXNbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIHRvayA9IHRoaXMudG9rKCdtaXhpbicsIGNhcHR1cmVzWzFdKTtcclxuICAgICAgdG9rLmFyZ3MgPSBjYXB0dXJlc1syXTtcclxuICAgICAgcmV0dXJuIHRvaztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDb25kaXRpb25hbC5cclxuICAgKi9cclxuICBcclxuICBjb25kaXRpb25hbDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXihpZnx1bmxlc3N8ZWxzZSBpZnxlbHNlKVxcYihbXlxcbl0qKS8uZXhlYyh0aGlzLmlucHV0KSkge1xyXG4gICAgICB0aGlzLmNvbnN1bWUoY2FwdHVyZXNbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIHR5cGUgPSBjYXB0dXJlc1sxXVxyXG4gICAgICAgICwganMgPSBjYXB0dXJlc1syXTtcclxuXHJcbiAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2lmJzoganMgPSAnaWYgKCcgKyBqcyArICcpJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndW5sZXNzJzoganMgPSAnaWYgKCEoJyArIGpzICsgJykpJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZWxzZSBpZic6IGpzID0gJ2Vsc2UgaWYgKCcgKyBqcyArICcpJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZWxzZSc6IGpzID0gJ2Vsc2UnOyBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudG9rKCdjb2RlJywganMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoaWxlLlxyXG4gICAqL1xyXG4gIFxyXG4gIFwid2hpbGVcIjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FwdHVyZXM7XHJcbiAgICBpZiAoY2FwdHVyZXMgPSAvXndoaWxlICsoW15cXG5dKykvLmV4ZWModGhpcy5pbnB1dCkpIHtcclxuICAgICAgdGhpcy5jb25zdW1lKGNhcHR1cmVzWzBdLmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvaygnY29kZScsICd3aGlsZSAoJyArIGNhcHR1cmVzWzFdICsgJyknKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFYWNoLlxyXG4gICAqL1xyXG4gIFxyXG4gIGVhY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhcHR1cmVzO1xyXG4gICAgaWYgKGNhcHR1cmVzID0gL14oPzotICopPyg/OmVhY2h8Zm9yKSArKFthLXpBLVpfJF1bXFx3JF0qKSg/OiAqLCAqKFthLXpBLVpfJF1bXFx3JF0qKSk/ICogaW4gKihbXlxcbl0rKS8uZXhlYyh0aGlzLmlucHV0KSkge1xyXG4gICAgICB0aGlzLmNvbnN1bWUoY2FwdHVyZXNbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIHRvayA9IHRoaXMudG9rKCdlYWNoJywgY2FwdHVyZXNbMV0pO1xyXG4gICAgICB0b2sua2V5ID0gY2FwdHVyZXNbMl0gfHwgJyRpbmRleCc7XHJcbiAgICAgIHRvay5jb2RlID0gY2FwdHVyZXNbM107XHJcbiAgICAgIHJldHVybiB0b2s7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBDb2RlLlxyXG4gICAqL1xyXG4gIFxyXG4gIGNvZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhcHR1cmVzO1xyXG4gICAgaWYgKGNhcHR1cmVzID0gL14oIT89fC0pWyBcXHRdKihbXlxcbl0rKS8uZXhlYyh0aGlzLmlucHV0KSkge1xyXG4gICAgICB0aGlzLmNvbnN1bWUoY2FwdHVyZXNbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIGZsYWdzID0gY2FwdHVyZXNbMV07XHJcbiAgICAgIGNhcHR1cmVzWzFdID0gY2FwdHVyZXNbMl07XHJcbiAgICAgIHZhciB0b2sgPSB0aGlzLnRvaygnY29kZScsIGNhcHR1cmVzWzFdKTtcclxuICAgICAgdG9rLmVzY2FwZSA9IGZsYWdzLmNoYXJBdCgwKSA9PT0gJz0nO1xyXG4gICAgICB0b2suYnVmZmVyID0gZmxhZ3MuY2hhckF0KDApID09PSAnPScgfHwgZmxhZ3MuY2hhckF0KDEpID09PSAnPSc7XHJcbiAgICAgIHJldHVybiB0b2s7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBBdHRyaWJ1dGVzLlxyXG4gICAqL1xyXG4gIFxyXG4gIGF0dHJzOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICgnKCcgPT0gdGhpcy5pbnB1dC5jaGFyQXQoMCkpIHtcclxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5icmFja2V0RXhwcmVzc2lvbigpLmVuZFxyXG4gICAgICAgICwgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHIoMSwgaW5kZXgtMSlcclxuICAgICAgICAsIHRvayA9IHRoaXMudG9rKCdhdHRycycpXHJcbiAgICAgICAgLCBsZW4gPSBzdHIubGVuZ3RoXHJcbiAgICAgICAgLCBjb2xvbnMgPSB0aGlzLmNvbG9uc1xyXG4gICAgICAgICwgc3RhdGVzID0gWydrZXknXVxyXG4gICAgICAgICwgZXNjYXBlZEF0dHJcclxuICAgICAgICAsIGtleSA9ICcnXHJcbiAgICAgICAgLCB2YWwgPSAnJ1xyXG4gICAgICAgICwgcXVvdGVcclxuICAgICAgICAsIGNcclxuICAgICAgICAsIHA7XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdGF0ZSgpe1xyXG4gICAgICAgIHJldHVybiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShhdHRyKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHIucmVwbGFjZSgvKFxcXFwpPyNcXHsoLispL2csIGZ1bmN0aW9uKF8sIGVzY2FwZSwgZXhwcil7XHJcbiAgICAgICAgICBpZiAoZXNjYXBlKSByZXR1cm4gXztcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHBhcnNlSlNFeHByZXNzaW9uKGV4cHIpO1xyXG4gICAgICAgICAgICBpZiAoZXhwcltyYW5nZS5lbmRdICE9PSAnfScpIHJldHVybiBfLnN1YnN0cigwLCAyKSArIGludGVycG9sYXRlKF8uc3Vic3RyKDIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlICsgXCIgKyAoXCIgKyByYW5nZS5zcmMgKyBcIikgKyBcIiArIHF1b3RlICsgaW50ZXJwb2xhdGUoZXhwci5zdWJzdHIocmFuZ2UuZW5kICsgMSkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8uc3Vic3RyKDAsIDIpICsgaW50ZXJwb2xhdGUoXy5zdWJzdHIoMikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbnN1bWUoaW5kZXggKyAxKTtcclxuICAgICAgdG9rLmF0dHJzID0ge307XHJcbiAgICAgIHRvay5lc2NhcGVkID0ge307XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYXJzZShjKSB7XHJcbiAgICAgICAgdmFyIHJlYWwgPSBjO1xyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB3aGVuIHBlb3BsZSBmaXggXCI6XCJcclxuICAgICAgICBpZiAoY29sb25zICYmICc6JyA9PSBjKSBjID0gJz0nO1xyXG4gICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICBjYXNlICdcXG4nOlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKCkpIHtcclxuICAgICAgICAgICAgICBjYXNlICdleHByJzpcclxuICAgICAgICAgICAgICBjYXNlICdhcnJheSc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgdmFsICs9IGM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1c2goJ2tleScpO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJycgPT0ga2V5KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZSgvXlsnXCJdfFsnXCJdJC9nLCAnJykucmVwbGFjZSgnIScsICcnKTtcclxuICAgICAgICAgICAgICAgIHRvay5lc2NhcGVkW2tleV0gPSBlc2NhcGVkQXR0cjtcclxuICAgICAgICAgICAgICAgIHRvay5hdHRyc1trZXldID0gJycgPT0gdmFsXHJcbiAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICA6IGludGVycG9sYXRlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSB2YWwgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJz0nOlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKCkpIHtcclxuICAgICAgICAgICAgICBjYXNlICdrZXkgY2hhcic6XHJcbiAgICAgICAgICAgICAgICBrZXkgKz0gcmVhbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbCc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnZXhwcic6XHJcbiAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgIHZhbCArPSByZWFsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGVzY2FwZWRBdHRyID0gJyEnICE9IHA7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaCgndmFsJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICcoJzpcclxuICAgICAgICAgICAgaWYgKCd2YWwnID09IHN0YXRlKClcclxuICAgICAgICAgICAgICB8fCAnZXhwcicgPT0gc3RhdGUoKSkgc3RhdGVzLnB1c2goJ2V4cHInKTtcclxuICAgICAgICAgICAgdmFsICs9IGM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnKSc6XHJcbiAgICAgICAgICAgIGlmICgnZXhwcicgPT0gc3RhdGUoKVxyXG4gICAgICAgICAgICAgIHx8ICd2YWwnID09IHN0YXRlKCkpIHN0YXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgdmFsICs9IGM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAneyc6XHJcbiAgICAgICAgICAgIGlmICgndmFsJyA9PSBzdGF0ZSgpKSBzdGF0ZXMucHVzaCgnb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIHZhbCArPSBjO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ30nOlxyXG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgPT0gc3RhdGUoKSkgc3RhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICB2YWwgKz0gYztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdbJzpcclxuICAgICAgICAgICAgaWYgKCd2YWwnID09IHN0YXRlKCkpIHN0YXRlcy5wdXNoKCdhcnJheScpO1xyXG4gICAgICAgICAgICB2YWwgKz0gYztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICddJzpcclxuICAgICAgICAgICAgaWYgKCdhcnJheScgPT0gc3RhdGUoKSkgc3RhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICB2YWwgKz0gYztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdcIic6XHJcbiAgICAgICAgICBjYXNlIFwiJ1wiOlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKCkpIHtcclxuICAgICAgICAgICAgICBjYXNlICdrZXknOlxyXG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1c2goJ2tleSBjaGFyJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdrZXkgY2hhcic6XHJcbiAgICAgICAgICAgICAgICBzdGF0ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gcXVvdGUpIHN0YXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBjO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKCdzdHJpbmcnKTtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBjO1xyXG4gICAgICAgICAgICAgICAgcXVvdGUgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnJzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKCkpIHtcclxuICAgICAgICAgICAgICBjYXNlICdrZXknOlxyXG4gICAgICAgICAgICAgIGNhc2UgJ2tleSBjaGFyJzpcclxuICAgICAgICAgICAgICAgIGtleSArPSBjO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZhbCArPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgcGFyc2Uoc3RyLmNoYXJBdChpKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhcnNlKCcsJyk7XHJcblxyXG4gICAgICBpZiAoJy8nID09IHRoaXMuaW5wdXQuY2hhckF0KDApKSB7XHJcbiAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xyXG4gICAgICAgIHRvay5zZWxmQ2xvc2luZyA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0b2s7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBJbmRlbnQgfCBPdXRkZW50IHwgTmV3bGluZS5cclxuICAgKi9cclxuICBcclxuICBpbmRlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhcHR1cmVzLCByZTtcclxuXHJcbiAgICAvLyBlc3RhYmxpc2hlZCByZWdleHBcclxuICAgIGlmICh0aGlzLmluZGVudFJlKSB7XHJcbiAgICAgIGNhcHR1cmVzID0gdGhpcy5pbmRlbnRSZS5leGVjKHRoaXMuaW5wdXQpO1xyXG4gICAgLy8gZGV0ZXJtaW5lIHJlZ2V4cFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdGFic1xyXG4gICAgICByZSA9IC9eXFxuKFxcdCopICovO1xyXG4gICAgICBjYXB0dXJlcyA9IHJlLmV4ZWModGhpcy5pbnB1dCk7XHJcblxyXG4gICAgICAvLyBzcGFjZXNcclxuICAgICAgaWYgKGNhcHR1cmVzICYmICFjYXB0dXJlc1sxXS5sZW5ndGgpIHtcclxuICAgICAgICByZSA9IC9eXFxuKCAqKS87XHJcbiAgICAgICAgY2FwdHVyZXMgPSByZS5leGVjKHRoaXMuaW5wdXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBlc3RhYmxpc2hlZFxyXG4gICAgICBpZiAoY2FwdHVyZXMgJiYgY2FwdHVyZXNbMV0ubGVuZ3RoKSB0aGlzLmluZGVudFJlID0gcmU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhcHR1cmVzKSB7XHJcbiAgICAgIHZhciB0b2tcclxuICAgICAgICAsIGluZGVudHMgPSBjYXB0dXJlc1sxXS5sZW5ndGg7XHJcblxyXG4gICAgICArK3RoaXMubGluZW5vO1xyXG4gICAgICB0aGlzLmNvbnN1bWUoaW5kZW50cyArIDEpO1xyXG5cclxuICAgICAgaWYgKCcgJyA9PSB0aGlzLmlucHV0WzBdIHx8ICdcXHQnID09IHRoaXMuaW5wdXRbMF0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZW50YXRpb24sIHlvdSBjYW4gdXNlIHRhYnMgb3Igc3BhY2VzIGJ1dCBub3QgYm90aCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBibGFuayBsaW5lXHJcbiAgICAgIGlmICgnXFxuJyA9PSB0aGlzLmlucHV0WzBdKSByZXR1cm4gdGhpcy50b2soJ25ld2xpbmUnKTtcclxuXHJcbiAgICAgIC8vIG91dGRlbnRcclxuICAgICAgaWYgKHRoaXMuaW5kZW50U3RhY2subGVuZ3RoICYmIGluZGVudHMgPCB0aGlzLmluZGVudFN0YWNrWzBdKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZW50U3RhY2subGVuZ3RoICYmIHRoaXMuaW5kZW50U3RhY2tbMF0gPiBpbmRlbnRzKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXNoLnB1c2godGhpcy50b2soJ291dGRlbnQnKSk7XHJcbiAgICAgICAgICB0aGlzLmluZGVudFN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvayA9IHRoaXMuc3Rhc2gucG9wKCk7XHJcbiAgICAgIC8vIGluZGVudFxyXG4gICAgICB9IGVsc2UgaWYgKGluZGVudHMgJiYgaW5kZW50cyAhPSB0aGlzLmluZGVudFN0YWNrWzBdKSB7XHJcbiAgICAgICAgdGhpcy5pbmRlbnRTdGFjay51bnNoaWZ0KGluZGVudHMpO1xyXG4gICAgICAgIHRvayA9IHRoaXMudG9rKCdpbmRlbnQnLCBpbmRlbnRzKTtcclxuICAgICAgLy8gbmV3bGluZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvayA9IHRoaXMudG9rKCduZXdsaW5lJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0b2s7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUGlwZS1sZXNzIHRleHQgY29uc3VtZWQgb25seSB3aGVuIFxyXG4gICAqIHBpcGVsZXNzIGlzIHRydWU7XHJcbiAgICovXHJcblxyXG4gIHBpcGVsZXNzVGV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5waXBlbGVzcykge1xyXG4gICAgICBpZiAoJ1xcbicgPT0gdGhpcy5pbnB1dFswXSkgcmV0dXJuO1xyXG4gICAgICB2YXIgaSA9IHRoaXMuaW5wdXQuaW5kZXhPZignXFxuJyk7XHJcbiAgICAgIGlmICgtMSA9PSBpKSBpID0gdGhpcy5pbnB1dC5sZW5ndGg7XHJcbiAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cigwLCBpKTtcclxuICAgICAgdGhpcy5jb25zdW1lKHN0ci5sZW5ndGgpO1xyXG4gICAgICByZXR1cm4gdGhpcy50b2soJ3RleHQnLCBzdHIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqICc6J1xyXG4gICAqL1xyXG5cclxuICBjb2xvbjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FuKC9eOiAqLywgJzonKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIG5leHQgdG9rZW4gb2JqZWN0LCBvciB0aG9zZVxyXG4gICAqIHByZXZpb3VzbHkgc3Rhc2hlZCBieSBsb29rYWhlYWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcbiAgXHJcbiAgYWR2YW5jZTogZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnN0YXNoZWQoKVxyXG4gICAgICB8fCB0aGlzLm5leHQoKTtcclxuICB9LFxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbmV4dCB0b2tlbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcbiAgXHJcbiAgbmV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kZWZlcnJlZCgpXHJcbiAgICAgIHx8IHRoaXMuYmxhbmsoKVxyXG4gICAgICB8fCB0aGlzLmVvcygpXHJcbiAgICAgIHx8IHRoaXMucGlwZWxlc3NUZXh0KClcclxuICAgICAgfHwgdGhpcy55aWVsZCgpXHJcbiAgICAgIHx8IHRoaXMuZG9jdHlwZSgpXHJcbiAgICAgIHx8IHRoaXMuaW50ZXJwb2xhdGlvbigpXHJcbiAgICAgIHx8IHRoaXNbXCJjYXNlXCJdKClcclxuICAgICAgfHwgdGhpcy53aGVuKClcclxuICAgICAgfHwgdGhpc1tcImRlZmF1bHRcIl0oKVxyXG4gICAgICB8fCB0aGlzW1wiZXh0ZW5kc1wiXSgpXHJcbiAgICAgIHx8IHRoaXMuYXBwZW5kKClcclxuICAgICAgfHwgdGhpcy5wcmVwZW5kKClcclxuICAgICAgfHwgdGhpcy5ibG9jaygpXHJcbiAgICAgIHx8IHRoaXMuaW5jbHVkZSgpXHJcbiAgICAgIHx8IHRoaXMubWl4aW4oKVxyXG4gICAgICB8fCB0aGlzLmNhbGwoKVxyXG4gICAgICB8fCB0aGlzLmNvbmRpdGlvbmFsKClcclxuICAgICAgfHwgdGhpcy5lYWNoKClcclxuICAgICAgfHwgdGhpc1tcIndoaWxlXCJdKClcclxuICAgICAgfHwgdGhpcy5hc3NpZ25tZW50KClcclxuICAgICAgfHwgdGhpcy50YWcoKVxyXG4gICAgICB8fCB0aGlzLmZpbHRlcigpXHJcbiAgICAgIHx8IHRoaXMuY29kZSgpXHJcbiAgICAgIHx8IHRoaXMuaWQoKVxyXG4gICAgICB8fCB0aGlzLmNsYXNzTmFtZSgpXHJcbiAgICAgIHx8IHRoaXMuYXR0cnMoKVxyXG4gICAgICB8fCB0aGlzLmluZGVudCgpXHJcbiAgICAgIHx8IHRoaXMuY29tbWVudCgpXHJcbiAgICAgIHx8IHRoaXMuY29sb24oKVxyXG4gICAgICB8fCB0aGlzLnRleHQoKTtcclxuICB9XHJcbn07XHJcbiIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gQXR0cnNcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKSxcclxuICAgIEJsb2NrID0gcmVxdWlyZSgnLi9ibG9jaycpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBgQXR0cnNgIG5vZGUuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxudmFyIEF0dHJzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBdHRycygpIHtcclxuICB0aGlzLmF0dHJzID0gW107XHJcbn07XHJcblxyXG4vKipcclxuICogSW5oZXJpdCBmcm9tIGBOb2RlYC5cclxuICovXHJcblxyXG5BdHRycy5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogU2V0IGF0dHJpYnV0ZSBgbmFtZWAgdG8gYHZhbGAsIGtlZXAgaW4gbWluZCB0aGVzZSBiZWNvbWVcclxuICogcGFydCBvZiBhIHJhdyBqcyBvYmplY3QgbGl0ZXJhbCwgc28gdG8gcXVvdGUgYSB2YWx1ZSB5b3UgbXVzdFxyXG4gKiAnXCJxdW90ZSBtZVwiJywgb3RoZXJ3aXNlIG9yIGV4YW1wbGUgJ3VzZXIubmFtZScgaXMgbGl0ZXJhbCBKYXZhU2NyaXB0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXNjYXBlZFxyXG4gKiBAcmV0dXJuIHtUYWd9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkF0dHJzLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWwsIGVzY2FwZWQpe1xyXG4gIHRoaXMuYXR0cnMucHVzaCh7IG5hbWU6IG5hbWUsIHZhbDogdmFsLCBlc2NhcGVkOiBlc2NhcGVkIH0pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhdHRyaWJ1dGUgYG5hbWVgIHdoZW4gcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5BdHRycy5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIGlmICh0aGlzLmF0dHJzW2ldICYmIHRoaXMuYXR0cnNbaV0ubmFtZSA9PSBuYW1lKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmF0dHJzW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYXR0cmlidXRlIHZhbHVlIGJ5IGBuYW1lYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkF0dHJzLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKXtcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hdHRycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKHRoaXMuYXR0cnNbaV0gJiYgdGhpcy5hdHRyc1tpXS5uYW1lID09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cnNbaV0udmFsO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuIiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gbm9kZXMgLSBCbG9ja0NvbW1lbnRcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgYEJsb2NrQ29tbWVudGAgd2l0aCB0aGUgZ2l2ZW4gYGJsb2NrYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxyXG4gKiBAcGFyYW0ge0Jsb2NrfSBibG9ja1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJ1ZmZlclxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBCbG9ja0NvbW1lbnQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEJsb2NrQ29tbWVudCh2YWwsIGJsb2NrLCBidWZmZXIpIHtcclxuICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcbiAgdGhpcy52YWwgPSB2YWw7XHJcbiAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5oZXJpdCBmcm9tIGBOb2RlYC5cclxuICovXHJcblxyXG5CbG9ja0NvbW1lbnQucHJvdG90eXBlLl9fcHJvdG9fXyA9IE5vZGUucHJvdG90eXBlOyIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gQmxvY2tcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBCbG9ja2Agd2l0aCBhbiBvcHRpb25hbCBgbm9kZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBCbG9jayA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQmxvY2sobm9kZSl7XHJcbiAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gIGlmIChub2RlKSB0aGlzLnB1c2gobm9kZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5oZXJpdCBmcm9tIGBOb2RlYC5cclxuICovXHJcblxyXG5CbG9jay5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQmxvY2sgZmxhZy5cclxuICovXHJcblxyXG5CbG9jay5wcm90b3R5cGUuaXNCbG9jayA9IHRydWU7XHJcblxyXG4vKipcclxuICogUmVwbGFjZSB0aGUgbm9kZXMgaW4gYG90aGVyYCB3aXRoIHRoZSBub2Rlc1xyXG4gKiBpbiBgdGhpc2AgYmxvY2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7QmxvY2t9IG90aGVyXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbkJsb2NrLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24ob3RoZXIpe1xyXG4gIG90aGVyLm5vZGVzID0gdGhpcy5ub2RlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQdXN0IHRoZSBnaXZlbiBgbm9kZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihub2RlKXtcclxuICByZXR1cm4gdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgYmxvY2sgaXMgZW1wdHkuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xyXG4gIHJldHVybiAwID09IHRoaXMubm9kZXMubGVuZ3RoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVuc2hpZnQgdGhlIGdpdmVuIGBub2RlYC5cclxuICpcclxuICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5CbG9jay5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKG5vZGUpe1xyXG4gIHJldHVybiB0aGlzLm5vZGVzLnVuc2hpZnQobm9kZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBcImxhc3RcIiBibG9jaywgb3IgdGhlIGZpcnN0IGB5aWVsZGAgbm9kZS5cclxuICpcclxuICogQHJldHVybiB7QmxvY2t9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbkJsb2NrLnByb3RvdHlwZS5pbmNsdWRlQmxvY2sgPSBmdW5jdGlvbigpe1xyXG4gIHZhciByZXQgPSB0aGlzXHJcbiAgICAsIG5vZGU7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICBub2RlID0gdGhpcy5ub2Rlc1tpXTtcclxuICAgIGlmIChub2RlLnlpZWxkKSByZXR1cm4gbm9kZTtcclxuICAgIGVsc2UgaWYgKG5vZGUudGV4dE9ubHkpIGNvbnRpbnVlO1xyXG4gICAgZWxzZSBpZiAobm9kZS5pbmNsdWRlQmxvY2spIHJldCA9IG5vZGUuaW5jbHVkZUJsb2NrKCk7XHJcbiAgICBlbHNlIGlmIChub2RlLmJsb2NrICYmICFub2RlLmJsb2NrLmlzRW1wdHkoKSkgcmV0ID0gbm9kZS5ibG9jay5pbmNsdWRlQmxvY2soKTtcclxuICAgIGlmIChyZXQueWllbGQpIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgYmxvY2suXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jsb2NrfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5CbG9jay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG4gIHZhciBjbG9uZSA9IG5ldyBCbG9jaztcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgY2xvbmUucHVzaCh0aGlzLm5vZGVzW2ldLmNsb25lKCkpO1xyXG4gIH1cclxuICByZXR1cm4gY2xvbmU7XHJcbn07XHJcblxyXG4iLCJcclxuLyohXHJcbiAqIEphZGUgLSBub2RlcyAtIENhc2VcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDYXNlYCB3aXRoIGBleHByYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgQ2FzZSA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENhc2UoZXhwciwgYmxvY2spe1xyXG4gIHRoaXMuZXhwciA9IGV4cHI7XHJcbiAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgTm9kZWAuXHJcbiAqL1xyXG5cclxuQ2FzZS5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7XHJcblxyXG52YXIgV2hlbiA9IGV4cG9ydHMuV2hlbiA9IGZ1bmN0aW9uIFdoZW4oZXhwciwgYmxvY2spe1xyXG4gIHRoaXMuZXhwciA9IGV4cHI7XHJcbiAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmhlcml0IGZyb20gYE5vZGVgLlxyXG4gKi9cclxuXHJcbldoZW4ucHJvdG90eXBlLl9fcHJvdG9fXyA9IE5vZGUucHJvdG90eXBlO1xyXG5cclxuIiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gbm9kZXMgLSBDb2RlXHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIGBDb2RlYCBub2RlIHdpdGggdGhlIGdpdmVuIGNvZGUgYHZhbGAuXHJcbiAqIENvZGUgbWF5IGFsc28gYmUgb3B0aW9uYWxseSBidWZmZXJlZCBhbmQgZXNjYXBlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVzY2FwZVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBDb2RlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDb2RlKHZhbCwgYnVmZmVyLCBlc2NhcGUpIHtcclxuICB0aGlzLnZhbCA9IHZhbDtcclxuICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICB0aGlzLmVzY2FwZSA9IGVzY2FwZTtcclxuICBpZiAodmFsLm1hdGNoKC9eICplbHNlLykpIHRoaXMuZGVidWcgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmhlcml0IGZyb20gYE5vZGVgLlxyXG4gKi9cclxuXHJcbkNvZGUucHJvdG90eXBlLl9fcHJvdG9fXyA9IE5vZGUucHJvdG90eXBlOyIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gQ29tbWVudFxyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG4vKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cclxuICovXHJcblxyXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBgQ29tbWVudGAgd2l0aCB0aGUgZ2l2ZW4gYHZhbGAsIG9wdGlvbmFsbHkgYGJ1ZmZlcmAsXHJcbiAqIG90aGVyd2lzZSB0aGUgY29tbWVudCBtYXkgcmVuZGVyIGluIHRoZSBvdXRwdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcclxuICogQHBhcmFtIHtCb29sZWFufSBidWZmZXJcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgQ29tbWVudCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ29tbWVudCh2YWwsIGJ1ZmZlcikge1xyXG4gIHRoaXMudmFsID0gdmFsO1xyXG4gIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgTm9kZWAuXHJcbiAqL1xyXG5cclxuQ29tbWVudC5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7IiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gbm9kZXMgLSBEb2N0eXBlXHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIGBEb2N0eXBlYCB3aXRoIHRoZSBnaXZlbiBgdmFsYC4gXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgRG9jdHlwZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRG9jdHlwZSh2YWwpIHtcclxuICB0aGlzLnZhbCA9IHZhbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmhlcml0IGZyb20gYE5vZGVgLlxyXG4gKi9cclxuXHJcbkRvY3R5cGUucHJvdG90eXBlLl9fcHJvdG9fXyA9IE5vZGUucHJvdG90eXBlOyIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gRWFjaFxyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG4vKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cclxuICovXHJcblxyXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYW4gYEVhY2hgIG5vZGUsIHJlcHJlc2VudGluZyBpdGVyYXRpb25cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG9ialxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuICogQHBhcmFtIHtCbG9ja30gYmxvY2tcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgRWFjaCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRWFjaChvYmosIHZhbCwga2V5LCBibG9jaykge1xyXG4gIHRoaXMub2JqID0gb2JqO1xyXG4gIHRoaXMudmFsID0gdmFsO1xyXG4gIHRoaXMua2V5ID0ga2V5O1xyXG4gIHRoaXMuYmxvY2sgPSBibG9jaztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmhlcml0IGZyb20gYE5vZGVgLlxyXG4gKi9cclxuXHJcbkVhY2gucHJvdG90eXBlLl9fcHJvdG9fXyA9IE5vZGUucHJvdG90eXBlOyIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gRmlsdGVyXHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcclxuICAsIEJsb2NrID0gcmVxdWlyZSgnLi9ibG9jaycpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBgRmlsdGVyYCBub2RlIHdpdGggdGhlIGdpdmVuXHJcbiAqIGZpbHRlciBgbmFtZWAgYW5kIGBibG9ja2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7QmxvY2t8Tm9kZX0gYmxvY2tcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgRmlsdGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWx0ZXIobmFtZSwgYmxvY2ssIGF0dHJzKSB7XHJcbiAgdGhpcy5uYW1lID0gbmFtZTtcclxuICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcbiAgdGhpcy5hdHRycyA9IGF0dHJzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgTm9kZWAuXHJcbiAqL1xyXG5cclxuRmlsdGVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBOb2RlLnByb3RvdHlwZTsiLCJcclxuLyohXHJcbiAqIEphZGUgLSBub2Rlc1xyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG5leHBvcnRzLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxuZXhwb3J0cy5UYWcgPSByZXF1aXJlKCcuL3RhZycpO1xyXG5leHBvcnRzLkNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcclxuZXhwb3J0cy5FYWNoID0gcmVxdWlyZSgnLi9lYWNoJyk7XHJcbmV4cG9ydHMuQ2FzZSA9IHJlcXVpcmUoJy4vY2FzZScpO1xyXG5leHBvcnRzLlRleHQgPSByZXF1aXJlKCcuL3RleHQnKTtcclxuZXhwb3J0cy5CbG9jayA9IHJlcXVpcmUoJy4vYmxvY2snKTtcclxuZXhwb3J0cy5NaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4nKTtcclxuZXhwb3J0cy5GaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xyXG5leHBvcnRzLkNvbW1lbnQgPSByZXF1aXJlKCcuL2NvbW1lbnQnKTtcclxuZXhwb3J0cy5MaXRlcmFsID0gcmVxdWlyZSgnLi9saXRlcmFsJyk7XHJcbmV4cG9ydHMuQmxvY2tDb21tZW50ID0gcmVxdWlyZSgnLi9ibG9jay1jb21tZW50Jyk7XHJcbmV4cG9ydHMuRG9jdHlwZSA9IHJlcXVpcmUoJy4vZG9jdHlwZScpO1xyXG4iLCJcclxuLyohXHJcbiAqIEphZGUgLSBub2RlcyAtIExpdGVyYWxcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgYExpdGVyYWxgIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gYHN0ci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBMaXRlcmFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBMaXRlcmFsKHN0cikge1xyXG4gIHRoaXMuc3RyID0gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgTm9kZWAuXHJcbiAqL1xyXG5cclxuTGl0ZXJhbC5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7XHJcbiIsIlxyXG4vKiFcclxuICogSmFkZSAtIG5vZGVzIC0gTWl4aW5cclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIEF0dHJzID0gcmVxdWlyZSgnLi9hdHRycycpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1peGluYCB3aXRoIGBuYW1lYCBhbmQgYGJsb2NrYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ3NcclxuICogQHBhcmFtIHtCbG9ja30gYmxvY2tcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG52YXIgTWl4aW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE1peGluKG5hbWUsIGFyZ3MsIGJsb2NrLCBjYWxsKXtcclxuICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG4gIHRoaXMuYXR0cnMgPSBbXTtcclxuICB0aGlzLmNhbGwgPSBjYWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgQXR0cnNgLlxyXG4gKi9cclxuXHJcbk1peGluLnByb3RvdHlwZS5fX3Byb3RvX18gPSBBdHRycy5wcm90b3R5cGU7XHJcblxyXG4iLCJcclxuLyohXHJcbiAqIEphZGUgLSBub2RlcyAtIE5vZGVcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBgTm9kZWAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxudmFyIE5vZGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE5vZGUoKXt9O1xyXG5cclxuLyoqXHJcbiAqIENsb25lIHRoaXMgbm9kZSAocmV0dXJuIGl0c2VsZilcclxuICpcclxuICogQHJldHVybiB7Tm9kZX1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcclxuLyohXHJcbiAqIEphZGUgLSBub2RlcyAtIFRhZ1xyXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG4vKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cclxuICovXHJcblxyXG52YXIgQXR0cnMgPSByZXF1aXJlKCcuL2F0dHJzJyksXHJcbiAgICBCbG9jayA9IHJlcXVpcmUoJy4vYmxvY2snKSxcclxuICAgIGlubGluZVRhZ3MgPSByZXF1aXJlKCcuLi9pbmxpbmUtdGFncycpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBgVGFnYCBub2RlIHdpdGggdGhlIGdpdmVuIHRhZyBgbmFtZWAgYW5kIG9wdGlvbmFsIGBibG9ja2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxudmFyIFRhZyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVGFnKG5hbWUsIGJsb2NrKSB7XHJcbiAgdGhpcy5uYW1lID0gbmFtZTtcclxuICB0aGlzLmF0dHJzID0gW107XHJcbiAgdGhpcy5ibG9jayA9IGJsb2NrIHx8IG5ldyBCbG9jaztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmhlcml0IGZyb20gYEF0dHJzYC5cclxuICovXHJcblxyXG5UYWcucHJvdG90eXBlLl9fcHJvdG9fXyA9IEF0dHJzLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDbG9uZSB0aGlzIHRhZy5cclxuICpcclxuICogQHJldHVybiB7VGFnfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5UYWcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcclxuICB2YXIgY2xvbmUgPSBuZXcgVGFnKHRoaXMubmFtZSwgdGhpcy5ibG9jay5jbG9uZSgpKTtcclxuICBjbG9uZS5saW5lID0gdGhpcy5saW5lO1xyXG4gIGNsb25lLmF0dHJzID0gdGhpcy5hdHRycztcclxuICBjbG9uZS50ZXh0T25seSA9IHRoaXMudGV4dE9ubHk7XHJcbiAgcmV0dXJuIGNsb25lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgdGFnIGlzIGFuIGlubGluZSB0YWcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcblRhZy5wcm90b3R5cGUuaXNJbmxpbmUgPSBmdW5jdGlvbigpe1xyXG4gIHJldHVybiB+aW5saW5lVGFncy5pbmRleE9mKHRoaXMubmFtZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyB0YWcncyBjb250ZW50cyBjYW4gYmUgaW5saW5lZC4gIFVzZWQgZm9yIHByZXR0eSBwcmludGluZy5cclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuVGFnLnByb3RvdHlwZS5jYW5JbmxpbmUgPSBmdW5jdGlvbigpe1xyXG4gIHZhciBub2RlcyA9IHRoaXMuYmxvY2subm9kZXM7XHJcblxyXG4gIGZ1bmN0aW9uIGlzSW5saW5lKG5vZGUpe1xyXG4gICAgLy8gUmVjdXJzZSBpZiB0aGUgbm9kZSBpcyBhIGJsb2NrXHJcbiAgICBpZiAobm9kZS5pc0Jsb2NrKSByZXR1cm4gbm9kZS5ub2Rlcy5ldmVyeShpc0lubGluZSk7XHJcbiAgICByZXR1cm4gbm9kZS5pc1RleHQgfHwgKG5vZGUuaXNJbmxpbmUgJiYgbm9kZS5pc0lubGluZSgpKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gRW1wdHkgdGFnXHJcbiAgaWYgKCFub2Rlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xyXG4gIFxyXG4gIC8vIFRleHQtb25seSBvciBpbmxpbmUtb25seSB0YWdcclxuICBpZiAoMSA9PSBub2Rlcy5sZW5ndGgpIHJldHVybiBpc0lubGluZShub2Rlc1swXSk7XHJcbiAgXHJcbiAgLy8gTXVsdGktbGluZSBpbmxpbmUtb25seSB0YWdcclxuICBpZiAodGhpcy5ibG9jay5ub2Rlcy5ldmVyeShpc0lubGluZSkpIHtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBpZiAobm9kZXNbaS0xXS5pc1RleHQgJiYgbm9kZXNbaV0uaXNUZXh0KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBcclxuICAvLyBNaXhlZCB0YWdcclxuICByZXR1cm4gZmFsc2U7XHJcbn07IiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gbm9kZXMgLSBUZXh0XHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxyXG4gKi9cclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIGBUZXh0YCBub2RlIHdpdGggb3B0aW9uYWwgYGxpbmVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbGluZVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBUZXh0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUZXh0KGxpbmUpIHtcclxuICB0aGlzLnZhbCA9ICcnO1xyXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgbGluZSkgdGhpcy52YWwgPSBsaW5lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgZnJvbSBgTm9kZWAuXHJcbiAqL1xyXG5cclxuVGV4dC5wcm90b3R5cGUuX19wcm90b19fID0gTm9kZS5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogRmxhZyBhcyB0ZXh0LlxyXG4gKi9cclxuXHJcblRleHQucHJvdG90eXBlLmlzVGV4dCA9IHRydWU7IiwiLyohXHJcbiAqIEphZGUgLSBQYXJzZXJcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXHJcbiAqL1xyXG5cclxudmFyIExleGVyID0gcmVxdWlyZSgnLi9sZXhlcicpXHJcbiAgLCBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKVxyXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcclxuICAsIGZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKVxyXG4gICwgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxyXG4gICwgZXh0bmFtZSA9IHBhdGguZXh0bmFtZTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGBQYXJzZXJgIHdpdGggdGhlIGdpdmVuIGlucHV0IGBzdHJgIGFuZCBgZmlsZW5hbWVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnZhciBQYXJzZXIgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQYXJzZXIoc3RyLCBmaWxlbmFtZSwgb3B0aW9ucyl7XHJcbiAgdGhpcy5pbnB1dCA9IHN0cjtcclxuICB0aGlzLmxleGVyID0gbmV3IExleGVyKHN0ciwgb3B0aW9ucyk7XHJcbiAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG4gIHRoaXMuYmxvY2tzID0ge307XHJcbiAgdGhpcy5taXhpbnMgPSB7fTtcclxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHRoaXMuY29udGV4dHMgPSBbdGhpc107XHJcbn07XHJcblxyXG4vKipcclxuICogVGFncyB0aGF0IG1heSBub3QgY29udGFpbiB0YWdzLlxyXG4gKi9cclxuXHJcbnZhciB0ZXh0T25seSA9IGV4cG9ydHMudGV4dE9ubHkgPSBbJ3NjcmlwdCcsICdzdHlsZSddO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlciBwcm90b3R5cGUuXHJcbiAqL1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUHVzaCBgcGFyc2VyYCBvbnRvIHRoZSBjb250ZXh0IHN0YWNrLFxyXG4gICAqIG9yIHBvcCBhbmQgcmV0dXJuIGEgYFBhcnNlcmAuXHJcbiAgICovXHJcblxyXG4gIGNvbnRleHQ6IGZ1bmN0aW9uKHBhcnNlcil7XHJcbiAgICBpZiAocGFyc2VyKSB7XHJcbiAgICAgIHRoaXMuY29udGV4dHMucHVzaChwYXJzZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHMucG9wKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBuZXh0IHRva2VuIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuXHJcbiAgYWR2YW5jZTogZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmxleGVyLmFkdmFuY2UoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTa2lwIGBuYCB0b2tlbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gblxyXG4gICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuICBza2lwOiBmdW5jdGlvbihuKXtcclxuICAgIHdoaWxlIChuLS0pIHRoaXMuYWR2YW5jZSgpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSB0b2tlbiBsb29rYWhlYWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcblxyXG4gIHBlZWs6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9va2FoZWFkKDEpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBsZXhlciBsaW5lbm8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcblxyXG4gIGxpbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubGV4ZXIubGluZW5vO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGBuYCB0b2tlbiBsb29rYWhlYWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gblxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuXHJcbiAgbG9va2FoZWFkOiBmdW5jdGlvbihuKXtcclxuICAgIHJldHVybiB0aGlzLmxleGVyLmxvb2thaGVhZChuKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSBpbnB1dCByZXR1cm5pbmcgYSBzdHJpbmcgb2YganMgZm9yIGV2YWx1YXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cclxuXHJcbiAgcGFyc2U6IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgYmxvY2sgPSBuZXcgbm9kZXMuQmxvY2ssIHBhcnNlcjtcclxuICAgIGJsb2NrLmxpbmUgPSB0aGlzLmxpbmUoKTtcclxuXHJcbiAgICB3aGlsZSAoJ2VvcycgIT0gdGhpcy5wZWVrKCkudHlwZSkge1xyXG4gICAgICBpZiAoJ25ld2xpbmUnID09IHRoaXMucGVlaygpLnR5cGUpIHtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VFeHByKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcnNlciA9IHRoaXMuZXh0ZW5kaW5nKSB7XHJcbiAgICAgIHRoaXMuY29udGV4dChwYXJzZXIpO1xyXG4gICAgICB2YXIgYXN0ID0gcGFyc2VyLnBhcnNlKCk7XHJcbiAgICAgIHRoaXMuY29udGV4dCgpO1xyXG5cclxuICAgICAgLy8gaG9pc3QgbWl4aW5zXHJcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5taXhpbnMpXHJcbiAgICAgICAgYXN0LnVuc2hpZnQodGhpcy5taXhpbnNbbmFtZV0pO1xyXG4gICAgICByZXR1cm4gYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBibG9jaztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFeHBlY3QgdGhlIGdpdmVuIHR5cGUsIG9yIHRocm93IGFuIGV4Y2VwdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXHJcblxyXG4gIGV4cGVjdDogZnVuY3Rpb24odHlwZSl7XHJcbiAgICBpZiAodGhpcy5wZWVrKCkudHlwZSA9PT0gdHlwZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIFwiJyArIHR5cGUgKyAnXCIsIGJ1dCBnb3QgXCInICsgdGhpcy5wZWVrKCkudHlwZSArICdcIicpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdCB0aGUgZ2l2ZW4gYHR5cGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuXHJcbiAgYWNjZXB0OiBmdW5jdGlvbih0eXBlKXtcclxuICAgIGlmICh0aGlzLnBlZWsoKS50eXBlID09PSB0eXBlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFkdmFuY2UoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiAgIHRhZ1xyXG4gICAqIHwgZG9jdHlwZVxyXG4gICAqIHwgbWl4aW5cclxuICAgKiB8IGluY2x1ZGVcclxuICAgKiB8IGZpbHRlclxyXG4gICAqIHwgY29tbWVudFxyXG4gICAqIHwgdGV4dFxyXG4gICAqIHwgZWFjaFxyXG4gICAqIHwgY29kZVxyXG4gICAqIHwgeWllbGRcclxuICAgKiB8IGlkXHJcbiAgICogfCBjbGFzc1xyXG4gICAqIHwgaW50ZXJwb2xhdGlvblxyXG4gICAqL1xyXG5cclxuICBwYXJzZUV4cHI6IGZ1bmN0aW9uKCl7XHJcbiAgICBzd2l0Y2ggKHRoaXMucGVlaygpLnR5cGUpIHtcclxuICAgICAgY2FzZSAndGFnJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRhZygpO1xyXG4gICAgICBjYXNlICdtaXhpbic6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNaXhpbigpO1xyXG4gICAgICBjYXNlICdibG9jayc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xyXG4gICAgICBjYXNlICdjYXNlJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhc2UoKTtcclxuICAgICAgY2FzZSAnd2hlbic6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaGVuKCk7XHJcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVmYXVsdCgpO1xyXG4gICAgICBjYXNlICdleHRlbmRzJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4dGVuZHMoKTtcclxuICAgICAgY2FzZSAnaW5jbHVkZSc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbmNsdWRlKCk7XHJcbiAgICAgIGNhc2UgJ2RvY3R5cGUnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9jdHlwZSgpO1xyXG4gICAgICBjYXNlICdmaWx0ZXInOlxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsdGVyKCk7XHJcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29tbWVudCgpO1xyXG4gICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRleHQoKTtcclxuICAgICAgY2FzZSAnZWFjaCc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFYWNoKCk7XHJcbiAgICAgIGNhc2UgJ2NvZGUnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29kZSgpO1xyXG4gICAgICBjYXNlICdjYWxsJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGwoKTtcclxuICAgICAgY2FzZSAnaW50ZXJwb2xhdGlvbic6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnRlcnBvbGF0aW9uKCk7XHJcbiAgICAgIGNhc2UgJ3lpZWxkJzpcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICB2YXIgYmxvY2sgPSBuZXcgbm9kZXMuQmxvY2s7XHJcbiAgICAgICAgYmxvY2sueWllbGQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBibG9jaztcclxuICAgICAgY2FzZSAnaWQnOlxyXG4gICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgdmFyIHRvayA9IHRoaXMuYWR2YW5jZSgpO1xyXG4gICAgICAgIHRoaXMubGV4ZXIuZGVmZXIodGhpcy5sZXhlci50b2soJ3RhZycsICdkaXYnKSk7XHJcbiAgICAgICAgdGhpcy5sZXhlci5kZWZlcih0b2spO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcigpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCB0b2tlbiBcIicgKyB0aGlzLnBlZWsoKS50eXBlICsgJ1wiJyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVGV4dFxyXG4gICAqL1xyXG5cclxuICBwYXJzZVRleHQ6IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdG9rID0gdGhpcy5leHBlY3QoJ3RleHQnKTtcclxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLlRleHQodG9rLnZhbCk7XHJcbiAgICBub2RlLmxpbmUgPSB0aGlzLmxpbmUoKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqICAgJzonIGV4cHJcclxuICAgKiB8IGJsb2NrXHJcbiAgICovXHJcblxyXG4gIHBhcnNlQmxvY2tFeHBhbnNpb246IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoJzonID09IHRoaXMucGVlaygpLnR5cGUpIHtcclxuICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgIHJldHVybiBuZXcgbm9kZXMuQmxvY2sodGhpcy5wYXJzZUV4cHIoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5ibG9jaygpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNhc2VcclxuICAgKi9cclxuXHJcbiAgcGFyc2VDYXNlOiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuZXhwZWN0KCdjYXNlJykudmFsO1xyXG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuQ2FzZSh2YWwpO1xyXG4gICAgbm9kZS5saW5lID0gdGhpcy5saW5lKCk7XHJcbiAgICBub2RlLmJsb2NrID0gdGhpcy5ibG9jaygpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogd2hlblxyXG4gICAqL1xyXG5cclxuICBwYXJzZVdoZW46IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5leHBlY3QoJ3doZW4nKS52YWxcclxuICAgIHJldHVybiBuZXcgbm9kZXMuQ2FzZS5XaGVuKHZhbCwgdGhpcy5wYXJzZUJsb2NrRXhwYW5zaW9uKCkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGRlZmF1bHRcclxuICAgKi9cclxuXHJcbiAgcGFyc2VEZWZhdWx0OiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5leHBlY3QoJ2RlZmF1bHQnKTtcclxuICAgIHJldHVybiBuZXcgbm9kZXMuQ2FzZS5XaGVuKCdkZWZhdWx0JywgdGhpcy5wYXJzZUJsb2NrRXhwYW5zaW9uKCkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNvZGVcclxuICAgKi9cclxuXHJcbiAgcGFyc2VDb2RlOiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHRvayA9IHRoaXMuZXhwZWN0KCdjb2RlJyk7XHJcbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5Db2RlKHRvay52YWwsIHRvay5idWZmZXIsIHRvay5lc2NhcGUpO1xyXG4gICAgdmFyIGJsb2NrO1xyXG4gICAgdmFyIGkgPSAxO1xyXG4gICAgbm9kZS5saW5lID0gdGhpcy5saW5lKCk7XHJcbiAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQoaSkgJiYgJ25ld2xpbmUnID09IHRoaXMubG9va2FoZWFkKGkpLnR5cGUpICsraTtcclxuICAgIGJsb2NrID0gJ2luZGVudCcgPT0gdGhpcy5sb29rYWhlYWQoaSkudHlwZTtcclxuICAgIGlmIChibG9jaykge1xyXG4gICAgICB0aGlzLnNraXAoaS0xKTtcclxuICAgICAgbm9kZS5ibG9jayA9IHRoaXMuYmxvY2soKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbW1lbnRcclxuICAgKi9cclxuXHJcbiAgcGFyc2VDb21tZW50OiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHRvayA9IHRoaXMuZXhwZWN0KCdjb21tZW50Jyk7XHJcbiAgICB2YXIgbm9kZTtcclxuXHJcbiAgICBpZiAoJ2luZGVudCcgPT0gdGhpcy5wZWVrKCkudHlwZSkge1xyXG4gICAgICBub2RlID0gbmV3IG5vZGVzLkJsb2NrQ29tbWVudCh0b2sudmFsLCB0aGlzLmJsb2NrKCksIHRvay5idWZmZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Db21tZW50KHRvay52YWwsIHRvay5idWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGUubGluZSA9IHRoaXMubGluZSgpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogZG9jdHlwZVxyXG4gICAqL1xyXG5cclxuICBwYXJzZURvY3R5cGU6IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdG9rID0gdGhpcy5leHBlY3QoJ2RvY3R5cGUnKTtcclxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkRvY3R5cGUodG9rLnZhbCk7XHJcbiAgICBub2RlLmxpbmUgPSB0aGlzLmxpbmUoKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGZpbHRlciBhdHRycz8gdGV4dC1ibG9ja1xyXG4gICAqL1xyXG5cclxuICBwYXJzZUZpbHRlcjogZnVuY3Rpb24oKXtcclxuICAgIHZhciB0b2sgPSB0aGlzLmV4cGVjdCgnZmlsdGVyJyk7XHJcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmFjY2VwdCgnYXR0cnMnKTtcclxuICAgIHZhciBibG9jaztcclxuXHJcbiAgICBpZiAoJ2luZGVudCcgPT0gdGhpcy5wZWVrKCkudHlwZSkge1xyXG4gICAgICB0aGlzLmxleGVyLnBpcGVsZXNzID0gdHJ1ZTtcclxuICAgICAgYmxvY2sgPSB0aGlzLnBhcnNlVGV4dEJsb2NrKCk7XHJcbiAgICAgIHRoaXMubGV4ZXIucGlwZWxlc3MgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBibG9jayA9IG5ldyBub2Rlcy5CbG9jaztcclxuXHJcbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5GaWx0ZXIodG9rLnZhbCwgYmxvY2ssIGF0dHJzICYmIGF0dHJzLmF0dHJzKTtcclxuICAgIG5vZGUubGluZSA9IHRoaXMubGluZSgpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogZWFjaCBibG9ja1xyXG4gICAqL1xyXG5cclxuICBwYXJzZUVhY2g6IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdG9rID0gdGhpcy5leHBlY3QoJ2VhY2gnKTtcclxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkVhY2godG9rLmNvZGUsIHRvay52YWwsIHRvay5rZXkpO1xyXG4gICAgbm9kZS5saW5lID0gdGhpcy5saW5lKCk7XHJcbiAgICBub2RlLmJsb2NrID0gdGhpcy5ibG9jaygpO1xyXG4gICAgaWYgKHRoaXMucGVlaygpLnR5cGUgPT0gJ2NvZGUnICYmIHRoaXMucGVlaygpLnZhbCA9PSAnZWxzZScpIHtcclxuICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSB0aGlzLmJsb2NrKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXNvbHZlcyBhIHBhdGggcmVsYXRpdmUgdG8gdGhlIHRlbXBsYXRlIGZvciB1c2UgaW5cclxuICAgKiBpbmNsdWRlcyBhbmQgZXh0ZW5kc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9ICBwYXRoXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9ICBwdXJwb3NlICBVc2VkIGluIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuXHJcbiAgcmVzb2x2ZVBhdGg6IGZ1bmN0aW9uIChwYXRoLCBwdXJwb3NlKSB7XHJcbiAgICB2YXIgcCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuICAgIHZhciBkaXJuYW1lID0gcC5kaXJuYW1lO1xyXG4gICAgdmFyIGJhc2VuYW1lID0gcC5iYXNlbmFtZTtcclxuICAgIHZhciBqb2luID0gcC5qb2luO1xyXG5cclxuICAgIGlmIChwYXRoWzBdICE9PSAnLycgJiYgIXRoaXMuZmlsZW5hbWUpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIFwiZmlsZW5hbWVcIiBvcHRpb24gaXMgcmVxdWlyZWQgdG8gdXNlIFwiJyArIHB1cnBvc2UgKyAnXCIgd2l0aCBcInJlbGF0aXZlXCIgcGF0aHMnKTtcclxuXHJcbiAgICBpZiAocGF0aFswXSA9PT0gJy8nICYmICF0aGlzLm9wdGlvbnMuYmFzZWRpcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgXCJiYXNlZGlyXCIgb3B0aW9uIGlzIHJlcXVpcmVkIHRvIHVzZSBcIicgKyBwdXJwb3NlICsgJ1wiIHdpdGggXCJhYnNvbHV0ZVwiIHBhdGhzJyk7XHJcblxyXG4gICAgcGF0aCA9IGpvaW4ocGF0aFswXSA9PT0gJy8nID8gdGhpcy5vcHRpb25zLmJhc2VkaXIgOiBkaXJuYW1lKHRoaXMuZmlsZW5hbWUpLCBwYXRoKTtcclxuXHJcbiAgICBpZiAoYmFzZW5hbWUocGF0aCkuaW5kZXhPZignLicpID09PSAtMSkgcGF0aCArPSAnLmphZGUnO1xyXG5cclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqICdleHRlbmRzJyBuYW1lXHJcbiAgICovXHJcblxyXG4gIHBhcnNlRXh0ZW5kczogZnVuY3Rpb24oKXtcclxuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcblxyXG4gICAgdmFyIHBhdGggPSB0aGlzLnJlc29sdmVQYXRoKHRoaXMuZXhwZWN0KCdleHRlbmRzJykudmFsLnRyaW0oKSwgJ2V4dGVuZHMnKTtcclxuICAgIGlmICgnLmphZGUnICE9IHBhdGguc3Vic3RyKC01KSkgcGF0aCArPSAnLmphZGUnO1xyXG5cclxuICAgIHZhciBzdHIgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcclxuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHN0ciwgcGF0aCwgdGhpcy5vcHRpb25zKTtcclxuXHJcbiAgICBwYXJzZXIuYmxvY2tzID0gdGhpcy5ibG9ja3M7XHJcbiAgICBwYXJzZXIuY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xyXG4gICAgdGhpcy5leHRlbmRpbmcgPSBwYXJzZXI7XHJcblxyXG4gICAgLy8gVE9ETzogbnVsbCBub2RlXHJcbiAgICByZXR1cm4gbmV3IG5vZGVzLkxpdGVyYWwoJycpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqICdibG9jaycgbmFtZSBibG9ja1xyXG4gICAqL1xyXG5cclxuICBwYXJzZUJsb2NrOiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGJsb2NrID0gdGhpcy5leHBlY3QoJ2Jsb2NrJyk7XHJcbiAgICB2YXIgbW9kZSA9IGJsb2NrLm1vZGU7XHJcbiAgICB2YXIgbmFtZSA9IGJsb2NrLnZhbC50cmltKCk7XHJcblxyXG4gICAgYmxvY2sgPSAnaW5kZW50JyA9PSB0aGlzLnBlZWsoKS50eXBlXHJcbiAgICAgID8gdGhpcy5ibG9jaygpXHJcbiAgICAgIDogbmV3IG5vZGVzLkJsb2NrKG5ldyBub2Rlcy5MaXRlcmFsKCcnKSk7XHJcblxyXG4gICAgdmFyIHByZXYgPSB0aGlzLmJsb2Nrc1tuYW1lXSB8fCB7cHJlcGVuZGVkOiBbXSwgYXBwZW5kZWQ6IFtdfVxyXG4gICAgaWYgKHByZXYubW9kZSA9PT0gJ3JlcGxhY2UnKSByZXR1cm4gdGhpcy5ibG9ja3NbbmFtZV0gPSBwcmV2O1xyXG5cclxuICAgIHZhciBhbGxOb2RlcyA9IHByZXYucHJlcGVuZGVkLmNvbmNhdChibG9jay5ub2RlcykuY29uY2F0KHByZXYuYXBwZW5kZWQpO1xyXG5cclxuICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICBjYXNlICdhcHBlbmQnOlxyXG4gICAgICAgIHByZXYuYXBwZW5kZWQgPSBwcmV2LnBhcnNlciA9PT0gdGhpcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuYXBwZW5kZWQuY29uY2F0KGJsb2NrLm5vZGVzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLm5vZGVzLmNvbmNhdChwcmV2LmFwcGVuZGVkKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncHJlcGVuZCc6XHJcbiAgICAgICAgcHJldi5wcmVwZW5kZWQgPSBwcmV2LnBhcnNlciA9PT0gdGhpcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5ub2Rlcy5jb25jYXQocHJldi5wcmVwZW5kZWQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYucHJlcGVuZGVkLmNvbmNhdChibG9jay5ub2Rlcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBibG9jay5ub2RlcyA9IGFsbE5vZGVzO1xyXG4gICAgYmxvY2suYXBwZW5kZWQgPSBwcmV2LmFwcGVuZGVkO1xyXG4gICAgYmxvY2sucHJlcGVuZGVkID0gcHJldi5wcmVwZW5kZWQ7XHJcbiAgICBibG9jay5tb2RlID0gbW9kZTtcclxuICAgIGJsb2NrLnBhcnNlciA9IHRoaXM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzW25hbWVdID0gYmxvY2s7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogaW5jbHVkZSBibG9jaz9cclxuICAgKi9cclxuXHJcbiAgcGFyc2VJbmNsdWRlOiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcclxuXHJcbiAgICB2YXIgcGF0aCA9IHRoaXMucmVzb2x2ZVBhdGgodGhpcy5leHBlY3QoJ2luY2x1ZGUnKS52YWwudHJpbSgpLCAnaW5jbHVkZScpO1xyXG5cclxuICAgIC8vIG5vbi1qYWRlXHJcbiAgICBpZiAoJy5qYWRlJyAhPSBwYXRoLnN1YnN0cigtNSkpIHtcclxuICAgICAgdmFyIHN0ciA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpLnJlcGxhY2UoL1xcci9nLCAnJyk7XHJcbiAgICAgIHZhciBleHQgPSBleHRuYW1lKHBhdGgpLnNsaWNlKDEpO1xyXG4gICAgICBpZiAoZmlsdGVycy5leGlzdHMoZXh0KSkgc3RyID0gZmlsdGVycyhleHQsIHN0ciwgeyBmaWxlbmFtZTogcGF0aCB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBub2Rlcy5MaXRlcmFsKHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0ciA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpO1xyXG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoc3RyLCBwYXRoLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgcGFyc2VyLmJsb2NrcyA9IHV0aWxzLm1lcmdlKHt9LCB0aGlzLmJsb2Nrcyk7XHJcblxyXG4gICAgcGFyc2VyLm1peGlucyA9IHRoaXMubWl4aW5zO1xyXG5cclxuICAgIHRoaXMuY29udGV4dChwYXJzZXIpO1xyXG4gICAgdmFyIGFzdCA9IHBhcnNlci5wYXJzZSgpO1xyXG4gICAgdGhpcy5jb250ZXh0KCk7XHJcbiAgICBhc3QuZmlsZW5hbWUgPSBwYXRoO1xyXG5cclxuICAgIGlmICgnaW5kZW50JyA9PSB0aGlzLnBlZWsoKS50eXBlKSB7XHJcbiAgICAgIGFzdC5pbmNsdWRlQmxvY2soKS5wdXNoKHRoaXMuYmxvY2soKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFzdDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjYWxsIGlkZW50IGJsb2NrXHJcbiAgICovXHJcblxyXG4gIHBhcnNlQ2FsbDogZnVuY3Rpb24oKXtcclxuICAgIHZhciB0b2sgPSB0aGlzLmV4cGVjdCgnY2FsbCcpO1xyXG4gICAgdmFyIG5hbWUgPSB0b2sudmFsO1xyXG4gICAgdmFyIGFyZ3MgPSB0b2suYXJncztcclxuICAgIHZhciBtaXhpbiA9IG5ldyBub2Rlcy5NaXhpbihuYW1lLCBhcmdzLCBuZXcgbm9kZXMuQmxvY2ssIHRydWUpO1xyXG5cclxuICAgIHRoaXMudGFnKG1peGluKTtcclxuICAgIGlmIChtaXhpbi5jb2RlKSB7XHJcbiAgICAgIG1peGluLmJsb2NrLnB1c2gobWl4aW4uY29kZSk7XHJcbiAgICAgIG1peGluLmNvZGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG1peGluLmJsb2NrLmlzRW1wdHkoKSkgbWl4aW4uYmxvY2sgPSBudWxsO1xyXG4gICAgcmV0dXJuIG1peGluO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIG1peGluIGJsb2NrXHJcbiAgICovXHJcblxyXG4gIHBhcnNlTWl4aW46IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdG9rID0gdGhpcy5leHBlY3QoJ21peGluJyk7XHJcbiAgICB2YXIgbmFtZSA9IHRvay52YWw7XHJcbiAgICB2YXIgYXJncyA9IHRvay5hcmdzO1xyXG4gICAgdmFyIG1peGluO1xyXG5cclxuICAgIC8vIGRlZmluaXRpb25cclxuICAgIGlmICgnaW5kZW50JyA9PSB0aGlzLnBlZWsoKS50eXBlKSB7XHJcbiAgICAgIG1peGluID0gbmV3IG5vZGVzLk1peGluKG5hbWUsIGFyZ3MsIHRoaXMuYmxvY2soKSwgZmFsc2UpO1xyXG4gICAgICB0aGlzLm1peGluc1tuYW1lXSA9IG1peGluO1xyXG4gICAgICByZXR1cm4gbWl4aW47XHJcbiAgICAvLyBjYWxsXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IG5vZGVzLk1peGluKG5hbWUsIGFyZ3MsIG51bGwsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGluZGVudCAodGV4dCB8IG5ld2xpbmUpKiBvdXRkZW50XHJcbiAgICovXHJcblxyXG4gIHBhcnNlVGV4dEJsb2NrOiBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGJsb2NrID0gbmV3IG5vZGVzLkJsb2NrO1xyXG4gICAgYmxvY2subGluZSA9IHRoaXMubGluZSgpO1xyXG4gICAgdmFyIHNwYWNlcyA9IHRoaXMuZXhwZWN0KCdpbmRlbnQnKS52YWw7XHJcbiAgICBpZiAobnVsbCA9PSB0aGlzLl9zcGFjZXMpIHRoaXMuX3NwYWNlcyA9IHNwYWNlcztcclxuICAgIHZhciBpbmRlbnQgPSBBcnJheShzcGFjZXMgLSB0aGlzLl9zcGFjZXMgKyAxKS5qb2luKCcgJyk7XHJcbiAgICB3aGlsZSAoJ291dGRlbnQnICE9IHRoaXMucGVlaygpLnR5cGUpIHtcclxuICAgICAgc3dpdGNoICh0aGlzLnBlZWsoKS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbmV3bGluZSc6XHJcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2luZGVudCc6XHJcbiAgICAgICAgICB0aGlzLnBhcnNlVGV4dEJsb2NrKCkubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgYmxvY2sucHVzaChub2RlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IG5vZGVzLlRleHQoaW5kZW50ICsgdGhpcy5hZHZhbmNlKCkudmFsKTtcclxuICAgICAgICAgIHRleHQubGluZSA9IHRoaXMubGluZSgpO1xyXG4gICAgICAgICAgYmxvY2sucHVzaCh0ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGFjZXMgPT0gdGhpcy5fc3BhY2VzKSB0aGlzLl9zcGFjZXMgPSBudWxsO1xyXG4gICAgdGhpcy5leHBlY3QoJ291dGRlbnQnKTtcclxuICAgIHJldHVybiBibG9jaztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBpbmRlbnQgZXhwciogb3V0ZGVudFxyXG4gICAqL1xyXG5cclxuICBibG9jazogZnVuY3Rpb24oKXtcclxuICAgIHZhciBibG9jayA9IG5ldyBub2Rlcy5CbG9jaztcclxuICAgIGJsb2NrLmxpbmUgPSB0aGlzLmxpbmUoKTtcclxuICAgIHRoaXMuZXhwZWN0KCdpbmRlbnQnKTtcclxuICAgIHdoaWxlICgnb3V0ZGVudCcgIT0gdGhpcy5wZWVrKCkudHlwZSkge1xyXG4gICAgICBpZiAoJ25ld2xpbmUnID09IHRoaXMucGVlaygpLnR5cGUpIHtcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VFeHByKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmV4cGVjdCgnb3V0ZGVudCcpO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGludGVycG9sYXRpb24gKGF0dHJzIHwgY2xhc3MgfCBpZCkqICh0ZXh0IHwgY29kZSB8ICc6Jyk/IG5ld2xpbmUqIGJsb2NrP1xyXG4gICAqL1xyXG5cclxuICBwYXJzZUludGVycG9sYXRpb246IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgdG9rID0gdGhpcy5hZHZhbmNlKCk7XHJcbiAgICB2YXIgdGFnID0gbmV3IG5vZGVzLlRhZyh0b2sudmFsKTtcclxuICAgIHRhZy5idWZmZXIgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXMudGFnKHRhZyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogdGFnIChhdHRycyB8IGNsYXNzIHwgaWQpKiAodGV4dCB8IGNvZGUgfCAnOicpPyBuZXdsaW5lKiBibG9jaz9cclxuICAgKi9cclxuXHJcbiAgcGFyc2VUYWc6IGZ1bmN0aW9uKCl7XHJcbiAgICAvLyBhc3QtZmlsdGVyIGxvb2stYWhlYWRcclxuICAgIHZhciBpID0gMjtcclxuICAgIGlmICgnYXR0cnMnID09IHRoaXMubG9va2FoZWFkKGkpLnR5cGUpICsraTtcclxuXHJcbiAgICB2YXIgdG9rID0gdGhpcy5hZHZhbmNlKCk7XHJcbiAgICB2YXIgdGFnID0gbmV3IG5vZGVzLlRhZyh0b2sudmFsKTtcclxuXHJcbiAgICB0YWcuc2VsZkNsb3NpbmcgPSB0b2suc2VsZkNsb3Npbmc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGFnKHRhZyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgdGFnLlxyXG4gICAqL1xyXG5cclxuICB0YWc6IGZ1bmN0aW9uKHRhZyl7XHJcbiAgICB2YXIgZG90O1xyXG5cclxuICAgIHRhZy5saW5lID0gdGhpcy5saW5lKCk7XHJcblxyXG4gICAgdmFyIHNlZW5BdHRycyA9IGZhbHNlO1xyXG4gICAgLy8gKGF0dHJzIHwgY2xhc3MgfCBpZCkqXHJcbiAgICBvdXQ6XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWsoKS50eXBlKSB7XHJcbiAgICAgICAgICBjYXNlICdpZCc6XHJcbiAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgICAgIHZhciB0b2sgPSB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgdGFnLnNldEF0dHJpYnV0ZSh0b2sudHlwZSwgXCInXCIgKyB0b2sudmFsICsgXCInXCIpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIGNhc2UgJ2F0dHJzJzpcclxuICAgICAgICAgICAgaWYgKHNlZW5BdHRycykge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignWW91IHNob3VsZCBub3QgaGF2ZSBqYWRlIHRhZ3Mgd2l0aCBtdWx0aXBsZSBhdHRyaWJ1dGVzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZW5BdHRycyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB0b2sgPSB0aGlzLmFkdmFuY2UoKVxyXG4gICAgICAgICAgICAgICwgb2JqID0gdG9rLmF0dHJzXHJcbiAgICAgICAgICAgICAgLCBlc2NhcGVkID0gdG9rLmVzY2FwZWRcclxuICAgICAgICAgICAgICAsIG5hbWVzID0gT2JqZWN0LmtleXMob2JqKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b2suc2VsZkNsb3NpbmcpIHRhZy5zZWxmQ2xvc2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldXHJcbiAgICAgICAgICAgICAgICAsIHZhbCA9IG9ialtuYW1lXTtcclxuICAgICAgICAgICAgICB0YWcuc2V0QXR0cmlidXRlKG5hbWUsIHZhbCwgZXNjYXBlZFtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgaW1tZWRpYXRlICcuJ1xyXG4gICAgaWYgKCcuJyA9PSB0aGlzLnBlZWsoKS52YWwpIHtcclxuICAgICAgZG90ID0gdGFnLnRleHRPbmx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5hZHZhbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHRleHQgfCBjb2RlIHwgJzonKT9cclxuICAgIHN3aXRjaCAodGhpcy5wZWVrKCkudHlwZSkge1xyXG4gICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICB0YWcuYmxvY2sucHVzaCh0aGlzLnBhcnNlVGV4dCgpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnY29kZSc6XHJcbiAgICAgICAgdGFnLmNvZGUgPSB0aGlzLnBhcnNlQ29kZSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICc6JzpcclxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcclxuICAgICAgICB0YWcuYmxvY2sgPSBuZXcgbm9kZXMuQmxvY2s7XHJcbiAgICAgICAgdGFnLmJsb2NrLnB1c2godGhpcy5wYXJzZUV4cHIoKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ25ld2xpbmUnOlxyXG4gICAgICBjYXNlICdpbmRlbnQnOlxyXG4gICAgICBjYXNlICdvdXRkZW50JzpcclxuICAgICAgY2FzZSAnZW9zJzpcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gYCcgKyB0aGlzLnBlZWsoKS50eXBlICsgJ2AgZXhwZWN0ZWQgYHRleHRgLCBgY29kZWAsIGA6YCwgYG5ld2xpbmVgIG9yIGBlb3NgJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBuZXdsaW5lKlxyXG4gICAgd2hpbGUgKCduZXdsaW5lJyA9PSB0aGlzLnBlZWsoKS50eXBlKSB0aGlzLmFkdmFuY2UoKTtcclxuXHJcbiAgICB0YWcudGV4dE9ubHkgPSB0YWcudGV4dE9ubHkgfHwgfnRleHRPbmx5LmluZGV4T2YodGFnLm5hbWUpO1xyXG5cclxuICAgIC8vIHNjcmlwdCBzcGVjaWFsLWNhc2VcclxuICAgIGlmICgnc2NyaXB0JyA9PSB0YWcubmFtZSkge1xyXG4gICAgICB2YXIgdHlwZSA9IHRhZy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcclxuICAgICAgaWYgKCFkb3QgJiYgdHlwZSAmJiAndGV4dC9qYXZhc2NyaXB0JyAhPSB0eXBlLnJlcGxhY2UoL15bJ1wiXXxbJ1wiXSQvZywgJycpKSB7XHJcbiAgICAgICAgdGFnLnRleHRPbmx5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBibG9jaz9cclxuICAgIGlmICgnaW5kZW50JyA9PSB0aGlzLnBlZWsoKS50eXBlKSB7XHJcbiAgICAgIGlmICh0YWcudGV4dE9ubHkpIHtcclxuICAgICAgICBpZiAoIWRvdCkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKHRoaXMuZmlsZW5hbWUgKyAnLCBsaW5lICcgKyB0aGlzLnBlZWsoKS5saW5lICsgJzonKVxyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdJbXBsaWNpdCB0ZXh0T25seSBmb3IgYHNjcmlwdGAgYW5kIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gIFVzZSBgc2NyaXB0LmAgb3IgYHN0eWxlLmAgaW5zdGVhZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZXhlci5waXBlbGVzcyA9IHRydWU7XHJcbiAgICAgICAgdGFnLmJsb2NrID0gdGhpcy5wYXJzZVRleHRCbG9jaygpO1xyXG4gICAgICAgIHRoaXMubGV4ZXIucGlwZWxlc3MgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XHJcbiAgICAgICAgaWYgKHRhZy5ibG9jaykge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJsb2NrLm5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHRhZy5ibG9jay5wdXNoKGJsb2NrLm5vZGVzW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFnLmJsb2NrID0gYmxvY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhZztcclxuICB9XHJcbn07XHJcbiIsIlxyXG4vKiFcclxuICogSmFkZSAtIHJ1bnRpbWVcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIExhbWUgQXJyYXkuaXNBcnJheSgpIHBvbHlmaWxsIGZvciBub3cuXHJcbiAqL1xyXG5cclxuaWYgKCFBcnJheS5pc0FycmF5KSB7XHJcbiAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKGFycil7XHJcbiAgICByZXR1cm4gJ1tvYmplY3QgQXJyYXldJyA9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTGFtZSBPYmplY3Qua2V5cygpIHBvbHlmaWxsIGZvciBub3cuXHJcbiAqL1xyXG5cclxuaWYgKCFPYmplY3Qua2V5cykge1xyXG4gIE9iamVjdC5rZXlzID0gZnVuY3Rpb24ob2JqKXtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgYXJyLnB1c2goa2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gYXR0cmlidXRlIG9iamVjdHMgZ2l2aW5nIHByZWNlZGVuY2VcclxuICogdG8gdmFsdWVzIGluIG9iamVjdCBgYmAuIENsYXNzZXMgYXJlIHNwZWNpYWwtY2FzZWRcclxuICogYWxsb3dpbmcgZm9yIGFycmF5cyBhbmQgbWVyZ2luZy9qb2luaW5nIGFwcHJvcHJpYXRlbHlcclxuICogcmVzdWx0aW5nIGluIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gYVxyXG4gKiBAcGFyYW0ge09iamVjdH0gYlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcclxuICB2YXIgYWMgPSBhWydjbGFzcyddO1xyXG4gIHZhciBiYyA9IGJbJ2NsYXNzJ107XHJcblxyXG4gIGlmIChhYyB8fCBiYykge1xyXG4gICAgYWMgPSBhYyB8fCBbXTtcclxuICAgIGJjID0gYmMgfHwgW107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWMpKSBhYyA9IFthY107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmMpKSBiYyA9IFtiY107XHJcbiAgICBhWydjbGFzcyddID0gYWMuY29uY2F0KGJjKS5maWx0ZXIobnVsbHMpO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcclxuICAgIGlmIChrZXkgIT0gJ2NsYXNzJykge1xyXG4gICAgICBhW2tleV0gPSBiW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaWx0ZXIgbnVsbCBgdmFsYHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG51bGxzKHZhbCkge1xyXG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwgIT09ICcnO1xyXG59XHJcblxyXG4vKipcclxuICogam9pbiBhcnJheSBhcyBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKHZhbCkge1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKGpvaW5DbGFzc2VzKS5maWx0ZXIobnVsbHMpLmpvaW4oJyAnKSA6IHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtPYmplY3R9IGVzY2FwZWRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmF0dHJzID0gZnVuY3Rpb24gYXR0cnMob2JqLCBlc2NhcGVkKXtcclxuICB2YXIgYnVmID0gW11cclxuICAgICwgdGVyc2UgPSBvYmoudGVyc2U7XHJcblxyXG4gIGRlbGV0ZSBvYmoudGVyc2U7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXHJcbiAgICAsIGxlbiA9IGtleXMubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuKSB7XHJcbiAgICBidWYucHVzaCgnJyk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldXHJcbiAgICAgICAgLCB2YWwgPSBvYmpba2V5XTtcclxuXHJcbiAgICAgIGlmICgnYm9vbGVhbicgPT0gdHlwZW9mIHZhbCB8fCBudWxsID09IHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgIHRlcnNlXHJcbiAgICAgICAgICAgID8gYnVmLnB1c2goa2V5KVxyXG4gICAgICAgICAgICA6IGJ1Zi5wdXNoKGtleSArICc9XCInICsga2V5ICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKDAgPT0ga2V5LmluZGV4T2YoJ2RhdGEnKSAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB7XHJcbiAgICAgICAgYnVmLnB1c2goa2V5ICsgXCI9J1wiICsgSlNPTi5zdHJpbmdpZnkodmFsKSArIFwiJ1wiKTtcclxuICAgICAgfSBlbHNlIGlmICgnY2xhc3MnID09IGtleSkge1xyXG4gICAgICAgIGlmIChlc2NhcGVkICYmIGVzY2FwZWRba2V5XSl7XHJcbiAgICAgICAgICBpZiAodmFsID0gZXhwb3J0cy5lc2NhcGUoam9pbkNsYXNzZXModmFsKSkpIHtcclxuICAgICAgICAgICAgYnVmLnB1c2goa2V5ICsgJz1cIicgKyB2YWwgKyAnXCInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHZhbCA9IGpvaW5DbGFzc2VzKHZhbCkpIHtcclxuICAgICAgICAgICAgYnVmLnB1c2goa2V5ICsgJz1cIicgKyB2YWwgKyAnXCInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCAmJiBlc2NhcGVkW2tleV0pIHtcclxuICAgICAgICBidWYucHVzaChrZXkgKyAnPVwiJyArIGV4cG9ydHMuZXNjYXBlKHZhbCkgKyAnXCInKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBidWYucHVzaChrZXkgKyAnPVwiJyArIHZhbCArICdcIicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnVmLmpvaW4oJyAnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGUgdGhlIGdpdmVuIHN0cmluZyBvZiBgaHRtbGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiBlc2NhcGUoaHRtbCl7XHJcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxyXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcclxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcclxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmUtdGhyb3cgdGhlIGdpdmVuIGBlcnJgIGluIGNvbnRleHQgdG8gdGhlXHJcbiAqIHRoZSBqYWRlIGluIGBmaWxlbmFtZWAgYXQgdGhlIGdpdmVuIGBsaW5lbm9gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lbm9cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5yZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdyhlcnIsIGZpbGVuYW1lLCBsaW5lbm8sIHN0cil7XHJcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB0aHJvdyBlcnI7XHJcbiAgaWYgKCh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnIHx8ICFmaWxlbmFtZSkgJiYgIXN0cikge1xyXG4gICAgZXJyLm1lc3NhZ2UgKz0gJyBvbiBsaW5lICcgKyBsaW5lbm87XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBzdHIgPSAgc3RyIHx8IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpXHJcbiAgfSBjYXRjaCAoZXgpIHtcclxuICAgIHJldGhyb3coZXJyLCBudWxsLCBsaW5lbm8pXHJcbiAgfVxyXG4gIHZhciBjb250ZXh0ID0gM1xyXG4gICAgLCBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJylcclxuICAgICwgc3RhcnQgPSBNYXRoLm1heChsaW5lbm8gLSBjb250ZXh0LCAwKVxyXG4gICAgLCBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVubyArIGNvbnRleHQpO1xyXG5cclxuICAvLyBFcnJvciBjb250ZXh0XHJcbiAgdmFyIGNvbnRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaSl7XHJcbiAgICB2YXIgY3VyciA9IGkgKyBzdGFydCArIDE7XHJcbiAgICByZXR1cm4gKGN1cnIgPT0gbGluZW5vID8gJyAgPiAnIDogJyAgICAnKVxyXG4gICAgICArIGN1cnJcclxuICAgICAgKyAnfCAnXHJcbiAgICAgICsgbGluZTtcclxuICB9KS5qb2luKCdcXG4nKTtcclxuXHJcbiAgLy8gQWx0ZXIgZXhjZXB0aW9uIG1lc3NhZ2VcclxuICBlcnIucGF0aCA9IGZpbGVuYW1lO1xyXG4gIGVyci5tZXNzYWdlID0gKGZpbGVuYW1lIHx8ICdKYWRlJykgKyAnOicgKyBsaW5lbm9cclxuICAgICsgJ1xcbicgKyBjb250ZXh0ICsgJ1xcblxcbicgKyBlcnIubWVzc2FnZTtcclxuICB0aHJvdyBlcnI7XHJcbn07XHJcbiIsIlxyXG4vKiFcclxuICogSmFkZSAtIHNlbGYgY2xvc2luZyB0YWdzXHJcbiAqIENvcHlyaWdodChjKSAyMDEwIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ21ldGEnXHJcbiAgLCAnaW1nJ1xyXG4gICwgJ2xpbmsnXHJcbiAgLCAnaW5wdXQnXHJcbiAgLCAnc291cmNlJ1xyXG4gICwgJ2FyZWEnXHJcbiAgLCAnYmFzZSdcclxuICAsICdjb2wnXHJcbiAgLCAnYnInXHJcbiAgLCAnaHInXHJcbl07IiwiXHJcbi8qIVxyXG4gKiBKYWRlIC0gdXRpbHNcclxuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cclxuICogTUlUIExpY2Vuc2VkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGFcclxuICogQHBhcmFtIHtPYmplY3R9IGJcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIGIpIGFba2V5XSA9IGJba2V5XTtcclxuICByZXR1cm4gYTtcclxufTtcclxuXHJcbiIsImV4cG9ydHMgPSAobW9kdWxlLmV4cG9ydHMgPSBwYXJzZSk7XHJcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcclxuZnVuY3Rpb24gcGFyc2Uoc3JjLCBzdGF0ZSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHN0YXRlID0gc3RhdGUgfHwgZXhwb3J0cy5kZWZhdWx0U3RhdGUoKTtcclxuICB2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XHJcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kIHx8IHNyYy5sZW5ndGg7XHJcbiAgdmFyIGluZGV4ID0gc3RhcnQ7XHJcbiAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XHJcbiAgICBpZiAoc3RhdGUucm91bmREZXB0aCA8IDAgfHwgc3RhdGUuY3VybHlEZXB0aCA8IDAgfHwgc3RhdGUuc3F1YXJlRGVwdGggPCAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTWlzbWF0Y2hlZCBCcmFja2V0OiAnICsgc3JjW2luZGV4IC0gMV0pO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5wYXJzZUNoYXIoc3JjW2luZGV4KytdLCBzdGF0ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuZXhwb3J0cy5wYXJzZU1heCA9IHBhcnNlTWF4O1xyXG5mdW5jdGlvbiBwYXJzZU1heChzcmMsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICB2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XHJcbiAgdmFyIGluZGV4ID0gc3RhcnQ7XHJcbiAgdmFyIHN0YXRlID0gZXhwb3J0cy5kZWZhdWx0U3RhdGUoKTtcclxuICB3aGlsZSAoc3RhdGUucm91bmREZXB0aCA+PSAwICYmIHN0YXRlLmN1cmx5RGVwdGggPj0gMCAmJiBzdGF0ZS5zcXVhcmVEZXB0aCA+PSAwKSB7XHJcbiAgICBpZiAoaW5kZXggPj0gc3JjLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmQgb2YgdGhlIHN0cmluZyB3YXMgcmVhY2hlZCB3aXRoIG5vIGNsb3NpbmcgYnJhY2tldCBmb3VuZC4nKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucGFyc2VDaGFyKHNyY1tpbmRleCsrXSwgc3RhdGUpO1xyXG4gIH1cclxuICB2YXIgZW5kID0gaW5kZXggLSAxO1xyXG4gIHJldHVybiB7XHJcbiAgICBzdGFydDogc3RhcnQsXHJcbiAgICBlbmQ6IGVuZCxcclxuICAgIHNyYzogc3JjLnN1YnN0cmluZyhzdGFydCwgZW5kKVxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydHMucGFyc2VVbnRpbCA9IHBhcnNlVW50aWw7XHJcbmZ1bmN0aW9uIHBhcnNlVW50aWwoc3JjLCBkZWxpbWl0ZXIsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICB2YXIgaW5jbHVkZUxpbmVDb21tZW50ID0gb3B0aW9ucy5pbmNsdWRlTGluZUNvbW1lbnQgfHwgZmFsc2U7XHJcbiAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xyXG4gIHZhciBpbmRleCA9IHN0YXJ0O1xyXG4gIHZhciBzdGF0ZSA9IGV4cG9ydHMuZGVmYXVsdFN0YXRlKCk7XHJcbiAgd2hpbGUgKHN0YXRlLnNpbmdsZVF1b3RlIHx8IHN0YXRlLmRvdWJsZVF1b3RlIHx8IHN0YXRlLnJlZ2V4cCB8fCBzdGF0ZS5ibG9ja0NvbW1lbnQgfHxcclxuICAgICAgICAgKCFpbmNsdWRlTGluZUNvbW1lbnQgJiYgc3RhdGUubGluZUNvbW1lbnQpIHx8ICFzdGFydHNXaXRoKHNyYywgZGVsaW1pdGVyLCBpbmRleCkpIHtcclxuICAgIGV4cG9ydHMucGFyc2VDaGFyKHNyY1tpbmRleCsrXSwgc3RhdGUpO1xyXG4gIH1cclxuICB2YXIgZW5kID0gaW5kZXg7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0OiBzdGFydCxcclxuICAgIGVuZDogZW5kLFxyXG4gICAgc3JjOiBzcmMuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXHJcbiAgfTtcclxufVxyXG5cclxuXHJcbmV4cG9ydHMucGFyc2VDaGFyID0gcGFyc2VDaGFyO1xyXG5mdW5jdGlvbiBwYXJzZUNoYXIoY2hhcmFjdGVyLCBzdGF0ZSkge1xyXG4gIGlmIChjaGFyYWN0ZXIubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ0NoYXJhY3RlciBtdXN0IGJlIGEgc3RyaW5nIG9mIGxlbmd0aCAxJyk7XHJcbiAgc3RhdGUgPSBzdGF0ZSB8fCBkZWZhdWx0U3RhdGUoKTtcclxuICB2YXIgd2FzQ29tbWVudCA9IHN0YXRlLmJsb2NrQ29tbWVudCB8fCBzdGF0ZS5saW5lQ29tbWVudDtcclxuICB2YXIgbGFzdENoYXIgPSBzdGF0ZS5oaXN0b3J5ID8gc3RhdGUuaGlzdG9yeVswXSA6ICcnO1xyXG4gIGlmIChzdGF0ZS5saW5lQ29tbWVudCkge1xyXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gJ1xcbicpIHtcclxuICAgICAgc3RhdGUubGluZUNvbW1lbnQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHN0YXRlLmJsb2NrQ29tbWVudCkge1xyXG4gICAgaWYgKHN0YXRlLmxhc3RDaGFyID09PSAnKicgJiYgY2hhcmFjdGVyID09PSAnLycpIHtcclxuICAgICAgc3RhdGUuYmxvY2tDb21tZW50ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5zaW5nbGVRdW90ZSkge1xyXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gJ1xcJycgJiYgIXN0YXRlLmVzY2FwZWQpIHtcclxuICAgICAgc3RhdGUuc2luZ2xlUXVvdGUgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnXFxcXCcgJiYgIXN0YXRlLmVzY2FwZWQpIHtcclxuICAgICAgc3RhdGUuZXNjYXBlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0ZS5lc2NhcGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5kb3VibGVRdW90ZSkge1xyXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gJ1wiJyAmJiAhc3RhdGUuZXNjYXBlZCkge1xyXG4gICAgICBzdGF0ZS5kb3VibGVRdW90ZSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICdcXFxcJyAmJiAhc3RhdGUuZXNjYXBlZCkge1xyXG4gICAgICBzdGF0ZS5lc2NhcGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlLmVzY2FwZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHN0YXRlLnJlZ2V4cCkge1xyXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gJy8nICYmICFzdGF0ZS5lc2NhcGVkKSB7XHJcbiAgICAgIHN0YXRlLnJlZ2V4cCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICdcXFxcJyAmJiAhc3RhdGUuZXNjYXBlZCkge1xyXG4gICAgICBzdGF0ZS5lc2NhcGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlLmVzY2FwZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGxhc3RDaGFyID09PSAnLycgJiYgY2hhcmFjdGVyID09PSAnLycpIHtcclxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnN1YnN0cigxKTtcclxuICAgIHN0YXRlLmxpbmVDb21tZW50ID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGxhc3RDaGFyID09PSAnLycgJiYgY2hhcmFjdGVyID09PSAnKicpIHtcclxuICAgIGhpc3RvcnkgPSBoaXN0b3J5LnN1YnN0cigxKTtcclxuICAgIHN0YXRlLmJsb2NrQ29tbWVudCA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICcvJykge1xyXG4gICAgLy9jb3VsZCBiZSBzdGFydCBvZiByZWdleHAgb3IgZGl2aWRlIHNpZ25cclxuICAgIHZhciBoaXN0b3J5ID0gc3RhdGUuaGlzdG9yeS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcclxuICAgIGlmIChoaXN0b3J5WzBdID09PSAnKScpIHtcclxuICAgICAgLy91bmxlc3MgaXRzIGFuIGBpZmAsIGB3aGlsZWAsIGBmb3JgIG9yIGB3aXRoYCBpdCdzIGEgZGl2aWRlXHJcbiAgICAgIC8vdGhpcyBpcyBwcm9iYWJseSBiZXN0IGxlZnQgdGhvdWdoXHJcbiAgICB9IGVsc2UgaWYgKGhpc3RvcnlbMF0gPT09ICd9Jykge1xyXG4gICAgICAvL3VubGVzcyBpdCdzIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiwgaXQncyBhIHJlZ2V4cFxyXG4gICAgICAvL3RoaXMgaXMgcHJvYmFibHkgYmVzdCBsZWZ0IHRob3VnaFxyXG4gICAgfSBlbHNlIGlmIChpc1B1bmN0dWF0b3IoaGlzdG9yeVswXSkpIHtcclxuICAgICAgc3RhdGUucmVnZXhwID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoL15cXHcrXFxiLy50ZXN0KGhpc3RvcnkpICYmIGlzS2V5d29yZCgvXlxcdytcXGIvLmV4ZWMoaGlzdG9yeSlbMF0pKSB7XHJcbiAgICAgIHN0YXRlLnJlZ2V4cCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhc3N1bWUgaXQncyBkaXZpZGVcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1xcJycpIHtcclxuICAgIHN0YXRlLnNpbmdsZVF1b3RlID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1wiJykge1xyXG4gICAgc3RhdGUuZG91YmxlUXVvdGUgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnKCcpIHtcclxuICAgIHN0YXRlLnJvdW5kRGVwdGgrKztcclxuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJyknKSB7XHJcbiAgICBzdGF0ZS5yb3VuZERlcHRoLS07XHJcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICd7Jykge1xyXG4gICAgc3RhdGUuY3VybHlEZXB0aCsrO1xyXG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnfScpIHtcclxuICAgIHN0YXRlLmN1cmx5RGVwdGgtLTtcclxuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1snKSB7XHJcbiAgICBzdGF0ZS5zcXVhcmVEZXB0aCsrO1xyXG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnXScpIHtcclxuICAgIHN0YXRlLnNxdWFyZURlcHRoLS07XHJcbiAgfVxyXG4gIGlmICghc3RhdGUuYmxvY2tDb21tZW50ICYmICFzdGF0ZS5saW5lQ29tbWVudCAmJiAhd2FzQ29tbWVudCkgc3RhdGUuaGlzdG9yeSA9IGNoYXJhY3RlciArIHN0YXRlLmhpc3Rvcnk7XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcclxuZnVuY3Rpb24gZGVmYXVsdFN0YXRlKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBsaW5lQ29tbWVudDogZmFsc2UsXHJcbiAgICBibG9ja0NvbW1lbnQ6IGZhbHNlLFxyXG5cclxuICAgIHNpbmdsZVF1b3RlOiBmYWxzZSxcclxuICAgIGRvdWJsZVF1b3RlOiBmYWxzZSxcclxuICAgIHJlZ2V4cDogZmFsc2UsXHJcbiAgICBlc2NhcGVkOiBmYWxzZSxcclxuXHJcbiAgICByb3VuZERlcHRoOiAwLFxyXG4gICAgY3VybHlEZXB0aDogMCxcclxuICAgIHNxdWFyZURlcHRoOiAwLFxyXG5cclxuICAgIGhpc3Rvcnk6ICcnXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHN0YXJ0LCBpKSB7XHJcbiAgcmV0dXJuIHN0ci5zdWJzdHIoaSB8fCAwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNQdW5jdHVhdG9yKGMpIHtcclxuICB2YXIgY29kZSA9IGMuY2hhckNvZGVBdCgwKVxyXG5cclxuICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgIGNhc2UgNDY6ICAgLy8gLiBkb3RcclxuICAgIGNhc2UgNDA6ICAgLy8gKCBvcGVuIGJyYWNrZXRcclxuICAgIGNhc2UgNDE6ICAgLy8gKSBjbG9zZSBicmFja2V0XHJcbiAgICBjYXNlIDU5OiAgIC8vIDsgc2VtaWNvbG9uXHJcbiAgICBjYXNlIDQ0OiAgIC8vICwgY29tbWFcclxuICAgIGNhc2UgMTIzOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXHJcbiAgICBjYXNlIDEyNTogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcclxuICAgIGNhc2UgOTE6ICAgLy8gW1xyXG4gICAgY2FzZSA5MzogICAvLyBdXHJcbiAgICBjYXNlIDU4OiAgIC8vIDpcclxuICAgIGNhc2UgNjM6ICAgLy8gP1xyXG4gICAgY2FzZSAxMjY6ICAvLyB+XHJcbiAgICBjYXNlIDM3OiAgIC8vICVcclxuICAgIGNhc2UgMzg6ICAgLy8gJlxyXG4gICAgY2FzZSA0MjogICAvLyAqOlxyXG4gICAgY2FzZSA0MzogICAvLyArXHJcbiAgICBjYXNlIDQ1OiAgIC8vIC1cclxuICAgIGNhc2UgNDc6ICAgLy8gL1xyXG4gICAgY2FzZSA2MDogICAvLyA8XHJcbiAgICBjYXNlIDYyOiAgIC8vID5cclxuICAgIGNhc2UgOTQ6ICAgLy8gXlxyXG4gICAgY2FzZSAxMjQ6ICAvLyB8XHJcbiAgICBjYXNlIDMzOiAgIC8vICFcclxuICAgIGNhc2UgNjE6ICAgLy8gPVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcclxuICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKSB8fCAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxyXG4gICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0JykgfHwgKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcclxuICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpIHx8IChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XHJcbiAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fCAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJykgfHxcclxuICAgICAgICAgIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8IChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8XHJcbiAgICAgICAgICAoaWQgPT09ICdpbXBvcnQnKSB8fCAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKSB8fCAoaWQgPT09ICdmdW5jdGlvbicpIHx8XHJcbiAgICAgICAgICAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJykgfHwgKGlkID09PSAncGFja2FnZScpIHx8IChpZCA9PT0gJ3ByaXZhdGUnKSB8fCAoaWQgPT09ICdpbnRlcmZhY2UnKSB8fFxyXG4gICAgICAgICAgKGlkID09PSAnaW5zdGFuY2VvZicpIHx8IChpZCA9PT0gJ2ltcGxlbWVudHMnKSB8fCAoaWQgPT09ICdwcm90ZWN0ZWQnKSB8fCAoaWQgPT09ICdwdWJsaWMnKSB8fCAoaWQgPT09ICdzdGF0aWMnKSB8fFxyXG4gICAgICAgICAgKGlkID09PSAneWllbGQnKSB8fCAoaWQgPT09ICdsZXQnKTtcclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbnZhciB1Z2xpZnkgPSByZXF1aXJlKCd1Z2xpZnktanMnKVxyXG5cclxudmFyIGxhc3RTUkMgPSAnKG51bGwpJ1xyXG52YXIgbGFzdFJlcyA9IHRydWVcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXNDb25zdGFudFxyXG5mdW5jdGlvbiBpc0NvbnN0YW50KHNyYykge1xyXG4gIHNyYyA9ICcoJyArIHNyYyArICcpJ1xyXG4gIGlmIChsYXN0U1JDID09PSBzcmMpIHJldHVybiBsYXN0UmVzXHJcbiAgbGFzdFNSQyA9IHNyY1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbGFzdFJlcyA9IChkZXRlY3Qoc3JjKS5sZW5ndGggPT09IDApXHJcbiAgfSBjYXRjaCAoZXgpIHtcclxuICAgIHJldHVybiBsYXN0UmVzID0gZmFsc2VcclxuICB9XHJcbn1cclxuaXNDb25zdGFudC5pc0NvbnN0YW50ID0gaXNDb25zdGFudFxyXG5cclxuaXNDb25zdGFudC50b0NvbnN0YW50ID0gdG9Db25zdGFudFxyXG5mdW5jdGlvbiB0b0NvbnN0YW50KHNyYykge1xyXG4gIGlmICghaXNDb25zdGFudChzcmMpKSB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoc3JjKSArICcgaXMgbm90IGNvbnN0YW50LicpXHJcbiAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gKCcgKyBzcmMgKyAnKScpKClcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZWN0KHNyYykge1xyXG4gIHZhciBhc3QgPSB1Z2xpZnkucGFyc2Uoc3JjLnRvU3RyaW5nKCkpXHJcbiAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUoKVxyXG4gIHZhciBnbG9iYWxzID0gYXN0Lmdsb2JhbHNcclxuICAgIC5tYXAoZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcclxuICAgICAgcmV0dXJuIG5hbWVcclxuICAgIH0pXHJcbiAgcmV0dXJuIGdsb2JhbHNcclxufSIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAgICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gICAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAgICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zZXQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIEFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLmhhcyhhU3RyKTtcbiAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgICB9XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildID0gaWR4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TZXRTdHJpbmcoYVN0cikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICAgIGlmICh0aGlzLmhhcyhhU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAgICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAgICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuICAvLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbiAgLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4gIC8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuICAvLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4gIC8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuICAvL1xuICAvLyAgIENvbnRpbnVhdGlvblxuICAvLyAgIHwgICAgU2lnblxuICAvLyAgIHwgICAgfFxuICAvLyAgIFYgICAgVlxuICAvLyAgIDEwMTAxMVxuXG4gIHZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuICAvLyBiaW5hcnk6IDAxMTExMVxuICB2YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIGlzIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAgICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAgICovXG4gIGZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHJldHVybiBhVmFsdWUgPCAwXG4gICAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBpcyBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gICAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICAgIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gICAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICAgID8gLXNoaWZ0ZWRcbiAgICAgIDogc2hpZnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICAgIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgICB2YXIgZGlnaXQ7XG5cbiAgICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICAgIGRvIHtcbiAgICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgICAgaWYgKHZscSA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgICB9XG4gICAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICAgKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZy5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGkgPj0gc3RyTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICAgIH1cbiAgICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJBdChpKyspKTtcbiAgICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBmcm9tVkxRU2lnbmVkKHJlc3VsdCksXG4gICAgICByZXN0OiBhU3RyLnNsaWNlKGkpXG4gICAgfTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBjaGFyVG9JbnRNYXAgPSB7fTtcbiAgdmFyIGludFRvQ2hhck1hcCA9IHt9O1xuXG4gICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuICAgIC5zcGxpdCgnJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2gsIGluZGV4KSB7XG4gICAgICBjaGFyVG9JbnRNYXBbY2hdID0gaW5kZXg7XG4gICAgICBpbnRUb0NoYXJNYXBbaW5kZXhdID0gY2g7XG4gICAgfSk7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9lbmNvZGUoYU51bWJlcikge1xuICAgIGlmIChhTnVtYmVyIGluIGludFRvQ2hhck1hcCkge1xuICAgICAgcmV0dXJuIGludFRvQ2hhck1hcFthTnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBhTnVtYmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgdG8gYW4gaW50ZWdlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0X2RlY29kZShhQ2hhcikge1xuICAgIGlmIChhQ2hhciBpbiBjaGFyVG9JbnRNYXApIHtcbiAgICAgIHJldHVybiBjaGFyVG9JbnRNYXBbYUNoYXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgdmFsaWQgYmFzZSA2NCBkaWdpdDogXCIgKyBhQ2hhcik7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgLy9cbiAgICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIG5leHRcbiAgICAvLyAgICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIGxlc3MgdGhhbiB0aGF0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB3aGljaCBpcyBsZXNzIHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2VcbiAgICAvLyAgICAgIHJldHVybiBudWxsLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIGFIYXlzdGFja1ttaWRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBncmVhdGVyIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBkaWQgbm90IGZpbmQgYW4gZXhhY3QgbWF0Y2gsIHJldHVybiB0aGUgbmV4dCBjbG9zZXN0IG9uZVxuICAgICAgLy8gKHRlcm1pbmF0aW9uIGNhc2UgMikuXG4gICAgICByZXR1cm4gYUhheXN0YWNrW21pZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgbGVzcyB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDIpIG9yICgzKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIHJldHVybiBhTG93IDwgMFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBhSGF5c3RhY2tbYUxvd107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgbmV4dCBsb3dlc3QgdmFsdWUgY2hlY2tlZCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gICAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gICAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAgICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICAgKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgIHJldHVybiBhSGF5c3RhY2subGVuZ3RoID4gMFxuICAgICAgPyByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpXG4gICAgICA6IG51bGw7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcblxuICAvKipcbiAgICogQSBTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAgIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMsIHRydWUpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcbiAgICAgIHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgbWFwcGluZ1NlcGFyYXRvciA9IC9eWyw7XS87XG4gICAgICB2YXIgc3RyID0gYVN0cjtcbiAgICAgIHZhciBtYXBwaW5nO1xuICAgICAgdmFyIHRlbXA7XG5cbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJzsnKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJywnKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICFtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQocHJldmlvdXNTb3VyY2UgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCBtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcblxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICFtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gdGhpcy5fbmFtZXMuYXQocHJldmlvdXNOYW1lICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiB0aGlzLnNvdXJjZVJvb3QpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGlibGUuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290XG4gICAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmIHNvdXJjZVJvb3QpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lXG4gICAgICAgIH07XG4gICAgICB9KS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG5cbiAgLyoqXG4gICAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAgICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gVG8gY3JlYXRlIGEgbmV3IG9uZSwgeW91IG11c3QgcGFzcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBbiBvcHRpb25hbCByb290IGZvciBhbGwgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJyk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gW107XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuXG4gICAgICBpZiAoc291cmNlICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSkge1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKCFhU291cmNlRmlsZSkge1xuICAgICAgICBhU291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcImFTb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBhU291cmNlRmlsZSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJhU291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gYVNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG9yaWdpbmFsLnNvdXJjZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPT0gbnVsbCAmJiBtYXBwaW5nLm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlIGlkZW50aWZpZXIgbmFtZSBpZiBpdCdzIGFuIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgLy8gaW4gYm90aCBTb3VyY2VNYXBzXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgICAgLy8gQ2FzZSAxLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgLy8gVGhlIG1hcHBpbmdzIG11c3QgYmUgZ3VhcmFudGVlZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIgYmVmb3JlIHdlIHN0YXJ0XG4gICAgICAvLyBzZXJpYWxpemluZyB0aGVtIG9yIGVsc2UgdGhlIGdlbmVyYXRlZCBsaW5lIG51bWJlcnMgKHdoaWNoIGFyZSBkZWZpbmVkXG4gICAgICAvLyB2aWEgdGhlICc7JyBzZXBhcmF0b3JzKSB3aWxsIGJlIGFsbCBtZXNzZWQgdXAuIE5vdGU6IGl0IG1pZ2h0IGJlIG1vcmVcbiAgICAgIC8vIHBlcmZvcm1hbnQgdG8gbWFpbnRhaW4gdGhlIHNvcnRpbmcgYXMgd2UgaW5zZXJ0IHRoZW0sIHJhdGhlciB0aGFuIGFzIHdlXG4gICAgICAvLyBzZXJpYWxpemUgdGhlbSwgYnV0IHRoZSBiaWcgTyBpcyB0aGUgc2FtZSBlaXRoZXIgd2F5LlxuICAgICAgdGhpcy5fbWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9tYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gdGhpcy5fbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZywgdGhpcy5fbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhU291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgZmlsZTogdGhpcy5fZmlsZSxcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QpIHtcbiAgICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAgICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gICAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICAgKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAgICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAgICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gICAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgICB0aGlzLmxpbmUgPSBhTGluZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFMaW5lO1xuICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFDb2x1bW47XG4gICAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogYVNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBhTmFtZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFOYW1lO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICovXG4gIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zaGlmdCgpICsgXCJcXG5cIik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZ1bGwgbGluZXMgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgY29kZSArPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgICB9IHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSk7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHJlYWNoZWQgdGhlIGNvcnJlY3QgbGluZSwgd2UgYWRkIGNvZGUgdW50aWwgd2VcbiAgICAgICAgICAgIC8vIHJlYWNoIHRoZSBjb3JyZWN0IGNvbHVtbiB0b28uXG4gICAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgICBjb2RlICs9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBTb3VyY2VOb2RlLlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgcmVtYWluaW5nTGluZXMuam9pbihcIlxcblwiKSk7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaHVuay5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC8oW1xcdytcXC0uXSspOlxcL1xcLygoXFx3KzpcXHcrKUApPyhbXFx3Ll0rKT8oOihcXGQrKSk/KFxcUyspPy87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLisvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbM10sXG4gICAgICBob3N0OiBtYXRjaFs0XSxcbiAgICAgIHBvcnQ6IG1hdGNoWzZdLFxuICAgICAgcGF0aDogbWF0Y2hbN11cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9IGFQYXJzZWRVcmwuc2NoZW1lICsgXCI6Ly9cIjtcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgXCJAXCJcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgdmFyIHVybDtcblxuICAgIGlmIChhUGF0aC5tYXRjaCh1cmxSZWdleHApIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nICYmICh1cmwgPSB1cmxQYXJzZShhUm9vdCkpKSB7XG4gICAgICB1cmwucGF0aCA9IGFQYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLycgKyBhUGF0aDtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFQYXRoLmNoYXJBdCgwKSA9PSBcIi9cIiAmJiB1cmwgJiYgdXJsLnBhdGggPT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBhUGF0aC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgPT09IDBcbiAgICAgID8gYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpXG4gICAgICA6IGFQYXRoO1xuICB9XG4gIGV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuICBmdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gICAgdmFyIHMxID0gYVN0cjEgfHwgXCJcIjtcbiAgICB2YXIgczIgPSBhU3RyMiB8fCBcIlwiO1xuICAgIHJldHVybiAoczEgPiBzMikgLSAoczEgPCBzMik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAgICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAgICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlXG4gICAqIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICAgKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICAgKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wO1xuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zO1xuXG59KTtcbiIsInZhciBwcm9jZXNzPXJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxfX2ZpbGVuYW1lPVwiLy4uLy4uL25vZGVfbW9kdWxlcy9qYWRlL25vZGVfbW9kdWxlcy9jb25zdGFudGlub3BsZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL25vZGVfbW9kdWxlcy9hbWRlZmluZS9hbWRlZmluZS5qc1wiOy8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMC4xLjAgQ29weXJpZ2h0IChjKSAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL2FtZGVmaW5lIGZvciBkZXRhaWxzXG4gKi9cblxuLypqc2xpbnQgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCBwcm9jZXNzICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZmluZSBmb3Igbm9kZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIFwibW9kdWxlXCIgb2JqZWN0IHRoYXQgaXMgZGVmaW5lZCBieSBOb2RlIGZvciB0aGVcbiAqIGN1cnJlbnQgbW9kdWxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlcXVpcmVGbl0uIE5vZGUncyByZXF1aXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudCBtb2R1bGUuXG4gKiBJdCBvbmx5IG5lZWRzIHRvIGJlIHBhc3NlZCBpbiBOb2RlIHZlcnNpb25zIGJlZm9yZSAwLjUsIHdoZW4gbW9kdWxlLnJlcXVpcmVcbiAqIGRpZCBub3QgZXhpc3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZGVmaW5lIGZ1bmN0aW9uIHRoYXQgaXMgdXNhYmxlIGZvciB0aGUgY3VycmVudCBub2RlXG4gKiBtb2R1bGUuXG4gKi9cbmZ1bmN0aW9uIGFtZGVmaW5lKG1vZHVsZSwgcmVxdWlyZUZuKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBkZWZpbmVDYWNoZSA9IHt9LFxuICAgICAgICBsb2FkZXJDYWNoZSA9IHt9LFxuICAgICAgICBhbHJlYWR5Q2FsbGVkID0gZmFsc2UsXG4gICAgICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgICAgIG1ha2VSZXF1aXJlLCBzdHJpbmdSZXF1aXJlO1xuXG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIC4gYW5kIC4uIGZyb20gYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBJdCB3aWxsIGtlZXAgYSBsZWFkaW5nIHBhdGggc2VnbWVudCBpZiBhIC4uIHdpbGwgYmVjb21lXG4gICAgICogdGhlIGZpcnN0IHBhdGggc2VnbWVudCwgdG8gaGVscCB3aXRoIG1vZHVsZSBuYW1lIGxvb2t1cHMsXG4gICAgICogd2hpY2ggYWN0IGxpa2UgcGF0aHMsIGJ1dCBjYW4gYmUgcmVtYXBwZWQuIEJ1dCB0aGUgZW5kIHJlc3VsdCxcbiAgICAgKiBhbGwgcGF0aHMgdGhhdCB1c2UgdGhpcyBmdW5jdGlvbiBzaG91bGQgbG9vayBub3JtYWxpemVkLlxuICAgICAqIE5PVEU6IHRoaXMgbWV0aG9kIE1PRElGSUVTIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnkgdGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbURvdHMoYXJ5KSB7XG4gICAgICAgIHZhciBpLCBwYXJ0O1xuICAgICAgICBmb3IgKGkgPSAwOyBhcnlbaV07IGkrPSAxKSB7XG4gICAgICAgICAgICBwYXJ0ID0gYXJ5W2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgKGFyeVsyXSA9PT0gJy4uJyB8fCBhcnlbMF0gPT09ICcuLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRW5kIG9mIHRoZSBsaW5lLiBLZWVwIGF0IGxlYXN0IG9uZSBub24tZG90XG4gICAgICAgICAgICAgICAgICAgIC8vcGF0aCBzZWdtZW50IGF0IHRoZSBmcm9udCBzbyBpdCBjYW4gYmUgbWFwcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdGx5IHRvIGRpc2suIE90aGVyd2lzZSwgdGhlcmUgaXMgbGlrZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vbm8gcGF0aCBtYXBwaW5nIGZvciBhIHBhdGggc3RhcnRpbmcgd2l0aCAnLi4nLlxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIHN0aWxsIGZhaWwsIGJ1dCBjYXRjaGVzIHRoZSBtb3N0IHJlYXNvbmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGJhc2VQYXJ0cztcblxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vSWYgaGF2ZSBhIGJhc2UgbmFtZSwgdHJ5IHRvIG5vcm1hbGl6ZSBhZ2FpbnN0IGl0LFxuICAgICAgICAgICAgLy9vdGhlcndpc2UsIGFzc3VtZSBpdCBpcyBhIHRvcC1sZXZlbCByZXF1aXJlIHRoYXQgd2lsbFxuICAgICAgICAgICAgLy9iZSByZWxhdGl2ZSB0byBiYXNlVXJsIGluIHRoZSBlbmQuXG4gICAgICAgICAgICBpZiAoYmFzZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLmNvbmNhdChuYW1lLnNwbGl0KCcvJykpO1xuICAgICAgICAgICAgICAgIHRyaW1Eb3RzKGJhc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGJhc2VQYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIG5vcm1hbGl6ZSgpIGZ1bmN0aW9uIHBhc3NlZCB0byBhIGxvYWRlciBwbHVnaW4nc1xuICAgICAqIG5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlTG9hZChpZCkge1xuICAgICAgICBmdW5jdGlvbiBsb2FkKHZhbHVlKSB7XG4gICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWQuZnJvbVRleHQgPSBmdW5jdGlvbiAoaWQsIHRleHQpIHtcbiAgICAgICAgICAgIC8vVGhpcyBvbmUgaXMgZGlmZmljdWx0IGJlY2F1c2UgdGhlIHRleHQgY2FuL3Byb2JhYmx5IHVzZXNcbiAgICAgICAgICAgIC8vZGVmaW5lLCBhbmQgYW55IHJlbGF0aXZlIHBhdGhzIGFuZCByZXF1aXJlcyBzaG91bGQgYmUgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vdG8gdGhhdCBpZCB3YXMgaXQgd291bGQgYmUgZm91bmQgb24gZGlzay4gQnV0IHRoaXMgd291bGQgcmVxdWlyZVxuICAgICAgICAgICAgLy9ib290c3RyYXBwaW5nIGEgbW9kdWxlL3JlcXVpcmUgZmFpcmx5IGRlZXBseSBmcm9tIG5vZGUgY29yZS5cbiAgICAgICAgICAgIC8vTm90IHN1cmUgaG93IGJlc3QgdG8gZ28gYWJvdXQgdGhhdCB5ZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIGRvZXMgbm90IGltcGxlbWVudCBsb2FkLmZyb21UZXh0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgfVxuXG4gICAgbWFrZVJlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCkge1xuICAgICAgICBmdW5jdGlvbiBhbWRSZXF1aXJlKGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9TeW5jaHJvbm91cywgc2luZ2xlIG1vZHVsZSByZXF1aXJlKCcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwcywgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL0FycmF5IG9mIGRlcGVuZGVuY2llcyB3aXRoIGEgY2FsbGJhY2suXG5cbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgdGhlIGRlcGVuZGVuY2llcyB0byBtb2R1bGVzLlxuICAgICAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcE5hbWUsIHJlbElkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vV2FpdCBmb3IgbmV4dCB0aWNrIHRvIGNhbGwgYmFjayB0aGUgcmVxdWlyZSBjYWxsLlxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBkZXBzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG4iLCJ2YXIgc3lzID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgTU9aX1NvdXJjZU1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpO1xudmFyIFVnbGlmeUpTID0gZXhwb3J0cztcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGFycmF5X3RvX2hhc2goYSkge1xuICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSlcbiAgICAgICAgcmV0W2FbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gc2xpY2UoYSwgc3RhcnQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgc3RhcnQgfHwgMCk7XG59O1xuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoXCJcIik7XG59O1xuXG5mdW5jdGlvbiBtZW1iZXIobmFtZSwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgIGlmIChhcnJheVtpXSA9PSBuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZmluZF9pZihmdW5jLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChmdW5jKGFycmF5W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiByZXBlYXRfc3RyaW5nKHN0ciwgaSkge1xuICAgIGlmIChpIDw9IDApIHJldHVybiBcIlwiO1xuICAgIGlmIChpID09IDEpIHJldHVybiBzdHI7XG4gICAgdmFyIGQgPSByZXBlYXRfc3RyaW5nKHN0ciwgaSA+PiAxKTtcbiAgICBkICs9IGQ7XG4gICAgaWYgKGkgJiAxKSBkICs9IHN0cjtcbiAgICByZXR1cm4gZDtcbn07XG5cbmZ1bmN0aW9uIERlZmF1bHRzRXJyb3IobXNnLCBkZWZzKSB7XG4gICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgdGhpcy5kZWZzID0gZGVmcztcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKGFyZ3MsIGRlZnMsIGNyb2FrKSB7XG4gICAgaWYgKGFyZ3MgPT09IHRydWUpXG4gICAgICAgIGFyZ3MgPSB7fTtcbiAgICB2YXIgcmV0ID0gYXJncyB8fCB7fTtcbiAgICBpZiAoY3JvYWspIGZvciAodmFyIGkgaW4gcmV0KSBpZiAocmV0Lmhhc093blByb3BlcnR5KGkpICYmICFkZWZzLmhhc093blByb3BlcnR5KGkpKVxuICAgICAgICB0aHJvdyBuZXcgRGVmYXVsdHNFcnJvcihcImBcIiArIGkgKyBcImAgaXMgbm90IGEgc3VwcG9ydGVkIG9wdGlvblwiLCBkZWZzKTtcbiAgICBmb3IgKHZhciBpIGluIGRlZnMpIGlmIChkZWZzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIHJldFtpXSA9IChhcmdzICYmIGFyZ3MuaGFzT3duUHJvcGVydHkoaSkpID8gYXJnc1tpXSA6IGRlZnNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBtZXJnZShvYmosIGV4dCkge1xuICAgIGZvciAodmFyIGkgaW4gZXh0KSBpZiAoZXh0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIG9ialtpXSA9IGV4dFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIE1BUCA9IChmdW5jdGlvbigpe1xuICAgIGZ1bmN0aW9uIE1BUChhLCBmLCBiYWNrd2FyZHMpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdLCB0b3AgPSBbXSwgaTtcbiAgICAgICAgZnVuY3Rpb24gZG9pdCgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBmKGFbaV0sIGkpO1xuICAgICAgICAgICAgdmFyIGlzX2xhc3QgPSB2YWwgaW5zdGFuY2VvZiBMYXN0O1xuICAgICAgICAgICAgaWYgKGlzX2xhc3QpIHZhbCA9IHZhbC52O1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEF0VG9wKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnY7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaC5hcHBseSh0b3AsIGJhY2t3YXJkcyA/IHZhbC52LnNsaWNlKCkucmV2ZXJzZSgpIDogdmFsLnYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9PSBza2lwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIGJhY2t3YXJkcyA/IHZhbC52LnNsaWNlKCkucmV2ZXJzZSgpIDogdmFsLnYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzX2xhc3Q7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBhLmxlbmd0aDsgLS1pID49IDA7KSBpZiAoZG9pdCgpKSBicmVhaztcbiAgICAgICAgICAgICAgICByZXQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIHRvcC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSBpZiAoZG9pdCgpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBhKSBpZiAoYS5oYXNPd25Qcm9wZXJ0eShpKSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcC5jb25jYXQocmV0KTtcbiAgICB9O1xuICAgIE1BUC5hdF90b3AgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBdFRvcCh2YWwpIH07XG4gICAgTUFQLnNwbGljZSA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IFNwbGljZSh2YWwpIH07XG4gICAgTUFQLmxhc3QgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBMYXN0KHZhbCkgfTtcbiAgICB2YXIgc2tpcCA9IE1BUC5za2lwID0ge307XG4gICAgZnVuY3Rpb24gQXRUb3AodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIGZ1bmN0aW9uIFNwbGljZSh2YWwpIHsgdGhpcy52ID0gdmFsIH07XG4gICAgZnVuY3Rpb24gTGFzdCh2YWwpIHsgdGhpcy52ID0gdmFsIH07XG4gICAgcmV0dXJuIE1BUDtcbn0pKCk7XG5cbmZ1bmN0aW9uIHB1c2hfdW5pcShhcnJheSwgZWwpIHtcbiAgICBpZiAoYXJyYXkuaW5kZXhPZihlbCkgPCAwKVxuICAgICAgICBhcnJheS5wdXNoKGVsKTtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ190ZW1wbGF0ZSh0ZXh0LCBwcm9wcykge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xceyguKz8pXFx9L2csIGZ1bmN0aW9uKHN0ciwgcCl7XG4gICAgICAgIHJldHVybiBwcm9wc1twXTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgZWwpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBlbCkgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY21wKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8IDIpIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICAgICAgdmFyIHIgPSBbXSwgYWkgPSAwLCBiaSA9IDAsIGkgPSAwO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbXAoYVthaV0sIGJbYmldKSA8PSAwXG4gICAgICAgICAgICAgICAgPyByW2krK10gPSBhW2FpKytdXG4gICAgICAgICAgICAgICAgOiByW2krK10gPSBiW2JpKytdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhaSA8IGEubGVuZ3RoKSByLnB1c2guYXBwbHkociwgYS5zbGljZShhaSkpO1xuICAgICAgICBpZiAoYmkgPCBiLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGIuc2xpY2UoYmkpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfbXMoYSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggPD0gMSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoYS5sZW5ndGggLyAyKSwgbGVmdCA9IGEuc2xpY2UoMCwgbSksIHJpZ2h0ID0gYS5zbGljZShtKTtcbiAgICAgICAgbGVmdCA9IF9tcyhsZWZ0KTtcbiAgICAgICAgcmlnaHQgPSBfbXMocmlnaHQpO1xuICAgICAgICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgcmV0dXJuIF9tcyhhcnJheSk7XG59O1xuXG5mdW5jdGlvbiBzZXRfZGlmZmVyZW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlbCkgPCAwO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gc2V0X2ludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlbCkgPj0gMDtcbiAgICB9KTtcbn07XG5cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBBY29ybiBbMV0sIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZVxuLy8gWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuXG5mdW5jdGlvbiBtYWtlUHJlZGljYXRlKHdvcmRzKSB7XG4gICAgaWYgKCEod29yZHMgaW5zdGFuY2VvZiBBcnJheSkpIHdvcmRzID0gd29yZHMuc3BsaXQoXCIgXCIpO1xuICAgIHZhciBmID0gXCJcIiwgY2F0cyA9IFtdO1xuICAgIG91dDogZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhdHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICBpZiAoY2F0c1tqXVswXS5sZW5ndGggPT0gd29yZHNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhdHMucHVzaChbd29yZHNbaV1dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVRvKGFycikge1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAxKSByZXR1cm4gZiArPSBcInJldHVybiBzdHIgPT09IFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyWzBdKSArIFwiO1wiO1xuICAgICAgICBmICs9IFwic3dpdGNoKHN0cil7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBmICs9IFwiY2FzZSBcIiArIEpTT04uc3RyaW5naWZ5KGFycltpXSkgKyBcIjpcIjtcbiAgICAgICAgZiArPSBcInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcIjtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIHRocmVlIGxlbmd0aCBjYXRlZ29yaWVzLCBhbiBvdXRlclxuICAgIC8vIHN3aXRjaCBmaXJzdCBkaXNwYXRjaGVzIG9uIHRoZSBsZW5ndGhzLCB0byBzYXZlIG9uIGNvbXBhcmlzb25zLlxuICAgIGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDt9KTtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2F0ID0gY2F0c1tpXTtcbiAgICAgICAgICAgIGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XG4gICAgICAgIH1cbiAgICAgICAgZiArPSBcIn1cIjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzaW1wbHkgZ2VuZXJhdGUgYSBmbGF0IGBzd2l0Y2hgIHN0YXRlbWVudC5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wYXJlVG8od29yZHMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RyXCIsIGYpO1xufTtcblxuZnVuY3Rpb24gYWxsKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIERpY3Rpb25hcnkoKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9zaXplID0gMDtcbn07XG5EaWN0aW9uYXJ5LnByb3RvdHlwZSA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkgKyt0aGlzLl9zaXplO1xuICAgICAgICB0aGlzLl92YWx1ZXNbXCIkXCIgKyBrZXldID0gdmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0KGtleSkucHVzaCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBbIHZhbCBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7IHJldHVybiB0aGlzLl92YWx1ZXNbXCIkXCIgKyBrZXldIH0sXG4gICAgZGVsOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl92YWx1ZXNbXCIkXCIgKyBrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIChcIiRcIiArIGtleSkgaW4gdGhpcy5fdmFsdWVzIH0sXG4gICAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3ZhbHVlcylcbiAgICAgICAgICAgIGYodGhpcy5fdmFsdWVzW2ldLCBpLnN1YnN0cigxKSk7XG4gICAgfSxcbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3ZhbHVlcylcbiAgICAgICAgICAgIHJldC5wdXNoKGYodGhpcy5fdmFsdWVzW2ldLCBpLnN1YnN0cigxKSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIERFRk5PREUodHlwZSwgcHJvcHMsIG1ldGhvZHMsIGJhc2UpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGJhc2UgPSBBU1RfTm9kZTtcbiAgICBpZiAoIXByb3BzKSBwcm9wcyA9IFtdO1xuICAgIGVsc2UgcHJvcHMgPSBwcm9wcy5zcGxpdCgvXFxzKy8pO1xuICAgIHZhciBzZWxmX3Byb3BzID0gcHJvcHM7XG4gICAgaWYgKGJhc2UgJiYgYmFzZS5QUk9QUylcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQoYmFzZS5QUk9QUyk7XG4gICAgdmFyIGNvZGUgPSBcInJldHVybiBmdW5jdGlvbiBBU1RfXCIgKyB0eXBlICsgXCIocHJvcHMpeyBpZiAocHJvcHMpIHsgXCI7XG4gICAgZm9yICh2YXIgaSA9IHByb3BzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGNvZGUgKz0gXCJ0aGlzLlwiICsgcHJvcHNbaV0gKyBcIiA9IHByb3BzLlwiICsgcHJvcHNbaV0gKyBcIjtcIjtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gYmFzZSAmJiBuZXcgYmFzZTtcbiAgICBpZiAocHJvdG8gJiYgcHJvdG8uaW5pdGlhbGl6ZSB8fCAobWV0aG9kcyAmJiBtZXRob2RzLmluaXRpYWxpemUpKVxuICAgICAgICBjb2RlICs9IFwidGhpcy5pbml0aWFsaXplKCk7XCI7XG4gICAgY29kZSArPSBcIn19XCI7XG4gICAgdmFyIGN0b3IgPSBuZXcgRnVuY3Rpb24oY29kZSkoKTtcbiAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgY3Rvci5CQVNFID0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGJhc2UpIGJhc2UuU1VCQ0xBU1NFUy5wdXNoKGN0b3IpO1xuICAgIGN0b3IucHJvdG90eXBlLkNUT1IgPSBjdG9yO1xuICAgIGN0b3IuUFJPUFMgPSBwcm9wcyB8fCBudWxsO1xuICAgIGN0b3IuU0VMRl9QUk9QUyA9IHNlbGZfcHJvcHM7XG4gICAgY3Rvci5TVUJDTEFTU0VTID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUuVFlQRSA9IGN0b3IuVFlQRSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChtZXRob2RzKSBmb3IgKGkgaW4gbWV0aG9kcykgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKC9eXFwkLy50ZXN0KGkpKSB7XG4gICAgICAgICAgICBjdG9yW2kuc3Vic3RyKDEpXSA9IG1ldGhvZHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVtpXSA9IG1ldGhvZHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3Rvci5ERUZNRVRIT0QgPSBmdW5jdGlvbihuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbiAgICByZXR1cm4gY3Rvcjtcbn07XG5cbnZhciBBU1RfVG9rZW4gPSBERUZOT0RFKFwiVG9rZW5cIiwgXCJ0eXBlIHZhbHVlIGxpbmUgY29sIHBvcyBlbmRwb3MgbmxiIGNvbW1lbnRzX2JlZm9yZSBmaWxlXCIsIHtcbn0sIG51bGwpO1xuXG52YXIgQVNUX05vZGUgPSBERUZOT0RFKFwiTm9kZVwiLCBcInN0YXJ0IGVuZFwiLCB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ1RPUih0aGlzKTtcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3Mgb2YgYWxsIEFTVCBub2Rlc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHN0YXJ0OiBcIltBU1RfVG9rZW5dIFRoZSBmaXJzdCB0b2tlbiBvZiB0aGlzIG5vZGVcIixcbiAgICAgICAgZW5kOiBcIltBU1RfVG9rZW5dIFRoZSBsYXN0IHRva2VuIG9mIHRoaXMgbm9kZVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcyk7XG4gICAgfSxcbiAgICB3YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxrKHZpc2l0b3IpOyAvLyBub3Qgc3VyZSB0aGUgaW5kaXJlY3Rpb24gd2lsbCBiZSBhbnkgaGVscFxuICAgIH1cbn0sIG51bGwpO1xuXG5BU1RfTm9kZS53YXJuX2Z1bmN0aW9uID0gbnVsbDtcbkFTVF9Ob2RlLndhcm4gPSBmdW5jdGlvbih0eHQsIHByb3BzKSB7XG4gICAgaWYgKEFTVF9Ob2RlLndhcm5fZnVuY3Rpb24pXG4gICAgICAgIEFTVF9Ob2RlLndhcm5fZnVuY3Rpb24oc3RyaW5nX3RlbXBsYXRlKHR4dCwgcHJvcHMpKTtcbn07XG5cbi8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N0YXRlbWVudCA9IERFRk5PREUoXCJTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3Mgb2YgYWxsIHN0YXRlbWVudHNcIixcbn0pO1xuXG52YXIgQVNUX0RlYnVnZ2VyID0gREVGTk9ERShcIkRlYnVnZ2VyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZXByZXNlbnRzIGEgZGVidWdnZXIgc3RhdGVtZW50XCIsXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9EaXJlY3RpdmUgPSBERUZOT0RFKFwiRGlyZWN0aXZlXCIsIFwidmFsdWUgc2NvcGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlcHJlc2VudHMgYSBkaXJlY3RpdmUsIGxpa2UgXFxcInVzZSBzdHJpY3RcXFwiO1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gQVNUX1N0cmluZyEpXCIsXG4gICAgICAgIHNjb3BlOiBcIltBU1RfU2NvcGUvU10gVGhlIHNjb3BlIHRoYXQgdGhpcyBkaXJlY3RpdmUgYWZmZWN0c1wiXG4gICAgfSxcbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1NpbXBsZVN0YXRlbWVudCA9IERFRk5PREUoXCJTaW1wbGVTdGF0ZW1lbnRcIiwgXCJib2R5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHN0YXRlbWVudCBjb25zaXN0aW5nIG9mIGFuIGV4cHJlc3Npb24sIGkuZS4gYSA9IDEgKyAyXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYm9keTogXCJbQVNUX05vZGVdIGFuIGV4cHJlc3Npb24gbm9kZSAoc2hvdWxkIG5vdCBiZSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxuZnVuY3Rpb24gd2Fsa19ib2R5KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBpZiAobm9kZS5ib2R5IGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgfVxuICAgIGVsc2Ugbm9kZS5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RhdCl7XG4gICAgICAgIHN0YXQuX3dhbGsodmlzaXRvcik7XG4gICAgfSk7XG59O1xuXG52YXIgQVNUX0Jsb2NrID0gREVGTk9ERShcIkJsb2NrXCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBib2R5IG9mIHN0YXRlbWVudHMgKHVzdWFsbHkgYnJhY2tldGVkKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnQqXSBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9CbG9ja1N0YXRlbWVudCA9IERFRk5PREUoXCJCbG9ja1N0YXRlbWVudFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBibG9jayBzdGF0ZW1lbnRcIixcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRW1wdHlTdGF0ZW1lbnQgPSBERUZOT0RFKFwiRW1wdHlTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBlbXB0eSBzdGF0ZW1lbnQgKGVtcHR5IGJsb2NrIG9yIHNpbXBseSBhIHNlbWljb2xvbilcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcyk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfU3RhdGVtZW50V2l0aEJvZHkgPSBERUZOT0RFKFwiU3RhdGVtZW50V2l0aEJvZHlcIiwgXCJib2R5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3RhdGVtZW50cyB0aGF0IGNvbnRhaW4gb25lIG5lc3RlZCBib2R5OiBgRm9yYCwgYEZvckluYCwgYERvYCwgYFdoaWxlYCwgYFdpdGhgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYm9keTogXCJbQVNUX1N0YXRlbWVudF0gdGhlIGJvZHk7IHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50LCBldmVuIGlmIGl0J3MgYW4gQVNUX0VtcHR5U3RhdGVtZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9MYWJlbGVkU3RhdGVtZW50ID0gREVGTk9ERShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgXCJsYWJlbFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3RhdGVtZW50IHdpdGggYSBsYWJlbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGxhYmVsOiBcIltBU1RfTGFiZWxdIGEgbGFiZWwgZGVmaW5pdGlvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubGFiZWwuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSk7XG5cbnZhciBBU1RfSXRlcmF0aW9uU3RhdGVtZW50ID0gREVGTk9ERShcIkl0ZXJhdGlvblN0YXRlbWVudFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiSW50ZXJuYWwgY2xhc3MuICBBbGwgbG9vcHMgaW5oZXJpdCBmcm9tIGl0LlwiXG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0RXTG9vcCA9IERFRk5PREUoXCJEV0xvb3BcIiwgXCJjb25kaXRpb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGRvL3doaWxlIHN0YXRlbWVudHNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgbG9vcCBjb25kaXRpb24uICBTaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9EbyA9IERFRk5PREUoXCJEb1wiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZG9gIHN0YXRlbWVudFwiLFxufSwgQVNUX0RXTG9vcCk7XG5cbnZhciBBU1RfV2hpbGUgPSBERUZOT0RFKFwiV2hpbGVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHdoaWxlYCBzdGF0ZW1lbnRcIixcbn0sIEFTVF9EV0xvb3ApO1xuXG52YXIgQVNUX0ZvciA9IERFRk5PREUoXCJGb3JcIiwgXCJpbml0IGNvbmRpdGlvbiBzdGVwXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmb3JgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGluaXQ6IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIGluaXRpYWxpemF0aW9uIGNvZGUsIG9yIG51bGwgaWYgZW1wdHlcIixcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCB0ZXJtaW5hdGlvbiBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcIixcbiAgICAgICAgc3RlcDogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdXBkYXRlIGNsYXVzZSwgb3IgbnVsbCBpZiBlbXB0eVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikgdGhpcy5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwKSB0aGlzLnN0ZXAuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX0ZvckluID0gREVGTk9ERShcIkZvckluXCIsIFwiaW5pdCBuYW1lIG9iamVjdFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yIC4uLiBpbmAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgaW5pdDogXCJbQVNUX05vZGVdIHRoZSBgZm9yL2luYCBpbml0aWFsaXphdGlvbiBjb2RlXCIsXG4gICAgICAgIG5hbWU6IFwiW0FTVF9TeW1ib2xSZWY/XSB0aGUgbG9vcCB2YXJpYWJsZSwgb25seSBpZiBgaW5pdGAgaXMgQVNUX1ZhclwiLFxuICAgICAgICBvYmplY3Q6IFwiW0FTVF9Ob2RlXSB0aGUgb2JqZWN0IHRoYXQgd2UncmUgbG9vcGluZyB0aHJvdWdoXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1dpdGggPSBERUZOT0RFKFwiV2l0aFwiLCBcImV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHdpdGhgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHdpdGhgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSk7XG5cbi8qIC0tLS0tWyBzY29wZSBhbmQgZnVuY3Rpb25zIF0tLS0tLSAqL1xuXG52YXIgQVNUX1Njb3BlID0gREVGTk9ERShcIlNjb3BlXCIsIFwiZGlyZWN0aXZlcyB2YXJpYWJsZXMgZnVuY3Rpb25zIHVzZXNfd2l0aCB1c2VzX2V2YWwgcGFyZW50X3Njb3BlIGVuY2xvc2VkIGNuYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3RhdGVtZW50cyBpbnRyb2R1Y2luZyBhIGxleGljYWwgc2NvcGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkaXJlY3RpdmVzOiBcIltzdHJpbmcqL1NdIGFuIGFycmF5IG9mIGRpcmVjdGl2ZXMgZGVjbGFyZWQgaW4gdGhpcyBzY29wZVwiLFxuICAgICAgICB2YXJpYWJsZXM6IFwiW09iamVjdC9TXSBhIG1hcCBvZiBuYW1lIC0+IFN5bWJvbERlZiBmb3IgYWxsIHZhcmlhYmxlcy9mdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlXCIsXG4gICAgICAgIGZ1bmN0aW9uczogXCJbT2JqZWN0L1NdIGxpa2UgYHZhcmlhYmxlc2AsIGJ1dCBvbmx5IGxpc3RzIGZ1bmN0aW9uIGRlY2xhcmF0aW9uc1wiLFxuICAgICAgICB1c2VzX3dpdGg6IFwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIHNjb3BlIHVzZXMgdGhlIGB3aXRoYCBzdGF0ZW1lbnRcIixcbiAgICAgICAgdXNlc19ldmFsOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSBjb250YWlucyBhIGRpcmVjdCBjYWxsIHRvIHRoZSBnbG9iYWwgYGV2YWxgXCIsXG4gICAgICAgIHBhcmVudF9zY29wZTogXCJbQVNUX1Njb3BlPy9TXSBsaW5rIHRvIHRoZSBwYXJlbnQgc2NvcGVcIixcbiAgICAgICAgZW5jbG9zZWQ6IFwiW1N5bWJvbERlZiovU10gYSBsaXN0IG9mIGFsbCBzeW1ib2wgZGVmaW5pdGlvbnMgdGhhdCBhcmUgYWNjZXNzZWQgZnJvbSB0aGlzIHNjb3BlIG9yIGFueSBzdWJzY29wZXNcIixcbiAgICAgICAgY25hbWU6IFwiW2ludGVnZXIvU10gY3VycmVudCBpbmRleCBmb3IgbWFuZ2xpbmcgdmFyaWFibGVzICh1c2VkIGludGVybmFsbHkgYnkgdGhlIG1hbmdsZXIpXCIsXG4gICAgfSxcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfVG9wbGV2ZWwgPSBERUZOT0RFKFwiVG9wbGV2ZWxcIiwgXCJnbG9iYWxzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgdG9wbGV2ZWwgc2NvcGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBnbG9iYWxzOiBcIltPYmplY3QvU10gYSBtYXAgb2YgbmFtZSAtPiBTeW1ib2xEZWYgZm9yIGFsbCB1bmRlY2xhcmVkIG5hbWVzXCIsXG4gICAgfSxcbiAgICB3cmFwX2VuY2xvc2U6IGZ1bmN0aW9uKGFyZ19wYXJhbWV0ZXJfcGFpcnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuXG4gICAgICAgIGFyZ19wYXJhbWV0ZXJfcGFpcnMuZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBwYWlyLnNwbGl0KFwiOlwiKTtcblxuICAgICAgICAgICAgYXJncy5wdXNoKHNwbGl0WzBdKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChzcGxpdFsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3cmFwcGVkX3RsID0gXCIoZnVuY3Rpb24oXCIgKyBwYXJhbWV0ZXJzLmpvaW4oXCIsXCIpICsgXCIpeyAnJE9SSUcnOyB9KShcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgICAgd3JhcHBlZF90bCA9IHBhcnNlKHdyYXBwZWRfdGwpO1xuICAgICAgICB3cmFwcGVkX3RsID0gd3JhcHBlZF90bC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbiBiZWZvcmUobm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUgJiYgbm9kZS52YWx1ZSA9PSBcIiRPUklHXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShzZWxmLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkX3RsO1xuICAgIH0sXG4gICAgd3JhcF9jb21tb25qczogZnVuY3Rpb24obmFtZSwgZXhwb3J0X2FsbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB0b19leHBvcnQgPSBbXTtcbiAgICAgICAgaWYgKGV4cG9ydF9hbGwpIHtcbiAgICAgICAgICAgIHNlbGYuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICAgICAgc2VsZi53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uICYmIG5vZGUuZGVmaW5pdGlvbigpLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmRfaWYoZnVuY3Rpb24obil7IHJldHVybiBuLm5hbWUgPT0gbm9kZS5uYW1lIH0sIHRvX2V4cG9ydCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b19leHBvcnQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZWRfdGwgPSBcIihmdW5jdGlvbihleHBvcnRzLCBnbG9iYWwpeyBnbG9iYWxbJ1wiICsgbmFtZSArIFwiJ10gPSBleHBvcnRzOyAnJE9SSUcnOyAnJEVYUE9SVFMnOyB9KHt9LCAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSkpKVwiO1xuICAgICAgICB3cmFwcGVkX3RsID0gcGFyc2Uod3JhcHBlZF90bCk7XG4gICAgICAgIHdyYXBwZWRfdGwgPSB3cmFwcGVkX3RsLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uIGJlZm9yZShub2RlKXtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSBzd2l0Y2ggKG5vZGUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIiRPUklHXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKHNlbGYuYm9keSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiJEVYUE9SVFNcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdG9fZXhwb3J0LmZvckVhY2goZnVuY3Rpb24oc3ltKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucHVzaChuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXcgQVNUX1N1Yih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBuZXcgQVNUX1N5bWJvbFJlZih7IG5hbWU6IFwiZXhwb3J0c1wiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG5ldyBBU1RfU3RyaW5nKHsgdmFsdWU6IHN5bS5uYW1lIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3IEFTVF9TeW1ib2xSZWYoc3ltKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gd3JhcHBlZF90bDtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0xhbWJkYSA9IERFRk5PREUoXCJMYW1iZGFcIiwgXCJuYW1lIGFyZ25hbWVzIHVzZXNfYXJndW1lbnRzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sRGVjbGFyYXRpb24/XSB0aGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uXCIsXG4gICAgICAgIGFyZ25hbWVzOiBcIltBU1RfU3ltYm9sRnVuYXJnKl0gYXJyYXkgb2YgZnVuY3Rpb24gYXJndW1lbnRzXCIsXG4gICAgICAgIHVzZXNfYXJndW1lbnRzOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBmdW5jdGlvbiBhY2Nlc3NlcyB0aGUgYXJndW1lbnRzIGFycmF5XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSkgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAgICAgYXJnLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TY29wZSk7XG5cbnZhciBBU1RfQWNjZXNzb3IgPSBERUZOT0RFKFwiQWNjZXNzb3JcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2V0dGVyL2dldHRlciBmdW5jdGlvbi4gIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgYWx3YXlzIG51bGwuXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0Z1bmN0aW9uID0gREVGTk9ERShcIkZ1bmN0aW9uXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGV4cHJlc3Npb25cIlxufSwgQVNUX0xhbWJkYSk7XG5cbnZhciBBU1RfRGVmdW4gPSBERUZOT0RFKFwiRGVmdW5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZnVuY3Rpb24gZGVmaW5pdGlvblwiXG59LCBBU1RfTGFtYmRhKTtcblxuLyogLS0tLS1bIEpVTVBTIF0tLS0tLSAqL1xuXG52YXIgQVNUX0p1bXAgPSBERUZOT0RFKFwiSnVtcFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3Ig4oCcanVtcHPigJ0gKGZvciBub3cgdGhhdCdzIGByZXR1cm5gLCBgdGhyb3dgLCBgYnJlYWtgIGFuZCBgY29udGludWVgKVwiXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9FeGl0ID0gREVGTk9ERShcIkV4aXRcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3Ig4oCcZXhpdHPigJ0gKGByZXR1cm5gIGFuZCBgdGhyb3dgKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltBU1RfTm9kZT9dIHRoZSB2YWx1ZSByZXR1cm5lZCBvciB0aHJvd24gYnkgdGhpcyBzdGF0ZW1lbnQ7IGNvdWxkIGJlIG51bGwgZm9yIEFTVF9SZXR1cm5cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIHRoaXMudmFsdWUgJiYgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9KdW1wKTtcblxudmFyIEFTVF9SZXR1cm4gPSBERUZOT0RFKFwiUmV0dXJuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGByZXR1cm5gIHN0YXRlbWVudFwiXG59LCBBU1RfRXhpdCk7XG5cbnZhciBBU1RfVGhyb3cgPSBERUZOT0RFKFwiVGhyb3dcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHRocm93YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0V4aXQpO1xuXG52YXIgQVNUX0xvb3BDb250cm9sID0gREVGTk9ERShcIkxvb3BDb250cm9sXCIsIFwibGFiZWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGxvb3AgY29udHJvbCBzdGF0ZW1lbnRzIChgYnJlYWtgIGFuZCBgY29udGludWVgKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGxhYmVsOiBcIltBU1RfTGFiZWxSZWY/XSB0aGUgbGFiZWwsIG9yIG51bGwgaWYgbm9uZVwiLFxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIHRoaXMubGFiZWwgJiYgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubGFiZWwuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9KdW1wKTtcblxudmFyIEFTVF9CcmVhayA9IERFRk5PREUoXCJCcmVha1wiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgYnJlYWtgIHN0YXRlbWVudFwiXG59LCBBU1RfTG9vcENvbnRyb2wpO1xuXG52YXIgQVNUX0NvbnRpbnVlID0gREVGTk9ERShcIkNvbnRpbnVlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjb250aW51ZWAgc3RhdGVtZW50XCJcbn0sIEFTVF9Mb29wQ29udHJvbCk7XG5cbi8qIC0tLS0tWyBJRiBdLS0tLS0gKi9cblxudmFyIEFTVF9JZiA9IERFRk5PREUoXCJJZlwiLCBcImNvbmRpdGlvbiBhbHRlcm5hdGl2ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgaWZgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGVdIHRoZSBgaWZgIGNvbmRpdGlvblwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJbQVNUX1N0YXRlbWVudD9dIHRoZSBgZWxzZWAgcGFydCwgb3IgbnVsbCBpZiBub3QgcHJlc2VudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRpdmUpIHRoaXMuYWx0ZXJuYXRpdmUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSk7XG5cbi8qIC0tLS0tWyBTV0lUQ0ggXS0tLS0tICovXG5cbnZhciBBU1RfU3dpdGNoID0gREVGTk9ERShcIlN3aXRjaFwiLCBcImV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHN3aXRjaGAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSBgc3dpdGNoYCDigJxkaXNjcmltaW5hbnTigJ1cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfU3dpdGNoQnJhbmNoID0gREVGTk9ERShcIlN3aXRjaEJyYW5jaFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYHN3aXRjaGAgYnJhbmNoZXNcIixcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRGVmYXVsdCA9IERFRk5PREUoXCJEZWZhdWx0XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBkZWZhdWx0YCBzd2l0Y2ggYnJhbmNoXCIsXG59LCBBU1RfU3dpdGNoQnJhbmNoKTtcblxudmFyIEFTVF9DYXNlID0gREVGTk9ERShcIkNhc2VcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjYXNlYCBzd2l0Y2ggYnJhbmNoXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSBgY2FzZWAgZXhwcmVzc2lvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbi8qIC0tLS0tWyBFWENFUFRJT05TIF0tLS0tLSAqL1xuXG52YXIgQVNUX1RyeSA9IERFRk5PREUoXCJUcnlcIiwgXCJiY2F0Y2ggYmZpbmFsbHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHRyeWAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYmNhdGNoOiBcIltBU1RfQ2F0Y2g/XSB0aGUgY2F0Y2ggYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIixcbiAgICAgICAgYmZpbmFsbHk6IFwiW0FTVF9GaW5hbGx5P10gdGhlIGZpbmFsbHkgYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5iY2F0Y2gpIHRoaXMuYmNhdGNoLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmZpbmFsbHkpIHRoaXMuYmZpbmFsbHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9CbG9jayk7XG5cbi8vIFhYWDogdGhpcyBpcyB3cm9uZyBhY2NvcmRpbmcgdG8gRUNNQS0yNjIgKDEyLjQpLiAgdGhlIGNhdGNoIGJsb2NrXG4vLyBzaG91bGQgaW50cm9kdWNlIGFub3RoZXIgc2NvcGUsIGFzIHRoZSBhcmduYW1lIHNob3VsZCBiZSB2aXNpYmxlXG4vLyBvbmx5IGluc2lkZSB0aGUgY2F0Y2ggYmxvY2suICBIb3dldmVyLCBkb2luZyBpdCB0aGlzIHdheSBiZWNhdXNlIG9mXG4vLyBJRSB3aGljaCBzaW1wbHkgaW50cm9kdWNlcyB0aGUgbmFtZSBpbiB0aGUgc3Vycm91bmRpbmcgc2NvcGUuICBJZlxuLy8gd2UgZXZlciB3YW50IHRvIGZpeCB0aGlzIHRoZW4gQVNUX0NhdGNoIHNob3VsZCBpbmhlcml0IGZyb21cbi8vIEFTVF9TY29wZS5cbnZhciBBU1RfQ2F0Y2ggPSBERUZOT0RFKFwiQ2F0Y2hcIiwgXCJhcmduYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjYXRjaGAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYXJnbmFtZTogXCJbQVNUX1N5bWJvbENhdGNoXSBzeW1ib2wgZm9yIHRoZSBleGNlcHRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmFyZ25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRmluYWxseSA9IERFRk5PREUoXCJGaW5hbGx5XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmaW5hbGx5YCBub2RlOyBvbmx5IG1ha2VzIHNlbnNlIGFzIHBhcnQgb2YgYSBgdHJ5YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0Jsb2NrKTtcblxuLyogLS0tLS1bIFZBUi9DT05TVCBdLS0tLS0gKi9cblxudmFyIEFTVF9EZWZpbml0aW9ucyA9IERFRk5PREUoXCJEZWZpbml0aW9uc1wiLCBcImRlZmluaXRpb25zXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBgdmFyYCBvciBgY29uc3RgIG5vZGVzICh2YXJpYWJsZSBkZWNsYXJhdGlvbnMvaW5pdGlhbGl6YXRpb25zKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGRlZmluaXRpb25zOiBcIltBU1RfVmFyRGVmKl0gYXJyYXkgb2YgdmFyaWFibGUgZGVmaW5pdGlvbnNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICBkZWYuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfVmFyID0gREVGTk9ERShcIlZhclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgdmFyYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0RlZmluaXRpb25zKTtcblxudmFyIEFTVF9Db25zdCA9IERFRk5PREUoXCJDb25zdFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29uc3RgIHN0YXRlbWVudFwiXG59LCBBU1RfRGVmaW5pdGlvbnMpO1xuXG52YXIgQVNUX1ZhckRlZiA9IERFRk5PREUoXCJWYXJEZWZcIiwgXCJuYW1lIHZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHZhcmlhYmxlIGRlY2xhcmF0aW9uOyBvbmx5IGFwcGVhcnMgaW4gYSBBU1RfRGVmaW5pdGlvbnMgbm9kZVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIG5hbWU6IFwiW0FTVF9TeW1ib2xWYXJ8QVNUX1N5bWJvbENvbnN0XSBuYW1lIG9mIHRoZSB2YXJpYWJsZVwiLFxuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGU/XSBpbml0aWFsaXplciwgb3IgbnVsbCBvZiB0aGVyZSdzIG5vIGluaXRpYWxpemVyXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKiAtLS0tLVsgT1RIRVIgXS0tLS0tICovXG5cbnZhciBBU1RfQ2FsbCA9IERFRk5PREUoXCJDYWxsXCIsIFwiZXhwcmVzc2lvbiBhcmdzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGNhbGwgZXhwcmVzc2lvblwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSBleHByZXNzaW9uIHRvIGludm9rZSBhcyBmdW5jdGlvblwiLFxuICAgICAgICBhcmdzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGFyZ3VtZW50c1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAgICAgYXJnLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX05ldyA9IERFRk5PREUoXCJOZXdcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBpbnN0YW50aWF0aW9uLiAgRGVyaXZlcyBmcm9tIGEgZnVuY3Rpb24gY2FsbCBzaW5jZSBpdCBoYXMgZXhhY3RseSB0aGUgc2FtZSBwcm9wZXJ0aWVzXCJcbn0sIEFTVF9DYWxsKTtcblxudmFyIEFTVF9TZXEgPSBERUZOT0RFKFwiU2VxXCIsIFwiY2FyIGNkclwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzZXF1ZW5jZSBleHByZXNzaW9uICh0d28gY29tbWEtc2VwYXJhdGVkIGV4cHJlc3Npb25zKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGNhcjogXCJbQVNUX05vZGVdIGZpcnN0IGVsZW1lbnQgaW4gc2VxdWVuY2VcIixcbiAgICAgICAgY2RyOiBcIltBU1RfTm9kZV0gc2Vjb25kIGVsZW1lbnQgaW4gc2VxdWVuY2VcIlxuICAgIH0sXG4gICAgJGNvbnM6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHNlcSA9IG5ldyBBU1RfU2VxKHgpO1xuICAgICAgICBzZXEuY2FyID0geDtcbiAgICAgICAgc2VxLmNkciA9IHk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfSxcbiAgICAkZnJvbV9hcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PSAxKSByZXR1cm4gYXJyYXlbMF0uY2xvbmUoKTtcbiAgICAgICAgdmFyIGxpc3QgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIGxpc3QgPSBBU1RfU2VxLmNvbnMoYXJyYXlbaV0sIGxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbGlzdDtcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGlmIChwLmNkciAmJiAhcC5jZHIuY2RyKSB7XG4gICAgICAgICAgICAgICAgcC5jZHIgPSBwLmNkci5jYXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5jZHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSxcbiAgICB0b19hcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcywgYSA9IFtdO1xuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgYS5wdXNoKHAuY2FyKTtcbiAgICAgICAgICAgIGlmIChwLmNkciAmJiAhKHAuY2RyIGluc3RhbmNlb2YgQVNUX1NlcSkpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2gocC5jZHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBwID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGlmICghKHAuY2RyIGluc3RhbmNlb2YgQVNUX1NlcSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IEFTVF9TZXEuY29ucyhwLmNkciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuY2RyID0gY2VsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLmNkcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNhci5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNkcikgdGhpcy5jZHIuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX1Byb3BBY2Nlc3MgPSBERUZOT0RFKFwiUHJvcEFjY2Vzc1wiLCBcImV4cHJlc3Npb24gcHJvcGVydHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIHByb3BlcnR5IGFjY2VzcyBleHByZXNzaW9ucywgaS5lLiBgYS5mb29gIG9yIGBhW1xcXCJmb29cXFwiXWBcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIOKAnGNvbnRhaW5lcuKAnSBleHByZXNzaW9uXCIsXG4gICAgICAgIHByb3BlcnR5OiBcIltBU1RfTm9kZXxzdHJpbmddIHRoZSBwcm9wZXJ0eSB0byBhY2Nlc3MuICBGb3IgQVNUX0RvdCB0aGlzIGlzIGFsd2F5cyBhIHBsYWluIHN0cmluZywgd2hpbGUgZm9yIEFTVF9TdWIgaXQncyBhbiBhcmJpdHJhcnkgQVNUX05vZGVcIlxuICAgIH1cbn0pO1xuXG52YXIgQVNUX0RvdCA9IERFRk5PREUoXCJEb3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZG90dGVkIHByb3BlcnR5IGFjY2VzcyBleHByZXNzaW9uXCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9TdWIgPSBERUZOT0RFKFwiU3ViXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJJbmRleC1zdHlsZSBwcm9wZXJ0eSBhY2Nlc3MsIGkuZS4gYGFbXFxcImZvb1xcXCJdYFwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1Byb3BBY2Nlc3MpO1xuXG52YXIgQVNUX1VuYXJ5ID0gREVGTk9ERShcIlVuYXJ5XCIsIFwib3BlcmF0b3IgZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgdW5hcnkgZXhwcmVzc2lvbnNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBvcGVyYXRvcjogXCJbc3RyaW5nXSB0aGUgb3BlcmF0b3JcIixcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIGV4cHJlc3Npb24gdGhhdCB0aGlzIHVuYXJ5IG9wZXJhdG9yIGFwcGxpZXMgdG9cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX1VuYXJ5UHJlZml4ID0gREVGTk9ERShcIlVuYXJ5UHJlZml4XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJVbmFyeSBwcmVmaXggZXhwcmVzc2lvbiwgaS5lLiBgdHlwZW9mIGlgIG9yIGArK2lgXCJcbn0sIEFTVF9VbmFyeSk7XG5cbnZhciBBU1RfVW5hcnlQb3N0Zml4ID0gREVGTk9ERShcIlVuYXJ5UG9zdGZpeFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVW5hcnkgcG9zdGZpeCBleHByZXNzaW9uLCBpLmUuIGBpKytgXCJcbn0sIEFTVF9VbmFyeSk7XG5cbnZhciBBU1RfQmluYXJ5ID0gREVGTk9ERShcIkJpbmFyeVwiLCBcImxlZnQgb3BlcmF0b3IgcmlnaHRcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJpbmFyeSBleHByZXNzaW9uLCBpLmUuIGBhICsgYmBcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsZWZ0OiBcIltBU1RfTm9kZV0gbGVmdC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiLFxuICAgICAgICBvcGVyYXRvcjogXCJbc3RyaW5nXSB0aGUgb3BlcmF0b3JcIixcbiAgICAgICAgcmlnaHQ6IFwiW0FTVF9Ob2RlXSByaWdodC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubGVmdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucmlnaHQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX0NvbmRpdGlvbmFsID0gREVGTk9ERShcIkNvbmRpdGlvbmFsXCIsIFwiY29uZGl0aW9uIGNvbnNlcXVlbnQgYWx0ZXJuYXRpdmVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gdXNpbmcgdGhlIHRlcm5hcnkgb3BlcmF0b3IsIGkuZS4gYGEgPyBiIDogY2BcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXVwiLFxuICAgICAgICBjb25zZXF1ZW50OiBcIltBU1RfTm9kZV1cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiW0FTVF9Ob2RlXVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBBU1RfQXNzaWduID0gREVGTk9ERShcIkFzc2lnblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYXNzaWdubWVudCBleHByZXNzaW9uIOKAlCBgYSA9IGIgKyA1YFwiLFxufSwgQVNUX0JpbmFyeSk7XG5cbi8qIC0tLS0tWyBMSVRFUkFMUyBdLS0tLS0gKi9cblxudmFyIEFTVF9BcnJheSA9IERFRk5PREUoXCJBcnJheVwiLCBcImVsZW1lbnRzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBhcnJheSBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZWxlbWVudHM6IFwiW0FTVF9Ob2RlKl0gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgICAgICAgICAgICAgIGVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX09iamVjdCA9IERFRk5PREUoXCJPYmplY3RcIiwgXCJwcm9wZXJ0aWVzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3QgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHByb3BlcnRpZXM6IFwiW0FTVF9PYmplY3RQcm9wZXJ0eSpdIGFycmF5IG9mIHByb3BlcnRpZXNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgICAgICBwcm9wLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX09iamVjdFByb3BlcnR5ID0gREVGTk9ERShcIk9iamVjdFByb3BlcnR5XCIsIFwia2V5IHZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBsaXRlcmFsIG9iamVjdCBwcm9wZXJ0aWVzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAga2V5OiBcIltzdHJpbmddIHRoZSBwcm9wZXJ0eSBuYW1lIGNvbnZlcnRlZCB0byBhIHN0cmluZyBmb3IgT2JqZWN0S2V5VmFsLiAgRm9yIHNldHRlcnMgYW5kIGdldHRlcnMgdGhpcyBpcyBhbiBhcmJpdHJhcnkgQVNUX05vZGUuXCIsXG4gICAgICAgIHZhbHVlOiBcIltBU1RfTm9kZV0gcHJvcGVydHkgdmFsdWUuICBGb3Igc2V0dGVycyBhbmQgZ2V0dGVycyB0aGlzIGlzIGFuIEFTVF9GdW5jdGlvbi5cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3RLZXlWYWwgPSBERUZOT0RFKFwiT2JqZWN0S2V5VmFsXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGtleTogdmFsdWUgb2JqZWN0IHByb3BlcnR5XCIsXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX09iamVjdFNldHRlciA9IERFRk5PREUoXCJPYmplY3RTZXR0ZXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBzZXR0ZXIgcHJvcGVydHlcIixcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfT2JqZWN0R2V0dGVyID0gREVGTk9ERShcIk9iamVjdEdldHRlclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGdldHRlciBwcm9wZXJ0eVwiLFxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9TeW1ib2wgPSBERUZOT0RFKFwiU3ltYm9sXCIsIFwic2NvcGUgbmFtZSB0aGVkZWZcIiwge1xuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIG5hbWU6IFwiW3N0cmluZ10gbmFtZSBvZiB0aGlzIHN5bWJvbFwiLFxuICAgICAgICBzY29wZTogXCJbQVNUX1Njb3BlL1NdIHRoZSBjdXJyZW50IHNjb3BlIChub3QgbmVjZXNzYXJpbHkgdGhlIGRlZmluaXRpb24gc2NvcGUpXCIsXG4gICAgICAgIHRoZWRlZjogXCJbU3ltYm9sRGVmL1NdIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgc3ltYm9sXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGFsbCBzeW1ib2xzXCIsXG59KTtcblxudmFyIEFTVF9TeW1ib2xBY2Nlc3NvciA9IERFRk5PREUoXCJTeW1ib2xBY2Nlc3NvclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIG5hbWUgb2YgYSBwcm9wZXJ0eSBhY2Nlc3NvciAoc2V0dGVyL2dldHRlciBmdW5jdGlvbilcIlxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sRGVjbGFyYXRpb24gPSBERUZOT0RFKFwiU3ltYm9sRGVjbGFyYXRpb25cIiwgXCJpbml0XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRlY2xhcmF0aW9uIHN5bWJvbCAoc3ltYm9sIGluIHZhci9jb25zdCwgZnVuY3Rpb24gbmFtZSBvciBhcmd1bWVudCwgc3ltYm9sIGluIGNhdGNoKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGluaXQ6IFwiW0FTVF9Ob2RlKi9TXSBhcnJheSBvZiBpbml0aWFsaXplcnMgZm9yIHRoaXMgZGVjbGFyYXRpb24uXCJcbiAgICB9XG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xWYXIgPSBERUZOT0RFKFwiU3ltYm9sVmFyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSB2YXJpYWJsZVwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xDb25zdCA9IERFRk5PREUoXCJTeW1ib2xDb25zdFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjb25zdGFudCBkZWNsYXJhdGlvblwiXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbEZ1bmFyZyA9IERFRk5PREUoXCJTeW1ib2xGdW5hcmdcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBmdW5jdGlvbiBhcmd1bWVudFwiLFxufSwgQVNUX1N5bWJvbFZhcik7XG5cbnZhciBBU1RfU3ltYm9sRGVmdW4gPSBERUZOT0RFKFwiU3ltYm9sRGVmdW5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBkZWZpbmluZyBhIGZ1bmN0aW9uXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbExhbWJkYSA9IERFRk5PREUoXCJTeW1ib2xMYW1iZGFcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBmdW5jdGlvbiBleHByZXNzaW9uXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbENhdGNoID0gREVGTk9ERShcIlN5bWJvbENhdGNoXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIHRoZSBleGNlcHRpb24gaW4gY2F0Y2hcIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfTGFiZWwgPSBERUZOT0RFKFwiTGFiZWxcIiwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgbGFiZWwgKGRlY2xhcmF0aW9uKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHJlZmVyZW5jZXM6IFwiW0FTVF9Mb29wQ29udHJvbCpdIGEgbGlzdCBvZiBub2RlcyByZWZlcnJpbmcgdG8gdGhpcyBsYWJlbFwiXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgICAgIHRoaXMudGhlZGVmID0gdGhpcztcbiAgICB9XG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xSZWYgPSBERUZOT0RFKFwiU3ltYm9sUmVmXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZWZlcmVuY2UgdG8gc29tZSBzeW1ib2wgKG5vdCBkZWZpbml0aW9uL2RlY2xhcmF0aW9uKVwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfTGFiZWxSZWYgPSBERUZOT0RFKFwiTGFiZWxSZWZcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlZmVyZW5jZSB0byBhIGxhYmVsIHN5bWJvbFwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfVGhpcyA9IERFRk5PREUoXCJUaGlzXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHRoaXNgIHN5bWJvbFwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfQ29uc3RhbnQgPSBERUZOT0RFKFwiQ29uc3RhbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGFsbCBjb25zdGFudHNcIixcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX1N0cmluZyA9IERFRk5PREUoXCJTdHJpbmdcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdHJpbmcgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltzdHJpbmddIHRoZSBjb250ZW50cyBvZiB0aGlzIHN0cmluZ1wiXG4gICAgfVxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9OdW1iZXIgPSBERUZOT0RFKFwiTnVtYmVyXCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgbnVtYmVyIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbbnVtYmVyXSB0aGUgbnVtZXJpYyB2YWx1ZVwiXG4gICAgfVxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9SZWdFeHAgPSBERUZOT0RFKFwiUmVnRXhwXCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgcmVnZXhwIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbUmVnRXhwXSB0aGUgYWN0dWFsIHJlZ2V4cFwiXG4gICAgfVxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9BdG9tID0gREVGTk9ERShcIkF0b21cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGF0b21zXCIsXG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX051bGwgPSBERUZOT0RFKFwiTnVsbFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBudWxsYCBhdG9tXCIsXG4gICAgdmFsdWU6IG51bGxcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9OYU4gPSBERUZOT0RFKFwiTmFOXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgaW1wb3NzaWJsZSB2YWx1ZVwiLFxuICAgIHZhbHVlOiAwLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9VbmRlZmluZWQgPSBERUZOT0RFKFwiVW5kZWZpbmVkXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHVuZGVmaW5lZGAgdmFsdWVcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCl7fSgpKVxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0hvbGUgPSBERUZOT0RFKFwiSG9sZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBob2xlIGluIGFuIGFycmF5XCIsXG4gICAgdmFsdWU6IChmdW5jdGlvbigpe30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9JbmZpbml0eSA9IERFRk5PREUoXCJJbmZpbml0eVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBJbmZpbml0eWAgdmFsdWVcIixcbiAgICB2YWx1ZTogMS8wXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfQm9vbGVhbiA9IERFRk5PREUoXCJCb29sZWFuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBib29sZWFuc1wiLFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0ZhbHNlID0gREVGTk9ERShcIkZhbHNlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYGZhbHNlYCBhdG9tXCIsXG4gICAgdmFsdWU6IGZhbHNlXG59LCBBU1RfQm9vbGVhbik7XG5cbnZhciBBU1RfVHJ1ZSA9IERFRk5PREUoXCJUcnVlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHRydWVgIGF0b21cIixcbiAgICB2YWx1ZTogdHJ1ZVxufSwgQVNUX0Jvb2xlYW4pO1xuXG4vKiAtLS0tLVsgVHJlZVdhbGtlciBdLS0tLS0gKi9cblxuZnVuY3Rpb24gVHJlZVdhbGtlcihjYWxsYmFjaykge1xuICAgIHRoaXMudmlzaXQgPSBjYWxsYmFjaztcbiAgICB0aGlzLnN0YWNrID0gW107XG59O1xuVHJlZVdhbGtlci5wcm90b3R5cGUgPSB7XG4gICAgX3Zpc2l0OiBmdW5jdGlvbihub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMudmlzaXQobm9kZSwgZGVzY2VuZCA/IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XG4gICAgICAgIH0gOiBub29wKTtcbiAgICAgICAgaWYgKCFyZXQgJiYgZGVzY2VuZCkge1xuICAgICAgICAgICAgZGVzY2VuZC5jYWxsKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgIH0sXG4gICAgcHVzaDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICAgIH0sXG4gICAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfSxcbiAgICBzZWxmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9LFxuICAgIGZpbmRfcGFyZW50OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhc19kaXJlY3RpdmU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZF9wYXJlbnQoQVNUX1Njb3BlKS5oYXNfZGlyZWN0aXZlKHR5cGUpO1xuICAgIH0sXG4gICAgaW5fYm9vbGVhbl9jb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGgsIHNlbGYgPSBzdGFja1stLWldO1xuICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgIHZhciBwID0gc3RhY2tbLS1pXTtcbiAgICAgICAgICAgIGlmICgocCBpbnN0YW5jZW9mIEFTVF9JZiAgICAgICAgICAgJiYgcC5jb25kaXRpb24gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0RXTG9vcCAgICAgICAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Gb3IgICAgICAgICAgJiYgcC5jb25kaXRpb24gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXggICYmIHAub3BlcmF0b3IgPT0gXCIhXCIgJiYgcC5leHByZXNzaW9uID09PSBzZWxmKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiJiZcIiB8fCBwLm9wZXJhdG9yID09IFwifHxcIikpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYgPSBwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsb29wY29udHJvbF90YXJnZXQ6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIGlmIChsYWJlbCkgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCAmJiB4LmxhYmVsLm5hbWUgPT0gbGFiZWwubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2ggfHwgeCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgUGFyc2VyIGJhc2VkIG9uIHBhcnNlLWpzIChodHRwOi8vbWFyaWpuLmhhdmVyYmVrZS5ubC9wYXJzZS1qcy8pLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEtFWVdPUkRTID0gJ2JyZWFrIGNhc2UgY2F0Y2ggY29uc3QgY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkZWxldGUgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbiBpbnN0YW5jZW9mIG5ldyByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB0eXBlb2YgdmFyIHZvaWQgd2hpbGUgd2l0aCc7XG52YXIgS0VZV09SRFNfQVRPTSA9ICdmYWxzZSBudWxsIHRydWUnO1xudmFyIFJFU0VSVkVEX1dPUkRTID0gJ2Fic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRoaXMgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZSdcbiAgICArIFwiIFwiICsgS0VZV09SRFNfQVRPTSArIFwiIFwiICsgS0VZV09SRFM7XG52YXIgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSAncmV0dXJuIG5ldyBkZWxldGUgdGhyb3cgZWxzZSBjYXNlJztcblxuS0VZV09SRFMgPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTKTtcblJFU0VSVkVEX1dPUkRTID0gbWFrZVByZWRpY2F0ZShSRVNFUlZFRF9XT1JEUyk7XG5LRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04pO1xuS0VZV09SRFNfQVRPTSA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQVRPTSk7XG5cbnZhciBPUEVSQVRPUl9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIistKiYlPTw+IT98fl5cIikpO1xuXG52YXIgUkVfSEVYX05VTUJFUiA9IC9eMHhbMC05YS1mXSskL2k7XG52YXIgUkVfT0NUX05VTUJFUiA9IC9eMFswLTddKyQvO1xudmFyIFJFX0RFQ19OVU1CRVIgPSAvXlxcZCpcXC4/XFxkKig/OmVbKy1dP1xcZCooPzpcXGRcXC4/fFxcLj9cXGQpXFxkKik/JC9pO1xuXG52YXIgT1BFUkFUT1JTID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJpblwiLFxuICAgIFwiaW5zdGFuY2VvZlwiLFxuICAgIFwidHlwZW9mXCIsXG4gICAgXCJuZXdcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiKytcIixcbiAgICBcIi0tXCIsXG4gICAgXCIrXCIsXG4gICAgXCItXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCImXCIsXG4gICAgXCJ8XCIsXG4gICAgXCJeXCIsXG4gICAgXCIqXCIsXG4gICAgXCIvXCIsXG4gICAgXCIlXCIsXG4gICAgXCI+PlwiLFxuICAgIFwiPDxcIixcbiAgICBcIj4+PlwiLFxuICAgIFwiPFwiLFxuICAgIFwiPlwiLFxuICAgIFwiPD1cIixcbiAgICBcIj49XCIsXG4gICAgXCI9PVwiLFxuICAgIFwiPT09XCIsXG4gICAgXCIhPVwiLFxuICAgIFwiIT09XCIsXG4gICAgXCI/XCIsXG4gICAgXCI9XCIsXG4gICAgXCIrPVwiLFxuICAgIFwiLT1cIixcbiAgICBcIi89XCIsXG4gICAgXCIqPVwiLFxuICAgIFwiJT1cIixcbiAgICBcIj4+PVwiLFxuICAgIFwiPDw9XCIsXG4gICAgXCI+Pj49XCIsXG4gICAgXCJ8PVwiLFxuICAgIFwiXj1cIixcbiAgICBcIiY9XCIsXG4gICAgXCImJlwiLFxuICAgIFwifHxcIlxuXSk7XG5cbnZhciBXSElURVNQQUNFX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiIFxcdTAwYTBcXG5cXHJcXHRcXGZcXHUwMDBiXFx1MjAwYlxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFwiKSk7XG5cbnZhciBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiW3soLC47OlwiKSk7XG5cbnZhciBQVU5DX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiW117fSgpLDs6XCIpKTtcblxudmFyIFJFR0VYUF9NT0RJRklFUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJnbXNpeVwiKSk7XG5cbi8qIC0tLS0tWyBUb2tlbml6ZXIgXS0tLS0tICovXG5cbi8vIHJlZ2V4cHMgYWRhcHRlZCBmcm9tIGh0dHA6Ly94cmVnZXhwLmNvbS9wbHVnaW5zLyN1bmljb2RlXG52YXIgVU5JQ09ERSA9IHtcbiAgICBsZXR0ZXI6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDQxLVxcXFx1MDA1QVxcXFx1MDA2MS1cXFxcdTAwN0FcXFxcdTAwQUFcXFxcdTAwQjVcXFxcdTAwQkFcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MjNcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIxLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzFcXFxcdTA5NzJcXFxcdTA5N0ItXFxcXHUwOTdGXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzNcXFxcdTBDMzUtXFxcXHUwQzM5XFxcXHUwQzNEXFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwXFxcXHUwQzYxXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkRcXFxcdTBDREVcXFxcdTBDRTBcXFxcdTBDRTFcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEMjhcXFxcdTBEMkEtXFxcXHUwRDM5XFxcXHUwRDNEXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDXFxcXHUwRUREXFxcXHUwRjAwXFxcXHUwRjQwLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGODgtXFxcXHUwRjhCXFxcXHUxMDAwLVxcXFx1MTAyQVxcXFx1MTAzRlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNUEtXFxcXHUxMDVEXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZFLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOEVcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQ1xcXFx1MTEwMC1cXFxcdTExNTlcXFxcdTExNUYtXFxcXHUxMUEyXFxcXHUxMUE4LVxcXFx1MTFGOVxcXFx1MTIwMC1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjRcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3NlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOTAwLVxcXFx1MTkxQ1xcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBOVxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQjA1LVxcXFx1MUIzM1xcXFx1MUI0NS1cXFxcdTFCNEJcXFxcdTFCODMtXFxcXHUxQkEwXFxcXHUxQkFFXFxcXHUxQkFGXFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxRDAwLVxcXFx1MURCRlxcXFx1MUUwMC1cXFxcdTFGMTVcXFxcdTFGMTgtXFxcXHUxRjFEXFxcXHUxRjIwLVxcXFx1MUY0NVxcXFx1MUY0OC1cXFxcdTFGNERcXFxcdTFGNTAtXFxcXHUxRjU3XFxcXHUxRjU5XFxcXHUxRjVCXFxcXHUxRjVEXFxcXHUxRjVGLVxcXFx1MUY3RFxcXFx1MUY4MC1cXFxcdTFGQjRcXFxcdTFGQjYtXFxcXHUxRkJDXFxcXHUxRkJFXFxcXHUxRkMyLVxcXFx1MUZDNFxcXFx1MUZDNi1cXFxcdTFGQ0NcXFxcdTFGRDAtXFxcXHUxRkQzXFxcXHUxRkQ2LVxcXFx1MUZEQlxcXFx1MUZFMC1cXFxcdTFGRUNcXFxcdTFGRjItXFxcXHUxRkY0XFxcXHUxRkY2LVxcXFx1MUZGQ1xcXFx1MjA3MVxcXFx1MjA3RlxcXFx1MjA5MC1cXFxcdTIwOTRcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxODNcXFxcdTIxODRcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDNkZcXFxcdTJDNzEtXFxcXHUyQzdEXFxcXHUyQzgwLVxcXFx1MkNFNFxcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMzAtXFxcXHUyRDY1XFxcXHUyRDZGXFxcXHUyRDgwLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyRTJGXFxcXHUzMDA1XFxcXHUzMDA2XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzQlxcXFx1MzAzQ1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOUQtXFxcXHUzMDlGXFxcXHUzMEExLVxcXFx1MzBGQVxcXFx1MzBGQy1cXFxcdTMwRkZcXFxcdTMxMDUtXFxcXHUzMTJEXFxcXHUzMTMxLVxcXFx1MzE4RVxcXFx1MzFBMC1cXFxcdTMxQjdcXFxcdTMxRjAtXFxcXHUzMUZGXFxcXHUzNDAwXFxcXHU0REI1XFxcXHU0RTAwXFxcXHU5RkMzXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTUwMC1cXFxcdUE2MENcXFxcdUE2MTAtXFxcXHVBNjFGXFxcXHVBNjJBXFxcXHVBNjJCXFxcXHVBNjQwLVxcXFx1QTY1RlxcXFx1QTY2Mi1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjk3XFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEJcXFxcdUE3OENcXFxcdUE3RkItXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE5MEEtXFxcXHVBOTI1XFxcXHVBOTMwLVxcXFx1QTk0NlxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUMwMFxcXFx1RDdBM1xcXFx1RjkwMC1cXFxcdUZBMkRcXFxcdUZBMzAtXFxcXHVGQTZBXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFEXFxcXHVGQjFGLVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdXCIpLFxuICAgIG5vbl9zcGFjaW5nX21hcms6IG5ldyBSZWdFeHAoXCJbXFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MDQ4My1cXFxcdTA0ODdcXFxcdTA1OTEtXFxcXHUwNUJEXFxcXHUwNUJGXFxcXHUwNUMxXFxcXHUwNUMyXFxcXHUwNUM0XFxcXHUwNUM1XFxcXHUwNUM3XFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDY0Qi1cXFxcdTA2NUVcXFxcdTA2NzBcXFxcdTA2RDYtXFxcXHUwNkRDXFxcXHUwNkRGLVxcXFx1MDZFNFxcXFx1MDZFN1xcXFx1MDZFOFxcXFx1MDZFQS1cXFxcdTA2RURcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRBXFxcXHUwN0E2LVxcXFx1MDdCMFxcXFx1MDdFQi1cXFxcdTA3RjNcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFCLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJEXFxcXHUwOTAwLVxcXFx1MDkwMlxcXFx1MDkzQ1xcXFx1MDk0MS1cXFxcdTA5NDhcXFxcdTA5NERcXFxcdTA5NTEtXFxcXHUwOTU1XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxXFxcXHUwOUJDXFxcXHUwOUMxLVxcXFx1MDlDNFxcXFx1MDlDRFxcXFx1MDlFMlxcXFx1MDlFM1xcXFx1MEEwMVxcXFx1MEEwMlxcXFx1MEEzQ1xcXFx1MEE0MVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNzBcXFxcdTBBNzFcXFxcdTBBNzVcXFxcdTBBODFcXFxcdTBBODJcXFxcdTBBQkNcXFxcdTBBQzEtXFxcXHUwQUM1XFxcXHUwQUM3XFxcXHUwQUM4XFxcXHUwQUNEXFxcXHUwQUUyXFxcXHUwQUUzXFxcXHUwQjAxXFxcXHUwQjNDXFxcXHUwQjNGXFxcXHUwQjQxLVxcXFx1MEI0NFxcXFx1MEI0RFxcXFx1MEI1NlxcXFx1MEI2MlxcXFx1MEI2M1xcXFx1MEI4MlxcXFx1MEJDMFxcXFx1MEJDRFxcXFx1MEMzRS1cXFxcdTBDNDBcXFxcdTBDNDYtXFxcXHUwQzQ4XFxcXHUwQzRBLVxcXFx1MEM0RFxcXFx1MEM1NVxcXFx1MEM1NlxcXFx1MEM2MlxcXFx1MEM2M1xcXFx1MENCQ1xcXFx1MENCRlxcXFx1MENDNlxcXFx1MENDQ1xcXFx1MENDRFxcXFx1MENFMlxcXFx1MENFM1xcXFx1MEQ0MS1cXFxcdTBENDRcXFxcdTBENERcXFxcdTBENjJcXFxcdTBENjNcXFxcdTBEQ0FcXFxcdTBERDItXFxcXHUwREQ0XFxcXHUwREQ2XFxcXHUwRTMxXFxcXHUwRTM0LVxcXFx1MEUzQVxcXFx1MEU0Ny1cXFxcdTBFNEVcXFxcdTBFQjFcXFxcdTBFQjQtXFxcXHUwRUI5XFxcXHUwRUJCXFxcXHUwRUJDXFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEYxOFxcXFx1MEYxOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEY3MS1cXFxcdTBGN0VcXFxcdTBGODAtXFxcXHUwRjg0XFxcXHUwRjg2XFxcXHUwRjg3XFxcXHUwRjkwLVxcXFx1MEY5N1xcXFx1MEY5OS1cXFxcdTBGQkNcXFxcdTBGQzZcXFxcdTEwMkQtXFxcXHUxMDMwXFxcXHUxMDMyLVxcXFx1MTAzN1xcXFx1MTAzOVxcXFx1MTAzQVxcXFx1MTAzRFxcXFx1MTAzRVxcXFx1MTA1OFxcXFx1MTA1OVxcXFx1MTA1RS1cXFxcdTEwNjBcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyXFxcXHUxMDg1XFxcXHUxMDg2XFxcXHUxMDhEXFxcXHUxMDlEXFxcXHUxMzVGXFxcXHUxNzEyLVxcXFx1MTcxNFxcXFx1MTczMi1cXFxcdTE3MzRcXFxcdTE3NTJcXFxcdTE3NTNcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3QjctXFxcXHUxN0JEXFxcXHUxN0M2XFxcXHUxN0M5LVxcXFx1MTdEM1xcXFx1MTdERFxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4QTlcXFxcdTE5MjAtXFxcXHUxOTIyXFxcXHUxOTI3XFxcXHUxOTI4XFxcXHUxOTMyXFxcXHUxOTM5LVxcXFx1MTkzQlxcXFx1MUExN1xcXFx1MUExOFxcXFx1MUE1NlxcXFx1MUE1OC1cXFxcdTFBNUVcXFxcdTFBNjBcXFxcdTFBNjJcXFxcdTFBNjUtXFxcXHUxQTZDXFxcXHUxQTczLVxcXFx1MUE3Q1xcXFx1MUE3RlxcXFx1MUIwMC1cXFxcdTFCMDNcXFxcdTFCMzRcXFxcdTFCMzYtXFxcXHUxQjNBXFxcXHUxQjNDXFxcXHUxQjQyXFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MFxcXFx1MUI4MVxcXFx1MUJBMi1cXFxcdTFCQTVcXFxcdTFCQThcXFxcdTFCQTlcXFxcdTFDMkMtXFxcXHUxQzMzXFxcXHUxQzM2XFxcXHUxQzM3XFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRTBcXFxcdTFDRTItXFxcXHUxQ0U4XFxcXHUxQ0VEXFxcXHUxREMwLVxcXFx1MURFNlxcXFx1MURGRC1cXFxcdTFERkZcXFxcdTIwRDAtXFxcXHUyMERDXFxcXHUyMEUxXFxcXHUyMEU1LVxcXFx1MjBGMFxcXFx1MkNFRi1cXFxcdTJDRjFcXFxcdTJERTAtXFxcXHUyREZGXFxcXHUzMDJBLVxcXFx1MzAyRlxcXFx1MzA5OVxcXFx1MzA5QVxcXFx1QTY2RlxcXFx1QTY3Q1xcXFx1QTY3RFxcXFx1QTZGMFxcXFx1QTZGMVxcXFx1QTgwMlxcXFx1QTgwNlxcXFx1QTgwQlxcXFx1QTgyNVxcXFx1QTgyNlxcXFx1QThDNFxcXFx1QThFMC1cXFxcdUE4RjFcXFxcdUE5MjYtXFxcXHVBOTJEXFxcXHVBOTQ3LVxcXFx1QTk1MVxcXFx1QTk4MC1cXFxcdUE5ODJcXFxcdUE5QjNcXFxcdUE5QjYtXFxcXHVBOUI5XFxcXHVBOUJDXFxcXHVBQTI5LVxcXFx1QUEyRVxcXFx1QUEzMVxcXFx1QUEzMlxcXFx1QUEzNVxcXFx1QUEzNlxcXFx1QUE0M1xcXFx1QUE0Q1xcXFx1QUFCMFxcXFx1QUFCMi1cXFxcdUFBQjRcXFxcdUFBQjdcXFxcdUFBQjhcXFxcdUFBQkVcXFxcdUFBQkZcXFxcdUFBQzFcXFxcdUFCRTVcXFxcdUFCRThcXFxcdUFCRURcXFxcdUZCMUVcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyNl1cIiksXG4gICAgc3BhY2VfY29tYmluaW5nX21hcms6IG5ldyBSZWdFeHAoXCJbXFxcXHUwOTAzXFxcXHUwOTNFLVxcXFx1MDk0MFxcXFx1MDk0OS1cXFxcdTA5NENcXFxcdTA5NEVcXFxcdTA5ODJcXFxcdTA5ODNcXFxcdTA5QkUtXFxcXHUwOUMwXFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCXFxcXHUwOUNDXFxcXHUwOUQ3XFxcXHUwQTAzXFxcXHUwQTNFLVxcXFx1MEE0MFxcXFx1MEE4M1xcXFx1MEFCRS1cXFxcdTBBQzBcXFxcdTBBQzlcXFxcdTBBQ0JcXFxcdTBBQ0NcXFxcdTBCMDJcXFxcdTBCMDNcXFxcdTBCM0VcXFxcdTBCNDBcXFxcdTBCNDdcXFxcdTBCNDhcXFxcdTBCNEJcXFxcdTBCNENcXFxcdTBCNTdcXFxcdTBCQkVcXFxcdTBCQkZcXFxcdTBCQzFcXFxcdTBCQzJcXFxcdTBCQzYtXFxcXHUwQkM4XFxcXHUwQkNBLVxcXFx1MEJDQ1xcXFx1MEJEN1xcXFx1MEMwMS1cXFxcdTBDMDNcXFxcdTBDNDEtXFxcXHUwQzQ0XFxcXHUwQzgyXFxcXHUwQzgzXFxcXHUwQ0JFXFxcXHUwQ0MwLVxcXFx1MENDNFxcXFx1MENDN1xcXFx1MENDOFxcXFx1MENDQVxcXFx1MENDQlxcXFx1MENENVxcXFx1MENENlxcXFx1MEQwMlxcXFx1MEQwM1xcXFx1MEQzRS1cXFxcdTBENDBcXFxcdTBENDYtXFxcXHUwRDQ4XFxcXHUwRDRBLVxcXFx1MEQ0Q1xcXFx1MEQ1N1xcXFx1MEQ4MlxcXFx1MEQ4M1xcXFx1MERDRi1cXFxcdTBERDFcXFxcdTBERDgtXFxcXHUwRERGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRjNFXFxcXHUwRjNGXFxcXHUwRjdGXFxcXHUxMDJCXFxcXHUxMDJDXFxcXHUxMDMxXFxcXHUxMDM4XFxcXHUxMDNCXFxcXHUxMDNDXFxcXHUxMDU2XFxcXHUxMDU3XFxcXHUxMDYyLVxcXFx1MTA2NFxcXFx1MTA2Ny1cXFxcdTEwNkRcXFxcdTEwODNcXFxcdTEwODRcXFxcdTEwODctXFxcXHUxMDhDXFxcXHUxMDhGXFxcXHUxMDlBLVxcXFx1MTA5Q1xcXFx1MTdCNlxcXFx1MTdCRS1cXFxcdTE3QzVcXFxcdTE3QzdcXFxcdTE3QzhcXFxcdTE5MjMtXFxcXHUxOTI2XFxcXHUxOTI5LVxcXFx1MTkyQlxcXFx1MTkzMFxcXFx1MTkzMVxcXFx1MTkzMy1cXFxcdTE5MzhcXFxcdTE5QjAtXFxcXHUxOUMwXFxcXHUxOUM4XFxcXHUxOUM5XFxcXHUxQTE5LVxcXFx1MUExQlxcXFx1MUE1NVxcXFx1MUE1N1xcXFx1MUE2MVxcXFx1MUE2M1xcXFx1MUE2NFxcXFx1MUE2RC1cXFxcdTFBNzJcXFxcdTFCMDRcXFxcdTFCMzVcXFxcdTFCM0JcXFxcdTFCM0QtXFxcXHUxQjQxXFxcXHUxQjQzXFxcXHUxQjQ0XFxcXHUxQjgyXFxcXHUxQkExXFxcXHUxQkE2XFxcXHUxQkE3XFxcXHUxQkFBXFxcXHUxQzI0LVxcXFx1MUMyQlxcXFx1MUMzNFxcXFx1MUMzNVxcXFx1MUNFMVxcXFx1MUNGMlxcXFx1QTgyM1xcXFx1QTgyNFxcXFx1QTgyN1xcXFx1QTg4MFxcXFx1QTg4MVxcXFx1QThCNC1cXFxcdUE4QzNcXFxcdUE5NTJcXFxcdUE5NTNcXFxcdUE5ODNcXFxcdUE5QjRcXFxcdUE5QjVcXFxcdUE5QkFcXFxcdUE5QkJcXFxcdUE5QkQtXFxcXHVBOUMwXFxcXHVBQTJGXFxcXHVBQTMwXFxcXHVBQTMzXFxcXHVBQTM0XFxcXHVBQTREXFxcXHVBQTdCXFxcXHVBQkUzXFxcXHVBQkU0XFxcXHVBQkU2XFxcXHVBQkU3XFxcXHVBQkU5XFxcXHVBQkVBXFxcXHVBQkVDXVwiKSxcbiAgICBjb25uZWN0b3JfcHVuY3R1YXRpb246IG5ldyBSZWdFeHAoXCJbXFxcXHUwMDVGXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkYzRl1cIilcbn07XG5cbmZ1bmN0aW9uIGlzX2xldHRlcihjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKVxuICAgICAgICB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKVxuICAgICAgICB8fCAoY29kZSA+PSAweGFhICYmIFVOSUNPREUubGV0dGVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkpO1xufTtcblxuZnVuY3Rpb24gaXNfZGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7IC8vWFhYOiBmaW5kIG91dCBpZiBcIlVuaWNvZGVEaWdpdFwiIG1lYW5zIHNvbWV0aGluZyBlbHNlIHRoYW4gMC4uOVxufTtcblxuZnVuY3Rpb24gaXNfYWxwaGFudW1lcmljX2NoYXIoY29kZSkge1xuICAgIHJldHVybiBpc19kaWdpdChjb2RlKSB8fCBpc19sZXR0ZXIoY29kZSk7XG59O1xuXG5mdW5jdGlvbiBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKSB7XG4gICAgcmV0dXJuIFVOSUNPREUubm9uX3NwYWNpbmdfbWFyay50ZXN0KGNoKSB8fCBVTklDT0RFLnNwYWNlX2NvbWJpbmluZ19tYXJrLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpIHtcbiAgICByZXR1cm4gVU5JQ09ERS5jb25uZWN0b3JfcHVuY3R1YXRpb24udGVzdChjaCk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4gIVJFU0VSVkVEX1dPUkRTKG5hbWUpICYmIC9eW2Etel8kXVthLXowLTlfJF0qJC9pLnRlc3QobmFtZSk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0YXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAzNiB8fCBjb2RlID09IDk1IHx8IGlzX2xldHRlcihjb2RlKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfY2hhcihjaCkge1xuICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKVxuICAgICAgICB8fCBpc19kaWdpdChjb2RlKVxuICAgICAgICB8fCBjb2RlID09IDgyMDQgLy8gXFx1MjAwYzogemVyby13aWR0aCBub24tam9pbmVyIDxaV05KPlxuICAgICAgICB8fCBjb2RlID09IDgyMDUgLy8gXFx1MjAwZDogemVyby13aWR0aCBqb2luZXIgPFpXSj4gKGluIG15IEVDTUEtMjYyIFBERiwgdGhpcyBpcyBhbHNvIDIwMGMpXG4gICAgICAgIHx8IGlzX3VuaWNvZGVfY29tYmluaW5nX21hcmsoY2gpXG4gICAgICAgIHx8IGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uKGNoKVxuICAgIDtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfc3RyaW5nKHN0cil7XG4gICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgIGlmIChpID09IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzX2lkZW50aWZpZXJfc3RhcnQoc3RyLmNoYXJDb2RlQXQoMCkpKSByZXR1cm4gZmFsc2U7XG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgIGlmICghaXNfaWRlbnRpZmllcl9jaGFyKHN0ci5jaGFyQXQoaSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlX2pzX251bWJlcihudW0pIHtcbiAgICBpZiAoUkVfSEVYX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDE2KTtcbiAgICB9IGVsc2UgaWYgKFJFX09DVF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDEpLCA4KTtcbiAgICB9IGVsc2UgaWYgKFJFX0RFQ19OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG51bSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xufTtcblxuSlNfUGFyc2VfRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZSArIFwiIChsaW5lOiBcIiArIHRoaXMubGluZSArIFwiLCBjb2w6IFwiICsgdGhpcy5jb2wgKyBcIiwgcG9zOiBcIiArIHRoaXMucG9zICsgXCIpXCIgKyBcIlxcblxcblwiICsgdGhpcy5zdGFjaztcbn07XG5cbmZ1bmN0aW9uIGpzX2Vycm9yKG1lc3NhZ2UsIGZpbGVuYW1lLCBsaW5lLCBjb2wsIHBvcykge1xuICAgIHRocm93IG5ldyBKU19QYXJzZV9FcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcyk7XG59O1xuXG5mdW5jdGlvbiBpc190b2tlbih0b2tlbiwgdHlwZSwgdmFsKSB7XG4gICAgcmV0dXJuIHRva2VuLnR5cGUgPT0gdHlwZSAmJiAodmFsID09IG51bGwgfHwgdG9rZW4udmFsdWUgPT0gdmFsKTtcbn07XG5cbnZhciBFWF9FT0YgPSB7fTtcblxuZnVuY3Rpb24gdG9rZW5pemVyKCRURVhULCBmaWxlbmFtZSwgaHRtbDVfY29tbWVudHMpIHtcblxuICAgIHZhciBTID0ge1xuICAgICAgICB0ZXh0ICAgICAgICAgICAgOiAkVEVYVC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgXCJcXG5cIikucmVwbGFjZSgvXFx1RkVGRi9nLCAnJyksXG4gICAgICAgIGZpbGVuYW1lICAgICAgICA6IGZpbGVuYW1lLFxuICAgICAgICBwb3MgICAgICAgICAgICAgOiAwLFxuICAgICAgICB0b2twb3MgICAgICAgICAgOiAwLFxuICAgICAgICBsaW5lICAgICAgICAgICAgOiAxLFxuICAgICAgICB0b2tsaW5lICAgICAgICAgOiAwLFxuICAgICAgICBjb2wgICAgICAgICAgICAgOiAwLFxuICAgICAgICB0b2tjb2wgICAgICAgICAgOiAwLFxuICAgICAgICBuZXdsaW5lX2JlZm9yZSAgOiBmYWxzZSxcbiAgICAgICAgcmVnZXhfYWxsb3dlZCAgIDogZmFsc2UsXG4gICAgICAgIGNvbW1lbnRzX2JlZm9yZSA6IFtdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnRleHQuY2hhckF0KFMucG9zKTsgfTtcblxuICAgIGZ1bmN0aW9uIG5leHQoc2lnbmFsX2VvZiwgaW5fc3RyaW5nKSB7XG4gICAgICAgIHZhciBjaCA9IFMudGV4dC5jaGFyQXQoUy5wb3MrKyk7XG4gICAgICAgIGlmIChzaWduYWxfZW9mICYmICFjaClcbiAgICAgICAgICAgIHRocm93IEVYX0VPRjtcbiAgICAgICAgaWYgKGNoID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBTLm5ld2xpbmVfYmVmb3JlIHx8ICFpbl9zdHJpbmc7XG4gICAgICAgICAgICArK1MubGluZTtcbiAgICAgICAgICAgIFMuY29sID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrUy5jb2w7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3J3YXJkKGkpIHtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIG5leHQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9va2luZ19hdChzdHIpIHtcbiAgICAgICAgcmV0dXJuIFMudGV4dC5zdWJzdHIoUy5wb3MsIHN0ci5sZW5ndGgpID09IHN0cjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmluZCh3aGF0LCBzaWduYWxfZW9mKSB7XG4gICAgICAgIHZhciBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XG4gICAgICAgIGlmIChzaWduYWxfZW9mICYmIHBvcyA9PSAtMSkgdGhyb3cgRVhfRU9GO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzdGFydF90b2tlbigpIHtcbiAgICAgICAgUy50b2tsaW5lID0gUy5saW5lO1xuICAgICAgICBTLnRva2NvbCA9IFMuY29sO1xuICAgICAgICBTLnRva3BvcyA9IFMucG9zO1xuICAgIH07XG5cbiAgICB2YXIgcHJldl93YXNfZG90ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGlzX2NvbW1lbnQpIHtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gKCh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAhVU5BUllfUE9TVEZJWCh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcImtleXdvcmRcIiAmJiBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcInB1bmNcIiAmJiBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OKHZhbHVlKSkpO1xuICAgICAgICBwcmV2X3dhc19kb3QgPSAodHlwZSA9PSBcInB1bmNcIiAmJiB2YWx1ZSA9PSBcIi5cIik7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICB0eXBlICAgOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWUgIDogdmFsdWUsXG4gICAgICAgICAgICBsaW5lICAgOiBTLnRva2xpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBTLnRva2NvbCxcbiAgICAgICAgICAgIHBvcyAgICA6IFMudG9rcG9zLFxuICAgICAgICAgICAgZW5kcG9zIDogUy5wb3MsXG4gICAgICAgICAgICBubGIgICAgOiBTLm5ld2xpbmVfYmVmb3JlLFxuICAgICAgICAgICAgZmlsZSAgIDogZmlsZW5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc19jb21tZW50KSB7XG4gICAgICAgICAgICByZXQuY29tbWVudHNfYmVmb3JlID0gUy5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgLy8gbWFrZSBub3RlIG9mIGFueSBuZXdsaW5lcyBpbiB0aGUgY29tbWVudHMgdGhhdCBjYW1lIGJlZm9yZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJldC5jb21tZW50c19iZWZvcmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQubmxiID0gcmV0Lm5sYiB8fCByZXQuY29tbWVudHNfYmVmb3JlW2ldLm5sYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHJldCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNraXBfd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUgKFdISVRFU1BBQ0VfQ0hBUlMocGVlaygpKSlcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBjaCwgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICYmIHByZWQoY2gsIGkrKykpXG4gICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZV9lcnJvcihlcnIpIHtcbiAgICAgICAganNfZXJyb3IoZXJyLCBmaWxlbmFtZSwgUy50b2tsaW5lLCBTLnRva2NvbCwgUy50b2twb3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWFkX251bShwcmVmaXgpIHtcbiAgICAgICAgdmFyIGhhc19lID0gZmFsc2UsIGFmdGVyX2UgPSBmYWxzZSwgaGFzX3ggPSBmYWxzZSwgaGFzX2RvdCA9IHByZWZpeCA9PSBcIi5cIjtcbiAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpe1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTIwOiBjYXNlIDg4OiAvLyB4WFxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNfeCA/IGZhbHNlIDogKGhhc194ID0gdHJ1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgMTAxOiBjYXNlIDY5OiAvLyBlRVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNfeCA/IHRydWUgOiBoYXNfZSA/IGZhbHNlIDogKGhhc19lID0gYWZ0ZXJfZSA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDQ1OiAvLyAtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2UgfHwgKGkgPT0gMCAmJiAhcHJlZml4KTtcbiAgICAgICAgICAgICAgY2FzZSA0MzogLy8gK1xuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlcl9lO1xuICAgICAgICAgICAgICBjYXNlIChhZnRlcl9lID0gZmFsc2UsIDQ2KTogLy8gLlxuICAgICAgICAgICAgICAgIHJldHVybiAoIWhhc19kb3QgJiYgIWhhc194ICYmICFoYXNfZSkgPyAoaGFzX2RvdCA9IHRydWUpIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNfYWxwaGFudW1lcmljX2NoYXIoY29kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlZml4KSBudW0gPSBwcmVmaXggKyBudW07XG4gICAgICAgIHZhciB2YWxpZCA9IHBhcnNlX2pzX251bWJlcihudW0pO1xuICAgICAgICBpZiAoIWlzTmFOKHZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwibnVtXCIsIHZhbGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBzeW50YXg6IFwiICsgbnVtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWFkX2VzY2FwZWRfY2hhcihpbl9zdHJpbmcpIHtcbiAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xuICAgICAgICBzd2l0Y2ggKGNoLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBjYXNlIDExMCA6IHJldHVybiBcIlxcblwiO1xuICAgICAgICAgIGNhc2UgMTE0IDogcmV0dXJuIFwiXFxyXCI7XG4gICAgICAgICAgY2FzZSAxMTYgOiByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgICBjYXNlIDk4ICA6IHJldHVybiBcIlxcYlwiO1xuICAgICAgICAgIGNhc2UgMTE4IDogcmV0dXJuIFwiXFx1MDAwYlwiOyAvLyBcXHZcbiAgICAgICAgICBjYXNlIDEwMiA6IHJldHVybiBcIlxcZlwiO1xuICAgICAgICAgIGNhc2UgNDggIDogcmV0dXJuIFwiXFwwXCI7XG4gICAgICAgICAgY2FzZSAxMjAgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoMikpOyAvLyBcXHhcbiAgICAgICAgICBjYXNlIDExNyA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleF9ieXRlcyg0KSk7IC8vIFxcdVxuICAgICAgICAgIGNhc2UgMTAgIDogcmV0dXJuIFwiXCI7IC8vIG5ld2xpbmVcbiAgICAgICAgICBkZWZhdWx0ICA6IHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoZXhfYnl0ZXMobikge1xuICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgZm9yICg7IG4gPiAwOyAtLW4pIHtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHBhcnNlSW50KG5leHQodHJ1ZSksIDE2KTtcbiAgICAgICAgICAgIGlmIChpc05hTihkaWdpdCkpXG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJJbnZhbGlkIGhleC1jaGFyYWN0ZXIgcGF0dGVybiBpbiBzdHJpbmdcIik7XG4gICAgICAgICAgICBudW0gPSAobnVtIDw8IDQpIHwgZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfc3RyaW5nID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBxdW90ZSA9IG5leHQoKSwgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgT2N0YWxFc2NhcGVTZXF1ZW5jZSAoWFhYOiBkZXByZWNhdGVkIGlmIFwic3RyaWN0IG1vZGVcIilcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8xNzhcbiAgICAgICAgICAgICAgICB2YXIgb2N0YWxfbGVuID0gMCwgZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF93aGlsZShmdW5jdGlvbihjaCl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPD0gXCIzXCIgJiYgb2N0YWxfbGVuIDw9IDIpIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID49IFwiNFwiICYmIG9jdGFsX2xlbiA8PSAxKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvY3RhbF9sZW4gPiAwKSBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY2gsIDgpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBxdW90ZSkgYnJlYWs7XG4gICAgICAgICAgICByZXQgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuKFwic3RyaW5nXCIsIHJldCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBza2lwX2xpbmVfY29tbWVudCh0eXBlKSB7XG4gICAgICAgIHZhciByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xuICAgICAgICB2YXIgaSA9IGZpbmQoXCJcXG5cIiksIHJldDtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHIoUy5wb3MpO1xuICAgICAgICAgICAgUy5wb3MgPSBTLnRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICBTLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaCh0b2tlbih0eXBlLCByZXQsIHRydWUpKTtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW4oKTtcbiAgICB9O1xuXG4gICAgdmFyIHNraXBfbXVsdGlsaW5lX2NvbW1lbnQgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBtdWx0aWxpbmUgY29tbWVudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcmVnZXhfYWxsb3dlZCA9IFMucmVnZXhfYWxsb3dlZDtcbiAgICAgICAgdmFyIGkgPSBmaW5kKFwiKi9cIiwgdHJ1ZSk7XG4gICAgICAgIHZhciB0ZXh0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgIHZhciBhID0gdGV4dC5zcGxpdChcIlxcblwiKSwgbiA9IGEubGVuZ3RoO1xuICAgICAgICAvLyB1cGRhdGUgc3RyZWFtIHBvc2l0aW9uXG4gICAgICAgIFMucG9zID0gaSArIDI7XG4gICAgICAgIFMubGluZSArPSBuIC0gMTtcbiAgICAgICAgaWYgKG4gPiAxKSBTLmNvbCA9IGFbbiAtIDFdLmxlbmd0aDtcbiAgICAgICAgZWxzZSBTLmNvbCArPSBhW24gLSAxXS5sZW5ndGg7XG4gICAgICAgIFMuY29sICs9IDI7XG4gICAgICAgIHZhciBubGIgPSBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPj0gMDtcbiAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaCh0b2tlbihcImNvbW1lbnQyXCIsIHRleHQsIHRydWUpKTtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IG5sYjtcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW4oKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfbmFtZSgpIHtcbiAgICAgICAgdmFyIGJhY2tzbGFzaCA9IGZhbHNlLCBuYW1lID0gXCJcIiwgY2gsIGVzY2FwZWQgPSBmYWxzZSwgaGV4O1xuICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikgZXNjYXBlZCA9IGJhY2tzbGFzaCA9IHRydWUsIG5leHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpKSBuYW1lICs9IG5leHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoICE9IFwidVwiKSBwYXJzZV9lcnJvcihcIkV4cGVjdGluZyBVbmljb2RlRXNjYXBlU2VxdWVuY2UgLS0gdVhYWFhcIik7XG4gICAgICAgICAgICAgICAgY2ggPSByZWFkX2VzY2FwZWRfY2hhcigpO1xuICAgICAgICAgICAgICAgIGlmICghaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgcGFyc2VfZXJyb3IoXCJVbmljb2RlIGNoYXI6IFwiICsgY2guY2hhckNvZGVBdCgwKSArIFwiIGlzIG5vdCB2YWxpZCBpbiBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gY2g7XG4gICAgICAgICAgICAgICAgYmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEtFWVdPUkRTKG5hbWUpICYmIGVzY2FwZWQpIHtcbiAgICAgICAgICAgIGhleCA9IG5hbWUuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIG5hbWUgPSBcIlxcXFx1XCIgKyBcIjAwMDBcIi5zdWJzdHIoaGV4Lmxlbmd0aCkgKyBoZXggKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICB2YXIgcmVhZF9yZWdleHAgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiwgZnVuY3Rpb24ocmVnZXhwKXtcbiAgICAgICAgdmFyIHByZXZfYmFja3NsYXNoID0gZmFsc2UsIGNoLCBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoKGNoID0gbmV4dCh0cnVlKSkpIGlmIChwcmV2X2JhY2tzbGFzaCkge1xuICAgICAgICAgICAgcmVnZXhwICs9IFwiXFxcXFwiICsgY2g7XG4gICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJdXCIgJiYgaW5fY2xhc3MpIHtcbiAgICAgICAgICAgIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICByZWdleHAgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgIWluX2NsYXNzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RzID0gcmVhZF9uYW1lKCk7XG4gICAgICAgIHJldHVybiB0b2tlbihcInJlZ2V4cFwiLCBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kcykpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVhZF9vcGVyYXRvcihwcmVmaXgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ3JvdyhvcCkge1xuICAgICAgICAgICAgaWYgKCFwZWVrKCkpIHJldHVybiBvcDtcbiAgICAgICAgICAgIHZhciBiaWdnZXIgPSBvcCArIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChPUEVSQVRPUlMoYmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdyhiaWdnZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0b2tlbihcIm9wZXJhdG9yXCIsIGdyb3cocHJlZml4IHx8IG5leHQoKSkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfc2xhc2goKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgc3dpdGNoIChwZWVrKCkpIHtcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNraXBfbGluZV9jb21tZW50KFwiY29tbWVudDFcIik7XG4gICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBza2lwX211bHRpbGluZV9jb21tZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFMucmVnZXhfYWxsb3dlZCA/IHJlYWRfcmVnZXhwKFwiXCIpIDogcmVhZF9vcGVyYXRvcihcIi9cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9kb3QoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGlzX2RpZ2l0KHBlZWsoKS5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICAgPyByZWFkX251bShcIi5cIilcbiAgICAgICAgICAgIDogdG9rZW4oXCJwdW5jXCIsIFwiLlwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF93b3JkKCkge1xuICAgICAgICB2YXIgd29yZCA9IHJlYWRfbmFtZSgpO1xuICAgICAgICBpZiAocHJldl93YXNfZG90KSByZXR1cm4gdG9rZW4oXCJuYW1lXCIsIHdvcmQpO1xuICAgICAgICByZXR1cm4gS0VZV09SRFNfQVRPTSh3b3JkKSA/IHRva2VuKFwiYXRvbVwiLCB3b3JkKVxuICAgICAgICAgICAgOiAhS0VZV09SRFMod29yZCkgPyB0b2tlbihcIm5hbWVcIiwgd29yZClcbiAgICAgICAgICAgIDogT1BFUkFUT1JTKHdvcmQpID8gdG9rZW4oXCJvcGVyYXRvclwiLCB3b3JkKVxuICAgICAgICAgICAgOiB0b2tlbihcImtleXdvcmRcIiwgd29yZCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpdGhfZW9mX2Vycm9yKGVvZl9lcnJvciwgY29udCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udCh4KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggPT09IEVYX0VPRikgcGFyc2VfZXJyb3IoZW9mX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBuZXh0X3Rva2VuKGZvcmNlX3JlZ2V4cCkge1xuICAgICAgICBpZiAoZm9yY2VfcmVnZXhwICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmVhZF9yZWdleHAoZm9yY2VfcmVnZXhwKTtcbiAgICAgICAgc2tpcF93aGl0ZXNwYWNlKCk7XG4gICAgICAgIHN0YXJ0X3Rva2VuKCk7XG4gICAgICAgIGlmIChodG1sNV9jb21tZW50cykge1xuICAgICAgICAgICAgaWYgKGxvb2tpbmdfYXQoXCI8IS0tXCIpKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZCg0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXCJjb21tZW50M1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb29raW5nX2F0KFwiLS0+XCIpICYmIFMubmV3bGluZV9iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBmb3J3YXJkKDMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQ0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaCA9IHBlZWsoKTtcbiAgICAgICAgaWYgKCFjaCkgcmV0dXJuIHRva2VuKFwiZW9mXCIpO1xuICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgMzQ6IGNhc2UgMzk6IHJldHVybiByZWFkX3N0cmluZygpO1xuICAgICAgICAgIGNhc2UgNDY6IHJldHVybiBoYW5kbGVfZG90KCk7XG4gICAgICAgICAgY2FzZSA0NzogcmV0dXJuIGhhbmRsZV9zbGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19kaWdpdChjb2RlKSkgcmV0dXJuIHJlYWRfbnVtKCk7XG4gICAgICAgIGlmIChQVU5DX0NIQVJTKGNoKSkgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBuZXh0KCkpO1xuICAgICAgICBpZiAoT1BFUkFUT1JfQ0hBUlMoY2gpKSByZXR1cm4gcmVhZF9vcGVyYXRvcigpO1xuICAgICAgICBpZiAoY29kZSA9PSA5MiB8fCBpc19pZGVudGlmaWVyX3N0YXJ0KGNvZGUpKSByZXR1cm4gcmVhZF93b3JkKCk7XG4gICAgICAgIHBhcnNlX2Vycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4uY29udGV4dCA9IGZ1bmN0aW9uKG5jKSB7XG4gICAgICAgIGlmIChuYykgUyA9IG5jO1xuICAgICAgICByZXR1cm4gUztcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5leHRfdG9rZW47XG5cbn07XG5cbi8qIC0tLS0tWyBQYXJzZXIgKGNvbnN0YW50cykgXS0tLS0tICovXG5cbnZhciBVTkFSWV9QUkVGSVggPSBtYWtlUHJlZGljYXRlKFtcbiAgICBcInR5cGVvZlwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCItLVwiLFxuICAgIFwiKytcIixcbiAgICBcIiFcIixcbiAgICBcIn5cIixcbiAgICBcIi1cIixcbiAgICBcIitcIlxuXSk7XG5cbnZhciBVTkFSWV9QT1NURklYID0gbWFrZVByZWRpY2F0ZShbIFwiLS1cIiwgXCIrK1wiIF0pO1xuXG52YXIgQVNTSUdOTUVOVCA9IG1ha2VQcmVkaWNhdGUoWyBcIj1cIiwgXCIrPVwiLCBcIi09XCIsIFwiLz1cIiwgXCIqPVwiLCBcIiU9XCIsIFwiPj49XCIsIFwiPDw9XCIsIFwiPj4+PVwiLCBcInw9XCIsIFwiXj1cIiwgXCImPVwiIF0pO1xuXG52YXIgUFJFQ0VERU5DRSA9IChmdW5jdGlvbihhLCByZXQpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYiA9IGFbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgcmV0W2Jbal1dID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn0pKFxuICAgIFtcbiAgICAgICAgW1wifHxcIl0sXG4gICAgICAgIFtcIiYmXCJdLFxuICAgICAgICBbXCJ8XCJdLFxuICAgICAgICBbXCJeXCJdLFxuICAgICAgICBbXCImXCJdLFxuICAgICAgICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICAgICAgICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gICAgICAgIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gICAgICAgIFtcIitcIiwgXCItXCJdLFxuICAgICAgICBbXCIqXCIsIFwiL1wiLCBcIiVcIl1cbiAgICBdLFxuICAgIHt9XG4pO1xuXG52YXIgU1RBVEVNRU5UU19XSVRIX0xBQkVMUyA9IGFycmF5X3RvX2hhc2goWyBcImZvclwiLCBcImRvXCIsIFwid2hpbGVcIiwgXCJzd2l0Y2hcIiBdKTtcblxudmFyIEFUT01JQ19TVEFSVF9UT0tFTiA9IGFycmF5X3RvX2hhc2goWyBcImF0b21cIiwgXCJudW1cIiwgXCJzdHJpbmdcIiwgXCJyZWdleHBcIiwgXCJuYW1lXCIgXSk7XG5cbi8qIC0tLS0tWyBQYXJzZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIHBhcnNlKCRURVhULCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzdHJpY3QgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBmaWxlbmFtZSAgICAgICA6IG51bGwsXG4gICAgICAgIHRvcGxldmVsICAgICAgIDogbnVsbCxcbiAgICAgICAgZXhwcmVzc2lvbiAgICAgOiBmYWxzZSxcbiAgICAgICAgaHRtbDVfY29tbWVudHMgOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgdmFyIFMgPSB7XG4gICAgICAgIGlucHV0ICAgICAgICAgOiAodHlwZW9mICRURVhUID09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuaXplcigkVEVYVCwgb3B0aW9ucy5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmh0bWw1X2NvbW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgIDogJFRFWFQpLFxuICAgICAgICB0b2tlbiAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHBlZWtlZCAgICAgICAgOiBudWxsLFxuICAgICAgICBpbl9mdW5jdGlvbiAgIDogMCxcbiAgICAgICAgaW5fZGlyZWN0aXZlcyA6IHRydWUsXG4gICAgICAgIGluX2xvb3AgICAgICAgOiAwLFxuICAgICAgICBsYWJlbHMgICAgICAgIDogW11cbiAgICB9O1xuXG4gICAgUy50b2tlbiA9IG5leHQoKTtcblxuICAgIGZ1bmN0aW9uIGlzKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc190b2tlbihTLnRva2VuLCB0eXBlLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpOyB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgUy5wcmV2ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKFMucGVla2VkKSB7XG4gICAgICAgICAgICBTLnRva2VuID0gUy5wZWVrZWQ7XG4gICAgICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXG4gICAgICAgICAgICBTLnRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICByZXR1cm4gUy5wcmV2O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcm9hayhtc2csIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgIHZhciBjdHggPSBTLmlucHV0LmNvbnRleHQoKTtcbiAgICAgICAganNfZXJyb3IobXNnLFxuICAgICAgICAgICAgICAgICBjdHguZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgIGxpbmUgIT0gbnVsbCA/IGxpbmUgOiBjdHgudG9rbGluZSxcbiAgICAgICAgICAgICAgICAgY29sICE9IG51bGwgPyBjb2wgOiBjdHgudG9rY29sLFxuICAgICAgICAgICAgICAgICBwb3MgIT0gbnVsbCA/IHBvcyA6IGN0eC50b2twb3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2tlbl9lcnJvcih0b2tlbiwgbXNnKSB7XG4gICAgICAgIGNyb2FrKG1zZywgdG9rZW4ubGluZSwgdG9rZW4uY29sKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgIHRva2VuID0gUy50b2tlbjtcbiAgICAgICAgdG9rZW5fZXJyb3IodG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbjogXCIgKyB0b2tlbi50eXBlICsgXCIgKFwiICsgdG9rZW4udmFsdWUgKyBcIilcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cGVjdF90b2tlbih0eXBlLCB2YWwpIHtcbiAgICAgICAgaWYgKGlzKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5fZXJyb3IoUy50b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgUy50b2tlbi50eXBlICsgXCIgwqtcIiArIFMudG9rZW4udmFsdWUgKyBcIsK7XCIgKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlICsgXCIgwqtcIiArIHZhbCArIFwiwrtcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIHB1bmMpOyB9O1xuXG4gICAgZnVuY3Rpb24gY2FuX2luc2VydF9zZW1pY29sb24oKSB7XG4gICAgICAgIHJldHVybiAhb3B0aW9ucy5zdHJpY3QgJiYgKFxuICAgICAgICAgICAgUy50b2tlbi5ubGIgfHwgaXMoXCJlb2ZcIikgfHwgaXMoXCJwdW5jXCIsIFwifVwiKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgICAgIGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2lzZWQoKSB7XG4gICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgIHZhciBleHAgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbWJlZF90b2tlbnMocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlcigpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIGV4cHIuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGV4cHIuZW5kID0gZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9yZWdleHAoKSB7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiL1wiKSB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiLz1cIikpIHtcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlbWVudCA9IGVtYmVkX3Rva2VucyhmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHZhciBkaXIgPSBTLmluX2RpcmVjdGl2ZXMsIHN0YXQgPSBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAvLyBYWFh2MjogZGVjaWRlIGhvdyB0byBmaXggZGlyZWN0aXZlc1xuICAgICAgICAgICAgaWYgKGRpciAmJiBzdGF0LmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmICFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RpcmVjdGl2ZSh7IHZhbHVlOiBzdGF0LmJvZHkudmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdDtcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgIHJldHVybiBpc190b2tlbihwZWVrKCksIFwicHVuY1wiLCBcIjpcIilcbiAgICAgICAgICAgICAgICA/IGxhYmVsZWRfc3RhdGVtZW50KClcbiAgICAgICAgICAgICAgICA6IHNpbXBsZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgICAgIGNhc2UgXCJwdW5jXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9CbG9ja1N0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgOiBibG9ja18oKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FbXB0eVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKHRtcCA9IFMudG9rZW4udmFsdWUsIG5leHQoKSwgdG1wKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJicmVha1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KEFTVF9CcmVhayk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0NvbnRpbnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZGVidWdnZXJcIjpcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EZWJ1Z2dlcigpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJkb1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RvKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgIDogaW5fbG9vcChzdGF0ZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gOiAoZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcIndoaWxlXCIpLCB0bXAgPSBwYXJlbnRoZXNpc2VkKCksIHNlbWljb2xvbigpLCB0bXApXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfV2hpbGUoe1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJmb3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9yXygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0RlZnVuKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgICAgIGlmIChTLmluX2Z1bmN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZXR1cm4oe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHQoKSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYW5faW5zZXJ0X3NlbWljb2xvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKSApXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInN3aXRjaFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N3aXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBpbl9sb29wKHN3aXRjaF9ib2R5XylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICAgICAgICBpZiAoUy50b2tlbi5ubGIpXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyICd0aHJvdydcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhyb3coe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInRyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnlfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0bXAgPSB2YXJfKCksIHNlbWljb2xvbigpLCB0bXA7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImNvbnN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcCA9IGNvbnN0XygpLCBzZW1pY29sb24oKSwgdG1wO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfV2l0aCh7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBzdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsYWJlbGVkX3N0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbCk7XG4gICAgICAgIGlmIChmaW5kX2lmKGZ1bmN0aW9uKGwpeyByZXR1cm4gbC5uYW1lID09IGxhYmVsLm5hbWUgfSwgUy5sYWJlbHMpKSB7XG4gICAgICAgICAgICAvLyBFQ01BLTI2MiwgMTIuMTI6IEFuIEVDTUFTY3JpcHQgcHJvZ3JhbSBpcyBjb25zaWRlcmVkXG4gICAgICAgICAgICAvLyBzeW50YWN0aWNhbGx5IGluY29ycmVjdCBpZiBpdCBjb250YWlucyBhXG4gICAgICAgICAgICAvLyBMYWJlbGxlZFN0YXRlbWVudCB0aGF0IGlzIGVuY2xvc2VkIGJ5IGFcbiAgICAgICAgICAgIC8vIExhYmVsbGVkU3RhdGVtZW50IHdpdGggdGhlIHNhbWUgSWRlbnRpZmllciBhcyBsYWJlbC5cbiAgICAgICAgICAgIGNyb2FrKFwiTGFiZWwgXCIgKyBsYWJlbC5uYW1lICsgXCIgZGVmaW5lZCB0d2ljZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICBTLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgUy5sYWJlbHMucG9wKCk7XG4gICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGBjb250aW51ZWAgdGhhdCByZWZlcnMgdG8gdGhpcyBsYWJlbC5cbiAgICAgICAgICAgIC8vIHRob3NlIHNob3VsZCBiZSByZXBvcnRlZCBhcyBzeW50YXggZXJyb3JzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzI4N1xuICAgICAgICAgICAgbGFiZWwucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlZil7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWYgPSByZWYubGFiZWwuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiQ29udGludWUgbGFiZWwgYFwiICsgbGFiZWwubmFtZSArIFwiYCByZWZlcnMgdG8gbm9uLUl0ZXJhdGlvblN0YXRlbWVudC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmxpbmUsIHJlZi5jb2wsIHJlZi5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xhYmVsZWRTdGF0ZW1lbnQoeyBib2R5OiBzdGF0LCBsYWJlbDogbGFiZWwgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNpbXBsZV9zdGF0ZW1lbnQodG1wKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7IGJvZHk6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKSB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnJlYWtfY29udCh0eXBlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIGxkZWY7XG4gICAgICAgIGlmICghY2FuX2luc2VydF9zZW1pY29sb24oKSkge1xuICAgICAgICAgICAgbGFiZWwgPSBhc19zeW1ib2woQVNUX0xhYmVsUmVmLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGRlZiA9IGZpbmRfaWYoZnVuY3Rpb24obCl7IHJldHVybiBsLm5hbWUgPT0gbGFiZWwubmFtZSB9LCBTLmxhYmVscyk7XG4gICAgICAgICAgICBpZiAoIWxkZWYpXG4gICAgICAgICAgICAgICAgY3JvYWsoXCJVbmRlZmluZWQgbGFiZWwgXCIgKyBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIGxhYmVsLnRoZWRlZiA9IGxkZWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUy5pbl9sb29wID09IDApXG4gICAgICAgICAgICBjcm9hayh0eXBlLlRZUEUgKyBcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcIik7XG4gICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICB2YXIgc3RhdCA9IG5ldyB0eXBlKHsgbGFiZWw6IGxhYmVsIH0pO1xuICAgICAgICBpZiAobGRlZikgbGRlZi5yZWZlcmVuY2VzLnB1c2goc3RhdCk7XG4gICAgICAgIHJldHVybiBzdGF0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JfKCkge1xuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiO1wiKSkge1xuICAgICAgICAgICAgaW5pdCA9IGlzKFwia2V5d29yZFwiLCBcInZhclwiKVxuICAgICAgICAgICAgICAgID8gKG5leHQoKSwgdmFyXyh0cnVlKSlcbiAgICAgICAgICAgICAgICA6IGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcImluXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGluaXQuZGVmaW5pdGlvbnMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJPbmx5IG9uZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbGxvd2VkIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcl9pbihpbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVndWxhcl9mb3IoaW5pdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlZ3VsYXJfZm9yKGluaXQpIHtcbiAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgdmFyIHRlc3QgPSBpcyhcInB1bmNcIiwgXCI7XCIpID8gbnVsbCA6IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgIHZhciBzdGVwID0gaXMoXCJwdW5jXCIsIFwiKVwiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3Ioe1xuICAgICAgICAgICAgaW5pdCAgICAgIDogaW5pdCxcbiAgICAgICAgICAgIGNvbmRpdGlvbiA6IHRlc3QsXG4gICAgICAgICAgICBzdGVwICAgICAgOiBzdGVwLFxuICAgICAgICAgICAgYm9keSAgICAgIDogaW5fbG9vcChzdGF0ZW1lbnQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JfaW4oaW5pdCkge1xuICAgICAgICB2YXIgbGhzID0gaW5pdCBpbnN0YW5jZW9mIEFTVF9WYXIgPyBpbml0LmRlZmluaXRpb25zWzBdLm5hbWUgOiBudWxsO1xuICAgICAgICB2YXIgb2JqID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRm9ySW4oe1xuICAgICAgICAgICAgaW5pdCAgIDogaW5pdCxcbiAgICAgICAgICAgIG5hbWUgICA6IGxocyxcbiAgICAgICAgICAgIG9iamVjdCA6IG9iaixcbiAgICAgICAgICAgIGJvZHkgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGZ1bmN0aW9uXyA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgICAgICAgdmFyIGluX3N0YXRlbWVudCA9IGN0b3IgPT09IEFTVF9EZWZ1bjtcbiAgICAgICAgdmFyIG5hbWUgPSBpcyhcIm5hbWVcIikgPyBhc19zeW1ib2woaW5fc3RhdGVtZW50ID8gQVNUX1N5bWJvbERlZnVuIDogQVNUX1N5bWJvbExhbWJkYSkgOiBudWxsO1xuICAgICAgICBpZiAoaW5fc3RhdGVtZW50ICYmICFuYW1lKVxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3Ioe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ25hbWVzOiAoZnVuY3Rpb24oZmlyc3QsIGEpe1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGFzX3N5bWJvbChBU1RfU3ltYm9sRnVuYXJnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0pKHRydWUsIFtdKSxcbiAgICAgICAgICAgIGJvZHk6IChmdW5jdGlvbihsb29wLCBsYWJlbHMpe1xuICAgICAgICAgICAgICAgICsrUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFMuaW5fbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgUy5sYWJlbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgICAgIC0tUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSBsb29wO1xuICAgICAgICAgICAgICAgIFMubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSkoUy5pbl9sb29wLCBTLmxhYmVscylcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlmXygpIHtcbiAgICAgICAgdmFyIGNvbmQgPSBwYXJlbnRoZXNpc2VkKCksIGJvZHkgPSBzdGF0ZW1lbnQoKSwgYmVsc2UgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZWxzZVwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYmVsc2UgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVF9JZih7XG4gICAgICAgICAgICBjb25kaXRpb24gICA6IGNvbmQsXG4gICAgICAgICAgICBib2R5ICAgICAgICA6IGJvZHksXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGJlbHNlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBibG9ja18oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICBhLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHN3aXRjaF9ib2R5XygpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGEgPSBbXSwgY3VyID0gbnVsbCwgYnJhbmNoID0gbnVsbCwgdG1wO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImNhc2VcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoKSBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgIGN1ciA9IFtdO1xuICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5ldyBBU1RfQ2FzZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiAodG1wID0gUy50b2tlbiwgbmV4dCgpLCB0bXApLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcmVzc2lvbih0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGN1clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpcyhcImtleXdvcmRcIiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0RlZmF1bHQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6ICh0bXAgPSBTLnRva2VuLCBuZXh0KCksIGV4cGVjdChcIjpcIiksIHRtcCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogY3VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIGN1ci5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoKSBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cnlfKCkge1xuICAgICAgICB2YXIgYm9keSA9IGJsb2NrXygpLCBiY2F0Y2ggPSBudWxsLCBiZmluYWxseSA9IG51bGw7XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXRjaFwiKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFzX3N5bWJvbChBU1RfU3ltYm9sQ2F0Y2gpO1xuICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgIGJjYXRjaCA9IG5ldyBBU1RfQ2F0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBhcmduYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgZW5kICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImZpbmFsbHlcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBiZmluYWxseSA9IG5ldyBBU1RfRmluYWxseSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJjYXRjaCAmJiAhYmZpbmFsbHkpXG4gICAgICAgICAgICBjcm9hayhcIk1pc3NpbmcgY2F0Y2gvZmluYWxseSBibG9ja3NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1RyeSh7XG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHksXG4gICAgICAgICAgICBiY2F0Y2ggICA6IGJjYXRjaCxcbiAgICAgICAgICAgIGJmaW5hbGx5IDogYmZpbmFsbHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHZhcmRlZnMobm9faW4sIGluX2NvbnN0KSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX1ZhckRlZih7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgIG5hbWUgIDogYXNfc3ltYm9sKGluX2NvbnN0ID8gQVNUX1N5bWJvbENvbnN0IDogQVNUX1N5bWJvbFZhciksXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSA/IChuZXh0KCksIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHZhciB2YXJfID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVmFyKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBmYWxzZSksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnN0XyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Db25zdCh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG5ld18gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgZXhwZWN0X3Rva2VuKFwib3BlcmF0b3JcIiwgXCJuZXdcIik7XG4gICAgICAgIHZhciBuZXdleHAgPSBleHByX2F0b20oZmFsc2UpLCBhcmdzO1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYXJncyA9IGV4cHJfbGlzdChcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9OZXcoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IG5ld2V4cCxcbiAgICAgICAgICAgIGFyZ3MgICAgICAgOiBhcmdzLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSgpIHtcbiAgICAgICAgdmFyIHRvayA9IFMudG9rZW4sIHJldDtcbiAgICAgICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIHJldCA9IF9tYWtlX3N5bWJvbChBU1RfU3ltYm9sUmVmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfTnVtYmVyKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2ssIHZhbHVlOiB0b2sudmFsdWUgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX1N0cmluZyh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9SZWdFeHAoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHRvay52YWx1ZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX0ZhbHNlKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9UcnVlKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9OdWxsKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBleHByX2F0b20gPSBmdW5jdGlvbihhbGxvd19jYWxscykge1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIm5ld1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld18oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXJ0LnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBleCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXguc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBleC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZXgsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcnJheV8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG9iamVjdF8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbl8oQVNUX0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIGZ1bmMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGZ1bmMuZW5kID0gcHJldigpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZnVuYywgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBVE9NSUNfU1RBUlRfVE9LRU5bUy50b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXNfYXRvbV9ub2RlKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cHJfbGlzdChjbG9zaW5nLCBhbGxvd190cmFpbGluZ19jb21tYSwgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBjbG9zaW5nKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICBpZiAoYWxsb3dfdHJhaWxpbmdfY29tbWEgJiYgaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSBicmVhaztcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfSG9sZSh7IHN0YXJ0OiBTLnRva2VuLCBlbmQ6IFMudG9rZW4gfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHZhciBhcnJheV8gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChcIltcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0FycmF5KHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBleHByX2xpc3QoXCJdXCIsICFvcHRpb25zLnN0cmljdCwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JqZWN0XyA9IGVtYmVkX3Rva2VucyhmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpcyhcInB1bmNcIiwgXCJ9XCIpKVxuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIGNvbW1hXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBzdGFydC50eXBlO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hbWVcIiAmJiAhaXMoXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0R2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IGFzX2F0b21fbm9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBmdW5jdGlvbl8oQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0U2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IGFzX2F0b21fbm9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBmdW5jdGlvbl8oQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0KHsgcHJvcGVydGllczogYSB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFzX3Byb3BlcnR5X25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRtcC52YWx1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfbWFrZV9zeW1ib2wodHlwZSkge1xuICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpcyA6IHR5cGUpKHtcbiAgICAgICAgICAgIG5hbWUgIDogU3RyaW5nKG5hbWUpLFxuICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgZW5kICAgOiBTLnRva2VuXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19zeW1ib2wodHlwZSwgbm9lcnJvcikge1xuICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCFub2Vycm9yKSBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltID0gX21ha2Vfc3ltYm9sKHR5cGUpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBzeW07XG4gICAgfTtcblxuICAgIHZhciBzdWJzY3JpcHRzID0gZnVuY3Rpb24oZXhwciwgYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXhwci5zdGFydDtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIi5cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfRG90KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IGFzX25hbWUoKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogcHJvcCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd19jYWxscyAmJiBpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBhcmdzICAgICAgIDogZXhwcl9saXN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIHZhciBtYXliZV91bmFyeSA9IGZ1bmN0aW9uKGFsbG93X2NhbGxzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BSRUZJWChzdGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGhhbmRsZV9yZWdleHAoKTtcbiAgICAgICAgICAgIHZhciBleCA9IG1ha2VfdW5hcnkoQVNUX1VuYXJ5UHJlZml4LCBzdGFydC52YWx1ZSwgbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpKTtcbiAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IGV4cHJfYXRvbShhbGxvd19jYWxscyk7XG4gICAgICAgIHdoaWxlIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BPU1RGSVgoUy50b2tlbi52YWx1ZSkgJiYgIVMudG9rZW4ubmxiKSB7XG4gICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVBvc3RmaXgsIFMudG9rZW4udmFsdWUsIHZhbCk7XG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkoY3Rvciwgb3AsIGV4cHIpIHtcbiAgICAgICAgaWYgKChvcCA9PSBcIisrXCIgfHwgb3AgPT0gXCItLVwiKSAmJiAhaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCB1c2Ugb2YgXCIgKyBvcCArIFwiIG9wZXJhdG9yXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IoeyBvcGVyYXRvcjogb3AsIGV4cHJlc3Npb246IGV4cHIgfSk7XG4gICAgfTtcblxuICAgIHZhciBleHByX29wID0gZnVuY3Rpb24obGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgaWYgKG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICB2YXIgcHJlYyA9IG9wICE9IG51bGwgPyBQUkVDRURFTkNFW29wXSA6IG51bGw7XG4gICAgICAgIGlmIChwcmVjICE9IG51bGwgJiYgcHJlYyA+IG1pbl9wcmVjKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCBwcmVjLCBub19pbik7XG4gICAgICAgICAgICByZXR1cm4gZXhwcl9vcChuZXcgQVNUX0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgOiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogcmlnaHQsXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiByaWdodC5lbmRcbiAgICAgICAgICAgIH0pLCBtaW5fcHJlYywgbm9faW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHByX29wcyhub19pbikge1xuICAgICAgICByZXR1cm4gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgMCwgbm9faW4pO1xuICAgIH07XG5cbiAgICB2YXIgbWF5YmVfY29uZGl0aW9uYWwgPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJfb3BzKG5vX2luKTtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uZGl0aW9uYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogeWVzLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogcGVlaygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfYXNzaWduYWJsZShleHByKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKTtcbiAgICB9O1xuXG4gICAgdmFyIG1heWJlX2Fzc2lnbiA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pLCB2YWwgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBBU1NJR05NRU5UKHZhbCkpIHtcbiAgICAgICAgICAgIGlmIChpc19hc3NpZ25hYmxlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogbWF5YmVfYXNzaWduKG5vX2luKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBhc3NpZ25tZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbW1hcywgbm9faW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGV4cHIgPSBtYXliZV9hc3NpZ24obm9faW4pO1xuICAgICAgICBpZiAoY29tbWFzICYmIGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1NlcSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY2FyICAgIDogZXhwcixcbiAgICAgICAgICAgICAgICBjZHIgICAgOiBleHByZXNzaW9uKHRydWUsIG5vX2luKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBwZWVrKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbl9sb29wKGNvbnQpIHtcbiAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIC0tUy5pbl9sb29wO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcImVvZlwiKSlcbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG4gICAgICAgIHZhciB0b3BsZXZlbCA9IG9wdGlvbnMudG9wbGV2ZWw7XG4gICAgICAgIGlmICh0b3BsZXZlbCkge1xuICAgICAgICAgICAgdG9wbGV2ZWwuYm9keSA9IHRvcGxldmVsLmJvZHkuY29uY2F0KGJvZHkpO1xuICAgICAgICAgICAgdG9wbGV2ZWwuZW5kID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSBuZXcgQVNUX1RvcGxldmVsKHsgc3RhcnQ6IHN0YXJ0LCBib2R5OiBib2R5LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wbGV2ZWw7XG4gICAgfSkoKTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gVHJlZSB0cmFuc2Zvcm1lciBoZWxwZXJzLlxuXG5mdW5jdGlvbiBUcmVlVHJhbnNmb3JtZXIoYmVmb3JlLCBhZnRlcikge1xuICAgIFRyZWVXYWxrZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmJlZm9yZSA9IGJlZm9yZTtcbiAgICB0aGlzLmFmdGVyID0gYWZ0ZXI7XG59XG5UcmVlVHJhbnNmb3JtZXIucHJvdG90eXBlID0gbmV3IFRyZWVXYWxrZXI7XG5cbihmdW5jdGlvbih1bmRlZmluZWQpe1xuXG4gICAgZnVuY3Rpb24gXyhub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKHR3LCBpbl9saXN0KXtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgdHcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0dy5iZWZvcmUpIHggPSB0dy5iZWZvcmUodGhpcywgZGVzY2VuZCwgaW5fbGlzdCk7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0dy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCh4LCB0dyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHcuc3RhY2tbdHcuc3RhY2subGVuZ3RoIC0gMV0gPSB4ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKHgsIHR3KTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHR3LmFmdGVyKHgsIGluX2xpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9fbGlzdChsaXN0LCB0dykge1xuICAgICAgICByZXR1cm4gTUFQKGxpc3QsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHJhbnNmb3JtKHR3LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIF8oQVNUX05vZGUsIG5vb3ApO1xuXG4gICAgXyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmxhYmVsID0gc2VsZi5sYWJlbC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EV0xvb3AsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBpZiAoc2VsZi5pbml0KSBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnN0ZXApIHNlbGYuc3RlcCA9IHNlbGYuc3RlcC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvckluLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuaW5pdCA9IHNlbGYuaW5pdC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLm9iamVjdCA9IHNlbGYub2JqZWN0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9FeGl0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTG9vcENvbnRyb2wsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgaWYgKHNlbGYubGFiZWwpIHNlbGYubGFiZWwgPSBzZWxmLmxhYmVsLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9UcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICAgICAgaWYgKHNlbGYuYmNhdGNoKSBzZWxmLmJjYXRjaCA9IHNlbGYuYmNhdGNoLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSBzZWxmLmJmaW5hbGx5ID0gc2VsZi5iZmluYWxseS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5hcmduYW1lID0gc2VsZi5hcmduYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmRlZmluaXRpb25zID0gZG9fbGlzdChzZWxmLmRlZmluaXRpb25zLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTGFtYmRhLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHNlbGYubmFtZSA9IHNlbGYubmFtZS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ25hbWVzID0gZG9fbGlzdChzZWxmLmFyZ25hbWVzLCB0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ3MgPSBkb19saXN0KHNlbGYuYXJncywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU2VxLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuY2FyID0gc2VsZi5jYXIudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRG90LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLnByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0eS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfVW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5sZWZ0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQXJyYXksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5lbGVtZW50cyA9IGRvX2xpc3Qoc2VsZi5lbGVtZW50cywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYucHJvcGVydGllcyA9IGRvX2xpc3Qoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBTeW1ib2xEZWYoc2NvcGUsIGluZGV4LCBvcmlnKSB7XG4gICAgdGhpcy5uYW1lID0gb3JpZy5uYW1lO1xuICAgIHRoaXMub3JpZyA9IFsgb3JpZyBdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gbnVsbDtcbiAgICB0aGlzLnVuZGVjbGFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxuU3ltYm9sRGVmLnByb3RvdHlwZSA9IHtcbiAgICB1bm1hbmdsZWFibGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdsb2JhbCAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy50b3BsZXZlbCkpXG4gICAgICAgICAgICB8fCB0aGlzLnVuZGVjbGFyZWRcbiAgICAgICAgICAgIHx8ICghKG9wdGlvbnMgJiYgb3B0aW9ucy5ldmFsKSAmJiAodGhpcy5zY29wZS51c2VzX2V2YWwgfHwgdGhpcy5zY29wZS51c2VzX3dpdGgpKTtcbiAgICB9LFxuICAgIG1hbmdsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMubWFuZ2xlZF9uYW1lICYmICF0aGlzLnVubWFuZ2xlYWJsZShvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNjcmV3X2llOCAmJiB0aGlzLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKVxuICAgICAgICAgICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICAgICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gcy5uZXh0X21hbmdsZWQob3B0aW9ucywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZmlndXJlX291dF9zY29wZVwiLCBmdW5jdGlvbigpe1xuICAgIC8vIFRoaXMgZG9lcyB3aGF0IGFzdF9hZGRfc2NvcGUgZGlkIGluIFVnbGlmeUpTIHYxLlxuICAgIC8vXG4gICAgLy8gUGFydCBvZiBpdCBjb3VsZCBiZSBkb25lIGF0IHBhcnNlIHRpbWUsIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlXG4gICAgLy8gdGhlIHBhcnNlciAoYW5kIGl0J3MgYWxyZWFkeSBraW5kYSBjb21wbGV4KS4gIEl0J3MgYWxzbyB3b3J0aFxuICAgIC8vIGhhdmluZyBpdCBzZXBhcmF0ZWQgYmVjYXVzZSB3ZSBtaWdodCBuZWVkIHRvIGNhbGwgaXQgbXVsdGlwbGVcbiAgICAvLyB0aW1lcyBvbiB0aGUgc2FtZSB0cmVlLlxuXG4gICAgLy8gcGFzcyAxOiBzZXR1cCBzY29wZSBjaGFpbmluZyBhbmQgaGFuZGxlIGRlZmluaXRpb25zXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY29wZSA9IHNlbGYucGFyZW50X3Njb3BlID0gbnVsbDtcbiAgICB2YXIgbmVzdGluZyA9IDA7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCl7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLmluaXRfc2NvcGVfdmFycyhuZXN0aW5nKTtcbiAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gbm9kZS5wYXJlbnRfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICsrbmVzdGluZztcbiAgICAgICAgICAgIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgIC0tbmVzdGluZztcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgLy8gZG9uJ3QgZGVzY2VuZCBhZ2FpbiBpbiBUcmVlV2Fsa2VyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBub2RlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBwdXNoX3VuaXEoc2NvcGUuZGlyZWN0aXZlcywgbm9kZS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gc2NvcGU7IHM7IHMgPSBzLnBhcmVudF9zY29wZSlcbiAgICAgICAgICAgICAgICBzLnVzZXNfd2l0aCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICBub2RlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKSB7XG4gICAgICAgICAgICBzY29wZS5kZWZfZnVuY3Rpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1bikge1xuICAgICAgICAgICAgLy8gQ2FyZWZ1bCBoZXJlLCB0aGUgc2NvcGUgd2hlcmUgdGhpcyBzaG91bGQgYmUgZGVmaW5lZCBpc1xuICAgICAgICAgICAgLy8gdGhlIHBhcmVudCBzY29wZS4gIFRoZSByZWFzb24gaXMgdGhhdCB3ZSBlbnRlciBhIG5ld1xuICAgICAgICAgICAgLy8gc2NvcGUgd2hlbiB3ZSBlbmNvdW50ZXIgdGhlIEFTVF9EZWZ1biBub2RlICh3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zdGFuY2VvZiBBU1RfU2NvcGUpIGJ1dCB3ZSBnZXQgdG8gdGhlIHN5bWJvbCBhIGJpdFxuICAgICAgICAgICAgLy8gbGF0ZXIuXG4gICAgICAgICAgICAobm9kZS5zY29wZSA9IHNjb3BlLnBhcmVudF9zY29wZSkuZGVmX2Z1bmN0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sVmFyXG4gICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBzY29wZS5kZWZfdmFyaWFibGUobm9kZSk7XG4gICAgICAgICAgICBkZWYuY29uc3RhbnQgPSBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0O1xuICAgICAgICAgICAgZGVmLmluaXQgPSB0dy5wYXJlbnQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAvLyBYWFg6IHRoaXMgaXMgd3JvbmcgYWNjb3JkaW5nIHRvIEVDTUEtMjYyICgxMi40KS4gIHRoZVxuICAgICAgICAgICAgLy8gYGNhdGNoYCBhcmd1bWVudCBuYW1lIHNob3VsZCBiZSB2aXNpYmxlIG9ubHkgaW5zaWRlIHRoZVxuICAgICAgICAgICAgLy8gY2F0Y2ggYmxvY2suICBGb3IgYSBxdWljayBmaXggQVNUX0NhdGNoIHNob3VsZCBpbmhlcml0XG4gICAgICAgICAgICAvLyBmcm9tIEFTVF9TY29wZS4gIEtlZXBpbmcgaXQgdGhpcyB3YXkgYmVjYXVzZSBvZiBJRSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXNuJ3Qgb2JleSB0aGUgc3RhbmRhcmQuIChpdCBpbnRyb2R1Y2VzIHRoZVxuICAgICAgICAgICAgLy8gaWRlbnRpZmllciBpbiB0aGUgZW5jbG9zaW5nIHNjb3BlKVxuICAgICAgICAgICAgc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZi53YWxrKHR3KTtcblxuICAgIC8vIHBhc3MgMjogZmluZCBiYWNrIHJlZmVyZW5jZXMgYW5kIGV2YWxcbiAgICB2YXIgZnVuYyA9IG51bGw7XG4gICAgdmFyIGdsb2JhbHMgPSBzZWxmLmdsb2JhbHMgPSBuZXcgRGljdGlvbmFyeSgpO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2X2Z1bmMgPSBmdW5jO1xuICAgICAgICAgICAgZnVuYyA9IG5vZGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBmdW5jID0gcHJldl9mdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgIHZhciBzeW0gPSBub2RlLnNjb3BlLmZpbmRfdmFyaWFibGUobmFtZSk7XG4gICAgICAgICAgICBpZiAoIXN5bSkge1xuICAgICAgICAgICAgICAgIHZhciBnO1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBnID0gZ2xvYmFscy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZyA9IG5ldyBTeW1ib2xEZWYoc2VsZiwgZ2xvYmFscy5zaXplKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBnLnVuZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBnLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHMuc2V0KG5hbWUsIGcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnRoZWRlZiA9IGc7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJldmFsXCIgJiYgdHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gbm9kZS5zY29wZTsgcyAmJiAhcy51c2VzX2V2YWw7IHMgPSBzLnBhcmVudF9zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHMudXNlc19ldmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMgJiYgbmFtZSA9PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMudXNlc19hcmd1bWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBzeW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxmLndhbGsodHcpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJpbml0X3Njb3BlX3ZhcnNcIiwgZnVuY3Rpb24obmVzdGluZyl7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gW107ICAgICAvLyBjb250YWlucyB0aGUgZGlyZWN0aXZlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGUsIGkuZS4gXCJ1c2Ugc3RyaWN0XCJcbiAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBEaWN0aW9uYXJ5KCk7IC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xWYXIgKHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGU7IGluY2x1ZGVzIGZ1bmN0aW9ucylcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG5ldyBEaWN0aW9uYXJ5KCk7IC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xEZWZ1biAoZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBzY29wZSlcbiAgICB0aGlzLnVzZXNfd2l0aCA9IGZhbHNlOyAgIC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhpcyBvciBzb21lIG5lc3RlZCBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XG4gICAgdGhpcy51c2VzX2V2YWwgPSBmYWxzZTsgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3IgbmVzdGVkIHNjb3BlIHVzZXMgdGhlIGdsb2JhbCBgZXZhbGBcbiAgICB0aGlzLnBhcmVudF9zY29wZSA9IG51bGw7IC8vIHRoZSBwYXJlbnQgc2NvcGVcbiAgICB0aGlzLmVuY2xvc2VkID0gW107ICAgICAgIC8vIGEgbGlzdCBvZiB2YXJpYWJsZXMgZnJvbSB0aGlzIG9yIG91dGVyIHNjb3BlKHMpIHRoYXQgYXJlIHJlZmVyZW5jZWQgZnJvbSB0aGlzIG9yIGlubmVyIHNjb3Blc1xuICAgIHRoaXMuY25hbWUgPSAtMTsgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgaW5kZXggZm9yIG1hbmdsaW5nIGZ1bmN0aW9ucy92YXJpYWJsZXNcbiAgICB0aGlzLm5lc3RpbmcgPSBuZXN0aW5nOyAgIC8vIHRoZSBuZXN0aW5nIGxldmVsIG9mIHRoaXMgc2NvcGUgKDAgbWVhbnMgdG9wbGV2ZWwpXG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcInN0cmljdFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xufSk7XG5cbkFTVF9MYW1iZGEuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKCl7XG4gICAgQVNUX1Njb3BlLnByb3RvdHlwZS5pbml0X3Njb3BlX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnVzZXNfYXJndW1lbnRzID0gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbFJlZi5ERUZNRVRIT0QoXCJyZWZlcmVuY2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZGVmaW5pdGlvbigpO1xuICAgIGRlZi5yZWZlcmVuY2VzLnB1c2godGhpcyk7XG4gICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgIHdoaWxlIChzKSB7XG4gICAgICAgIHB1c2hfdW5pcShzLmVuY2xvc2VkLCBkZWYpO1xuICAgICAgICBpZiAocyA9PT0gZGVmLnNjb3BlKSBicmVhaztcbiAgICAgICAgcyA9IHMucGFyZW50X3Njb3BlO1xuICAgIH1cbiAgICB0aGlzLmZyYW1lID0gdGhpcy5zY29wZS5uZXN0aW5nIC0gZGVmLnNjb3BlLm5lc3Rpbmc7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImZpbmRfdmFyaWFibGVcIiwgZnVuY3Rpb24obmFtZSl7XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBuYW1lID0gbmFtZS5uYW1lO1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmZpbmRfdmFyaWFibGUobmFtZSkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJoYXNfZGlyZWN0aXZlXCIsIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRfc2NvcGUgJiYgdGhpcy5wYXJlbnRfc2NvcGUuaGFzX2RpcmVjdGl2ZSh2YWx1ZSlcbiAgICAgICAgfHwgKHRoaXMuZGlyZWN0aXZlcy5pbmRleE9mKHZhbHVlKSA+PSAwID8gdGhpcyA6IG51bGwpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfZnVuY3Rpb25cIiwgZnVuY3Rpb24oc3ltYm9sKXtcbiAgICB0aGlzLmZ1bmN0aW9ucy5zZXQoc3ltYm9sLm5hbWUsIHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfdmFyaWFibGVcIiwgZnVuY3Rpb24oc3ltYm9sKXtcbiAgICB2YXIgZGVmO1xuICAgIGlmICghdGhpcy52YXJpYWJsZXMuaGFzKHN5bWJvbC5uYW1lKSkge1xuICAgICAgICBkZWYgPSBuZXcgU3ltYm9sRGVmKHRoaXMsIHRoaXMudmFyaWFibGVzLnNpemUoKSwgc3ltYm9sKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KHN5bWJvbC5uYW1lLCBkZWYpO1xuICAgICAgICBkZWYuZ2xvYmFsID0gIXRoaXMucGFyZW50X3Njb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZiA9IHRoaXMudmFyaWFibGVzLmdldChzeW1ib2wubmFtZSk7XG4gICAgICAgIGRlZi5vcmlnLnB1c2goc3ltYm9sKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbC50aGVkZWYgPSBkZWY7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcIm5leHRfbWFuZ2xlZFwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICB2YXIgZXh0ID0gdGhpcy5lbmNsb3NlZDtcbiAgICBvdXQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBtID0gYmFzZTU0KCsrdGhpcy5jbmFtZSk7XG4gICAgICAgIGlmICghaXNfaWRlbnRpZmllcihtKSkgY29udGludWU7IC8vIHNraXAgb3ZlciBcImRvXCJcbiAgICAgICAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbWFuZ2xlZCBuYW1lIGRvZXMgbm90IHNoYWRvdyBhIG5hbWVcbiAgICAgICAgLy8gZnJvbSBzb21lIHBhcmVudCBzY29wZSB0aGF0IGlzIHJlZmVyZW5jZWQgaW4gdGhpcyBvciBpblxuICAgICAgICAvLyBpbm5lciBzY29wZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSBleHQubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBzeW0gPSBleHRbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHN5bS5tYW5nbGVkX25hbWUgfHwgKHN5bS51bm1hbmdsZWFibGUob3B0aW9ucykgJiYgc3ltLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG0gPT0gbmFtZSkgY29udGludWUgb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0pO1xuXG5BU1RfRnVuY3Rpb24uREVGTUVUSE9EKFwibmV4dF9tYW5nbGVkXCIsIGZ1bmN0aW9uKG9wdGlvbnMsIGRlZil7XG4gICAgLy8gIzE3OSwgIzMyNlxuICAgIC8vIGluIFNhZmFyaSBzdHJpY3QgbW9kZSwgc29tZXRoaW5nIGxpa2UgKGZ1bmN0aW9uIHgoeCl7Li4ufSkgaXMgYSBzeW50YXggZXJyb3I7XG4gICAgLy8gYSBmdW5jdGlvbiBleHByZXNzaW9uJ3MgYXJndW1lbnQgY2Fubm90IHNoYWRvdyB0aGUgZnVuY3Rpb24gZXhwcmVzc2lvbidzIG5hbWVcblxuICAgIHZhciB0cmlja3lfZGVmID0gZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnICYmIHRoaXMubmFtZSAmJiB0aGlzLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gQVNUX0xhbWJkYS5wcm90b3R5cGUubmV4dF9tYW5nbGVkLmNhbGwodGhpcywgb3B0aW9ucywgZGVmKTtcbiAgICAgICAgaWYgKCEodHJpY2t5X2RlZiAmJiB0cmlja3lfZGVmLm1hbmdsZWRfbmFtZSA9PSBuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwicmVmZXJlbmNlc1wiLCBmdW5jdGlvbihzeW0pe1xuICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBzeW0gPSBzeW0uZGVmaW5pdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmVuY2xvc2VkLmluZGV4T2Yoc3ltKSA8IDAgPyBudWxsIDogc3ltO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24oKS51bm1hbmdsZWFibGUob3B0aW9ucyk7XG59KTtcblxuLy8gcHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgbWFuZ2xlYWJsZVxuQVNUX1N5bWJvbEFjY2Vzc29yLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbi8vIGxhYmVscyBhcmUgYWx3YXlzIG1hbmdsZWFibGVcbkFTVF9MYWJlbC5ERUZNRVRIT0QoXCJ1bm1hbmdsZWFibGVcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJ1bnJlZmVyZW5jZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5sZW5ndGggPT0gMFxuICAgICAgICAmJiAhKHRoaXMuc2NvcGUudXNlc19ldmFsIHx8IHRoaXMuc2NvcGUudXNlc193aXRoKTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVuZGVjbGFyZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkudW5kZWNsYXJlZDtcbn0pO1xuXG5BU1RfTGFiZWxSZWYuREVGTUVUSE9EKFwidW5kZWNsYXJlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG5BU1RfTGFiZWwuREVGTUVUSE9EKFwidW5kZWNsYXJlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcImRlZmluaXRpb25cIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy50aGVkZWY7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJnbG9iYWxcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkuZ2xvYmFsO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJfZGVmYXVsdF9tYW5nbGVyX29wdGlvbnNcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgcmV0dXJuIGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZXhjZXB0ICAgOiBbXSxcbiAgICAgICAgZXZhbCAgICAgOiBmYWxzZSxcbiAgICAgICAgc29ydCAgICAgOiBmYWxzZSxcbiAgICAgICAgdG9wbGV2ZWwgOiBmYWxzZSxcbiAgICAgICAgc2NyZXdfaWU4IDogZmFsc2VcbiAgICB9KTtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwibWFuZ2xlX25hbWVzXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKTtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gbWFuZ2xlIGRlY2xhcmF0aW9uIG5vZGVzLiAgU3BlY2lhbCBsb2dpYyB3aXJlZFxuICAgIC8vIGludG8gdGhlIGNvZGUgZ2VuZXJhdG9yIHdpbGwgZGlzcGxheSB0aGUgbWFuZ2xlZCBuYW1lIGlmIGl0J3NcbiAgICAvLyBwcmVzZW50IChhbmQgZm9yIEFTVF9TeW1ib2xSZWYtcyBpdCdsbCB1c2UgdGhlIG1hbmdsZWQgbmFtZSBvZlxuICAgIC8vIHRoZSBBU1RfU3ltYm9sRGVjbGFyYXRpb24gdGhhdCBpdCBwb2ludHMgdG8pLlxuICAgIHZhciBsbmFtZSA9IC0xO1xuICAgIHZhciB0b19tYW5nbGUgPSBbXTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkge1xuICAgICAgICAgICAgLy8gbG5hbWUgaXMgaW5jcmVtZW50ZWQgd2hlbiB3ZSBnZXQgdG8gdGhlIEFTVF9MYWJlbFxuICAgICAgICAgICAgdmFyIHNhdmVfbmVzdGluZyA9IGxuYW1lO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgbG5hbWUgPSBzYXZlX25lc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgIC8vIGRvbid0IGRlc2NlbmQgYWdhaW4gaW4gVHJlZVdhbGtlclxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHR3LnBhcmVudCgpLCBhID0gW107XG4gICAgICAgICAgICBub2RlLnZhcmlhYmxlcy5lYWNoKGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhjZXB0LmluZGV4T2Yoc3ltYm9sLm5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQpIGEuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5yZWZlcmVuY2VzLmxlbmd0aCAtIGEucmVmZXJlbmNlcy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvX21hbmdsZS5wdXNoLmFwcGx5KHRvX21hbmdsZSwgYSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgZG8gbmFtZSA9IGJhc2U1NCgrK2xuYW1lKTsgd2hpbGUgKCFpc19pZGVudGlmaWVyKG5hbWUpKTtcbiAgICAgICAgICAgIG5vZGUubWFuZ2xlZF9uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrKHR3KTtcbiAgICB0b19tYW5nbGUuZm9yRWFjaChmdW5jdGlvbihkZWYpeyBkZWYubWFuZ2xlKG9wdGlvbnMpIH0pO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJjb21wdXRlX2NoYXJfZnJlcXVlbmN5XCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5wcmludF90b19zdHJpbmcoKSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwicmV0dXJuXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Rocm93KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwidGhyb3dcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29udGludWUpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjb250aW51ZVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhaylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImJyZWFrXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlYnVnZ2VyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZGVidWdnZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUudmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1doaWxlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwid2hpbGVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG8pXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJkbyB3aGlsZVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiaWZcIik7XG4gICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGl2ZSkgYmFzZTU0LmNvbnNpZGVyKFwiZWxzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1ZhcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInZhclwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Db25zdClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImNvbnN0XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZ1bmN0aW9uXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZvclwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3JJbilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZvciBpblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJzd2l0Y2hcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FzZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImNhc2VcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImRlZmF1bHRcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfV2l0aClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcIndpdGhcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0U2V0dGVyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwic2V0XCIgKyBub2RlLmtleSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0R2V0dGVyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZ2V0XCIgKyBub2RlLmtleSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUua2V5KTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9OZXcpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJuZXdcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInRoaXNcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ5KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwidHJ5XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NhdGNoKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiY2F0Y2hcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRmluYWxseSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZpbmFsbHlcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sICYmIG5vZGUudW5tYW5nbGVhYmxlKG9wdGlvbnMpKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUubmFtZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnkgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5vcGVyYXRvcik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG90KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUucHJvcGVydHkpO1xuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG4gICAgYmFzZTU0LnNvcnQoKTtcbn0pO1xuXG52YXIgYmFzZTU0ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXzAxMjM0NTY3ODlcIjtcbiAgICB2YXIgY2hhcnMsIGZyZXF1ZW5jeTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgZnJlcXVlbmN5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY2hhcnMgPSBzdHJpbmcuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGNoKXsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgfSk7XG4gICAgICAgIGNoYXJzLmZvckVhY2goZnVuY3Rpb24oY2gpeyBmcmVxdWVuY3lbY2hdID0gMCB9KTtcbiAgICB9XG4gICAgYmFzZTU0LmNvbnNpZGVyID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlIGluIGZyZXF1ZW5jeSkgKytmcmVxdWVuY3lbY29kZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGJhc2U1NC5zb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNoYXJzID0gbWVyZ2VTb3J0KGNoYXJzLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgIGlmIChpc19kaWdpdChhKSAmJiAhaXNfZGlnaXQoYikpIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGlzX2RpZ2l0KGIpICYmICFpc19kaWdpdChhKSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIGZyZXF1ZW5jeVtiXSAtIGZyZXF1ZW5jeVthXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBiYXNlNTQucmVzZXQgPSByZXNldDtcbiAgICByZXNldCgpO1xuICAgIGJhc2U1NC5nZXQgPSBmdW5jdGlvbigpeyByZXR1cm4gY2hhcnMgfTtcbiAgICBiYXNlNTQuZnJlcSA9IGZ1bmN0aW9uKCl7IHJldHVybiBmcmVxdWVuY3kgfTtcbiAgICBmdW5jdGlvbiBiYXNlNTQobnVtKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBiYXNlID0gNTQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJzW251bSAlIGJhc2VdKTtcbiAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gYmFzZSk7XG4gICAgICAgICAgICBiYXNlID0gNjQ7XG4gICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgcmV0dXJuIGJhc2U1NDtcbn0pKCk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJzY29wZV93YXJuaW5nc1wiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICB1bmRlY2xhcmVkICAgICAgIDogZmFsc2UsIC8vIHRoaXMgbWFrZXMgYSBsb3Qgb2Ygbm9pc2VcbiAgICAgICAgdW5yZWZlcmVuY2VkICAgICA6IHRydWUsXG4gICAgICAgIGFzc2lnbl90b19nbG9iYWwgOiB0cnVlLFxuICAgICAgICBmdW5jX2FyZ3VtZW50cyAgIDogdHJ1ZSxcbiAgICAgICAgbmVzdGVkX2RlZnVucyAgICA6IHRydWUsXG4gICAgICAgIGV2YWwgICAgICAgICAgICAgOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIGlmIChvcHRpb25zLnVuZGVjbGFyZWRcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBub2RlLnVuZGVjbGFyZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gWFhYOiB0aGlzIGFsc28gd2FybnMgYWJvdXQgSlMgc3RhbmRhcmQgbmFtZXMsXG4gICAgICAgICAgICAvLyBpLmUuIE9iamVjdCwgQXJyYXksIHBhcnNlSW50IGV0Yy4gIFNob3VsZCBhZGQgYSBsaXN0IG9mXG4gICAgICAgICAgICAvLyBleGNlcHRpb25zLlxuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIlVuZGVjbGFyZWQgc3ltYm9sOiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ25fdG9fZ2xvYmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3ltID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiBub2RlLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgIHN5bSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgbm9kZS5pbml0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICBzeW0gPSBub2RlLmluaXQ7XG4gICAgICAgICAgICBpZiAoc3ltXG4gICAgICAgICAgICAgICAgJiYgKHN5bS51bmRlY2xhcmVkKClcbiAgICAgICAgICAgICAgICAgICAgfHwgKHN5bS5nbG9iYWwoKSAmJiBzeW0uc2NvcGUgIT09IHN5bS5kZWZpbml0aW9uKCkuc2NvcGUpKSkge1xuICAgICAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJ7bXNnfToge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogc3ltLnVuZGVjbGFyZWQoKSA/IFwiQWNjaWRlbnRhbCBnbG9iYWw/XCIgOiBcIkFzc2lnbm1lbnQgdG8gZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBzeW0uc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3ltLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogc3ltLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV2YWxcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBub2RlLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgJiYgbm9kZS5uYW1lID09IFwiZXZhbFwiKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiRXZhbCBpcyB1c2VkIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy51bnJlZmVyZW5jZWRcbiAgICAgICAgICAgICYmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpXG4gICAgICAgICAgICAmJiBub2RlLnVucmVmZXJlbmNlZCgpKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwie3R5cGV9IHtuYW1lfSBpcyBkZWNsYXJlZCBidXQgbm90IHJlZmVyZW5jZWQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsID8gXCJMYWJlbFwiIDogXCJTeW1ib2xcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mdW5jX2FyZ3VtZW50c1xuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICYmIG5vZGUudXNlc19hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJhcmd1bWVudHMgdXNlZCBpbiBmdW5jdGlvbiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUgPyBub2RlLm5hbWUubmFtZSA6IFwiYW5vbnltb3VzXCIsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5uZXN0ZWRfZGVmdW5zXG4gICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuXG4gICAgICAgICAgICAmJiAhKHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1Njb3BlKSkge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIkZ1bmN0aW9uIHtuYW1lfSBkZWNsYXJlZCBpbiBuZXN0ZWQgc3RhdGVtZW50IFxcXCJ7dHlwZX1cXFwiIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHcucGFyZW50KCkuVFlQRSxcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrKHR3KTtcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBPdXRwdXRTdHJlYW0ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgaW5kZW50X3N0YXJ0ICA6IDAsXG4gICAgICAgIGluZGVudF9sZXZlbCAgOiA0LFxuICAgICAgICBxdW90ZV9rZXlzICAgIDogZmFsc2UsXG4gICAgICAgIHNwYWNlX2NvbG9uICAgOiB0cnVlLFxuICAgICAgICBhc2NpaV9vbmx5ICAgIDogZmFsc2UsXG4gICAgICAgIGlubGluZV9zY3JpcHQgOiBmYWxzZSxcbiAgICAgICAgd2lkdGggICAgICAgICA6IDgwLFxuICAgICAgICBtYXhfbGluZV9sZW4gIDogMzIwMDAsXG4gICAgICAgIGJlYXV0aWZ5ICAgICAgOiBmYWxzZSxcbiAgICAgICAgc291cmNlX21hcCAgICA6IG51bGwsXG4gICAgICAgIGJyYWNrZXRpemUgICAgOiBmYWxzZSxcbiAgICAgICAgc2VtaWNvbG9ucyAgICA6IHRydWUsXG4gICAgICAgIGNvbW1lbnRzICAgICAgOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVfbGluZSA6IGZhbHNlLFxuICAgICAgICBzY3Jld19pZTggICAgIDogZmFsc2UsXG4gICAgICAgIHByZWFtYmxlICAgICAgOiBudWxsLFxuICAgIH0sIHRydWUpO1xuXG4gICAgdmFyIGluZGVudGF0aW9uID0gMDtcbiAgICB2YXIgY3VycmVudF9jb2wgPSAwO1xuICAgIHZhciBjdXJyZW50X2xpbmUgPSAxO1xuICAgIHZhciBjdXJyZW50X3BvcyA9IDA7XG4gICAgdmFyIE9VVFBVVCA9IFwiXCI7XG5cbiAgICBmdW5jdGlvbiB0b19hc2NpaShzdHIsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx1MDA4MC1cXHVmZmZmXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA8PSAyICYmICFpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDwgMikgY29kZSA9IFwiMFwiICsgY29kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxceFwiICsgY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDwgNCkgY29kZSA9IFwiMFwiICsgY29kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdVwiICsgY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2Vfc3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgZHEgPSAwLCBzcSA9IDA7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcYlxcZlxcblxcclxcdFxceDIyXFx4MjdcXHUyMDI4XFx1MjAyOVxcMF0vZywgZnVuY3Rpb24ocyl7XG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcYlwiOiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxmXCI6IHJldHVybiBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjogcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOiByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOiByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjogcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICAgIGNhc2UgJ1wiJzogKytkcTsgcmV0dXJuICdcIic7XG4gICAgICAgICAgICAgIGNhc2UgXCInXCI6ICsrc3E7IHJldHVybiBcIidcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcMFwiOiByZXR1cm4gXCJcXFxceDAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpIHN0ciA9IHRvX2FzY2lpKHN0cik7XG4gICAgICAgIGlmIChkcSA+IHNxKSByZXR1cm4gXCInXCIgKyBzdHIucmVwbGFjZSgvXFx4MjcvZywgXCJcXFxcJ1wiKSArIFwiJ1wiO1xuICAgICAgICBlbHNlIHJldHVybiAnXCInICsgc3RyLnJlcGxhY2UoL1xceDIyL2csICdcXFxcXCInKSArICdcIic7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuY29kZV9zdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciByZXQgPSBtYWtlX3N0cmluZyhzdHIpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmxpbmVfc2NyaXB0KVxuICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLzxcXHgyZnNjcmlwdChbPlxcL1xcdFxcblxcZlxcciBdKS9naSwgXCI8XFxcXC9zY3JpcHQkMVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9uYW1lKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNjaWlfb25seSlcbiAgICAgICAgICAgIG5hbWUgPSB0b19hc2NpaShuYW1lLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfaW5kZW50KGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHJlcGVhdF9zdHJpbmcoXCIgXCIsIG9wdGlvbnMuaW5kZW50X3N0YXJ0ICsgaW5kZW50YXRpb24gLSBiYWNrICogb3B0aW9ucy5pbmRlbnRfbGV2ZWwpO1xuICAgIH07XG5cbiAgICAvKiAtLS0tLVsgYmVhdXRpZmljYXRpb24vbWluaWZpY2F0aW9uIF0tLS0tLSAqL1xuXG4gICAgdmFyIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICB2YXIgbWlnaHRfbmVlZF9zZW1pY29sb24gPSBmYWxzZTtcbiAgICB2YXIgbGFzdCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBsYXN0X2NoYXIoKSB7XG4gICAgICAgIHJldHVybiBsYXN0LmNoYXJBdChsYXN0Lmxlbmd0aCAtIDEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZV9uZXdsaW5lKCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhfbGluZV9sZW4gJiYgY3VycmVudF9jb2wgPiBvcHRpb25zLm1heF9saW5lX2xlbilcbiAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWlyZVNlbWljb2xvbkNoYXJzID0gbWFrZVByZWRpY2F0ZShcIiggWyArICogLyAtICwgLlwiKTtcblxuICAgIGZ1bmN0aW9uIHByaW50KHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKG1pZ2h0X25lZWRfc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICBpZiAoKCFjaCB8fCBcIjt9XCIuaW5kZXhPZihjaCkgPCAwKSAmJiAhL1s7XSQvLnRlc3QobGFzdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZW1pY29sb25zIHx8IHJlcXVpcmVTZW1pY29sb25DaGFycyhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCsrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2xpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYmVhdXRpZnkpXG4gICAgICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgICAgICBtYXliZV9uZXdsaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYmVhdXRpZnkgJiYgb3B0aW9ucy5wcmVzZXJ2ZV9saW5lICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0X2xpbmUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5zdGFydC5saW5lO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfbGluZSA8IHRhcmdldF9saW5lKSB7XG4gICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50X2xpbmUrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCA9IDA7XG4gICAgICAgICAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pZ2h0X25lZWRfc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbGFzdF9jaGFyKCk7XG4gICAgICAgICAgICBpZiAoKGlzX2lkZW50aWZpZXJfY2hhcihwcmV2KVxuICAgICAgICAgICAgICAgICAmJiAoaXNfaWRlbnRpZmllcl9jaGFyKGNoKSB8fCBjaCA9PSBcIlxcXFxcIikpXG4gICAgICAgICAgICAgICAgfHwgKC9eW1xcK1xcLVxcL10kLy50ZXN0KGNoKSAmJiBjaCA9PSBwcmV2KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgY3VycmVudF9jb2wrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gc3RyLnNwbGl0KC9cXHI/XFxuLyksIG4gPSBhLmxlbmd0aCAtIDE7XG4gICAgICAgIGN1cnJlbnRfbGluZSArPSBuO1xuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50X2NvbCArPSBhW25dLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRfY29sID0gYVtuXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudF9wb3MgKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgbGFzdCA9IHN0cjtcbiAgICAgICAgT1VUUFVUICs9IHN0cjtcbiAgICB9O1xuXG4gICAgdmFyIHNwYWNlID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmludChcIiBcIik7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGluZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihoYWxmKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJlYXV0aWZ5KSB7XG4gICAgICAgICAgICBwcmludChtYWtlX2luZGVudChoYWxmID8gMC41IDogMCkpO1xuICAgICAgICB9XG4gICAgfSA6IG5vb3A7XG5cbiAgICB2YXIgd2l0aF9pbmRlbnQgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oY29sLCBjb250KSB7XG4gICAgICAgIGlmIChjb2wgPT09IHRydWUpIGNvbCA9IG5leHRfaW5kZW50KCk7XG4gICAgICAgIHZhciBzYXZlX2luZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgICAgIGluZGVudGF0aW9uID0gY29sO1xuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICBpbmRlbnRhdGlvbiA9IHNhdmVfaW5kZW50YXRpb247XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSA6IGZ1bmN0aW9uKGNvbCwgY29udCkgeyByZXR1cm4gY29udCgpIH07XG5cbiAgICB2YXIgbmV3bGluZSA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCJcXG5cIik7XG4gICAgfSA6IG5vb3A7XG5cbiAgICB2YXIgc2VtaWNvbG9uID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmludChcIjtcIik7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IHRydWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3NlbWljb2xvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgcHJpbnQoXCI7XCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBuZXh0X2luZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudGF0aW9uICsgb3B0aW9ucy5pbmRlbnRfbGV2ZWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpdGhfYmxvY2soY29udCkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBwcmludChcIntcIik7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgd2l0aF9pbmRlbnQobmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldCA9IGNvbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGVudCgpO1xuICAgICAgICBwcmludChcIn1cIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpdGhfcGFyZW5zKGNvbnQpIHtcbiAgICAgICAgcHJpbnQoXCIoXCIpO1xuICAgICAgICAvL1hYWDogc3RpbGwgbmljZSB0byBoYXZlIHRoYXQgZm9yIGFyZ3VtZW50IGxpc3RzXG4gICAgICAgIC8vdmFyIHJldCA9IHdpdGhfaW5kZW50KGN1cnJlbnRfY29sLCBjb250KTtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgcHJpbnQoXCIpXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX3NxdWFyZShjb250KSB7XG4gICAgICAgIHByaW50KFwiW1wiKTtcbiAgICAgICAgLy92YXIgcmV0ID0gd2l0aF9pbmRlbnQoY3VycmVudF9jb2wsIGNvbnQpO1xuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICBwcmludChcIl1cIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbW1hKCkge1xuICAgICAgICBwcmludChcIixcIik7XG4gICAgICAgIHNwYWNlKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbG9uKCkge1xuICAgICAgICBwcmludChcIjpcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNwYWNlX2NvbG9uKSBzcGFjZSgpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkX21hcHBpbmcgPSBvcHRpb25zLnNvdXJjZV9tYXAgPyBmdW5jdGlvbih0b2tlbiwgbmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRva2VuKSBvcHRpb25zLnNvdXJjZV9tYXAuYWRkKFxuICAgICAgICAgICAgICAgIHRva2VuLmZpbGUgfHwgXCI/XCIsXG4gICAgICAgICAgICAgICAgY3VycmVudF9saW5lLCBjdXJyZW50X2NvbCxcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5lLCB0b2tlbi5jb2wsXG4gICAgICAgICAgICAgICAgKCFuYW1lICYmIHRva2VuLnR5cGUgPT0gXCJuYW1lXCIpID8gdG9rZW4udmFsdWUgOiBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiQ291bGRuJ3QgZmlndXJlIG91dCBtYXBwaW5nIGZvciB7ZmlsZX06e2xpbmV9LHtjb2x9IOKGkiB7Y2xpbmV9LHtjY29sfSBbe25hbWV9XVwiLCB7XG4gICAgICAgICAgICAgICAgZmlsZTogdG9rZW4uZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogdG9rZW4uY29sLFxuICAgICAgICAgICAgICAgIGNsaW5lOiBjdXJyZW50X2xpbmUsXG4gICAgICAgICAgICAgICAgY2NvbDogY3VycmVudF9jb2wsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBcIlwiXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSA6IG5vb3A7XG5cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPVVRQVVQ7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICAgIHByaW50KG9wdGlvbnMucHJlYW1ibGUucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldfFxccyokL2csIFwiXFxuXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgICAgICAgICAgICAgOiBnZXQsXG4gICAgICAgIHRvU3RyaW5nICAgICAgICA6IGdldCxcbiAgICAgICAgaW5kZW50ICAgICAgICAgIDogaW5kZW50LFxuICAgICAgICBpbmRlbnRhdGlvbiAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGluZGVudGF0aW9uIH0sXG4gICAgICAgIGN1cnJlbnRfd2lkdGggICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9jb2wgLSBpbmRlbnRhdGlvbiB9LFxuICAgICAgICBzaG91bGRfYnJlYWsgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbnMud2lkdGggJiYgdGhpcy5jdXJyZW50X3dpZHRoKCkgPj0gb3B0aW9ucy53aWR0aCB9LFxuICAgICAgICBuZXdsaW5lICAgICAgICAgOiBuZXdsaW5lLFxuICAgICAgICBwcmludCAgICAgICAgICAgOiBwcmludCxcbiAgICAgICAgc3BhY2UgICAgICAgICAgIDogc3BhY2UsXG4gICAgICAgIGNvbW1hICAgICAgICAgICA6IGNvbW1hLFxuICAgICAgICBjb2xvbiAgICAgICAgICAgOiBjb2xvbixcbiAgICAgICAgbGFzdCAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBsYXN0IH0sXG4gICAgICAgIHNlbWljb2xvbiAgICAgICA6IHNlbWljb2xvbixcbiAgICAgICAgZm9yY2Vfc2VtaWNvbG9uIDogZm9yY2Vfc2VtaWNvbG9uLFxuICAgICAgICB0b19hc2NpaSAgICAgICAgOiB0b19hc2NpaSxcbiAgICAgICAgcHJpbnRfbmFtZSAgICAgIDogZnVuY3Rpb24obmFtZSkgeyBwcmludChtYWtlX25hbWUobmFtZSkpIH0sXG4gICAgICAgIHByaW50X3N0cmluZyAgICA6IGZ1bmN0aW9uKHN0cikgeyBwcmludChlbmNvZGVfc3RyaW5nKHN0cikpIH0sXG4gICAgICAgIG5leHRfaW5kZW50ICAgICA6IG5leHRfaW5kZW50LFxuICAgICAgICB3aXRoX2luZGVudCAgICAgOiB3aXRoX2luZGVudCxcbiAgICAgICAgd2l0aF9ibG9jayAgICAgIDogd2l0aF9ibG9jayxcbiAgICAgICAgd2l0aF9wYXJlbnMgICAgIDogd2l0aF9wYXJlbnMsXG4gICAgICAgIHdpdGhfc3F1YXJlICAgICA6IHdpdGhfc3F1YXJlLFxuICAgICAgICBhZGRfbWFwcGluZyAgICAgOiBhZGRfbWFwcGluZyxcbiAgICAgICAgb3B0aW9uICAgICAgICAgIDogZnVuY3Rpb24ob3B0KSB7IHJldHVybiBvcHRpb25zW29wdF0gfSxcbiAgICAgICAgbGluZSAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X2xpbmUgfSxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X2NvbCB9LFxuICAgICAgICBwb3MgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfcG9zIH0sXG4gICAgICAgIHB1c2hfbm9kZSAgICAgICA6IGZ1bmN0aW9uKG5vZGUpIHsgc3RhY2sucHVzaChub2RlKSB9LFxuICAgICAgICBwb3Bfbm9kZSAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrLnBvcCgpIH0sXG4gICAgICAgIHN0YWNrICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhY2sgfSxcbiAgICAgICAgcGFyZW50ICAgICAgICAgIDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDIgLSAobiB8fCAwKV07XG4gICAgICAgIH1cbiAgICB9O1xuXG59O1xuXG4vKiAtLS0tLVsgY29kZSBnZW5lcmF0b3JzIF0tLS0tLSAqL1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIC8qIC0tLS0tWyB1dGlscyBdLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIERFRlBSSU5UKG5vZGV0eXBlLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgbm9kZXR5cGUuREVGTUVUSE9EKFwiX2NvZGVnZW5cIiwgZ2VuZXJhdG9yKTtcbiAgICB9O1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRcIiwgZnVuY3Rpb24oc3RyZWFtLCBmb3JjZV9wYXJlbnMpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGdlbmVyYXRvciA9IHNlbGYuX2NvZGVnZW47XG4gICAgICAgIGZ1bmN0aW9uIGRvaXQoKSB7XG4gICAgICAgICAgICBzZWxmLmFkZF9jb21tZW50cyhzdHJlYW0pO1xuICAgICAgICAgICAgc2VsZi5hZGRfc291cmNlX21hcChzdHJlYW0pO1xuICAgICAgICAgICAgZ2VuZXJhdG9yKHNlbGYsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnB1c2hfbm9kZShzZWxmKTtcbiAgICAgICAgaWYgKGZvcmNlX3BhcmVucyB8fCBzZWxmLm5lZWRzX3BhcmVucyhzdHJlYW0pKSB7XG4gICAgICAgICAgICBzdHJlYW0ud2l0aF9wYXJlbnMoZG9pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2l0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvcF9ub2RlKCk7XG4gICAgfSk7XG5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJwcmludF90b19zdHJpbmdcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAgIHZhciBzID0gT3V0cHV0U3RyZWFtKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByaW50KHMpO1xuICAgICAgICByZXR1cm4gcy5nZXQoKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBjb21tZW50cyBdLS0tLS0gKi9cblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImFkZF9jb21tZW50c1wiLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgYyA9IG91dHB1dC5vcHRpb24oXCJjb21tZW50c1wiKSwgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBzZWxmLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICYmICFzdGFydC5fY29tbWVudHNfZHVtcGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQuX2NvbW1lbnRzX2R1bXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gc3RhcnQuY29tbWVudHNfYmVmb3JlIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gWFhYOiB1Z2x5IGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzExMlxuICAgICAgICAgICAgICAgIC8vICAgICAgaWYgdGhpcyBub2RlIGlzIGByZXR1cm5gIG9yIGB0aHJvd2AsIHdlIGNhbm5vdCBhbGxvdyBjb21tZW50cyBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgIHRoZSByZXR1cm5lZCBvciB0aHJvd24gdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfRXhpdCAmJiBzZWxmLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoc2VsZi52YWx1ZS5zdGFydC5jb21tZW50c19iZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5maWx0ZXIoZnVuY3Rpb24oY29tbWVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy50ZXN0KGNvbW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmZpbHRlcihmdW5jdGlvbihjb21tZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjKHNlbGYsIGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWVudHMuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9jb21tZW50WzEzNF0vLnRlc3QoYy50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLy9cIiArIGMudmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjLnR5cGUgPT0gXCJjb21tZW50MlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIvKlwiICsgYy52YWx1ZSArIFwiKi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQubmxiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIFBBUkVOVEhFU0VTIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gUEFSRU5TKG5vZGV0eXBlLCBmdW5jKSB7XG4gICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIm5lZWRzX3BhcmVuc1wiLCBmdW5jKTtcbiAgICB9O1xuXG4gICAgUEFSRU5TKEFTVF9Ob2RlLCBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBhIGZ1bmN0aW9uIGV4cHJlc3Npb24gbmVlZHMgcGFyZW5zIGFyb3VuZCBpdCB3aGVuIGl0J3MgcHJvdmFibHlcbiAgICAvLyB0aGUgZmlyc3QgdG9rZW4gdG8gYXBwZWFyIGluIGEgc3RhdGVtZW50LlxuICAgIFBBUkVOUyhBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHJldHVybiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8vIHNhbWUgZ29lcyBmb3IgYW4gb2JqZWN0IGxpdGVyYWwsIGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IHdvdWxkIGJlXG4gICAgLy8gaW50ZXJwcmV0ZWQgYXMgYSBibG9jayBvZiBjb2RlLlxuICAgIFBBUkVOUyhBU1RfT2JqZWN0LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICByZXR1cm4gZmlyc3RfaW5fc3RhdGVtZW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1VuYXJ5LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXM7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1NlcSwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX0NhbGwgICAgICAgICAgICAgLy8gKGZvbywgYmFyKSgpIG9yIGZvbygxLCAoMiwgMyksIDQpXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1VuYXJ5ICAgICAgICAgICAgLy8gIShmb28sIGJhciwgYmF6KVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgICAgICAgICAgIC8vIDEgKyAoMiwgMykgKyA0ID09PiA4XG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1ZhckRlZiAgICAgICAgICAgLy8gdmFyIGEgPSAoMSwgMiksIGIgPSBhICsgYTsgPT0+IGIgPT0gNFxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Eb3QgICAgICAgICAgICAgIC8vICgxLCB7Zm9vOjJ9KS5mb28gPT0+IDJcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQXJyYXkgICAgICAgICAgICAvLyBbIDEsICgyLCAzKSwgNCBdID09PiBbIDEsIDMsIDQgXVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAgIC8vIHsgZm9vOiAoMSwgMikgfS5mb28gPT0+IDJcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgICAgICAvKiAoZmFsc2UsIHRydWUpID8gKGEgPSAxMCwgYiA9IDIwKSA6IChjID0gMzApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogPT0+IDIwIChzaWRlIGVmZmVjdCwgc2V0IGEgOj0gMTAgYW5kIGIgOj0gMjApICovXG4gICAgICAgIDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQmluYXJ5LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gKGZvbyAmJiBiYXIpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdHlwZW9mIChmb28gJiYgYmFyKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoZm9vICYmIGJhcilbXCJwcm9wXCJdLCAoZm9vICYmIGJhcikucHJvcFxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB0aGlzIGRlYWxzIHdpdGggcHJlY2VkZW5jZTogMyAqICgyICsgMSlcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICB2YXIgcG8gPSBwLm9wZXJhdG9yLCBwcCA9IFBSRUNFREVOQ0VbcG9dO1xuICAgICAgICAgICAgdmFyIHNvID0gdGhpcy5vcGVyYXRvciwgc3AgPSBQUkVDRURFTkNFW3NvXTtcbiAgICAgICAgICAgIGlmIChwcCA+IHNwXG4gICAgICAgICAgICAgICAgfHwgKHBwID09IHNwXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMgPT09IHAucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX05ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIC8vIGkuZS4gbmV3IChmb28uYmFyKCkuYmF6KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgb25lIGNhbGwgaW50byB0aGlzIHN1YnRyZWUsIHRoZW4gd2UgbmVlZFxuICAgICAgICAgICAgLy8gcGFyZW5zIGFyb3VuZCBpdCB0b28sIG90aGVyd2lzZSB0aGUgY2FsbCB3aWxsIGJlXG4gICAgICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIHVwcGVyIE5ld1xuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB0aHJvdyBwO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggIT09IHApIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0NhbGwsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpLCBwMTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIFNhZmFyaSBidWcuXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM1MDZcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXNcbiAgICAgICAgICAgICYmIChwMSA9IG91dHB1dC5wYXJlbnQoMSkpIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgcDEubGVmdCA9PT0gcDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTmV3LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKG5vX2NvbnN0cnVjdG9yX3BhcmVucyh0aGlzLCBvdXRwdXQpXG4gICAgICAgICAgICAmJiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIC8vIChuZXcgRGF0ZSkuZ2V0VGltZSgpLCAobmV3IERhdGUpW1wiZ2V0VGltZVwiXSgpXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykpIC8vIChuZXcgZm9vKShiYXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTnVtYmVyLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA8IDAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9OYU4sIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYXNzaWduX2FuZF9jb25kaXRpb25hbF9wYXJlbl9ydWxlcyhvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vICEoYSA9IGZhbHNlKSDihpIgdHJ1ZVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAxICsgKGEgPSAyKSArIDMg4oaSIDYsIHNpZGUgZWZmZWN0IHNldHRpbmcgYSA9IDJcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmICEocCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZnVuYykoKSDigJRvcuKAlCBuZXcgKGEgPSBPYmplY3QpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmb28pID8gYmFyIDogYmF6XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZm9vKVtcInByb3BcIl0g4oCUb3LigJQgKGEgPSBmb28pLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgUEFSRU5TKEFTVF9Bc3NpZ24sIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuICAgIFBBUkVOUyhBU1RfQ29uZGl0aW9uYWwsIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuXG4gICAgLyogLS0tLS1bIFBSSU5URVJTIF0tLS0tLSAqL1xuXG4gICAgREVGUFJJTlQoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLnZhbHVlKTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVidWdnZXJcIik7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheV9ib2R5KGJvZHksIGlzX3RvcGxldmVsLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKXtcbiAgICAgICAgICAgIGlmICghKHN0bXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpID09IGxhc3QgJiYgaXNfdG9wbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc190b3BsZXZlbCkgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBU1RfU3RhdGVtZW50V2l0aEJvZHkuREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHRoaXMuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1RvcGxldmVsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHJpbnRfYnJhY2tldGVkKGJvZHksIG91dHB1dCkge1xuICAgICAgICBpZiAoYm9keS5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGlzcGxheV9ib2R5KGJvZHksIGZhbHNlLCBvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRG8sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImRvXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1doaWxlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aGlsZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZm9yXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoc2VsZi5pbml0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi5pbml0LCBvdXRwdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc3RlcCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RlcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRm9ySW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImluXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2l0aFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGZ1bmN0aW9ucyBdLS0tLS0gKi9cbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIG5va2V5d29yZCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFub2tleXdvcmQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgYXJnLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhpdHMgXS0tLS0tICovXG4gICAgQVNUX0V4aXQuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUmV0dXJuLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwicmV0dXJuXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UaHJvdywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInRocm93XCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxvb3AgY29udHJvbCBdLS0tLS0gKi9cbiAgICBBU1RfTG9vcENvbnRyb2wuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQnJlYWssIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJicmVha1wiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29udGludWUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb250aW51ZVwiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBpZiBdLS0tLS0gKi9cbiAgICBmdW5jdGlvbiBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYnJhY2tldGl6ZVwiKSkge1xuICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2tldHMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXNlbGYuYm9keSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRG9cbiAgICAgICAgICAgICYmICFvdXRwdXQub3B0aW9uKFwic2NyZXdfaWU4XCIpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8jaXNzdWUvNTcgSUVcbiAgICAgICAgICAgIC8vIGNyb2FrcyB3aXRoIFwic3ludGF4IGVycm9yXCIgb24gY29kZSBsaWtlIHRoaXM6IGlmIChmb28pXG4gICAgICAgICAgICAvLyBkbyAuLi4gd2hpbGUoY29uZCk7IGVsc2UgLi4uICB3ZSBuZWVkIGJsb2NrIGJyYWNrZXRzXG4gICAgICAgICAgICAvLyBhcm91bmQgZG8vd2hpbGVcbiAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gc2VsZi5ib2R5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IGIuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFdpdGhCb2R5KSB7XG4gICAgICAgICAgICAgICAgYiA9IGIuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaWZcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIG1ha2VfdGhlbihzZWxmLCBvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJlbHNlXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBmb3JjZV9zdGF0ZW1lbnQoc2VsZi5hbHRlcm5hdGl2ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHN3aXRjaCBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJzd2l0Y2hcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgIH0pO1xuICAgIEFTVF9Td2l0Y2hCcmFuY2guREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCl7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRGVmYXVsdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVmYXVsdDpcIik7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiY2FzZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI6XCIpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhjZXB0aW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ0cnlcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5iY2F0Y2gucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmJmaW5hbGx5LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhdGNoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9GaW5hbGx5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmaW5hbGx5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyB2YXIvY29uc3QgXS0tLS0tICovXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpKXtcbiAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIGRlZi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHZhciBpbl9mb3IgPSBwIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBwIGluc3RhbmNlb2YgQVNUX0ZvckluO1xuICAgICAgICB2YXIgYXZvaWRfc2VtaWNvbG9uID0gaW5fZm9yICYmIHAuaW5pdCA9PT0gdGhpcztcbiAgICAgICAgaWYgKCFhdm9pZF9zZW1pY29sb24pXG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ZhciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInZhclwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uc3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb25zdFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZV9mb3Jfbm9pbihub2RlLCBvdXRwdXQsIG5vaW4pIHtcbiAgICAgICAgaWYgKCFub2luKSBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgIGVsc2UgdHJ5IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdGFrZSBzb21lIHByZWNhdXRpb25zIGhlcmU6XG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNjBcbiAgICAgICAgICAgIG5vZGUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PSBcImluXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG91dHB1dDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5vZGUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBvdXRwdXQpIHRocm93IGV4O1xuICAgICAgICAgICAgbm9kZS5wcmludChvdXRwdXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERFRlBSSU5UKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoMSk7XG4gICAgICAgICAgICB2YXIgbm9pbiA9IHAgaW5zdGFuY2VvZiBBU1RfRm9yIHx8IHAgaW5zdGFuY2VvZiBBU1RfRm9ySW47XG4gICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi52YWx1ZSwgb3V0cHV0LCBub2luKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIG90aGVyIGV4cHJlc3Npb25zIF0tLS0tLSAqL1xuICAgIERFRlBSSU5UKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIG5vX2NvbnN0cnVjdG9yX3BhcmVucyhzZWxmLCBvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwibmV3XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgQVNUX0NhbGwucHJvdG90eXBlLl9jb2RlZ2VuKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBBU1RfU2VxLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB0aGlzLmNhci5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5jZHIpIHtcbiAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5zaG91bGRfYnJlYWsoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TZXEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gICAgIG91dHB1dC53aXRoX2luZGVudChvdXRwdXQubmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIGV4cHIuZ2V0VmFsdWUoKSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoIS9beGEtZi5dL2kudGVzdChvdXRwdXQubGFzdCgpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgLy8gdGhlIG5hbWUgYWZ0ZXIgZG90IHdvdWxkIGJlIG1hcHBlZCBhYm91dCBoZXJlLlxuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5lbmQpO1xuICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShzZWxmLnByb3BlcnR5KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiW1wiKTtcbiAgICAgICAgc2VsZi5wcm9wZXJ0eS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJdXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5vcGVyYXRvcjtcbiAgICAgICAgb3V0cHV0LnByaW50KG9wKTtcbiAgICAgICAgaWYgKC9eW2Etel0vaS50ZXN0KG9wKSlcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IpO1xuICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIjxcIlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcIiFcIlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmV4cHJlc3Npb24ub3BlcmF0b3IgPT0gXCItLVwiKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBpcyBtYW5kYXRvcnkgdG8gYXZvaWQgb3V0cHV0dGluZyA8IS0tXG4gICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5zcGVjLndoYXR3Zy5vcmcvI2NvbW1lbnQtc3ludGF4XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlIHNwYWNlIGlzIG9wdGlvbmFsIGRlcGVuZGluZyBvbiBcImJlYXV0aWZ5XCJcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI/XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5jb25zZXF1ZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQuY29sb24oKTtcbiAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxpdGVyYWxzIF0tLS0tLSAqL1xuICAgIERFRlBSSU5UKEFTVF9BcnJheSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgYSA9IHNlbGYuZWxlbWVudHMsIGxlbiA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDApIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uKGV4cCwgaSl7XG4gICAgICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIGV4cC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaW5hbCBlbGVtZW50IGlzIGEgaG9sZSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXRcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGxvb2sgbGlrZSBhIHRyYWlsaW5nIGNvbW1hLCBieSBpbnNlcnRpbmcgYW4gYWN0dWFsXG4gICAgICAgICAgICAgICAgLy8gdHJhaWxpbmcgY29tbWEuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEgJiYgZXhwIGluc3RhbmNlb2YgQVNUX0hvbGUpXG4gICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDApIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aCA+IDApIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgcHJvcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0S2V5VmFsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICB2YXIga2V5ID0gc2VsZi5rZXk7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwicXVvdGVfa2V5c1wiKSkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhrZXkgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGtleSA9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgIHx8ICFvdXRwdXQub3B0aW9uKFwiYmVhdXRpZnlcIilcbiAgICAgICAgICAgICAgICAgICAgJiYgK2tleSArIFwiXCIgPT0ga2V5KVxuICAgICAgICAgICAgICAgICAgICYmIHBhcnNlRmxvYXQoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQobWFrZV9udW0oa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoUkVTRVJWRURfV09SRFMoa2V5KSA/IG91dHB1dC5vcHRpb24oXCJzY3Jld19pZThcIikgOiBpc19pZGVudGlmaWVyX3N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLnZhbHVlLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdFNldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic2V0XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5rZXkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgc2VsZi52YWx1ZS5fZG9fcHJpbnQob3V0cHV0LCB0cnVlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0R2V0dGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJnZXRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICBzZWxmLnZhbHVlLl9kb19wcmludChvdXRwdXQsIHRydWUpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TeW1ib2wsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBkZWYgPSBzZWxmLmRlZmluaXRpb24oKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUoZGVmID8gZGVmLm1hbmdsZWRfbmFtZSB8fCBkZWYubmFtZSA6IHNlbGYubmFtZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VuZGVmaW5lZCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwidm9pZCAwXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ib2xlLCBub29wKTtcbiAgICBERUZQUklOVChBU1RfSW5maW5pdHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcIjEvMFwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTmFOLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCIwLzBcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1RoaXMsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcInRoaXNcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3RyaW5nLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX051bWJlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KG1ha2VfbnVtKHNlbGYuZ2V0VmFsdWUoKSkpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9SZWdFeHAsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBzdHIgPSBzZWxmLmdldFZhbHVlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJhc2NpaV9vbmx5XCIpKVxuICAgICAgICAgICAgc3RyID0gb3V0cHV0LnRvX2FzY2lpKHN0cik7XG4gICAgICAgIG91dHB1dC5wcmludChzdHIpO1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIC9eaW4vLnRlc3QocC5vcGVyYXRvcikgJiYgcC5sZWZ0ID09PSBzZWxmKVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiIFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3N0YXRlbWVudChzdGF0LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJicmFja2V0aXplXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudClcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgZWxzZSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBzdGF0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdGF0IHx8IHN0YXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHN0YXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjayAodGhhdCBtZWFucyB0aGVcbiAgICAvLyBpbm5lcm1vc3Qgbm9kZSBpbiB0aGUgY3VycmVudCBvdXRwdXQpIGlzIGxleGljYWxseSB0aGUgZmlyc3QgaW5cbiAgICAvLyBhIHN0YXRlbWVudC5cbiAgICBmdW5jdGlvbiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KSB7XG4gICAgICAgIHZhciBhID0gb3V0cHV0LnN0YWNrKCksIGkgPSBhLmxlbmd0aCwgbm9kZSA9IGFbLS1pXSwgcCA9IGFbLS1pXTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQgJiYgcC5ib2R5ID09PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKChwIGluc3RhbmNlb2YgQVNUX1NlcSAgICAgICAgICAgJiYgcC5jYXIgPT09IG5vZGUgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICAgICAgICAgICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSAmJiAhKHAgaW5zdGFuY2VvZiBBU1RfTmV3KSApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRG90ICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1N1YiAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAgICYmIHAuY29uZGl0aW9uID09PSBub2RlICApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAmJiBwLmxlZnQgPT09IG5vZGUgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5UG9zdGZpeCAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHA7XG4gICAgICAgICAgICAgICAgcCA9IGFbLS1pXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNlbGYgc2hvdWxkIGJlIEFTVF9OZXcuICBkZWNpZGUgaWYgd2Ugd2FudCB0byBzaG93IHBhcmVucyBvciBub3QuXG4gICAgZnVuY3Rpb24gbm9fY29uc3RydWN0b3JfcGFyZW5zKHNlbGYsIG91dHB1dCkge1xuICAgICAgICByZXR1cm4gc2VsZi5hcmdzLmxlbmd0aCA9PSAwICYmICFvdXRwdXQub3B0aW9uKFwiYmVhdXRpZnlcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJlc3Rfb2YoYSkge1xuICAgICAgICB2YXIgYmVzdCA9IGFbMF0sIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhW2ldLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxMCksIGEgPSBbIHN0ci5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKCdlKycsICdlJykgXSwgbTtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IobnVtKSA9PT0gbnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCIweFwiICsgbnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCAvLyBwcm9iYWJseSBwb2ludGxlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIgKyBudW0udG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCItMHhcIiArICgtbnVtKS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgIFwiLTBcIiArICgtbnVtKS50b1N0cmluZyg4KSk7IC8vIHNhbWUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG0gPSAvXiguKj8pKDArKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2gobVsxXSArIFwiZVwiICsgbVsyXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14wP1xcLigwKykoLiopJC8uZXhlYyhudW0pKSkge1xuICAgICAgICAgICAgYS5wdXNoKG1bMl0gKyBcImUtXCIgKyAobVsxXS5sZW5ndGggKyBtWzJdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgc3RyLnN1YnN0cihzdHIuaW5kZXhPZihcIi5cIikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdF9vZihhKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ibG9jayhzdG10LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qIC0tLS0tWyBzb3VyY2UgbWFwIGdlbmVyYXRvcnMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZNQVAobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJhZGRfc291cmNlX21hcFwiLCBmdW5jdGlvbihzdHJlYW0pe1xuICAgICAgICAgICAgZ2VuZXJhdG9yKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBXZSBjb3VsZCBlYXNpbHkgYWRkIGluZm8gZm9yIEFMTCBub2RlcywgYnV0IGl0IHNlZW1zIHRvIG1lIHRoYXRcbiAgICAvLyB3b3VsZCBiZSBxdWl0ZSB3YXN0ZWZ1bCwgaGVuY2UgdGhpcyBub29wIGluIHRoZSBiYXNlIGNsYXNzLlxuICAgIERFRk1BUChBU1RfTm9kZSwgbm9vcCk7XG5cbiAgICBmdW5jdGlvbiBiYXNpY19zb3VyY2VtYXBfZ2VuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5zdGFydCk7XG4gICAgfTtcblxuICAgIC8vIFhYWDogSSdtIG5vdCBleGFjdGx5IHN1cmUgaWYgd2UgbmVlZCBpdCBmb3IgYWxsIG9mIHRoZXNlIG5vZGVzLFxuICAgIC8vIG9yIGlmIHdlIHNob3VsZCBhZGQgZXZlbiBtb3JlLlxuXG4gICAgREVGTUFQKEFTVF9EaXJlY3RpdmUsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVidWdnZXIsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3ltYm9sLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0p1bXAsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3RhdGVtZW50V2l0aEJvZHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfTGFiZWxlZFN0YXRlbWVudCwgbm9vcCk7IC8vIHNpbmNlIHRoZSBsYWJlbCBzeW1ib2wgd2lsbCBtYXJrIGl0XG4gICAgREVGTUFQKEFTVF9MYW1iZGEsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3dpdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N3aXRjaEJyYW5jaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9CbG9ja1N0YXRlbWVudCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9Ub3BsZXZlbCwgbm9vcCk7XG4gICAgREVGTUFQKEFTVF9OZXcsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfVHJ5LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0NhdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0ZpbmFsbHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVmaW5pdGlvbnMsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfQ29uc3RhbnQsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLnN0YXJ0LCBzZWxmLmtleSk7XG4gICAgfSk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIENvbXByZXNzb3Iob3B0aW9ucywgZmFsc2VfYnlfZGVmYXVsdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wcmVzc29yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc29yKG9wdGlvbnMsIGZhbHNlX2J5X2RlZmF1bHQpO1xuICAgIFRyZWVUcmFuc2Zvcm1lci5jYWxsKHRoaXMsIHRoaXMuYmVmb3JlLCB0aGlzLmFmdGVyKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHNlcXVlbmNlcyAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllcyAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBkZWFkX2NvZGUgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGRyb3BfZGVidWdnZXIgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgdW5zYWZlICAgICAgICA6IGZhbHNlLFxuICAgICAgICB1bnNhZmVfY29tcHMgIDogZmFsc2UsXG4gICAgICAgIGNvbmRpdGlvbmFscyAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgY29tcGFyaXNvbnMgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBldmFsdWF0ZSAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGJvb2xlYW5zICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgbG9vcHMgICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICB1bnVzZWQgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGhvaXN0X2Z1bnMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgaG9pc3RfdmFycyAgICA6IGZhbHNlLFxuICAgICAgICBpZl9yZXR1cm4gICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGpvaW5fdmFycyAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgY2FzY2FkZSAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBzaWRlX2VmZmVjdHMgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIHB1cmVfZ2V0dGVycyAgOiBmYWxzZSxcbiAgICAgICAgcHVyZV9mdW5jcyAgICA6IG51bGwsXG4gICAgICAgIG5lZ2F0ZV9paWZlICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgc2NyZXdfaWU4ICAgICA6IGZhbHNlLFxuXG4gICAgICAgIHdhcm5pbmdzICAgICAgOiB0cnVlLFxuICAgICAgICBnbG9iYWxfZGVmcyAgIDoge31cbiAgICB9LCB0cnVlKTtcbn07XG5cbkNvbXByZXNzb3IucHJvdG90eXBlID0gbmV3IFRyZWVUcmFuc2Zvcm1lcjtcbm1lcmdlKENvbXByZXNzb3IucHJvdG90eXBlLCB7XG4gICAgb3B0aW9uOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldIH0sXG4gICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FybmluZ3MpXG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuLmFwcGx5KEFTVF9Ob2RlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbihub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgIGlmIChub2RlLl9zcXVlZXplZCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICAvL25vZGUuZHJvcF91bnVzZWQodGhpcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5ob2lzdF9kZWNsYXJhdGlvbnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgbm9kZSA9IG5vZGUub3B0aW1pemUodGhpcyk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLmRyb3BfdW51c2VkKHRoaXMpO1xuICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLl9zcXVlZXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn0pO1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIGZ1bmN0aW9uIE9QVChub2RlLCBvcHRpbWl6ZXIpIHtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJvcHRpbWl6ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLl9vcHRpbWl6ZWQpIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGltaXplcihzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIG9wdC5fb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHQgPT09IHNlbGYpIHJldHVybiBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gb3B0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE9QVChBU1RfTm9kZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwiZXF1aXZhbGVudF90b1wiLCBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgLy8gWFhYOiB0aGlzIGlzIGEgcmF0aGVyIGV4cGVuc2l2ZSB3YXkgdG8gdGVzdCB0d28gbm9kZSdzIGVxdWl2YWxlbmNlOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmludF90b19zdHJpbmcoKSA9PSBub2RlLnByaW50X3RvX3N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ub2RlKGN0b3IsIG9yaWcsIHByb3BzKSB7XG4gICAgICAgIGlmICghcHJvcHMpIHByb3BzID0ge307XG4gICAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLnN0YXJ0KSBwcm9wcy5zdGFydCA9IG9yaWcuc3RhcnQ7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmVuZCkgcHJvcHMuZW5kID0gb3JpZy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHByb3BzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCBvcmlnKSB7XG4gICAgICAgIC8vIFhYWDogV0lQLlxuICAgICAgICAvLyBpZiAodmFsIGluc3RhbmNlb2YgQVNUX05vZGUpIHJldHVybiB2YWwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIobnVsbCwgZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIC8vICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIgc2NvcGUgPSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9TY29wZSk7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUobm9kZSk7XG4gICAgICAgIC8vICAgICAgICAgbm9kZS50aGVkZWYgPSBkZWY7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH0pKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG5cbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm4gdmFsLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShpc05hTih2YWwpID8gQVNUX05hTiA6IEFTVF9OdW1iZXIsIG9yaWcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZSh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBvcmlnKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX051bGwsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1JlZ0V4cCwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiQ2FuJ3QgaGFuZGxlIGNvbnN0YW50IG9mIHR5cGU6IHt0eXBlfVwiLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX3N0YXRlbWVudF9hcnJheSh0aGluZykge1xuICAgICAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSByZXR1cm4gW107XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHJldHVybiBbIHRoaW5nIF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdGhpbmcgdG8gc3RhdGVtZW50IGFycmF5XCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc19lbXB0eSh0aGluZykge1xuICAgICAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHJldHVybiB0aGluZy5ib2R5Lmxlbmd0aCA9PSAwO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvb3BfYm9keSh4KSB7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX1N3aXRjaCkgcmV0dXJuIHg7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0ZvciB8fCB4IGluc3RhbmNlb2YgQVNUX0ZvckluIHx8IHggaW5zdGFuY2VvZiBBU1RfRFdMb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gKHguYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCA/IHguYm9keSA6IHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0aWdodGVuX2JvZHkoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgQ0hBTkdFRDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgQ0hBTkdFRCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGVtZW50cyA9IGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdGVtZW50cyk7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gZWxpbWluYXRlX2RlYWRfY29kZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImlmX3JldHVyblwiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBoYW5kbGVfaWZfcmV0dXJuKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2VxdWVuY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IHNlcXVlbmNlc2l6ZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImpvaW5fdmFyc1wiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBqb2luX2NvbnNlY3V0aXZlX3ZhcnMoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKENIQU5HRUQpO1xuXG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcIm5lZ2F0ZV9paWZlXCIpKSB7XG4gICAgICAgICAgICBuZWdhdGVfaWlmZXMoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcblxuICAgICAgICBmdW5jdGlvbiBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBzZWVuX2RpcnMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdC5ib2R5KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5fZGlycy5pbmRleE9mKHN0YXQudmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbl9kaXJzLnB1c2goc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICAgICAgdmFyIGluX2xhbWJkYSA9IHNlbGYgaW5zdGFuY2VvZiBBU1RfTGFtYmRhO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IHN0YXRlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIChpbl9sYW1iZGEgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIXN0YXQudmFsdWUgJiYgcmV0Lmxlbmd0aCA9PSAwKTpcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGUsIHJldC5sZW5ndGggaXMgcHJvYmFibHkgYWx3YXlzIHplcm9cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkcm9wIHVucmVhY2hhYmxlIGNvZGUgYmVmb3JlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcC4gIG5ldmVydGhlbGVzcywgaXQncyBnb29kIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgY2FzZSBzdGF0IGluc3RhbmNlb2YgQVNUX0lmOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5ib2R5IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXR0eSBzaWxseSBjYXNlLCBidXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybjsgcmV0dXJuOyA9PT4gZm9vKCk7IHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGluX2xhbWJkYSAmJiByZXQubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmICFyZXRbMF0udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZCA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzdGF0LmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzdGF0LmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KGNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgcmV0dXJuIHk7ID09PiByZXR1cm4gZm9vKCkgPyB4IDogeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmIHN0YXQuYm9keS52YWx1ZSAmJiByZXRbMF0udmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0WzBdID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybiB4OyBbIHJldHVybiA7IF0gPT0+IHJldHVybiBmb28oKSA/IHggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJldC5sZW5ndGggPT0gMCB8fCByZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSAmJiBzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gcmV0WzBdIHx8IG1ha2Vfbm9kZShBU1RfUmV0dXJuLCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc3RhdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbMF0gPSBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuOyBbIGVsc2UgeC4uLiBdOyB5Li4uID09PiBpZiAoIWZvbygpKSB7IHguLi47IHkuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0LmJvZHkudmFsdWUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmNvbmRpdGlvbiA9IHN0YXQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFsgc3RhdC50cmFuc2Zvcm0oY29tcHJlc3NvcikgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoID09IDEgJiYgaW5fbGFtYmRhICYmIHJldFswXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoIXN0YXQuYWx0ZXJuYXRpdmUgfHwgc3RhdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9SZXR1cm4sIHJldFswXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHJldFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3NvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsY3QgPSBhYiBpbnN0YW5jZW9mIEFTVF9Mb29wQ29udHJvbCA/IGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGFiLmxhYmVsKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYiAmJiAoKGFiIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhYWIudmFsdWUgJiYgaW5fbGFtYmRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChhYiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSAmJiBzZWxmID09PSBsb29wX2JvZHkobGN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ICYmIHNlbGYgPT09IGxjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWIubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoYWIubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIGFiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5jb25kaXRpb24gPSBzdGF0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbIHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gYWIgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgPyBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChhYi5sYWJlbCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWIgJiYgKChhYiBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIWFiLnZhbHVlICYmIGluX2xhbWJkYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQ29udGludWUgJiYgc2VsZiA9PT0gbG9vcF9ib2R5KGxjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGFiIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxjdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCAmJiBzZWxmID09PSBsY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGFiLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBhYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5hbHRlcm5hdGl2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gWyBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgdmFyIGhhc19xdWl0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb3JpZyA9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX3F1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHN0YXQsIGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSB8fCAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Db250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShzdGF0LmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRzKHN0YXQpKSBoYXNfcXVpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgQ0hBTkdFRCA9IHN0YXRlbWVudHMubGVuZ3RoICE9IG9yaWc7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgICAgICB2YXIgc2VxID0gW10sIHJldCA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHVzaF9zZXEoKSB7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHNlcSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcSkgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlcSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZXFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgc2VxID0gW107XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkgc2VxLnB1c2goc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHB1c2hfc2VxKCksIHJldC5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwdXNoX3NlcSgpO1xuICAgICAgICAgICAgcmV0ID0gc2VxdWVuY2VzaXplXzIocmV0LCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIENIQU5HRUQgPSByZXQubGVuZ3RoICE9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemVfMihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjb25zX3NlcShyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldC5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHByZXYuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5hZGQocmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBBU1RfU2VxLmNvbnMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmJvZHkud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3BlcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmluaXQgJiYgIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IGNvbnNfc2VxKHN0YXQuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzdGF0LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCAhPT0gb3BlcmEpIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gY29uc19zZXEoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gY29uc19zZXEoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQgJiYgc3RhdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKHN0YXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzdGF0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGNvbnNfc2VxKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgcHJldiA9IHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ID8gc3RhdCA6IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiBwcmV2ICYmIHByZXYuVFlQRSA9PSBzdGF0LlRZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwcmV2IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCFzdGF0LmluaXQgfHwgc3RhdC5pbml0LlRZUEUgPT0gcHJldi5UWVBFKSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0LmRlZmluaXRpb25zID0gcHJldi5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBzdGF0O1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5lZ2F0ZV9paWZlcyhzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYm9keSA9IChmdW5jdGlvbiB0cmFuc2Zvcm0odGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZy50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRyYW5zZm9ybShub2RlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhciA9IHRyYW5zZm9ybShub2RlLmNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0cmFuc2Zvcm0obm9kZS5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciAhPT0gbm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBiZWVuIG5lZ2F0ZWQsIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZGl0aW9uID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQgPSBub2RlLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGl2ZSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVucmVhY2hhYmxlIGNvZGUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHN0YXQuc3RhcnQpO1xuICAgICAgICBzdGF0LndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRlY2xhcmF0aW9ucyBpbiB1bnJlYWNoYWJsZSBjb2RlISBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVfaW5pdGlhbGl6ZXJzKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH07XG5cbiAgICAvKiAtLS0tLVsgYm9vbGVhbi9uZWdhdGlvbiBoZWxwZXJzIF0tLS0tLSAqL1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBleHByZXNzaW9uIGhhcyBhIGJvb2xlYW4gcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIHZhciB1bmFyeV9ib29sID0gWyBcIiFcIiwgXCJkZWxldGVcIiBdO1xuICAgICAgICB2YXIgYmluYXJ5X2Jvb2wgPSBbIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLCBcIjxcIiwgXCI8PVwiLCBcIj49XCIsIFwiPlwiIF07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCB1bmFyeV9ib29sKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCBiaW5hcnlfYm9vbCkgfHxcbiAgICAgICAgICAgICAgICAoICh0aGlzLm9wZXJhdG9yID09IFwiJiZcIiB8fCB0aGlzLm9wZXJhdG9yID09IFwifHxcIikgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pc19ib29sZWFuKCkgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX2Jvb2xlYW4oKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX2Jvb2xlYW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXNzaWduLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNkci5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1RydWUsIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICBkZWYoQVNUX0ZhbHNlLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19ib29sZWFuXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiBoYXMgYSBzdHJpbmcgcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1N0cmluZywgZnVuY3Rpb24oKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGRlZihBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInR5cGVvZlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCIrXCIgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSB8fCB0aGlzLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIis9XCIpICYmIHRoaXMucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TZXEsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RyLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19zdHJpbmcoY29tcHJlc3NvcikgJiYgdGhpcy5hbHRlcm5hdGl2ZS5pc19zdHJpbmcoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NhbGwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICYmIHRoaXMuZXhwcmVzc2lvbi5uYW1lID09IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmV4cHJlc3Npb24udW5kZWNsYXJlZCgpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19zdHJpbmdcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBiZXN0X29mKGFzdDEsIGFzdDIpIHtcbiAgICAgICAgcmV0dXJuIGFzdDEucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoID5cbiAgICAgICAgICAgIGFzdDIucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoXG4gICAgICAgICAgICA/IGFzdDIgOiBhc3QxO1xuICAgIH07XG5cbiAgICAvLyBtZXRob2RzIHRvIGV2YWx1YXRlIGEgY29uc3RhbnQgZXhwcmVzc2lvblxuICAgIChmdW5jdGlvbiAoZGVmKXtcbiAgICAgICAgLy8gVGhlIGV2YWx1YXRlIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IHdpdGggb25lIG9yIHR3b1xuICAgICAgICAvLyBlbGVtZW50cy4gIElmIHRoZSBub2RlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZWR1Y2VkIHRvIGFcbiAgICAgICAgLy8gY29uc3RhbnQsIHRoZW4gdGhlIHNlY29uZCBlbGVtZW50IHRlbGxzIHVzIHRoZSB2YWx1ZTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBtaXNzaW5nLiAgVGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgLy8gb2YgdGhlIGFycmF5IGlzIGFsd2F5cyBhbiBBU1RfTm9kZSBkZXNjZW5kYW50OyBpZlxuICAgICAgICAvLyBldmFsdWF0aW9uIHdhcyBzdWNjZXNzZnVsIGl0J3MgYSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgICAgICAgLy8gY29uc3RhbnQ7IG90aGVyd2lzZSBpdCdzIHRoZSBvcmlnaW5hbCBvciBhIHJlcGxhY2VtZW50IG5vZGUuXG4gICAgICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImV2YWx1YXRlXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpKSByZXR1cm4gWyB0aGlzIF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9ldmFsKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbIGJlc3Rfb2YobWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCB0aGlzKSwgdGhpcyksIHZhbCBdO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleCAhPT0gZGVmKSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdfdGVtcGxhdGUoXCJDYW5ub3QgZXZhbHVhdGUgYSBzdGF0ZW1lbnQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHRoaXMuc3RhcnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBYWFg6IEFTVF9GdW5jdGlvbiBpbmhlcml0cyBmcm9tIEFTVF9TY29wZSwgd2hpY2ggaXRzZWxmXG4gICAgICAgICAgICAvLyBpbmhlcml0cyBmcm9tIEFTVF9TdGF0ZW1lbnQ7IGhvd2V2ZXIsIGFuIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgLy8gaXNuJ3QgcmVhbGx5IGEgc3RhdGVtZW50LiAgVGhpcyBjb3VsZCBieXRlIGluIG90aGVyXG4gICAgICAgICAgICAvLyBwbGFjZXMgdG9vLiA6LSggV2lzaCBKUyBoYWQgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBldihub2RlLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIkNvbXByZXNzb3IgbXVzdCBiZSBwYXNzZWRcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLl9ldmFsKGNvbXByZXNzb3IpO1xuICAgICAgICB9O1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aHJvdyBkZWY7ICAgICAgICAgIC8vIG5vdCBjb25zdGFudFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIhXCI6IHJldHVybiAhZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiB3b3VsZCBiZSBldmFsdWF0ZWQgdG8gYW4gYXJyYXkgYW5kIHNvIHR5cGVvZiB3b3VsZFxuICAgICAgICAgICAgICAgIC8vIGluY29ycmVjdGx5IHJldHVybiAnb2JqZWN0Jy4gSGVuY2UgbWFraW5nIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uKSByZXR1cm4gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICAgICAgICAgIGUgPSBldihlLCBjb21wcmVzc29yKTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGVvZiA8UmVnRXhwPiByZXR1cm5zIFwib2JqZWN0XCIgb3IgXCJmdW5jdGlvblwiIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvLyBzbyBjYW5ub3QgZXZhbHVhdGUgcmVsaWFibHlcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlZ0V4cCkgdGhyb3cgZGVmO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICBjYXNlIFwidm9pZFwiOiByZXR1cm4gdm9pZCBldihlLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIH5ldihlLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICBlID0gZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IDApIHRocm93IGRlZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLWU7XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiArZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0JpbmFyeSwgZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdCwgcmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCImJlwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJiYgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ8fFwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgfHwgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ8XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgfCAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCImXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJeXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgXiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgKyAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIqXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgKiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIvXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgLyAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIlXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJSAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCItXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgLSAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PFwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPDwgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+PlwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj4gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+Pj5cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj4+ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPT0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PT1cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPT09ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgIT0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPT1cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgIT09ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPCAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPD0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJpblwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgaW4gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJpbnN0YW5jZW9mXCIgOiByZXR1cm4gZXYobGVmdCwgYykgaW5zdGFuY2VvZiBldihyaWdodCwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBldih0aGlzLmNvbmRpdGlvbiwgY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICA/IGV2KHRoaXMuY29uc2VxdWVudCwgY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICA6IGV2KHRoaXMuYWx0ZXJuYXRpdmUsIGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChkICYmIGQuY29uc3RhbnQgJiYgZC5pbml0KSByZXR1cm4gZXYoZC5pbml0LCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHRocm93IGRlZjtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiX2V2YWxcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvLyBtZXRob2QgdG8gbmVnYXRlIGFuIGV4cHJlc3Npb25cbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZnVuY3Rpb24gYmFzaWNfbmVnYXRpb24oZXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3RhdGVtZW50LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG5lZ2F0ZSBhIHN0YXRlbWVudFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU2VxLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYmFzaWNfbmVnYXRpb24odGhpcyksIHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCksIG9wID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9jb21wc1wiKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiPlwiICA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgOiBzZWxmLm9wZXJhdG9yID0gXCI+PVwiIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiPj1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIjxcIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPD1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBcIj09XCIgOiBzZWxmLm9wZXJhdG9yID0gXCIhPVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIj09PVwiOiBzZWxmLm9wZXJhdG9yID0gXCIhPT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPT1cIjogc2VsZi5vcGVyYXRvciA9IFwiPT09XCI7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gXCJ8fFwiO1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGJhc2ljX25lZ2F0aW9uKHRoaXMpLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwiJiZcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihiYXNpY19uZWdhdGlvbih0aGlzKSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcIm5lZ2F0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpcywgY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaGFzIHNpZGUgZWZmZWN0c1xuICAgIChmdW5jdGlvbihkZWYpe1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcblxuICAgICAgICBkZWYoQVNUX0VtcHR5U3RhdGVtZW50LCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1RoaXMsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gZmFsc2UgfSk7XG5cbiAgICAgICAgZGVmKEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBwdXJlID0gY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2Z1bmNzXCIpO1xuICAgICAgICAgICAgaWYgKCFwdXJlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBwdXJlLmluZGV4T2YodGhpcy5leHByZXNzaW9uLnByaW50X3RvX3N0cmluZygpKSA8IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZihBU1RfQmxvY2ssIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYm9keS5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZihBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRGVmdW4sIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY29uc2VxdWVudC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PSBcIisrXCJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLm9wZXJhdG9yID09IFwiLS1cIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gZmFsc2UgfSk7XG4gICAgICAgIGRlZihBU1RfT2JqZWN0LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tpXS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXJyYXksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0RvdCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3ViLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIikpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5wcm9wZXJ0eS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Qcm9wQWNjZXNzLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiAhY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXIuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY2RyLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcImhhc19zaWRlX2VmZmVjdHNcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvLyB0ZWxsIG1lIGlmIGEgc3RhdGVtZW50IGFib3J0c1xuICAgIGZ1bmN0aW9uIGFib3J0cyh0aGluZykge1xuICAgICAgICByZXR1cm4gdGhpbmcgJiYgdGhpbmcuYWJvcnRzKCk7XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZGVmKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7IHJldHVybiBudWxsIH0pO1xuICAgICAgICBkZWYoQVNUX0p1bXAsIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzIH0pO1xuICAgICAgICBmdW5jdGlvbiBibG9ja19hYm9ydHMoKXtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBuID4gMCAmJiBhYm9ydHModGhpcy5ib2R5W24gLSAxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZihBU1RfQmxvY2tTdGF0ZW1lbnQsIGJsb2NrX2Fib3J0cyk7XG4gICAgICAgIGRlZihBU1RfU3dpdGNoQnJhbmNoLCBibG9ja19hYm9ydHMpO1xuICAgICAgICBkZWYoQVNUX0lmLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmUgJiYgYWJvcnRzKHRoaXMuYm9keSkgJiYgYWJvcnRzKHRoaXMuYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJhYm9ydHNcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgb3B0aW1pemVycyBdLS0tLS0gKi9cblxuICAgIE9QVChBU1RfRGlyZWN0aXZlLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuc2NvcGUuaGFzX2RpcmVjdGl2ZShzZWxmLnZhbHVlKSAhPT0gc2VsZi5zY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRyb3BfZGVidWdnZXJcIikpXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CcmVha1xuICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc2VsZi5ib2R5LmxhYmVsKSA9PT0gc2VsZi5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYubGFiZWwucmVmZXJlbmNlcy5sZW5ndGggPT0gMCA/IHNlbGYuYm9keSA6IHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICBzd2l0Y2ggKHNlbGYuYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBzZWxmLmJvZHlbMF07XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfU2NvcGUuREVGTUVUSE9EKFwiZHJvcF91bnVzZWRcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICAgICAmJiAhKHNlbGYgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpXG4gICAgICAgICAgICAmJiAhc2VsZi51c2VzX2V2YWxcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaW5fdXNlID0gW107XG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25zID0gbmV3IERpY3Rpb25hcnkoKTtcbiAgICAgICAgICAgIC8vIHBhc3MgMTogZmluZCBvdXQgd2hpY2ggc3ltYm9scyBhcmUgZGlyZWN0bHkgdXNlZCBpblxuICAgICAgICAgICAgLy8gdGhpcyBzY29wZSAobm90IGluIG5lc3RlZCBzY29wZXMpLlxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvbnMuYWRkKG5vZGUubmFtZS5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBkb24ndCBnbyBpbiBuZXN0ZWQgc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgc2NvcGUgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25zLmFkZChkZWYubmFtZS5uYW1lLCBkZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZS53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoX3VuaXEoaW5fdXNlLCBub2RlLmRlZmluaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhdmVfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLndhbGsodHcpO1xuICAgICAgICAgICAgLy8gcGFzcyAyOiBmb3IgZXZlcnkgdXNlZCBzeW1ib2wgd2UgbmVlZCB0byB3YWxrIGl0c1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gY29kZSB0byBmaWd1cmUgb3V0IGlmIGl0IHVzZXMgb3RoZXJcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgKHRoYXQgbWF5IG5vdCBiZSBpbl91c2UpLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbl91c2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl91c2VbaV0ub3JpZy5mb3JFYWNoKGZ1bmN0aW9uKGRlY2wpe1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlY2xhcmVkIGdsb2JhbHMgd2lsbCBiZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSBpbml0aWFsaXphdGlvbnMuZ2V0KGRlY2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0KSBpbml0LmZvckVhY2goZnVuY3Rpb24oaW5pdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF91bmlxKGluX3VzZSwgbm9kZS5kZWZpbml0aW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdC53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYXNzIDM6IHdlIHNob3VsZCBkcm9wIGRlY2xhcmF0aW9ucyBub3QgaW5fdXNlXG4gICAgICAgICAgICB2YXIgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQWNjZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gbm9kZS5hcmduYW1lcywgaSA9IGEubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gYVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ltLnVucmVmZXJlbmNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVudXNlZCBmdW5jdGlvbiBhcmd1bWVudCB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgOiBzeW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgOiBzeW0uc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgOiBzeW0uc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAgOiBzeW0uc3RhcnQuY29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuICYmIG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVtYmVyKG5vZGUubmFtZS5kZWZpbml0aW9uKCksIGluX3VzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnVzZWQgZnVuY3Rpb24ge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgOiBub2RlLm5hbWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA6IG5vZGUubmFtZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIDogbm9kZS5uYW1lLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAgOiBub2RlLm5hbWUuc3RhcnQuY29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgISh0dC5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9Gb3JJbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBub2RlLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIoZGVmLm5hbWUuZGVmaW5pdGlvbigpLCBpbl91c2UpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA6IGRlZi5uYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgOiBkZWYubmFtZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIDogZGVmLm5hbWUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sICA6IGRlZi5uYW1lLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSAmJiBkZWYudmFsdWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuX3VudXNlZF9zaWRlX2VmZmVjdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJTaWRlIGVmZmVjdHMgaW4gaW5pdGlhbGl6YXRpb24gb2YgdW51c2VkIHZhcmlhYmxlIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnVzZWQgdmFyaWFibGUge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIHVuaW5pdGlhbGl6ZWQgbmFtZXMgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYgPSBtZXJnZVNvcnQoZGVmLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEudmFsdWUgJiYgYi52YWx1ZSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYi52YWx1ZSAmJiBhLnZhbHVlKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVudXNlZCBuYW1lcyB3aG9zZSBpbml0aWFsaXphdGlvbiBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZGUgZWZmZWN0cywgd2UgY2FuIGNhc2NhZGUgdGhlIGluaXQuIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIG5leHQgb25lLCBvciBuZXh0IHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlX2VmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGRlZltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5fdW51c2VkX3NpZGVfZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZV9lZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cy5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC52YWx1ZSA9IEFTVF9TZXEuZnJvbV9hcnJheShzaWRlX2VmZmVjdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cyA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogWyBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogQVNUX1NlcS5mcm9tX2FycmF5KHNpZGVfZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPT0gMCAmJiAhc2lkZV9lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlX2VmZmVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlZmluaXRpb25zID0gZGVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cy5ib2R5LnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNpZGVfZWZmZWN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Zvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5pdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29tYmluYXRpb24gb2YgdW51c2VkIG5hbWUgKyBzaWRlIGVmZmVjdCBsZWFkcyB0bzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYW4gaW52YWxpZCBBU1QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZml4IGl0IGF0IHRoaXMgc3RhZ2UgYnkgbW92aW5nIHRoZSBgdmFyYCBvdXRzaWRlIHRoZSBgZm9yYC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gbm9kZS5pbml0LmJvZHkuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5pdCA9IG5vZGUuaW5pdC5ib2R5LnNsaWNlKC0xKVswXS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucHVzaChub2RlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNwbGljZShib2R5KSA6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm0odHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBBU1RfU2NvcGUuREVGTUVUSE9EKFwiaG9pc3RfZGVjbGFyYXRpb25zXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgaG9pc3RfZnVucyA9IGNvbXByZXNzb3Iub3B0aW9uKFwiaG9pc3RfZnVuc1wiKTtcbiAgICAgICAgdmFyIGhvaXN0X3ZhcnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3ZhcnNcIik7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGhvaXN0X2Z1bnMgfHwgaG9pc3RfdmFycykge1xuICAgICAgICAgICAgdmFyIGRpcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBob2lzdGVkID0gW107XG4gICAgICAgICAgICB2YXIgdmFycyA9IG5ldyBEaWN0aW9uYXJ5KCksIHZhcnNfZm91bmQgPSAwLCB2YXJfZGVjbCA9IDA7XG4gICAgICAgICAgICAvLyBsZXQncyBjb3VudCB2YXJfZGVjbCBmaXJzdCwgd2Ugc2VlbSB0byB3YXN0ZSBhIGxvdCBvZlxuICAgICAgICAgICAgLy8gc3BhY2UgaWYgd2UgaG9pc3QgYHZhcmAgd2hlbiB0aGVyZSdzIG9ubHkgb25lLlxuICAgICAgICAgICAgc2VsZi53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Zhcikge1xuICAgICAgICAgICAgICAgICAgICArK3Zhcl9kZWNsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBob2lzdF92YXJzID0gaG9pc3RfdmFycyAmJiB2YXJfZGVjbCA+IDE7XG4gICAgICAgICAgICB2YXIgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gJiYgaG9pc3RfZnVucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0ZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXIgJiYgaG9pc3RfdmFycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChkZWYubmFtZS5uYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3ZhcnNfZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcSA9IG5vZGUudG9fYXNzaWdubWVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHR0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0ZvckluICYmIHAuaW5pdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxID09IG51bGwpIHJldHVybiBub2RlLmRlZmluaXRpb25zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0ZvciAmJiBwLmluaXQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXEpIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTsgLy8gdG8gYXZvaWQgZGVzY2VuZGluZyBpbiBuZXN0ZWQgc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZiA9IHNlbGYudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgIGlmICh2YXJzX2ZvdW5kID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Qgb25seSB2YXJzIHdoaWNoIGRvbid0IHNob3cgdXAgaW4gc2VsZidzIGFyZ3VtZW50cyBsaXN0XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXJzLmVhY2goZnVuY3Rpb24oZGVmLCBuYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBmaW5kX2lmKGZ1bmN0aW9uKHgpeyByZXR1cm4geC5uYW1lID09IGRlZi5uYW1lLm5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmduYW1lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuZGVsKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gZGVmLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gbWVyZ2UgaW4gYXNzaWdubWVudHNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmJvZHkubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHNlbGYuYm9keVtpXS5ib2R5LCBzeW0sIGFzc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXhwci5vcGVyYXRvciA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc3ltID0gZXhwci5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmFycy5oYXMoc3ltLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHZhcnMuZ2V0KHN5bS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGV4cHIucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShkZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX1NlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYXNzaWduID0gZXhwci5jYXIpIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhc3NpZ24ub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSA9IGFzc2lnbi5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmFycy5oYXMoc3ltLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHZhcnMuZ2V0KHN5bS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGFzc2lnbi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGRlZnMsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHlbaV0uYm9keSA9IGV4cHIuY2RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gWyBpLCAxIF0uY29uY2F0KHNlbGYuYm9keVtpXS5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlLmFwcGx5KHNlbGYuYm9keSwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBtYWtlX25vZGUoQVNUX1Zhciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IGRlZnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0ZWQucHVzaChkZWZzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5ib2R5ID0gZGlycy5jb25jYXQoaG9pc3RlZCwgc2VsZi5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuYm9keS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiRHJvcHBpbmcgc2lkZS1lZmZlY3QtZnJlZSBzdGF0ZW1lbnQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRFdMb29wLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBjb25kWzBdO1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwibG9vcHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoY29uZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Zvciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmJvZHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9XaGlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgZnVuY3Rpb24gZHJvcF9pdChyZXN0KSB7XG4gICAgICAgICAgICByZXN0ID0gYXNfc3RhdGVtZW50X2FycmF5KHJlc3QpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keS5ib2R5ID0gcmVzdC5jb25jYXQoc2VsZi5ib2R5LmJvZHkuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuYm9keSA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYuYm9keSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiByZXN0XG4gICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWZfYnJlYWtfaW5fbG9vcChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgPyBzZWxmLmJvZHkuYm9keVswXSA6IHNlbGYuYm9keTtcbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QuYm9keSBpbnN0YW5jZW9mIEFTVF9CcmVha1xuICAgICAgICAgICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGZpcnN0LmJvZHkubGFiZWwpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmlyc3QuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBmaXJzdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcm9wX2l0KGZpcnN0LmFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0LmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAgICAgICAgICAmJiBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChmaXJzdC5hbHRlcm5hdGl2ZS5sYWJlbCkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmaXJzdC5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gZmlyc3QuY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcm9wX2l0KGZpcnN0LmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9QVChBU1RfV2hpbGUsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgc2VsZiA9IEFTVF9EV0xvb3AucHJvdG90eXBlLm9wdGltaXplLmNhbGwoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX1doaWxlKSB7XG4gICAgICAgICAgICBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfRm9yLCBzZWxmLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBjb25kID0gc2VsZi5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kKSB7XG4gICAgICAgICAgICBjb25kID0gY29uZC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gY29uZFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwibG9vcHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoY29uZCkge1xuICAgICAgICAgICAgaWYgKGNvbmQubGVuZ3RoID4gMSAmJiAhY29uZFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbml0IGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHNlbGYuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuaW5pdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuaW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmJvZHksIGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfSWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiY29uZGl0aW9uYWxzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgLy8gaWYgY29uZGl0aW9uIGNhbiBiZSBzdGF0aWNhbGx5IGRldGVybWluZWQsIHdhcm4gYW5kIGRyb3BcbiAgICAgICAgLy8gb25lIG9mIHRoZSBibG9ja3MuICBub3RlLCBzdGF0aWNhbGx5IGRldGVybWluZWQgaW1wbGllc1xuICAgICAgICAvLyDigJxoYXMgbm8gc2lkZSBlZmZlY3Rz4oCdOyBhbHNvIGl0IGRvZXNuJ3Qgd29yayBmb3IgY2FzZXMgbGlrZVxuICAgICAgICAvLyBgeCAmJiB0cnVlYCwgdGhvdWdoIGl0IHByb2JhYmx5IHNob3VsZC5cbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBjb25kWzBdO1xuICAgICAgICBpZiAoY29uZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkNvbmRpdGlvbiBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5jb25kaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYWx0ZXJuYXRpdmUsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzZWxmLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBhIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkNvbmRpdGlvbiBhbHdheXMgZmFsc2UgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuY29uZGl0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSBhLnB1c2goc2VsZi5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICB2YXIgbmVnYXRlZCA9IHNlbGYuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgdmFyIG5lZ2F0ZWRfaXNfYmVzdCA9IGJlc3Rfb2Yoc2VsZi5jb25kaXRpb24sIG5lZ2F0ZWQpID09PSBuZWdhdGVkO1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSAmJiBuZWdhdGVkX2lzX2Jlc3QpIHtcbiAgICAgICAgICAgIG5lZ2F0ZWRfaXNfYmVzdCA9IGZhbHNlOyAvLyBiZWNhdXNlIHdlIGFscmVhZHkgZG8gdGhlIHN3aXRjaCBoZXJlLlxuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBuZWdhdGVkO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHNlbGYuYm9keTtcbiAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYWx0ZXJuYXRpdmUgfHwgbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCk7XG4gICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19lbXB0eShzZWxmLmJvZHkpICYmIGlzX2VtcHR5KHNlbGYuYWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudFxuICAgICAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudCAgOiBzZWxmLmJvZHkuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBzZWxmLmFsdGVybmF0aXZlLmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19lbXB0eShzZWxmLmFsdGVybmF0aXZlKSAmJiBzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobmVnYXRlZF9pc19iZXN0KSByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwifHxcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBuZWdhdGVkLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYm9keS5ib2R5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYm9keS5ib2R5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50XG4gICAgICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlXG4gICAgICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5hbHRlcm5hdGl2ZS5ib2R5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0V4aXRcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAgICAgJiYgc2VsZi5ib2R5LlRZUEUgPT0gc2VsZi5hbHRlcm5hdGl2ZS5UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKHNlbGYuYm9keS5DVE9SLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudCAgOiBzZWxmLmJvZHkudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYuYm9keSkub3B0aW1pemUoY29tcHJlc3NvciksXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogc2VsZi5hbHRlcm5hdGl2ZS52YWx1ZSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5hbHRlcm5hdGl2ZSkub3B0aW1pemUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfSWZcbiAgICAgICAgICAgICYmICFzZWxmLmJvZHkuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICYmICFzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYuYm9keS5jb25kaXRpb25cbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYm9ydHMoc2VsZi5ib2R5KSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ID0gc2VsZi5hbHRlcm5hdGl2ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBbIHNlbGYsIGFsdCBdXG4gICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhYm9ydHMoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gc2VsZi5ib2R5O1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5hbHRlcm5hdGl2ZTtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbmVnYXRlZF9pc19iZXN0ID8gbmVnYXRlZCA6IHNlbGYuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBbIHNlbGYsIGJvZHkgXVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9Td2l0Y2gsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi5ib2R5Lmxlbmd0aCA9PSAwICYmIGNvbXByZXNzb3Iub3B0aW9uKFwiY29uZGl0aW9uYWxzXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmV4cHJlc3Npb25cbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoOzspIHtcbiAgICAgICAgICAgIHZhciBsYXN0X2JyYW5jaCA9IHNlbGYuYm9keVtzZWxmLmJvZHkubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdF9icmFuY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IGxhc3RfYnJhbmNoLmJvZHlbbGFzdF9icmFuY2guYm9keS5sZW5ndGggLSAxXTsgLy8gbGFzdCBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiBsb29wX2JvZHkoY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdC5sYWJlbCkpID09PSBzZWxmKVxuICAgICAgICAgICAgICAgICAgICBsYXN0X2JyYW5jaC5ib2R5LnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0X2JyYW5jaCBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0ICYmIGxhc3RfYnJhbmNoLmJvZHkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBvdXQ6IGlmIChleHAubGVuZ3RoID09IDIpIHRyeSB7XG4gICAgICAgICAgICAvLyBjb25zdGFudCBleHByZXNzaW9uXG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBleHBbMF07XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSBicmVhayBvdXQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBleHBbMV07XG4gICAgICAgICAgICB2YXIgaW5faWYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbl9ibG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcnVpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQsIGluX2xpc3Qpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGRlc2NlbmQgdGhlc2Ugbm9kZSB0eXBlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2ggJiYgbm9kZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVpbmVkID8gbm9kZSA6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG5vZGUuYm9keS5yZWR1Y2UoZnVuY3Rpb24oYSwgYnJhbmNoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYnJhbmNoLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9JZiB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1RyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2F2ZSA9IGluX2lmO1xuICAgICAgICAgICAgICAgICAgICBpbl9pZiA9ICFpbl9ibG9jaztcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5faWYgPSBzYXZlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2F2ZSA9IGluX2Jsb2NrO1xuICAgICAgICAgICAgICAgICAgICBpbl9ibG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGluX2Jsb2NrID0gc2F2ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgdGhpcy5sb29wY29udHJvbF90YXJnZXQobm9kZS5sYWJlbCkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluX2lmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluX2Jsb2NrKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNraXAgOiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2hCcmFuY2ggJiYgdGhpcy5wYXJlbnQoKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gbm9kZS5leHByZXNzaW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ290IGEgY2FzZSB3aXRoIG5vbi1jb25zdGFudCBleHByZXNzaW9uLCBiYWxpbmcgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBbMV0gPT09IHZhbHVlIHx8IHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRzKG5vZGUpKSBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5za2lwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHQuc3RhY2sgPSBjb21wcmVzc29yLnN0YWNrLnNsaWNlKCk7IC8vIHNvIHRoYXQncyBhYmxlIHRvIHNlZSBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIHNlbGYgPSBzZWxmLnRyYW5zZm9ybSh0dCk7XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIGlmIChleCAhPT0gc2VsZikgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmLmJvZHkgPSB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIEFTVF9EZWZpbml0aW9ucy5ERUZNRVRIT0QoXCJyZW1vdmVfaW5pdGlhbGl6ZXJzXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpeyBkZWYudmFsdWUgPSBudWxsIH0pO1xuICAgIH0pO1xuXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcInRvX2Fzc2lnbm1lbnRzXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhc3NpZ25tZW50cyA9IHRoaXMuZGVmaW5pdGlvbnMucmVkdWNlKGZ1bmN0aW9uKGEsIGRlZil7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgZGVmLm5hbWUsIGRlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBhLnB1c2gobWFrZV9ub2RlKEFTVF9Bc3NpZ24sIGRlZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogZGVmLnZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEFTVF9TZXEuZnJvbV9hcnJheShhc3NpZ25tZW50cyk7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0RlZmluaXRpb25zLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuZGVmaW5pdGlvbnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYgPSBBU1RfTGFtYmRhLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm5hbWUgJiYgc2VsZi5uYW1lLnVucmVmZXJlbmNlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQ2FsbCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICAgICAgdmFyIGV4cCA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIGV4cC51bmRlY2xhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQXJyYXksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogc2VsZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX09iamVjdCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPD0gMSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSlcbiAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIlxuICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9GYWxzZSwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDEpIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCJcbiAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJGdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsKHNlbGYuYXJncywgZnVuY3Rpb24oeCl7IHJldHVybiB4IGluc3RhbmNlb2YgQVNUX1N0cmluZyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVpdGUgYSBjb3JuZXItY2FzZSwgYnV0IHdlIGNhbiBoYW5kbGUgaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8yMDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb2RlIGFyZ3VtZW50IGlzIGEgY29uc3RhbnQsIHRoZW4gd2UgY2FuIG1pbmlmeSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcIihmdW5jdGlvbihcIiArIHNlbGYuYXJncy5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIil7XCIgKyBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLnZhbHVlICsgXCJ9KSgpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHBhcnNlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5maWd1cmVfb3V0X3Njb3BlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAgPSBuZXcgQ29tcHJlc3Nvcihjb21wcmVzc29yLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdCA9IGFzdC50cmFuc2Zvcm0oY29tcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QubWFuZ2xlX25hbWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Qud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1biA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggIT09IGFzdCkgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZ1bi5hcmduYW1lcy5tYXAoZnVuY3Rpb24oYXJnLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLmFyZ3NbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcucHJpbnRfdG9fc3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBU1RfQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLl9jb2RlZ2VuLmNhbGwoZnVuLCBmdW4sIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnRvU3RyaW5nKCkucmVwbGFjZSgvXlxce3xcXH0kL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZi5hcmdzW3NlbGYuYXJncy5sZW5ndGggLSAxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEpTX1BhcnNlX0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkVycm9yIHBhcnNpbmcgY29kZSBwYXNzZWQgdG8gbmV3IEZ1bmN0aW9uIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3QgJiYgZXhwLnByb3BlcnR5ID09IFwidG9TdHJpbmdcIiAmJiBzZWxmLmFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwIGluc3RhbmNlb2YgQVNUX0RvdCAmJiBleHAuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9BcnJheSAmJiBleHAucHJvcGVydHkgPT0gXCJqb2luXCIpIEVYSVQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gc2VsZi5hcmdzLmxlbmd0aCA9PSAwID8gXCIsXCIgOiBzZWxmLmFyZ3NbMF0uZXZhbHVhdGUoY29tcHJlc3NvcilbMV07XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PSBudWxsKSBicmVhayBFWElUOyAvLyBub3QgYSBjb25zdGFudFxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGV4cC5leHByZXNzaW9uLmVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBlbCl7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA9PSAwIHx8IGVsLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBcIlwiICsgbGFzdFsxXSArIHNlcGFyYXRvciArIGVsWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IFsgbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCBsYXN0WzBdKSwgdmFsIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIGVsZW1lbnRzWzBdWzBdO1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXVswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGVsZW1lbnRzWzFdWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBlbGVtZW50cy5zaGlmdCgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgZWxbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogcHJldixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IGVsWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZpcnN0KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBhd2t3YXJkIGNsb25pbmcgdG8gbm90IGFmZmVjdCBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gYmVzdF9vZiB3aWxsIGRlY2lkZSB3aGljaCBvbmUgdG8gZ2V0IHRocm91Z2guXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxmLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uLmVsZW1lbnRzID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKHNlbGYsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgICAgICYmIHNlbGYuYXJncy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgICYmICFBU1RfQmxvY2sucHJvdG90eXBlLmhhc19zaWRlX2VmZmVjdHMuY2FsbChzZWxmLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICAgICAgdmFyIGV4cCA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIGV4cC51bmRlY2xhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiUmVnRXhwXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0NhbGwsIHNlbGYsIHNlbGYpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1NlcSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmNhci5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3QgY29tcHJlc3MgKDEsZXZhbCkoc29tZXRoaW5nKSB0b1xuICAgICAgICAgICAgLy8gZXZhbChzb21ldGhpbmcpIGJlY2F1c2UgdGhhdCBjaGFuZ2VzIHRoZSBtZWFuaW5nIG9mXG4gICAgICAgICAgICAvLyBldmFsIChiZWNvbWVzIGxleGljYWwgaW5zdGVhZCBvZiBnbG9iYWwpLlxuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAoIShzZWxmLmNkciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLm5hbWUgPT0gXCJldmFsXCJcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgICAgICAgJiYgKHAgPSBjb21wcmVzc29yLnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNhc2NhZGVcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5jYXIubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5jYXIubGVmdC5lcXVpdmFsZW50X3RvKHNlbGYuY2RyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jYXIuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmICFzZWxmLmNkci5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5jYXIuZXF1aXZhbGVudF90byhzZWxmLmNkcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfVW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9VbmFyeVBvc3RmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICByZXR1cm4gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICAgICAgdmFyIGUgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIGUub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gISFmb28gPT0+IGZvbywgaWYgd2UncmUgaW4gYm9vbGVhbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gdHlwZW9mIGFsd2F5cyByZXR1cm5zIGEgbm9uLWVtcHR5IHN0cmluZywgdGh1cyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIHRydWUgaW4gYm9vbGVhbnNcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuIGV4cHJlc3Npb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHNlbGYub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBlLm5lZ2F0ZShjb21wcmVzc29yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYXNfc2lkZV9lZmZlY3RzX29yX3Byb3BfYWNjZXNzKG5vZGUsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIHNhdmVfcHVyZV9nZXR0ZXJzID0gY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIik7XG4gICAgICAgIGNvbXByZXNzb3Iub3B0aW9ucy5wdXJlX2dldHRlcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgY29tcHJlc3Nvci5vcHRpb25zLnB1cmVfZ2V0dGVycyA9IHNhdmVfcHVyZV9nZXR0ZXJzO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIEFTVF9CaW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgaW5zdGFuY2VvZiBBU1RfU2VxXG4gICAgICAgICAgICAgICAgJiYgdGhpcyBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAmJiAhaGFzX3NpZGVfZWZmZWN0c19vcl9wcm9wX2FjY2Vzcyh0aGlzLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IHRoaXMucmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBzZXEudG9fYXJyYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbW11dGF0aXZlT3BlcmF0b3JzID0gbWFrZVByZWRpY2F0ZShcIj09ID09PSAhPSAhPT0gKiAmIHwgXlwiKTtcblxuICAgIE9QVChBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIHJldmVyc2UgPSBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2UgYXNtXCIpID8gbm9vcFxuICAgICAgICAgICAgOiBmdW5jdGlvbihvcCwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgIShzZWxmLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSB8fCBzZWxmLnJpZ2h0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcCkgc2VsZi5vcGVyYXRvciA9IG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmIChjb21tdXRhdGl2ZU9wZXJhdG9ycyhzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiByaWdodCBpcyBhIGNvbnN0YW50LCB3aGF0ZXZlciBzaWRlIGVmZmVjdHMgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVmdCBzaWRlIG1pZ2h0IGhhdmUgY291bGQgbm90IGluZmx1ZW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXN1bHQuICBoZW5jZSwgZm9yY2Ugc3dpdGNoLlxuXG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICYmIFBSRUNFREVOQ0Vbc2VsZi5sZWZ0Lm9wZXJhdG9yXSA+PSBQUkVDRURFTkNFW3NlbGYub3BlcmF0b3JdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXlshPV09PT8kLy50ZXN0KHNlbGYub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodC5jb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5jb25zZXF1ZW50LmRlZmluaXRpb24oKSA9PT0gc2VsZi5sZWZ0LmRlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9ePT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLnJpZ2h0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0LmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5hbHRlcm5hdGl2ZS5kZWZpbml0aW9uKCkgPT09IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXj09Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eIT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLnJpZ2h0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQuY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5jb25zZXF1ZW50LmRlZmluaXRpb24oKSA9PT0gc2VsZi5yaWdodC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXj09Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5sZWZ0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5sZWZ0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5hbHRlcm5hdGl2ZS5kZWZpbml0aW9uKCkgPT09IHNlbGYucmlnaHQuZGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL149PS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYubGVmdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eIT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLmxlZnQuY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYgPSBzZWxmLmxpZnRfc2VxdWVuY2VzKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjb21wYXJpc29uc1wiKSkgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICAgIGNhc2UgXCIhPT1cIjpcbiAgICAgICAgICAgIGlmICgoc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5sZWZ0LmlzX2Jvb2xlYW4oKSAmJiBzZWxmLnJpZ2h0LmlzX2Jvb2xlYW4oKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5vcGVyYXRvci5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBYWFg6IGludGVudGlvbmFsbHkgZmFsbGluZyBkb3duIHRvIHRoZSBuZXh0IGNhc2VcbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnZhbHVlID09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcInR5cGVvZlwiXG4gICAgICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShzZWxmLnJpZ2h0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgICAgICB8fCAhc2VsZi5yaWdodC5leHByZXNzaW9uLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5sZWZ0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IubGVuZ3RoID09IDIpIHNlbGYub3BlcmF0b3IgKz0gXCI9XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNcIikgJiYgY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmICFsbFsxXSkgfHwgKHJyLmxlbmd0aCA+IDEgJiYgIXJyWzFdKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkJvb2xlYW4gJiYgYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9GYWxzZSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGwubGVuZ3RoID4gMSAmJiBsbFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyci5sZW5ndGggPiAxICYmIHJyWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxsWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmIGxsWzFdKSB8fCAocnIubGVuZ3RoID4gMSAmJiByclsxXSkpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuIHx8IGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsbC5sZW5ndGggPiAxICYmICFsbFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyci5sZW5ndGggPiAxICYmICFyclsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmIGxsWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBsbFsxXSkgfHxcbiAgICAgICAgICAgICAgICAocnIubGVuZ3RoID4gMSAmJiByclswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgJiYgcnJbMV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiKyBpbiBib29sZWFuIGNvbnRleHQgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29tcGFyaXNvbnNcIikpIHtcbiAgICAgICAgICAgIGlmICghKGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KVxuICAgICAgICAgICAgICAgIHx8IGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZWQgPSBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5uZWdhdGUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBuZWdhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiOiByZXZlcnNlKFwiPlwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiOiByZXZlcnNlKFwiPj1cIik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmdldFZhbHVlKCkgPT09IFwiXCIgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIitcIiAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQuZ2V0VmFsdWUoKSA9PT0gXCJcIiAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYubGVmdC5yaWdodCBpbnN0YW5jZW9mIEFTVF9OdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYucmlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhzZWxmLmxlZnQucmlnaHQudmFsdWUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIitcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiICsgc2VsZi5sZWZ0LmdldFZhbHVlKCkgKyBzZWxmLnJpZ2h0LmxlZnQuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5sZWZ0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiICsgc2VsZi5sZWZ0LnJpZ2h0LmdldFZhbHVlKCkgKyBzZWxmLnJpZ2h0LmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5yaWdodC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGYucmlnaHQuZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIgKyBzZWxmLmxlZnQucmlnaHQuZ2V0VmFsdWUoKSArIHNlbGYucmlnaHQubGVmdC5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LnJpZ2h0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGYucmlnaHQubGVmdC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geCAqICh5ICogeikgID09PiAgeCAqIHkgKiB6XG4gICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBzZWxmLm9wZXJhdG9yXG4gICAgICAgICAgICAmJiAoc2VsZi5vcGVyYXRvciA9PSBcIipcIiB8fCBzZWxmLm9wZXJhdG9yID09IFwiJiZcIiB8fCBzZWxmLm9wZXJhdG9yID09IFwifHxcIikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYubGVmdCA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLnJpZ2h0LmxlZnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQucmlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgdmFyIGRlZmluZXMgPSBjb21wcmVzc29yLm9wdGlvbihcImdsb2JhbF9kZWZzXCIpO1xuICAgICAgICAgICAgaWYgKGRlZmluZXMgJiYgZGVmaW5lcy5oYXNPd25Qcm9wZXJ0eShzZWxmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIGRlZmluZXNbc2VsZi5uYW1lXSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX05hTiwgc2VsZik7XG4gICAgICAgICAgICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0luZmluaXR5LCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5kZWZpbmVkLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9TY29wZSk7XG4gICAgICAgICAgICB2YXIgdW5kZWYgPSBzY29wZS5maW5kX3ZhcmlhYmxlKFwidW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgaWYgKHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgICA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICA6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICB0aGVkZWYgOiB1bmRlZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlZi5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgdmFyIEFTU0lHTl9PUFMgPSBbICcrJywgJy0nLCAnLycsICcqJywgJyUnLCAnPj4nLCAnPDwnLCAnPj4+JywgJ3wnLCAnXicsICcmJyBdO1xuICAgIE9QVChBU1RfQXNzaWduLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZiA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0Lm5hbWUgPT0gc2VsZi5sZWZ0Lm5hbWVcbiAgICAgICAgICAgICYmIG1lbWJlcihzZWxmLnJpZ2h0Lm9wZXJhdG9yLCBBU1NJR05fT1BTKSkge1xuICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IHNlbGYucmlnaHQub3BlcmF0b3IgKyBcIj1cIjtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24gaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICB2YXIgY2FyID0gc2VsZi5jb25kaXRpb24uY2FyO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi5jZHI7XG4gICAgICAgICAgICByZXR1cm4gQVNUX1NlcS5jb25zKGNhciwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGNvbmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvbmRbMV0pIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkNvbmRpdGlvbiBhbHdheXMgZmFsc2UgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZWdhdGVkID0gY29uZFswXS5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChiZXN0X29mKGNvbmRbMF0sIG5lZ2F0ZWQpID09PSBuZWdhdGVkKSB7XG4gICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogbmVnYXRlZCxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBzZWxmLmFsdGVybmF0aXZlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBzZWxmLmNvbnNlcXVlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zZXF1ZW50ID0gc2VsZi5jb25zZXF1ZW50O1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICBpZiAoY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmIGFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5vcGVyYXRvciA9PSBhbHRlcm5hdGl2ZS5vcGVyYXRvclxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5sZWZ0LmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUubGVmdClcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogU3R1ZmYgbGlrZSB0aGlzOlxuICAgICAgICAgICAgICogaWYgKGZvbykgZXhwID0gc29tZXRoaW5nOyBlbHNlIGV4cCA9IHNvbWV0aGluZ19lbHNlO1xuICAgICAgICAgICAgICogPT0+XG4gICAgICAgICAgICAgKiBleHAgPSBmb28gPyBzb21ldGhpbmcgOiBzb21ldGhpbmdfZWxzZTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQXNzaWduLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvbnNlcXVlbnQub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdDogY29uc2VxdWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRlcm5hdGl2ZS5yaWdodFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQm9vbGVhbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgKHAub3BlcmF0b3IgPT0gXCI9PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCIhPVwiKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIk5vbi1zdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCBib29sZWFuOiB7b3BlcmF0b3J9IHt2YWx1ZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBwLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHNlbGYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUgICAgIDogcC5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lICAgICA6IHAuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sICAgICAgOiBwLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICtzZWxmLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMSAtIHNlbGYudmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIGNvbXByZXNzb3Iub3B0aW9uKFwicHJvcGVydGllc1wiKSkge1xuICAgICAgICAgICAgcHJvcCA9IHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUyhwcm9wKSA/IGNvbXByZXNzb3Iub3B0aW9uKFwic2NyZXdfaWU4XCIpIDogaXNfaWRlbnRpZmllcl9zdHJpbmcocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Eb3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHNlbGYuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3BcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgT1BUKEFTVF9BcnJheSwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcbiAgICBPUFQoQVNUX09iamVjdCwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcbiAgICBPUFQoQVNUX1JlZ0V4cCwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcblxufSkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBmaXR6Z2VuJ3Mgc291cmNlLW1hcCBsaWJyYXJ5XG5mdW5jdGlvbiBTb3VyY2VNYXAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGZpbGUgOiBudWxsLFxuICAgICAgICByb290IDogbnVsbCxcbiAgICAgICAgb3JpZyA6IG51bGwsXG4gICAgfSk7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBNT1pfU291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGUgICAgICAgOiBvcHRpb25zLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3QgOiBvcHRpb25zLnJvb3RcbiAgICB9KTtcbiAgICB2YXIgb3JpZ19tYXAgPSBvcHRpb25zLm9yaWcgJiYgbmV3IE1PWl9Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIob3B0aW9ucy5vcmlnKTtcbiAgICBmdW5jdGlvbiBhZGQoc291cmNlLCBnZW5fbGluZSwgZ2VuX2NvbCwgb3JpZ19saW5lLCBvcmlnX2NvbCwgbmFtZSkge1xuICAgICAgICBpZiAob3JpZ19tYXApIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gb3JpZ19tYXAub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ19saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ19jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc291cmNlID0gaW5mby5zb3VyY2U7XG4gICAgICAgICAgICBvcmlnX2xpbmUgPSBpbmZvLmxpbmU7XG4gICAgICAgICAgICBvcmlnX2NvbCA9IGluZm8uY29sdW1uO1xuICAgICAgICAgICAgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBnZW5lcmF0ZWQgOiB7IGxpbmU6IGdlbl9saW5lLCBjb2x1bW46IGdlbl9jb2wgfSxcbiAgICAgICAgICAgIG9yaWdpbmFsICA6IHsgbGluZTogb3JpZ19saW5lLCBjb2x1bW46IG9yaWdfY29sIH0sXG4gICAgICAgICAgICBzb3VyY2UgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICBuYW1lICAgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkICAgICAgICA6IGFkZCxcbiAgICAgICAgZ2V0ICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2VuZXJhdG9yIH0sXG4gICAgICAgIHRvU3RyaW5nICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdlbmVyYXRvci50b1N0cmluZygpIH1cbiAgICB9O1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgTU9aX1RPX01FID0ge1xuICAgICAgICBUcnlTdGF0ZW1lbnQgOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ucnkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYm9keSAgICAgOiBmcm9tX21veihNLmJsb2NrKS5ib2R5LFxuICAgICAgICAgICAgICAgIGJjYXRjaCAgIDogZnJvbV9tb3ooTS5oYW5kbGVyc1swXSksXG4gICAgICAgICAgICAgICAgYmZpbmFsbHkgOiBNLmZpbmFsaXplciA/IG5ldyBBU1RfRmluYWxseShmcm9tX21veihNLmZpbmFsaXplcikpIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIENhdGNoQ2xhdXNlIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2F0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGFyZ25hbWUgOiBmcm9tX21veihNLnBhcmFtKSxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogZnJvbV9tb3ooTS5ib2R5KS5ib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbiA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA6IE0ucHJvcGVydGllcy5tYXAoZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBrZXkudHlwZSA9PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKHByb3AudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICAgICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBmcm9tX21veihwcm9wLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3Aua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RLZXlWYWwoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy52YWx1ZS5uYW1lID0gZnJvbV9tb3ooa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdFNldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnZhbHVlLm5hbWUgPSBmcm9tX21veihrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0R2V0dGVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gQVNUX1NlcS5mcm9tX2FycmF5KE0uZXhwcmVzc2lvbnMubWFwKGZyb21fbW96KSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLmNvbXB1dGVkID8gQVNUX1N1YiA6IEFTVF9Eb3QpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogTS5jb21wdXRlZCA/IGZyb21fbW96KE0ucHJvcGVydHkpIDogTS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLm9iamVjdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBTd2l0Y2hDYXNlIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS50ZXN0ID8gQVNUX0Nhc2UgOiBBU1RfRGVmYXVsdCkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLnRlc3QpLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBNLmNvbnNlcXVlbnQubWFwKGZyb21fbW96KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIExpdGVyYWwgOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gTS52YWx1ZSwgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBteV9lbmRfdG9rZW4oTSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gbmV3IEFTVF9OdWxsKGFyZ3MpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N0cmluZyhhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfTnVtYmVyKGFyZ3MpO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHZhbCA/IEFTVF9UcnVlIDogQVNUX0ZhbHNlKShhcmdzKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JlZ0V4cChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBGcm9tX01vel9VbmFyeSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogRnJvbV9Nb3pfVW5hcnksXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBwID0gRlJPTV9NT1pfU1RBQ0tbRlJPTV9NT1pfU1RBQ0subGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLm5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJMYWJlbGVkU3RhdGVtZW50XCIgPyBBU1RfTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIgJiYgcC5pZCA9PT0gTSA/IChwLmtpbmQgPT0gXCJjb25zdFwiID8gQVNUX1N5bWJvbENvbnN0IDogQVNUX1N5bWJvbFZhcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPyAocC5pZCA9PT0gTSA/IEFTVF9TeW1ib2xMYW1iZGEgOiBBU1RfU3ltYm9sRnVuYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyAocC5pZCA9PT0gTSA/IEFTVF9TeW1ib2xEZWZ1biA6IEFTVF9TeW1ib2xGdW5hcmcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkNhdGNoQ2xhdXNlXCIgPyBBU1RfU3ltYm9sQ2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiQnJlYWtTdGF0ZW1lbnRcIiB8fCBwLnR5cGUgPT0gXCJDb250aW51ZVN0YXRlbWVudFwiID8gQVNUX0xhYmVsUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEFTVF9TeW1ib2xSZWYpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgIDogTS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGcm9tX01vel9VbmFyeShNKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBcInByZWZpeFwiIGluIE0gPyBNLnByZWZpeFxuICAgICAgICAgICAgOiBNLnR5cGUgPT0gXCJVbmFyeUV4cHJlc3Npb25cIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyAocHJlZml4ID8gQVNUX1VuYXJ5UHJlZml4IDogQVNUX1VuYXJ5UG9zdGZpeCkoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgIG9wZXJhdG9yICAgOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGZyb21fbW96KE0uYXJndW1lbnQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgTUVfVE9fTU9aID0ge307XG5cbiAgICBtYXAoXCJOb2RlXCIsIEFTVF9Ob2RlKTtcbiAgICBtYXAoXCJQcm9ncmFtXCIsIEFTVF9Ub3BsZXZlbCwgXCJib2R5QGJvZHlcIik7XG4gICAgbWFwKFwiRnVuY3Rpb25cIiwgQVNUX0Z1bmN0aW9uLCBcImlkPm5hbWUsIHBhcmFtc0BhcmduYW1lcywgYm9keSVib2R5XCIpO1xuICAgIG1hcChcIkVtcHR5U3RhdGVtZW50XCIsIEFTVF9FbXB0eVN0YXRlbWVudCk7XG4gICAgbWFwKFwiQmxvY2tTdGF0ZW1lbnRcIiwgQVNUX0Jsb2NrU3RhdGVtZW50LCBcImJvZHlAYm9keVwiKTtcbiAgICBtYXAoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIEFTVF9TaW1wbGVTdGF0ZW1lbnQsIFwiZXhwcmVzc2lvbj5ib2R5XCIpO1xuICAgIG1hcChcIklmU3RhdGVtZW50XCIsIEFTVF9JZiwgXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5ib2R5LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIik7XG4gICAgbWFwKFwiTGFiZWxlZFN0YXRlbWVudFwiLCBBU1RfTGFiZWxlZFN0YXRlbWVudCwgXCJsYWJlbD5sYWJlbCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkJyZWFrU3RhdGVtZW50XCIsIEFTVF9CcmVhaywgXCJsYWJlbD5sYWJlbFwiKTtcbiAgICBtYXAoXCJDb250aW51ZVN0YXRlbWVudFwiLCBBU1RfQ29udGludWUsIFwibGFiZWw+bGFiZWxcIik7XG4gICAgbWFwKFwiV2l0aFN0YXRlbWVudFwiLCBBU1RfV2l0aCwgXCJvYmplY3Q+ZXhwcmVzc2lvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIlN3aXRjaFN0YXRlbWVudFwiLCBBU1RfU3dpdGNoLCBcImRpc2NyaW1pbmFudD5leHByZXNzaW9uLCBjYXNlc0Bib2R5XCIpO1xuICAgIG1hcChcIlJldHVyblN0YXRlbWVudFwiLCBBU1RfUmV0dXJuLCBcImFyZ3VtZW50PnZhbHVlXCIpO1xuICAgIG1hcChcIlRocm93U3RhdGVtZW50XCIsIEFTVF9UaHJvdywgXCJhcmd1bWVudD52YWx1ZVwiKTtcbiAgICBtYXAoXCJXaGlsZVN0YXRlbWVudFwiLCBBU1RfV2hpbGUsIFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJEb1doaWxlU3RhdGVtZW50XCIsIEFTVF9EbywgXCJ0ZXN0PmNvbmRpdGlvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkZvclN0YXRlbWVudFwiLCBBU1RfRm9yLCBcImluaXQ+aW5pdCwgdGVzdD5jb25kaXRpb24sIHVwZGF0ZT5zdGVwLCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRm9ySW5TdGF0ZW1lbnRcIiwgQVNUX0ZvckluLCBcImxlZnQ+aW5pdCwgcmlnaHQ+b2JqZWN0LCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgQVNUX0RlYnVnZ2VyKTtcbiAgICBtYXAoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIEFTVF9EZWZ1biwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIEFTVF9WYXIsIFwiZGVjbGFyYXRpb25zQGRlZmluaXRpb25zXCIpO1xuICAgIG1hcChcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCBBU1RfVmFyRGVmLCBcImlkPm5hbWUsIGluaXQ+dmFsdWVcIik7XG5cbiAgICBtYXAoXCJUaGlzRXhwcmVzc2lvblwiLCBBU1RfVGhpcyk7XG4gICAgbWFwKFwiQXJyYXlFeHByZXNzaW9uXCIsIEFTVF9BcnJheSwgXCJlbGVtZW50c0BlbGVtZW50c1wiKTtcbiAgICBtYXAoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgQVNUX0Z1bmN0aW9uLCBcImlkPm5hbWUsIHBhcmFtc0BhcmduYW1lcywgYm9keSVib2R5XCIpO1xuICAgIG1hcChcIkJpbmFyeUV4cHJlc3Npb25cIiwgQVNUX0JpbmFyeSwgXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKTtcbiAgICBtYXAoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBBU1RfQXNzaWduLCBcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpO1xuICAgIG1hcChcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIEFTVF9CaW5hcnksIFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIik7XG4gICAgbWFwKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIEFTVF9Db25kaXRpb25hbCwgXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5jb25zZXF1ZW50LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIik7XG4gICAgbWFwKFwiTmV3RXhwcmVzc2lvblwiLCBBU1RfTmV3LCBcImNhbGxlZT5leHByZXNzaW9uLCBhcmd1bWVudHNAYXJnc1wiKTtcbiAgICBtYXAoXCJDYWxsRXhwcmVzc2lvblwiLCBBU1RfQ2FsbCwgXCJjYWxsZWU+ZXhwcmVzc2lvbiwgYXJndW1lbnRzQGFyZ3NcIik7XG5cbiAgICAvKiAtLS0tLVsgdG9vbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBteV9zdGFydF90b2tlbihtb3pub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHtcbiAgICAgICAgICAgIGZpbGUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnNvdXJjZSxcbiAgICAgICAgICAgIGxpbmUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBwb3MgICAgOiBtb3pub2RlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kcG9zIDogbW96bm9kZS5zdGFydFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbXlfZW5kX3Rva2VuKG1vem5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oe1xuICAgICAgICAgICAgZmlsZSAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2Muc291cmNlLFxuICAgICAgICAgICAgbGluZSAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2MuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5lbmQuY29sdW1uLFxuICAgICAgICAgICAgcG9zICAgIDogbW96bm9kZS5lbmQsXG4gICAgICAgICAgICBlbmRwb3MgOiBtb3pub2RlLmVuZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwKG1venR5cGUsIG15dHlwZSwgcHJvcG1hcCkge1xuICAgICAgICB2YXIgbW96X3RvX21lID0gXCJmdW5jdGlvbiBGcm9tX01vel9cIiArIG1venR5cGUgKyBcIihNKXtcXG5cIjtcbiAgICAgICAgbW96X3RvX21lICs9IFwicmV0dXJuIG5ldyBteXR5cGUoe1xcblwiICtcbiAgICAgICAgICAgIFwic3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxcblwiICtcbiAgICAgICAgICAgIFwiZW5kOiBteV9lbmRfdG9rZW4oTSlcIjtcblxuICAgICAgICBpZiAocHJvcG1hcCkgcHJvcG1hcC5zcGxpdCgvXFxzKixcXHMqLykuZm9yRWFjaChmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHZhciBtID0gLyhbYS16MC05JF9dKykoPXxAfD58JSkoW2EtejAtOSRfXSspL2kuZXhlYyhwcm9wKTtcbiAgICAgICAgICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdW5kZXJzdGFuZCBwcm9wZXJ0eSBtYXA6IFwiICsgcHJvcCk7XG4gICAgICAgICAgICB2YXIgbW96ID0gXCJNLlwiICsgbVsxXSwgaG93ID0gbVsyXSwgbXkgPSBtWzNdO1xuICAgICAgICAgICAgbW96X3RvX21lICs9IFwiLFxcblwiICsgbXkgKyBcIjogXCI7XG4gICAgICAgICAgICBpZiAoaG93ID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IG1veiArIFwiLm1hcChmcm9tX21veilcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooXCIgKyBtb3ogKyBcIilcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IG1vejtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiJVwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooXCIgKyBtb3ogKyBcIikuYm9keVwiO1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVuZGVyc3RhbmQgb3BlcmF0b3IgaW4gcHJvcG1hcDogXCIgKyBwcm9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vel90b19tZSArPSBcIlxcbn0pfVwiO1xuXG4gICAgICAgIC8vIG1vel90b19tZSA9IHBhcnNlKG1vel90b19tZSkucHJpbnRfdG9fc3RyaW5nKHsgYmVhdXRpZnk6IHRydWUgfSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1vel90b19tZSk7XG5cbiAgICAgICAgbW96X3RvX21lID0gbmV3IEZ1bmN0aW9uKFwibXl0eXBlXCIsIFwibXlfc3RhcnRfdG9rZW5cIiwgXCJteV9lbmRfdG9rZW5cIiwgXCJmcm9tX21velwiLCBcInJldHVybihcIiArIG1vel90b19tZSArIFwiKVwiKShcbiAgICAgICAgICAgIG15dHlwZSwgbXlfc3RhcnRfdG9rZW4sIG15X2VuZF90b2tlbiwgZnJvbV9tb3pcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIE1PWl9UT19NRVttb3p0eXBlXSA9IG1vel90b19tZTtcbiAgICB9O1xuXG4gICAgdmFyIEZST01fTU9aX1NUQUNLID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGZyb21fbW96KG5vZGUpIHtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sucHVzaChub2RlKTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUgIT0gbnVsbCA/IE1PWl9UT19NRVtub2RlLnR5cGVdKG5vZGUpIDogbnVsbDtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sucG9wKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIEFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QgPSBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHNhdmVfc3RhY2sgPSBGUk9NX01PWl9TVEFDSztcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sgPSBbXTtcbiAgICAgICAgdmFyIGFzdCA9IGZyb21fbW96KG5vZGUpO1xuICAgICAgICBGUk9NX01PWl9TVEFDSyA9IHNhdmVfc3RhY2s7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcblxufSkoKTtcblxuXG5leHBvcnRzLnN5cyA9IHN5cztcbmV4cG9ydHMuTU9aX1NvdXJjZU1hcCA9IE1PWl9Tb3VyY2VNYXA7XG5leHBvcnRzLlVnbGlmeUpTID0gVWdsaWZ5SlM7XG5leHBvcnRzLmFycmF5X3RvX2hhc2ggPSBhcnJheV90b19oYXNoO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy5jaGFyYWN0ZXJzID0gY2hhcmFjdGVycztcbmV4cG9ydHMubWVtYmVyID0gbWVtYmVyO1xuZXhwb3J0cy5maW5kX2lmID0gZmluZF9pZjtcbmV4cG9ydHMucmVwZWF0X3N0cmluZyA9IHJlcGVhdF9zdHJpbmc7XG5leHBvcnRzLkRlZmF1bHRzRXJyb3IgPSBEZWZhdWx0c0Vycm9yO1xuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuTUFQID0gTUFQO1xuZXhwb3J0cy5wdXNoX3VuaXEgPSBwdXNoX3VuaXE7XG5leHBvcnRzLnN0cmluZ190ZW1wbGF0ZSA9IHN0cmluZ190ZW1wbGF0ZTtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZXhwb3J0cy5tZXJnZVNvcnQgPSBtZXJnZVNvcnQ7XG5leHBvcnRzLnNldF9kaWZmZXJlbmNlID0gc2V0X2RpZmZlcmVuY2U7XG5leHBvcnRzLnNldF9pbnRlcnNlY3Rpb24gPSBzZXRfaW50ZXJzZWN0aW9uO1xuZXhwb3J0cy5tYWtlUHJlZGljYXRlID0gbWFrZVByZWRpY2F0ZTtcbmV4cG9ydHMuYWxsID0gYWxsO1xuZXhwb3J0cy5EaWN0aW9uYXJ5ID0gRGljdGlvbmFyeTtcbmV4cG9ydHMuREVGTk9ERSA9IERFRk5PREU7XG5leHBvcnRzLkFTVF9Ub2tlbiA9IEFTVF9Ub2tlbjtcbmV4cG9ydHMuQVNUX05vZGUgPSBBU1RfTm9kZTtcbmV4cG9ydHMuQVNUX1N0YXRlbWVudCA9IEFTVF9TdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9EZWJ1Z2dlciA9IEFTVF9EZWJ1Z2dlcjtcbmV4cG9ydHMuQVNUX0RpcmVjdGl2ZSA9IEFTVF9EaXJlY3RpdmU7XG5leHBvcnRzLkFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBBU1RfU2ltcGxlU3RhdGVtZW50O1xuZXhwb3J0cy53YWxrX2JvZHkgPSB3YWxrX2JvZHk7XG5leHBvcnRzLkFTVF9CbG9jayA9IEFTVF9CbG9jaztcbmV4cG9ydHMuQVNUX0Jsb2NrU3RhdGVtZW50ID0gQVNUX0Jsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRW1wdHlTdGF0ZW1lbnQgPSBBU1RfRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9TdGF0ZW1lbnRXaXRoQm9keSA9IEFTVF9TdGF0ZW1lbnRXaXRoQm9keTtcbmV4cG9ydHMuQVNUX0xhYmVsZWRTdGF0ZW1lbnQgPSBBU1RfTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuQVNUX0l0ZXJhdGlvblN0YXRlbWVudCA9IEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9EV0xvb3AgPSBBU1RfRFdMb29wO1xuZXhwb3J0cy5BU1RfRG8gPSBBU1RfRG87XG5leHBvcnRzLkFTVF9XaGlsZSA9IEFTVF9XaGlsZTtcbmV4cG9ydHMuQVNUX0ZvciA9IEFTVF9Gb3I7XG5leHBvcnRzLkFTVF9Gb3JJbiA9IEFTVF9Gb3JJbjtcbmV4cG9ydHMuQVNUX1dpdGggPSBBU1RfV2l0aDtcbmV4cG9ydHMuQVNUX1Njb3BlID0gQVNUX1Njb3BlO1xuZXhwb3J0cy5BU1RfVG9wbGV2ZWwgPSBBU1RfVG9wbGV2ZWw7XG5leHBvcnRzLkFTVF9MYW1iZGEgPSBBU1RfTGFtYmRhO1xuZXhwb3J0cy5BU1RfQWNjZXNzb3IgPSBBU1RfQWNjZXNzb3I7XG5leHBvcnRzLkFTVF9GdW5jdGlvbiA9IEFTVF9GdW5jdGlvbjtcbmV4cG9ydHMuQVNUX0RlZnVuID0gQVNUX0RlZnVuO1xuZXhwb3J0cy5BU1RfSnVtcCA9IEFTVF9KdW1wO1xuZXhwb3J0cy5BU1RfRXhpdCA9IEFTVF9FeGl0O1xuZXhwb3J0cy5BU1RfUmV0dXJuID0gQVNUX1JldHVybjtcbmV4cG9ydHMuQVNUX1Rocm93ID0gQVNUX1Rocm93O1xuZXhwb3J0cy5BU1RfTG9vcENvbnRyb2wgPSBBU1RfTG9vcENvbnRyb2w7XG5leHBvcnRzLkFTVF9CcmVhayA9IEFTVF9CcmVhaztcbmV4cG9ydHMuQVNUX0NvbnRpbnVlID0gQVNUX0NvbnRpbnVlO1xuZXhwb3J0cy5BU1RfSWYgPSBBU1RfSWY7XG5leHBvcnRzLkFTVF9Td2l0Y2ggPSBBU1RfU3dpdGNoO1xuZXhwb3J0cy5BU1RfU3dpdGNoQnJhbmNoID0gQVNUX1N3aXRjaEJyYW5jaDtcbmV4cG9ydHMuQVNUX0RlZmF1bHQgPSBBU1RfRGVmYXVsdDtcbmV4cG9ydHMuQVNUX0Nhc2UgPSBBU1RfQ2FzZTtcbmV4cG9ydHMuQVNUX1RyeSA9IEFTVF9Ucnk7XG5leHBvcnRzLkFTVF9DYXRjaCA9IEFTVF9DYXRjaDtcbmV4cG9ydHMuQVNUX0ZpbmFsbHkgPSBBU1RfRmluYWxseTtcbmV4cG9ydHMuQVNUX0RlZmluaXRpb25zID0gQVNUX0RlZmluaXRpb25zO1xuZXhwb3J0cy5BU1RfVmFyID0gQVNUX1ZhcjtcbmV4cG9ydHMuQVNUX0NvbnN0ID0gQVNUX0NvbnN0O1xuZXhwb3J0cy5BU1RfVmFyRGVmID0gQVNUX1ZhckRlZjtcbmV4cG9ydHMuQVNUX0NhbGwgPSBBU1RfQ2FsbDtcbmV4cG9ydHMuQVNUX05ldyA9IEFTVF9OZXc7XG5leHBvcnRzLkFTVF9TZXEgPSBBU1RfU2VxO1xuZXhwb3J0cy5BU1RfUHJvcEFjY2VzcyA9IEFTVF9Qcm9wQWNjZXNzO1xuZXhwb3J0cy5BU1RfRG90ID0gQVNUX0RvdDtcbmV4cG9ydHMuQVNUX1N1YiA9IEFTVF9TdWI7XG5leHBvcnRzLkFTVF9VbmFyeSA9IEFTVF9VbmFyeTtcbmV4cG9ydHMuQVNUX1VuYXJ5UHJlZml4ID0gQVNUX1VuYXJ5UHJlZml4O1xuZXhwb3J0cy5BU1RfVW5hcnlQb3N0Zml4ID0gQVNUX1VuYXJ5UG9zdGZpeDtcbmV4cG9ydHMuQVNUX0JpbmFyeSA9IEFTVF9CaW5hcnk7XG5leHBvcnRzLkFTVF9Db25kaXRpb25hbCA9IEFTVF9Db25kaXRpb25hbDtcbmV4cG9ydHMuQVNUX0Fzc2lnbiA9IEFTVF9Bc3NpZ247XG5leHBvcnRzLkFTVF9BcnJheSA9IEFTVF9BcnJheTtcbmV4cG9ydHMuQVNUX09iamVjdCA9IEFTVF9PYmplY3Q7XG5leHBvcnRzLkFTVF9PYmplY3RQcm9wZXJ0eSA9IEFTVF9PYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMuQVNUX09iamVjdEtleVZhbCA9IEFTVF9PYmplY3RLZXlWYWw7XG5leHBvcnRzLkFTVF9PYmplY3RTZXR0ZXIgPSBBU1RfT2JqZWN0U2V0dGVyO1xuZXhwb3J0cy5BU1RfT2JqZWN0R2V0dGVyID0gQVNUX09iamVjdEdldHRlcjtcbmV4cG9ydHMuQVNUX1N5bWJvbCA9IEFTVF9TeW1ib2w7XG5leHBvcnRzLkFTVF9TeW1ib2xBY2Nlc3NvciA9IEFTVF9TeW1ib2xBY2Nlc3NvcjtcbmV4cG9ydHMuQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gQVNUX1N5bWJvbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5BU1RfU3ltYm9sVmFyID0gQVNUX1N5bWJvbFZhcjtcbmV4cG9ydHMuQVNUX1N5bWJvbENvbnN0ID0gQVNUX1N5bWJvbENvbnN0O1xuZXhwb3J0cy5BU1RfU3ltYm9sRnVuYXJnID0gQVNUX1N5bWJvbEZ1bmFyZztcbmV4cG9ydHMuQVNUX1N5bWJvbERlZnVuID0gQVNUX1N5bWJvbERlZnVuO1xuZXhwb3J0cy5BU1RfU3ltYm9sTGFtYmRhID0gQVNUX1N5bWJvbExhbWJkYTtcbmV4cG9ydHMuQVNUX1N5bWJvbENhdGNoID0gQVNUX1N5bWJvbENhdGNoO1xuZXhwb3J0cy5BU1RfTGFiZWwgPSBBU1RfTGFiZWw7XG5leHBvcnRzLkFTVF9TeW1ib2xSZWYgPSBBU1RfU3ltYm9sUmVmO1xuZXhwb3J0cy5BU1RfTGFiZWxSZWYgPSBBU1RfTGFiZWxSZWY7XG5leHBvcnRzLkFTVF9UaGlzID0gQVNUX1RoaXM7XG5leHBvcnRzLkFTVF9Db25zdGFudCA9IEFTVF9Db25zdGFudDtcbmV4cG9ydHMuQVNUX1N0cmluZyA9IEFTVF9TdHJpbmc7XG5leHBvcnRzLkFTVF9OdW1iZXIgPSBBU1RfTnVtYmVyO1xuZXhwb3J0cy5BU1RfUmVnRXhwID0gQVNUX1JlZ0V4cDtcbmV4cG9ydHMuQVNUX0F0b20gPSBBU1RfQXRvbTtcbmV4cG9ydHMuQVNUX051bGwgPSBBU1RfTnVsbDtcbmV4cG9ydHMuQVNUX05hTiA9IEFTVF9OYU47XG5leHBvcnRzLkFTVF9VbmRlZmluZWQgPSBBU1RfVW5kZWZpbmVkO1xuZXhwb3J0cy5BU1RfSG9sZSA9IEFTVF9Ib2xlO1xuZXhwb3J0cy5BU1RfSW5maW5pdHkgPSBBU1RfSW5maW5pdHk7XG5leHBvcnRzLkFTVF9Cb29sZWFuID0gQVNUX0Jvb2xlYW47XG5leHBvcnRzLkFTVF9GYWxzZSA9IEFTVF9GYWxzZTtcbmV4cG9ydHMuQVNUX1RydWUgPSBBU1RfVHJ1ZTtcbmV4cG9ydHMuVHJlZVdhbGtlciA9IFRyZWVXYWxrZXI7XG5leHBvcnRzLktFWVdPUkRTID0gS0VZV09SRFM7XG5leHBvcnRzLktFWVdPUkRTX0FUT00gPSBLRVlXT1JEU19BVE9NO1xuZXhwb3J0cy5SRVNFUlZFRF9XT1JEUyA9IFJFU0VSVkVEX1dPUkRTO1xuZXhwb3J0cy5LRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9IEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OO1xuZXhwb3J0cy5PUEVSQVRPUl9DSEFSUyA9IE9QRVJBVE9SX0NIQVJTO1xuZXhwb3J0cy5SRV9IRVhfTlVNQkVSID0gUkVfSEVYX05VTUJFUjtcbmV4cG9ydHMuUkVfT0NUX05VTUJFUiA9IFJFX09DVF9OVU1CRVI7XG5leHBvcnRzLlJFX0RFQ19OVU1CRVIgPSBSRV9ERUNfTlVNQkVSO1xuZXhwb3J0cy5PUEVSQVRPUlMgPSBPUEVSQVRPUlM7XG5leHBvcnRzLldISVRFU1BBQ0VfQ0hBUlMgPSBXSElURVNQQUNFX0NIQVJTO1xuZXhwb3J0cy5QVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gUFVOQ19CRUZPUkVfRVhQUkVTU0lPTjtcbmV4cG9ydHMuUFVOQ19DSEFSUyA9IFBVTkNfQ0hBUlM7XG5leHBvcnRzLlJFR0VYUF9NT0RJRklFUlMgPSBSRUdFWFBfTU9ESUZJRVJTO1xuZXhwb3J0cy5VTklDT0RFID0gVU5JQ09ERTtcbmV4cG9ydHMuaXNfbGV0dGVyID0gaXNfbGV0dGVyO1xuZXhwb3J0cy5pc19kaWdpdCA9IGlzX2RpZ2l0O1xuZXhwb3J0cy5pc19hbHBoYW51bWVyaWNfY2hhciA9IGlzX2FscGhhbnVtZXJpY19jaGFyO1xuZXhwb3J0cy5pc191bmljb2RlX2NvbWJpbmluZ19tYXJrID0gaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyaztcbmV4cG9ydHMuaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24gPSBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbjtcbmV4cG9ydHMuaXNfaWRlbnRpZmllciA9IGlzX2lkZW50aWZpZXI7XG5leHBvcnRzLmlzX2lkZW50aWZpZXJfc3RhcnQgPSBpc19pZGVudGlmaWVyX3N0YXJ0O1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX2NoYXIgPSBpc19pZGVudGlmaWVyX2NoYXI7XG5leHBvcnRzLmlzX2lkZW50aWZpZXJfc3RyaW5nID0gaXNfaWRlbnRpZmllcl9zdHJpbmc7XG5leHBvcnRzLnBhcnNlX2pzX251bWJlciA9IHBhcnNlX2pzX251bWJlcjtcbmV4cG9ydHMuSlNfUGFyc2VfRXJyb3IgPSBKU19QYXJzZV9FcnJvcjtcbmV4cG9ydHMuanNfZXJyb3IgPSBqc19lcnJvcjtcbmV4cG9ydHMuaXNfdG9rZW4gPSBpc190b2tlbjtcbmV4cG9ydHMuRVhfRU9GID0gRVhfRU9GO1xuZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG5leHBvcnRzLlVOQVJZX1BSRUZJWCA9IFVOQVJZX1BSRUZJWDtcbmV4cG9ydHMuVU5BUllfUE9TVEZJWCA9IFVOQVJZX1BPU1RGSVg7XG5leHBvcnRzLkFTU0lHTk1FTlQgPSBBU1NJR05NRU5UO1xuZXhwb3J0cy5QUkVDRURFTkNFID0gUFJFQ0VERU5DRTtcbmV4cG9ydHMuU1RBVEVNRU5UU19XSVRIX0xBQkVMUyA9IFNUQVRFTUVOVFNfV0lUSF9MQUJFTFM7XG5leHBvcnRzLkFUT01JQ19TVEFSVF9UT0tFTiA9IEFUT01JQ19TVEFSVF9UT0tFTjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuVHJlZVRyYW5zZm9ybWVyID0gVHJlZVRyYW5zZm9ybWVyO1xuZXhwb3J0cy5TeW1ib2xEZWYgPSBTeW1ib2xEZWY7XG5leHBvcnRzLmJhc2U1NCA9IGJhc2U1NDtcbmV4cG9ydHMuT3V0cHV0U3RyZWFtID0gT3V0cHV0U3RyZWFtO1xuZXhwb3J0cy5Db21wcmVzc29yID0gQ29tcHJlc3NvcjtcbmV4cG9ydHMuU291cmNlTWFwID0gU291cmNlTWFwO1xuXG5leHBvcnRzLkFTVF9Ob2RlLndhcm5fZnVuY3Rpb24gPSBmdW5jdGlvbiAodHh0KSB7IGlmICh0eXBlb2YgY29uc29sZSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikgY29uc29sZS53YXJuKHR4dCkgfVxuXG5leHBvcnRzLm1pbmlmeSA9IGZ1bmN0aW9uIChmaWxlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVZ2xpZnlKUy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIG91dFNvdXJjZU1hcCA6IG51bGwsXG4gICAgICAgIHNvdXJjZVJvb3QgICA6IG51bGwsXG4gICAgICAgIGluU291cmNlTWFwICA6IG51bGwsXG4gICAgICAgIGZyb21TdHJpbmcgICA6IGZhbHNlLFxuICAgICAgICB3YXJuaW5ncyAgICAgOiBmYWxzZSxcbiAgICAgICAgbWFuZ2xlICAgICAgIDoge30sXG4gICAgICAgIG91dHB1dCAgICAgICA6IG51bGwsXG4gICAgICAgIGNvbXByZXNzICAgICA6IHt9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBmaWxlcyA9PSBcInN0cmluZ1wiKVxuICAgICAgICBmaWxlcyA9IFsgZmlsZXMgXTtcblxuICAgIFVnbGlmeUpTLmJhc2U1NC5yZXNldCgpO1xuXG4gICAgLy8gMS4gcGFyc2VcbiAgICB2YXIgdG9wbGV2ZWwgPSBudWxsO1xuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIHZhciBjb2RlID0gb3B0aW9ucy5mcm9tU3RyaW5nXG4gICAgICAgICAgICA/IGZpbGVcbiAgICAgICAgICAgIDogZnMucmVhZEZpbGVTeW5jKGZpbGUsIFwidXRmOFwiKTtcbiAgICAgICAgdG9wbGV2ZWwgPSBVZ2xpZnlKUy5wYXJzZShjb2RlLCB7XG4gICAgICAgICAgICBmaWxlbmFtZTogb3B0aW9ucy5mcm9tU3RyaW5nID8gXCI/XCIgOiBmaWxlLFxuICAgICAgICAgICAgdG9wbGV2ZWw6IHRvcGxldmVsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gMi4gY29tcHJlc3NcbiAgICBpZiAob3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICB2YXIgY29tcHJlc3MgPSB7IHdhcm5pbmdzOiBvcHRpb25zLndhcm5pbmdzIH07XG4gICAgICAgIFVnbGlmeUpTLm1lcmdlKGNvbXByZXNzLCBvcHRpb25zLmNvbXByZXNzKTtcbiAgICAgICAgdG9wbGV2ZWwuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICB2YXIgc3EgPSBVZ2xpZnlKUy5Db21wcmVzc29yKGNvbXByZXNzKTtcbiAgICAgICAgdG9wbGV2ZWwgPSB0b3BsZXZlbC50cmFuc2Zvcm0oc3EpO1xuICAgIH1cblxuICAgIC8vIDMuIG1hbmdsZVxuICAgIGlmIChvcHRpb25zLm1hbmdsZSkge1xuICAgICAgICB0b3BsZXZlbC5maWd1cmVfb3V0X3Njb3BlKCk7XG4gICAgICAgIHRvcGxldmVsLmNvbXB1dGVfY2hhcl9mcmVxdWVuY3koKTtcbiAgICAgICAgdG9wbGV2ZWwubWFuZ2xlX25hbWVzKG9wdGlvbnMubWFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyA0LiBvdXRwdXRcbiAgICB2YXIgaW5NYXAgPSBvcHRpb25zLmluU291cmNlTWFwO1xuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5Tb3VyY2VNYXAgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpbk1hcCA9IGZzLnJlYWRGaWxlU3luYyhvcHRpb25zLmluU291cmNlTWFwLCBcInV0ZjhcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm91dFNvdXJjZU1hcCkge1xuICAgICAgICBvdXRwdXQuc291cmNlX21hcCA9IFVnbGlmeUpTLlNvdXJjZU1hcCh7XG4gICAgICAgICAgICBmaWxlOiBvcHRpb25zLm91dFNvdXJjZU1hcCxcbiAgICAgICAgICAgIG9yaWc6IGluTWFwLFxuICAgICAgICAgICAgcm9vdDogb3B0aW9ucy5zb3VyY2VSb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICAgICAgVWdsaWZ5SlMubWVyZ2Uob3V0cHV0LCBvcHRpb25zLm91dHB1dCk7XG4gICAgfVxuICAgIHZhciBzdHJlYW0gPSBVZ2xpZnlKUy5PdXRwdXRTdHJlYW0ob3V0cHV0KTtcbiAgICB0b3BsZXZlbC5wcmludChzdHJlYW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGUgOiBzdHJlYW0gKyBcIlwiLFxuICAgICAgICBtYXAgIDogb3V0cHV0LnNvdXJjZV9tYXAgKyBcIlwiXG4gICAgfTtcbn07XG5cbmV4cG9ydHMuZGVzY3JpYmVfYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvdXQgPSBVZ2xpZnlKUy5PdXRwdXRTdHJlYW0oeyBiZWF1dGlmeTogdHJ1ZSB9KTtcbiAgICBmdW5jdGlvbiBkb2l0ZW0oY3Rvcikge1xuICAgICAgICBvdXQucHJpbnQoXCJBU1RfXCIgKyBjdG9yLlRZUEUpO1xuICAgICAgICB2YXIgcHJvcHMgPSBjdG9yLlNFTEZfUFJPUFMuZmlsdGVyKGZ1bmN0aW9uKHByb3Ape1xuICAgICAgICAgICAgcmV0dXJuICEvXlxcJC8udGVzdChwcm9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKSBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnByaW50KHByb3ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0b3IuZG9jdW1lbnRhdGlvbikge1xuICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXQucHJpbnRfc3RyaW5nKGN0b3IuZG9jdW1lbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0b3IuU1VCQ0xBU1NFUy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY3Rvci5TVUJDTEFTU0VTLmZvckVhY2goZnVuY3Rpb24oY3RvciwgaSl7XG4gICAgICAgICAgICAgICAgICAgIG91dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9pdGVtKGN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBvdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRvaXRlbShVZ2xpZnlKUy5BU1RfTm9kZSk7XG4gICAgcmV0dXJuIG91dCArIFwiXCI7XG59OyIsInZhciBnbG9iYWw9c2VsZjt2YXIgdWdsaWZ5ID0gcmVxdWlyZSgndWdsaWZ5LWpzJylcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFdpdGhcclxuXHJcbmZ1bmN0aW9uIGFkZFdpdGgob2JqLCBzcmMsIGV4Y2x1ZGUpIHtcclxuICBleGNsdWRlID0gZXhjbHVkZSB8fCBbXVxyXG4gIGV4Y2x1ZGUgPSBleGNsdWRlLmNvbmNhdChkZXRlY3Qob2JqKSlcclxuICB2YXIgdmFycyA9IGRldGVjdCgnKGZ1bmN0aW9uICgpIHsnICsgc3JjICsgJ30oKSknKS8vYWxsb3dzIHRoZSBgcmV0dXJuYCBrZXl3b3JkXHJcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIHJldHVybiAhKHYgaW4gZ2xvYmFsKSAmJiBleGNsdWRlLmluZGV4T2YodikgPT09IC0xXHJcbiAgICB9KVxyXG5cclxuICBpZiAodmFycy5sZW5ndGggPT09IDApIHJldHVybiBzcmNcclxuXHJcbiAgdmFyIGRlY2xhcmVMb2NhbCA9ICcnXHJcbiAgdmFyIGxvY2FsID0gJ2xvY2FscydcclxuICBpZiAoL15bYS16QS1aMC05JF9dKyQvLnRlc3Qob2JqKSkge1xyXG4gICAgbG9jYWwgPSBvYmpcclxuICB9IGVsc2Uge1xyXG4gICAgd2hpbGUgKHZhcnMuaW5kZXhPZihsb2NhbCkgIT0gLTEgfHwgZXhjbHVkZS5pbmRleE9mKGxvY2FsKSAhPSAtMSkge1xyXG4gICAgICBsb2NhbCArPSAnXydcclxuICAgIH1cclxuICAgIGRlY2xhcmVMb2NhbCA9IGxvY2FsICsgJyA9ICgnICsgb2JqICsgJyksJ1xyXG4gIH1cclxuICByZXR1cm4gJ3ZhciAnICsgZGVjbGFyZUxvY2FsICsgdmFyc1xyXG4gICAgLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICByZXR1cm4gdiArICcgPSAnICsgbG9jYWwgKyAnLicgKyB2XHJcbiAgICB9KS5qb2luKCcsJykgKyAnOycgKyBzcmNcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZWN0KHNyYykge1xyXG4gICAgdmFyIGFzdCA9IHVnbGlmeS5wYXJzZShzcmMudG9TdHJpbmcoKSlcclxuICAgIGFzdC5maWd1cmVfb3V0X3Njb3BlKClcclxuICAgIHZhciBnbG9iYWxzID0gYXN0Lmdsb2JhbHNcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lXHJcbiAgICAgICAgfSlcclxuICAgIHJldHVybiBnbG9iYWxzO1xyXG59IiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuaGFzKGFTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1NldFN0cmluZyhhU3RyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgaWYgKHRoaXMuaGFzKGFTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogaXMgcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIGlzIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckF0KGkrKykpO1xuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGZyb21WTFFTaWduZWQocmVzdWx0KSxcbiAgICAgIHJlc3Q6IGFTdHIuc2xpY2UoaSlcbiAgICB9O1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGNoYXJUb0ludE1hcCA9IHt9O1xuICB2YXIgaW50VG9DaGFyTWFwID0ge307XG5cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gICAgLnNwbGl0KCcnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaCwgaW5kZXgpIHtcbiAgICAgIGNoYXJUb0ludE1hcFtjaF0gPSBpbmRleDtcbiAgICAgIGludFRvQ2hhck1hcFtpbmRleF0gPSBjaDtcbiAgICB9KTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0X2VuY29kZShhTnVtYmVyKSB7XG4gICAgaWYgKGFOdW1iZXIgaW4gaW50VG9DaGFyTWFwKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW2FOdW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBkaWdpdCB0byBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XG4gICAgaWYgKGFDaGFyIGluIGNoYXJUb0ludE1hcCkge1xuICAgICAgcmV0dXJuIGNoYXJUb0ludE1hcFthQ2hhcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcIiArIGFDaGFyKTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgbmV4dFxuICAgIC8vICAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgbGVzcyB0aGFuIHRoYXQgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHdoaWNoIGlzIGxlc3MgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZVxuICAgIC8vICAgICAgcmV0dXJuIG51bGwuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gYUhheXN0YWNrW21pZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIGFIYXlzdGFja1ttaWRdIGlzIGdyZWF0ZXIgdGhhbiBvdXIgbmVlZGxlLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpZCBub3QgZmluZCBhbiBleGFjdCBtYXRjaCwgcmV0dXJuIHRoZSBuZXh0IGNsb3Nlc3Qgb25lXG4gICAgICAvLyAodGVybWluYXRpb24gY2FzZSAyKS5cbiAgICAgIHJldHVybiBhSGF5c3RhY2tbbWlkXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBsZXNzIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMikgb3IgKDMpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgcmV0dXJuIGFMb3cgPCAwXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGFIYXlzdGFja1thTG93XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBuZXh0IGxvd2VzdCB2YWx1ZSBjaGVja2VkIGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgcmV0dXJuIGFIYXlzdGFjay5sZW5ndGggPiAwXG4gICAgICA/IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSlcbiAgICAgIDogbnVsbDtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuXG4gIC8qKlxuICAgKiBBIFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBtYXBwaW5nU2VwYXJhdG9yID0gL15bLDtdLztcbiAgICAgIHZhciBzdHIgPSBhU3RyO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgdGVtcDtcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChwcmV2aW91c1NvdXJjZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgbWFwcGluZ1NlcGFyYXRvci50ZXN0KHN0ci5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChwcmV2aW91c05hbWUgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICYmIHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsaWJsZS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3RcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290KSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBUbyBjcmVhdGUgYSBuZXcgb25lLCB5b3UgbXVzdCBwYXNzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIHNvdXJjZVJvb3Q6IEFuIG9wdGlvbmFsIHJvb3QgZm9yIGFsbCBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG5cbiAgICAgIGlmIChzb3VyY2UgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLnB1c2goe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlKSB7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoIWFTb3VyY2VGaWxlKSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwiYVNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgYVNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIGFTb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcImFTb3VyY2VGaWxlXCJcbiAgICAgIHRoaXMuX21hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBhU291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgb3JpZ2luYWwuc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9PSBudWxsICYmIG1hcHBpbmcubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGUgaWRlbnRpZmllciBuYW1lIGlmIGl0J3MgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAvLyBpbiBib3RoIFNvdXJjZU1hcHNcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICAvLyBUaGUgbWFwcGluZ3MgbXVzdCBiZSBndWFyYW50ZWVkIHRvIGJlIGluIHNvcnRlZCBvcmRlciBiZWZvcmUgd2Ugc3RhcnRcbiAgICAgIC8vIHNlcmlhbGl6aW5nIHRoZW0gb3IgZWxzZSB0aGUgZ2VuZXJhdGVkIGxpbmUgbnVtYmVycyAod2hpY2ggYXJlIGRlZmluZWRcbiAgICAgIC8vIHZpYSB0aGUgJzsnIHNlcGFyYXRvcnMpIHdpbGwgYmUgYWxsIG1lc3NlZCB1cC4gTm90ZTogaXQgbWlnaHQgYmUgbW9yZVxuICAgICAgLy8gcGVyZm9ybWFudCB0byBtYWludGFpbiB0aGUgc29ydGluZyBhcyB3ZSBpbnNlcnQgdGhlbSwgcmF0aGVyIHRoYW4gYXMgd2VcbiAgICAgIC8vIHNlcmlhbGl6ZSB0aGVtLCBidXQgdGhlIGJpZyBPIGlzIHRoZSBzYW1lIGVpdGhlciB3YXkuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX21hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcHBpbmcgPSB0aGlzLl9tYXBwaW5nc1tpXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsnO1xuICAgICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtYXBwaW5nLCB0aGlzLl9tYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290KSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkpXG4gICAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgICB2YXIgbWFwID0ge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICBmaWxlOiB0aGlzLl9maWxlLFxuICAgICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09PSB1bmRlZmluZWQgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09PSB1bmRlZmluZWQgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09PSB1bmRlZmluZWQgPyBudWxsIDogYU5hbWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXkuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZnVsbCBsaW5lcyB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjb2RlICs9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKTtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgcmVhY2hlZCB0aGUgY29ycmVjdCBsaW5lLCB3ZSBhZGQgY29kZSB1bnRpbCB3ZVxuICAgICAgICAgICAgLy8gcmVhY2ggdGhlIGNvcnJlY3QgY29sdW1uIHRvby5cbiAgICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICAgIGNvZGUgKz0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIFNvdXJjZU5vZGUuXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCByZW1haW5pbmdMaW5lcy5qb2luKFwiXFxuXCIpKTtcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNodW5rLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gLyhbXFx3K1xcLS5dKyk6XFwvXFwvKChcXHcrOlxcdyspQCk/KFtcXHcuXSspPyg6KFxcZCspKT8oXFxTKyk/LztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKy87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFszXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzRdLFxuICAgICAgcG9ydDogbWF0Y2hbNl0sXG4gICAgICBwYXRoOiBtYXRjaFs3XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gYVBhcnNlZFVybC5zY2hlbWUgKyBcIjovL1wiO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyBcIkBcIlxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICB2YXIgdXJsO1xuXG4gICAgaWYgKGFQYXRoLm1hdGNoKHVybFJlZ2V4cCkgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09PSAnLycgJiYgKHVybCA9IHVybFBhcnNlKGFSb290KSkpIHtcbiAgICAgIHVybC5wYXRoID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJyArIGFQYXRoO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwidmFyIHByb2Nlc3M9cmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLF9fZmlsZW5hbWU9XCIvLi4vLi4vbm9kZV9tb2R1bGVzL2phZGUvbm9kZV9tb2R1bGVzL3dpdGgvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanNcIjsvKiogdmltOiBldDp0cz00OnN3PTQ6c3RzPTRcbiAqIEBsaWNlbnNlIGFtZGVmaW5lIDAuMS4wIENvcHlyaWdodCAoYykgMjAxMSwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9hbWRlZmluZSBmb3IgZGV0YWlsc1xuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcHJvY2VzcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWZpbmUgZm9yIG5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBcIm1vZHVsZVwiIG9iamVjdCB0aGF0IGlzIGRlZmluZWQgYnkgTm9kZSBmb3IgdGhlXG4gKiBjdXJyZW50IG1vZHVsZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXF1aXJlRm5dLiBOb2RlJ3MgcmVxdWlyZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnQgbW9kdWxlLlxuICogSXQgb25seSBuZWVkcyB0byBiZSBwYXNzZWQgaW4gTm9kZSB2ZXJzaW9ucyBiZWZvcmUgMC41LCB3aGVuIG1vZHVsZS5yZXF1aXJlXG4gKiBkaWQgbm90IGV4aXN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGRlZmluZSBmdW5jdGlvbiB0aGF0IGlzIHVzYWJsZSBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICogbW9kdWxlLlxuICovXG5mdW5jdGlvbiBhbWRlZmluZShtb2R1bGUsIHJlcXVpcmVGbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGVmaW5lQ2FjaGUgPSB7fSxcbiAgICAgICAgbG9hZGVyQ2FjaGUgPSB7fSxcbiAgICAgICAgYWxyZWFkeUNhbGxlZCA9IGZhbHNlLFxuICAgICAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgICAgICBtYWtlUmVxdWlyZSwgc3RyaW5nUmVxdWlyZTtcblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSAuIGFuZCAuLiBmcm9tIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICogSXQgd2lsbCBrZWVwIGEgbGVhZGluZyBwYXRoIHNlZ21lbnQgaWYgYSAuLiB3aWxsIGJlY29tZVxuICAgICAqIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQsIHRvIGhlbHAgd2l0aCBtb2R1bGUgbmFtZSBsb29rdXBzLFxuICAgICAqIHdoaWNoIGFjdCBsaWtlIHBhdGhzLCBidXQgY2FuIGJlIHJlbWFwcGVkLiBCdXQgdGhlIGVuZCByZXN1bHQsXG4gICAgICogYWxsIHBhdGhzIHRoYXQgdXNlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGxvb2sgbm9ybWFsaXplZC5cbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBNT0RJRklFUyB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJ5IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xuICAgICAgICB2YXIgaSwgcGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgYXJ5W2ldOyBpKz0gMSkge1xuICAgICAgICAgICAgcGFydCA9IGFyeVtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChhcnlbMl0gPT09ICcuLicgfHwgYXJ5WzBdID09PSAnLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvL0VuZCBvZiB0aGUgbGluZS4gS2VlcCBhdCBsZWFzdCBvbmUgbm9uLWRvdFxuICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxuICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RseSB0byBkaXNrLiBPdGhlcndpc2UsIHRoZXJlIGlzIGxpa2VseVxuICAgICAgICAgICAgICAgICAgICAvL25vIHBhdGggbWFwcGluZyBmb3IgYSBwYXRoIHN0YXJ0aW5nIHdpdGggJy4uJy5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyBvZiAuLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XG4gICAgICAgIHZhciBiYXNlUGFydHM7XG5cbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxuICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZS5zcGxpdCgnLycpKTtcbiAgICAgICAgICAgICAgICB0cmltRG90cyhiYXNlUGFydHMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBub3JtYWxpemUoKSBmdW5jdGlvbiBwYXNzZWQgdG8gYSBsb2FkZXIgcGx1Z2luJ3NcbiAgICAgKiBub3JtYWxpemUgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoaWQpIHtcbiAgICAgICAgZnVuY3Rpb24gbG9hZCh2YWx1ZSkge1xuICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkLmZyb21UZXh0ID0gZnVuY3Rpb24gKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAvL1RoaXMgb25lIGlzIGRpZmZpY3VsdCBiZWNhdXNlIHRoZSB0ZXh0IGNhbi9wcm9iYWJseSB1c2VzXG4gICAgICAgICAgICAvL2RlZmluZSwgYW5kIGFueSByZWxhdGl2ZSBwYXRocyBhbmQgcmVxdWlyZXMgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgICAgICAvL3RvIHRoYXQgaWQgd2FzIGl0IHdvdWxkIGJlIGZvdW5kIG9uIGRpc2suIEJ1dCB0aGlzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwcGluZyBhIG1vZHVsZS9yZXF1aXJlIGZhaXJseSBkZWVwbHkgZnJvbSBub2RlIGNvcmUuXG4gICAgICAgICAgICAvL05vdCBzdXJlIGhvdyBiZXN0IHRvIGdvIGFib3V0IHRoYXQgeWV0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSBkb2VzIG5vdCBpbXBsZW1lbnQgbG9hZC5mcm9tVGV4dCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsb2FkO1xuICAgIH1cblxuICAgIG1ha2VSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpIHtcbiAgICAgICAgZnVuY3Rpb24gYW1kUmVxdWlyZShkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vU3luY2hyb25vdXMsIHNpbmdsZSBtb2R1bGUgcmVxdWlyZSgnJylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcHMsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9BcnJheSBvZiBkZXBlbmRlbmNpZXMgd2l0aCBhIGNhbGxiYWNrLlxuXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IHRoZSBkZXBlbmRlbmNpZXMgdG8gbW9kdWxlcy5cbiAgICAgICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBOYW1lLCByZWxJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL1dhaXQgZm9yIG5leHQgdGljayB0byBjYWxsIGJhY2sgdGhlIHJlcXVpcmUgY2FsbC5cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbWRSZXF1aXJlLnRvVXJsID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVBhdGguaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShmaWxlUGF0aCwgcGF0aC5kaXJuYW1lKG1vZHVsZS5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFtZFJlcXVpcmU7XG4gICAgfTtcblxuICAgIC8vRmF2b3IgZXhwbGljaXQgdmFsdWUsIHBhc3NlZCBpbiBpZiB0aGUgbW9kdWxlIHdhbnRzIHRvIHN1cHBvcnQgTm9kZSAwLjQuXG4gICAgcmVxdWlyZUZuID0gcmVxdWlyZUZuIHx8IGZ1bmN0aW9uIHJlcSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5yZXF1aXJlLmFwcGx5KG1vZHVsZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICB2YXIgciwgZSwgbSwgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgZSA9IGxvYWRlckNhY2hlW2lkXSA9IHt9O1xuICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdXJpOiBfX2ZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL09ubHkgc3VwcG9ydCBvbmUgZGVmaW5lIGNhbGwgcGVyIGZpbGVcbiAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSB3aXRoIG5vIG1vZHVsZSBJRCBjYW5ub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHBlciBmaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vVXNlIHRoZSByZWFsIHZhcmlhYmxlcyBmcm9tIG5vZGVcbiAgICAgICAgICAgIC8vVXNlIG1vZHVsZS5leHBvcnRzIGZvciBleHBvcnRzLCBzaW5jZVxuICAgICAgICAgICAgLy90aGUgZXhwb3J0cyBpbiBoZXJlIGlzIGFtZGVmaW5lIGV4cG9ydHMuXG4gICAgICAgICAgICBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgICBtID0gbW9kdWxlO1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgbW9kdWxlLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcywgdGhleSBhcmUgc3RyaW5ncywgc28gbmVlZFxuICAgICAgICAvL3RvIGNvbnZlcnQgdGhlbSB0byBkZXBlbmRlbmN5IHZhbHVlcy5cbiAgICAgICAgaWYgKGRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByKGRlcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0NhbGwgdGhlIGZhY3Rvcnkgd2l0aCB0aGUgcmlnaHQgZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnkuYXBwbHkobS5leHBvcnRzLCBkZXBzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG0uZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IG0uZXhwb3J0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZ1JlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBpZCwgcmVsSWQpIHtcbiAgICAgICAgLy9TcGxpdCB0aGUgSUQgYnkgYSAhIHNvIHRoYXRcbiAgICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZignIScpLFxuICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkLFxuICAgICAgICAgICAgcHJlZml4LCBwbHVnaW47XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcblxuICAgICAgICAgICAgLy9TdHJhaWdodCBtb2R1bGUgbG9va3VwLiBJZiBpdCBpcyBvbmUgb2YgdGhlIHNwZWNpYWwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgLy9kZWFsIHdpdGggaXQsIG90aGVyd2lzZSwgZGVsZWdhdGUgdG8gbm9kZS5cbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvYWRlckNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihzeXN0ZW1SZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1SZXF1aXJlKG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9kdWxlIHdpdGggSUQ6ICcgKyBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UaGVyZSBpcyBhIHBsdWdpbiBpbiBwbGF5LlxuICAgICAgICAgICAgcHJlZml4ID0gaWQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKGluZGV4ICsgMSwgaWQubGVuZ3RoKTtcblxuICAgICAgICAgICAgcGx1Z2luID0gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHByZWZpeCwgcmVsSWQpO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIGlkID0gcGx1Z2luLm5vcm1hbGl6ZShpZCwgbWFrZU5vcm1hbGl6ZShyZWxJZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgSUQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5sb2FkKGlkLCBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSwgbWFrZUxvYWQoaWQpLCB7fSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vQ3JlYXRlIGEgZGVmaW5lIGZ1bmN0aW9uIHNwZWNpZmljIHRvIHRoZSBtb2R1bGUgYXNraW5nIGZvciBhbWRlZmluZS5cbiAgICBmdW5jdGlvbiBkZWZpbmUoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBpZDtcbiAgICAgICAgICAgIGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBpZDtcbiAgICAgICAgICAgIGlkID0gZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXBzICYmICFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU2V0IHVwIHByb3BlcnRpZXMgZm9yIHRoaXMgbW9kdWxlLiBJZiBhbiBJRCwgdGhlbiB1c2VcbiAgICAgICAgLy9pbnRlcm5hbCBjYWNoZS4gSWYgbm8gSUQsIHRoZW4gdXNlIHRoZSBleHRlcm5hbCB2YXJpYWJsZXNcbiAgICAgICAgLy9mb3IgdGhpcyBub2RlIG1vZHVsZS5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAvL1B1dCB0aGUgbW9kdWxlIGluIGRlZXAgZnJlZXplIHVudGlsIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vcmVxdWlyZSBjYWxsIGZvciBpdC5cbiAgICAgICAgICAgIGRlZmluZUNhY2hlW2lkXSA9IFtpZCwgZGVwcywgZmFjdG9yeV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVmaW5lLnJlcXVpcmUsIHdoaWNoIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSB2YWx1ZXMgaW4gdGhlXG4gICAgLy9jYWNoZS4gVXNlZnVsIGZvciBBTUQgbW9kdWxlcyB0aGF0IGFsbCBoYXZlIElEcyBpbiB0aGUgZmlsZSxcbiAgICAvL2J1dCBuZWVkIHRvIGZpbmFsbHkgZXhwb3J0IGEgdmFsdWUgdG8gbm9kZSBiYXNlZCBvbiBvbmUgb2YgdGhvc2VcbiAgICAvL0lEcy5cbiAgICBkZWZpbmUucmVxdWlyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUuYW1kID0ge307XG5cbiAgICByZXR1cm4gZGVmaW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFtZGVmaW5lO1xuIiwidmFyIHN5cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIE1PWl9Tb3VyY2VNYXAgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKTtcbnZhciBVZ2xpZnlKUyA9IGV4cG9ydHM7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBhcnJheV90b19oYXNoKGEpIHtcbiAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHJldFthW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIHNsaWNlKGEsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIHN0YXJ0IHx8IDApO1xufTtcblxuZnVuY3Rpb24gY2hhcmFjdGVycyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KFwiXCIpO1xufTtcblxuZnVuY3Rpb24gbWVtYmVyKG5hbWUsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICBpZiAoYXJyYXlbaV0gPT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGZpbmRfaWYoZnVuYywgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoZnVuYyhhcnJheVtpXSkpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVwZWF0X3N0cmluZyhzdHIsIGkpIHtcbiAgICBpZiAoaSA8PSAwKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoaSA9PSAxKSByZXR1cm4gc3RyO1xuICAgIHZhciBkID0gcmVwZWF0X3N0cmluZyhzdHIsIGkgPj4gMSk7XG4gICAgZCArPSBkO1xuICAgIGlmIChpICYgMSkgZCArPSBzdHI7XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5mdW5jdGlvbiBEZWZhdWx0c0Vycm9yKG1zZywgZGVmcykge1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIHRoaXMuZGVmcyA9IGRlZnM7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0cyhhcmdzLCBkZWZzLCBjcm9haykge1xuICAgIGlmIChhcmdzID09PSB0cnVlKVxuICAgICAgICBhcmdzID0ge307XG4gICAgdmFyIHJldCA9IGFyZ3MgfHwge307XG4gICAgaWYgKGNyb2FrKSBmb3IgKHZhciBpIGluIHJldCkgaWYgKHJldC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhZGVmcy5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgdGhyb3cgbmV3IERlZmF1bHRzRXJyb3IoXCJgXCIgKyBpICsgXCJgIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cIiwgZGVmcyk7XG4gICAgZm9yICh2YXIgaSBpbiBkZWZzKSBpZiAoZGVmcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBhcmdzLmhhc093blByb3BlcnR5KGkpKSA/IGFyZ3NbaV0gOiBkZWZzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqLCBleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGV4dCkgaWYgKGV4dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBvYmpbaV0gPSBleHRbaV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBub29wKCkge307XG5cbnZhciBNQVAgPSAoZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBNQVAoYSwgZiwgYmFja3dhcmRzKSB7XG4gICAgICAgIHZhciByZXQgPSBbXSwgdG9wID0gW10sIGk7XG4gICAgICAgIGZ1bmN0aW9uIGRvaXQoKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZihhW2ldLCBpKTtcbiAgICAgICAgICAgIHZhciBpc19sYXN0ID0gdmFsIGluc3RhbmNlb2YgTGFzdDtcbiAgICAgICAgICAgIGlmIChpc19sYXN0KSB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBdFRvcCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC52O1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2guYXBwbHkodG9wLCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc19sYXN0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gYS5sZW5ndGg7IC0taSA+PSAwOykgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0b3AucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIGlmIChkb2l0KCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3AuY29uY2F0KHJldCk7XG4gICAgfTtcbiAgICBNQVAuYXRfdG9wID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXRUb3AodmFsKSB9O1xuICAgIE1BUC5zcGxpY2UgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBTcGxpY2UodmFsKSB9O1xuICAgIE1BUC5sYXN0ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgTGFzdCh2YWwpIH07XG4gICAgdmFyIHNraXAgPSBNQVAuc2tpcCA9IHt9O1xuICAgIGZ1bmN0aW9uIEF0VG9wKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcbiAgICBmdW5jdGlvbiBTcGxpY2UodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIGZ1bmN0aW9uIExhc3QodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIHJldHVybiBNQVA7XG59KSgpO1xuXG5mdW5jdGlvbiBwdXNoX3VuaXEoYXJyYXksIGVsKSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YoZWwpIDwgMClcbiAgICAgICAgYXJyYXkucHVzaChlbCk7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdfdGVtcGxhdGUodGV4dCwgcHJvcHMpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHsoLis/KVxcfS9nLCBmdW5jdGlvbihzdHIsIHApe1xuICAgICAgICByZXR1cm4gcHJvcHNbcF07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZWwpIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBtZXJnZVNvcnQoYXJyYXksIGNtcCkge1xuICAgIGlmIChhcnJheS5sZW5ndGggPCAyKSByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgICAgIHZhciByID0gW10sIGFpID0gMCwgYmkgPSAwLCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGFpIDwgYS5sZW5ndGggJiYgYmkgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgY21wKGFbYWldLCBiW2JpXSkgPD0gMFxuICAgICAgICAgICAgICAgID8gcltpKytdID0gYVthaSsrXVxuICAgICAgICAgICAgICAgIDogcltpKytdID0gYltiaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWkgPCBhLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGEuc2xpY2UoYWkpKTtcbiAgICAgICAgaWYgKGJpIDwgYi5sZW5ndGgpIHIucHVzaC5hcHBseShyLCBiLnNsaWNlKGJpKSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX21zKGEpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKGEubGVuZ3RoIC8gMiksIGxlZnQgPSBhLnNsaWNlKDAsIG0pLCByaWdodCA9IGEuc2xpY2UobSk7XG4gICAgICAgIGxlZnQgPSBfbXMobGVmdCk7XG4gICAgICAgIHJpZ2h0ID0gX21zKHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBfbXMoYXJyYXkpO1xufTtcblxuZnVuY3Rpb24gc2V0X2RpZmZlcmVuY2UoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpIDwgMDtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHNldF9pbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpID49IDA7XG4gICAgfSk7XG59O1xuXG4vLyB0aGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gQWNvcm4gWzFdLCB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2Vcbi8vIFsxXSBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29yblxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgIGlmICghKHdvcmRzIGluc3RhbmNlb2YgQXJyYXkpKSB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgICB2YXIgZiA9IFwiXCIsIGNhdHMgPSBbXTtcbiAgICBvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhdHNbal0ucHVzaCh3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG4gICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBsZW5ndGggY2F0ZWdvcmllcywgYW4gb3V0ZXJcbiAgICAvLyBzd2l0Y2ggZmlyc3QgZGlzcGF0Y2hlcyBvbiB0aGUgbGVuZ3RocywgdG8gc2F2ZSBvbiBjb21wYXJpc29ucy5cbiAgICBpZiAoY2F0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIGNhdHMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7fSk7XG4gICAgICAgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNhdCA9IGNhdHNbaV07XG4gICAgICAgICAgICBmICs9IFwiY2FzZSBcIiArIGNhdFswXS5sZW5ndGggKyBcIjpcIjtcbiAgICAgICAgICAgIGNvbXBhcmVUbyhjYXQpO1xuICAgICAgICB9XG4gICAgICAgIGYgKz0gXCJ9XCI7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2ltcGx5IGdlbmVyYXRlIGEgZmxhdCBgc3dpdGNoYCBzdGF0ZW1lbnQuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbn07XG5cbmZ1bmN0aW9uIGFsbChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuRGljdGlvbmFyeS5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpICsrdGhpcy5fc2l6ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmdldChrZXkpLnB1c2godmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgWyB2YWwgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSB9LFxuICAgIGRlbDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAtLXRoaXMuX3NpemU7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oa2V5KSB7IHJldHVybiAoXCIkXCIgKyBrZXkpIGluIHRoaXMuX3ZhbHVlcyB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICBmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICByZXQucHVzaChmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBERUZOT0RFKHR5cGUsIHByb3BzLCBtZXRob2RzLCBiYXNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBiYXNlID0gQVNUX05vZGU7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSBbXTtcbiAgICBlbHNlIHByb3BzID0gcHJvcHMuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgc2VsZl9wcm9wcyA9IHByb3BzO1xuICAgIGlmIChiYXNlICYmIGJhc2UuUFJPUFMpXG4gICAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KGJhc2UuUFJPUFMpO1xuICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24gQVNUX1wiICsgdHlwZSArIFwiKHByb3BzKXsgaWYgKHByb3BzKSB7IFwiO1xuICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5cIiArIHByb3BzW2ldICsgXCIgPSBwcm9wcy5cIiArIHByb3BzW2ldICsgXCI7XCI7XG4gICAgfVxuICAgIHZhciBwcm90byA9IGJhc2UgJiYgbmV3IGJhc2U7XG4gICAgaWYgKHByb3RvICYmIHByb3RvLmluaXRpYWxpemUgfHwgKG1ldGhvZHMgJiYgbWV0aG9kcy5pbml0aWFsaXplKSlcbiAgICAgICAgY29kZSArPSBcInRoaXMuaW5pdGlhbGl6ZSgpO1wiO1xuICAgIGNvZGUgKz0gXCJ9fVwiO1xuICAgIHZhciBjdG9yID0gbmV3IEZ1bmN0aW9uKGNvZGUpKCk7XG4gICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIGN0b3IuQkFTRSA9IGJhc2U7XG4gICAgfVxuICAgIGlmIChiYXNlKSBiYXNlLlNVQkNMQVNTRVMucHVzaChjdG9yKTtcbiAgICBjdG9yLnByb3RvdHlwZS5DVE9SID0gY3RvcjtcbiAgICBjdG9yLlBST1BTID0gcHJvcHMgfHwgbnVsbDtcbiAgICBjdG9yLlNFTEZfUFJPUFMgPSBzZWxmX3Byb3BzO1xuICAgIGN0b3IuU1VCQ0xBU1NFUyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLlRZUEUgPSBjdG9yLlRZUEUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAobWV0aG9kcykgZm9yIChpIGluIG1ldGhvZHMpIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmICgvXlxcJC8udGVzdChpKSkge1xuICAgICAgICAgICAgY3RvcltpLnN1YnN0cigxKV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0b3IuREVGTUVUSE9EID0gZnVuY3Rpb24obmFtZSwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgIH07XG4gICAgcmV0dXJuIGN0b3I7XG59O1xuXG52YXIgQVNUX1Rva2VuID0gREVGTk9ERShcIlRva2VuXCIsIFwidHlwZSB2YWx1ZSBsaW5lIGNvbCBwb3MgZW5kcG9zIG5sYiBjb21tZW50c19iZWZvcmUgZmlsZVwiLCB7XG59LCBudWxsKTtcblxudmFyIEFTVF9Ob2RlID0gREVGTk9ERShcIk5vZGVcIiwgXCJzdGFydCBlbmRcIiwge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNUT1IodGhpcyk7XG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBBU1Qgbm9kZXNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBzdGFydDogXCJbQVNUX1Rva2VuXSBUaGUgZmlyc3QgdG9rZW4gb2YgdGhpcyBub2RlXCIsXG4gICAgICAgIGVuZDogXCJbQVNUX1Rva2VuXSBUaGUgbGFzdCB0b2tlbiBvZiB0aGlzIG5vZGVcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH0sXG4gICAgd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Fsayh2aXNpdG9yKTsgLy8gbm90IHN1cmUgdGhlIGluZGlyZWN0aW9uIHdpbGwgYmUgYW55IGhlbHBcbiAgICB9XG59LCBudWxsKTtcblxuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IG51bGw7XG5BU1RfTm9kZS53YXJuID0gZnVuY3Rpb24odHh0LCBwcm9wcykge1xuICAgIGlmIChBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKVxuICAgICAgICBBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKHN0cmluZ190ZW1wbGF0ZSh0eHQsIHByb3BzKSk7XG59O1xuXG4vKiAtLS0tLVsgc3RhdGVtZW50cyBdLS0tLS0gKi9cblxudmFyIEFTVF9TdGF0ZW1lbnQgPSBERUZOT0RFKFwiU3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBzdGF0ZW1lbnRzXCIsXG59KTtcblxudmFyIEFTVF9EZWJ1Z2dlciA9IERFRk5PREUoXCJEZWJ1Z2dlclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVwcmVzZW50cyBhIGRlYnVnZ2VyIHN0YXRlbWVudFwiLFxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRGlyZWN0aXZlID0gREVGTk9ERShcIkRpcmVjdGl2ZVwiLCBcInZhbHVlIHNjb3BlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZXByZXNlbnRzIGEgZGlyZWN0aXZlLCBsaWtlIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSBUaGUgdmFsdWUgb2YgdGhpcyBkaXJlY3RpdmUgYXMgYSBwbGFpbiBzdHJpbmcgKGl0J3Mgbm90IGFuIEFTVF9TdHJpbmchKVwiLFxuICAgICAgICBzY29wZTogXCJbQVNUX1Njb3BlL1NdIFRoZSBzY29wZSB0aGF0IHRoaXMgZGlyZWN0aXZlIGFmZmVjdHNcIlxuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBERUZOT0RFKFwiU2ltcGxlU3RhdGVtZW50XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdGF0ZW1lbnQgY29uc2lzdGluZyBvZiBhbiBleHByZXNzaW9uLCBpLmUuIGEgPSAxICsgMlwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9Ob2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbmZ1bmN0aW9uIHdhbGtfYm9keShub2RlLCB2aXNpdG9yKSB7XG4gICAgaWYgKG5vZGUuYm9keSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgIH1cbiAgICBlbHNlIG5vZGUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICBzdGF0Ll93YWxrKHZpc2l0b3IpO1xuICAgIH0pO1xufTtcblxudmFyIEFTVF9CbG9jayA9IERFRk5PREUoXCJCbG9ja1wiLCBcImJvZHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNrZXRlZClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBib2R5OiBcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfQmxvY2tTdGF0ZW1lbnQgPSBERUZOT0RFKFwiQmxvY2tTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2sgc3RhdGVtZW50XCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0VtcHR5U3RhdGVtZW50ID0gREVGTk9ERShcIkVtcHR5U3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgZW1wdHkgc3RhdGVtZW50IChlbXB0eSBibG9jayBvciBzaW1wbHkgYSBzZW1pY29sb24pXCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1N0YXRlbWVudFdpdGhCb2R5ID0gREVGTk9ERShcIlN0YXRlbWVudFdpdGhCb2R5XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgdGhhdCBjb250YWluIG9uZSBuZXN0ZWQgYm9keTogYEZvcmAsIGBGb3JJbmAsIGBEb2AsIGBXaGlsZWAsIGBXaXRoYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEFTVF9FbXB0eVN0YXRlbWVudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfTGFiZWxlZFN0YXRlbWVudCA9IERFRk5PREUoXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwibGFiZWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0RXTG9vcCA9IERFRk5PREUoXCJEV0xvb3BcIiwgXCJjb25kaXRpb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGRvL3doaWxlIHN0YXRlbWVudHNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgbG9vcCBjb25kaXRpb24uICBTaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0RvID0gREVGTk9ERShcIkRvXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBkb2Agc3RhdGVtZW50XCIsXG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9XaGlsZSA9IERFRk5PREUoXCJXaGlsZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgd2hpbGVgIHN0YXRlbWVudFwiLFxufSwgQVNUX0RXTG9vcCk7XG5cbnZhciBBU1RfRm9yID0gREVGTk9ERShcIkZvclwiLCBcImluaXQgY29uZGl0aW9uIHN0ZXBcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGZvcmAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgaW5pdDogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgaW5pdGlhbGl6YXRpb24gY29kZSwgb3IgbnVsbCBpZiBlbXB0eVwiLFxuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHRlcm1pbmF0aW9uIGNsYXVzZSwgb3IgbnVsbCBpZiBlbXB0eVwiLFxuICAgICAgICBzdGVwOiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCB1cGRhdGUgY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uKSB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXApIHRoaXMuc3RlcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxudmFyIEFTVF9Gb3JJbiA9IERFRk5PREUoXCJGb3JJblwiLCBcImluaXQgbmFtZSBvYmplY3RcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGZvciAuLi4gaW5gIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGluaXQ6IFwiW0FTVF9Ob2RlXSB0aGUgYGZvci9pbmAgaW5pdGlhbGl6YXRpb24gY29kZVwiLFxuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sUmVmP10gdGhlIGxvb3AgdmFyaWFibGUsIG9ubHkgaWYgYGluaXRgIGlzIEFTVF9WYXJcIixcbiAgICAgICAgb2JqZWN0OiBcIltBU1RfTm9kZV0gdGhlIG9iamVjdCB0aGF0IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX1dpdGggPSBERUZOT0RFKFwiV2l0aFwiLCBcImV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHdpdGhgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHdpdGhgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSk7XG5cbi8qIC0tLS0tWyBzY29wZSBhbmQgZnVuY3Rpb25zIF0tLS0tLSAqL1xuXG52YXIgQVNUX1Njb3BlID0gREVGTk9ERShcIlNjb3BlXCIsIFwiZGlyZWN0aXZlcyB2YXJpYWJsZXMgZnVuY3Rpb25zIHVzZXNfd2l0aCB1c2VzX2V2YWwgcGFyZW50X3Njb3BlIGVuY2xvc2VkIGNuYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3RhdGVtZW50cyBpbnRyb2R1Y2luZyBhIGxleGljYWwgc2NvcGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkaXJlY3RpdmVzOiBcIltzdHJpbmcqL1NdIGFuIGFycmF5IG9mIGRpcmVjdGl2ZXMgZGVjbGFyZWQgaW4gdGhpcyBzY29wZVwiLFxuICAgICAgICB2YXJpYWJsZXM6IFwiW09iamVjdC9TXSBhIG1hcCBvZiBuYW1lIC0+IFN5bWJvbERlZiBmb3IgYWxsIHZhcmlhYmxlcy9mdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlXCIsXG4gICAgICAgIGZ1bmN0aW9uczogXCJbT2JqZWN0L1NdIGxpa2UgYHZhcmlhYmxlc2AsIGJ1dCBvbmx5IGxpc3RzIGZ1bmN0aW9uIGRlY2xhcmF0aW9uc1wiLFxuICAgICAgICB1c2VzX3dpdGg6IFwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIHNjb3BlIHVzZXMgdGhlIGB3aXRoYCBzdGF0ZW1lbnRcIixcbiAgICAgICAgdXNlc19ldmFsOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSBjb250YWlucyBhIGRpcmVjdCBjYWxsIHRvIHRoZSBnbG9iYWwgYGV2YWxgXCIsXG4gICAgICAgIHBhcmVudF9zY29wZTogXCJbQVNUX1Njb3BlPy9TXSBsaW5rIHRvIHRoZSBwYXJlbnQgc2NvcGVcIixcbiAgICAgICAgZW5jbG9zZWQ6IFwiW1N5bWJvbERlZiovU10gYSBsaXN0IG9mIGFsbCBzeW1ib2wgZGVmaW5pdGlvbnMgdGhhdCBhcmUgYWNjZXNzZWQgZnJvbSB0aGlzIHNjb3BlIG9yIGFueSBzdWJzY29wZXNcIixcbiAgICAgICAgY25hbWU6IFwiW2ludGVnZXIvU10gY3VycmVudCBpbmRleCBmb3IgbWFuZ2xpbmcgdmFyaWFibGVzICh1c2VkIGludGVybmFsbHkgYnkgdGhlIG1hbmdsZXIpXCIsXG4gICAgfSxcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfVG9wbGV2ZWwgPSBERUZOT0RFKFwiVG9wbGV2ZWxcIiwgXCJnbG9iYWxzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgdG9wbGV2ZWwgc2NvcGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBnbG9iYWxzOiBcIltPYmplY3QvU10gYSBtYXAgb2YgbmFtZSAtPiBTeW1ib2xEZWYgZm9yIGFsbCB1bmRlY2xhcmVkIG5hbWVzXCIsXG4gICAgfSxcbiAgICB3cmFwX2VuY2xvc2U6IGZ1bmN0aW9uKGFyZ19wYXJhbWV0ZXJfcGFpcnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuXG4gICAgICAgIGFyZ19wYXJhbWV0ZXJfcGFpcnMuZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBwYWlyLnNwbGl0KFwiOlwiKTtcblxuICAgICAgICAgICAgYXJncy5wdXNoKHNwbGl0WzBdKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChzcGxpdFsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3cmFwcGVkX3RsID0gXCIoZnVuY3Rpb24oXCIgKyBwYXJhbWV0ZXJzLmpvaW4oXCIsXCIpICsgXCIpeyAnJE9SSUcnOyB9KShcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgICAgd3JhcHBlZF90bCA9IHBhcnNlKHdyYXBwZWRfdGwpO1xuICAgICAgICB3cmFwcGVkX3RsID0gd3JhcHBlZF90bC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbiBiZWZvcmUobm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUgJiYgbm9kZS52YWx1ZSA9PSBcIiRPUklHXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShzZWxmLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkX3RsO1xuICAgIH0sXG4gICAgd3JhcF9jb21tb25qczogZnVuY3Rpb24obmFtZSwgZXhwb3J0X2FsbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB0b19leHBvcnQgPSBbXTtcbiAgICAgICAgaWYgKGV4cG9ydF9hbGwpIHtcbiAgICAgICAgICAgIHNlbGYuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICAgICAgc2VsZi53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uICYmIG5vZGUuZGVmaW5pdGlvbigpLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmRfaWYoZnVuY3Rpb24obil7IHJldHVybiBuLm5hbWUgPT0gbm9kZS5uYW1lIH0sIHRvX2V4cG9ydCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b19leHBvcnQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZWRfdGwgPSBcIihmdW5jdGlvbihleHBvcnRzLCBnbG9iYWwpeyBnbG9iYWxbJ1wiICsgbmFtZSArIFwiJ10gPSBleHBvcnRzOyAnJE9SSUcnOyAnJEVYUE9SVFMnOyB9KHt9LCAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSkpKVwiO1xuICAgICAgICB3cmFwcGVkX3RsID0gcGFyc2Uod3JhcHBlZF90bCk7XG4gICAgICAgIHdyYXBwZWRfdGwgPSB3cmFwcGVkX3RsLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uIGJlZm9yZShub2RlKXtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSBzd2l0Y2ggKG5vZGUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIiRPUklHXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKHNlbGYuYm9keSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiJEVYUE9SVFNcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdG9fZXhwb3J0LmZvckVhY2goZnVuY3Rpb24oc3ltKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucHVzaChuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXcgQVNUX1N1Yih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBuZXcgQVNUX1N5bWJvbFJlZih7IG5hbWU6IFwiZXhwb3J0c1wiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG5ldyBBU1RfU3RyaW5nKHsgdmFsdWU6IHN5bS5uYW1lIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3IEFTVF9TeW1ib2xSZWYoc3ltKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gd3JhcHBlZF90bDtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0xhbWJkYSA9IERFRk5PREUoXCJMYW1iZGFcIiwgXCJuYW1lIGFyZ25hbWVzIHVzZXNfYXJndW1lbnRzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sRGVjbGFyYXRpb24/XSB0aGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uXCIsXG4gICAgICAgIGFyZ25hbWVzOiBcIltBU1RfU3ltYm9sRnVuYXJnKl0gYXJyYXkgb2YgZnVuY3Rpb24gYXJndW1lbnRzXCIsXG4gICAgICAgIHVzZXNfYXJndW1lbnRzOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBmdW5jdGlvbiBhY2Nlc3NlcyB0aGUgYXJndW1lbnRzIGFycmF5XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSkgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAgICAgYXJnLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TY29wZSk7XG5cbnZhciBBU1RfQWNjZXNzb3IgPSBERUZOT0RFKFwiQWNjZXNzb3JcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2V0dGVyL2dldHRlciBmdW5jdGlvblwiXG59LCBBU1RfTGFtYmRhKTtcblxudmFyIEFTVF9GdW5jdGlvbiA9IERFRk5PREUoXCJGdW5jdGlvblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0RlZnVuID0gREVGTk9ERShcIkRlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIlxufSwgQVNUX0xhbWJkYSk7XG5cbi8qIC0tLS0tWyBKVU1QUyBdLS0tLS0gKi9cblxudmFyIEFTVF9KdW1wID0gREVGTk9ERShcIkp1bXBcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGp1bXBz4oCdIChmb3Igbm93IHRoYXQncyBgcmV0dXJuYCwgYHRocm93YCwgYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIlxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRXhpdCA9IERFRk5PREUoXCJFeGl0XCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGV4aXRz4oCdIChgcmV0dXJuYCBhbmQgYHRocm93YClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGU/XSB0aGUgdmFsdWUgcmV0dXJuZWQgb3IgdGhyb3duIGJ5IHRoaXMgc3RhdGVtZW50OyBjb3VsZCBiZSBudWxsIGZvciBBU1RfUmV0dXJuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLnZhbHVlICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfUmV0dXJuID0gREVGTk9ERShcIlJldHVyblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgcmV0dXJuYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0V4aXQpO1xuXG52YXIgQVNUX1Rocm93ID0gREVGTk9ERShcIlRocm93XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0aHJvd2Agc3RhdGVtZW50XCJcbn0sIEFTVF9FeGl0KTtcblxudmFyIEFTVF9Mb29wQ29udHJvbCA9IERFRk5PREUoXCJMb29wQ29udHJvbFwiLCBcImxhYmVsXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBsb29wIGNvbnRyb2wgc3RhdGVtZW50cyAoYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsUmVmP10gdGhlIGxhYmVsLCBvciBudWxsIGlmIG5vbmVcIixcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLmxhYmVsICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfQnJlYWsgPSBERUZOT0RFKFwiQnJlYWtcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGJyZWFrYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0xvb3BDb250cm9sKTtcblxudmFyIEFTVF9Db250aW51ZSA9IERFRk5PREUoXCJDb250aW51ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29udGludWVgIHN0YXRlbWVudFwiXG59LCBBU1RfTG9vcENvbnRyb2wpO1xuXG4vKiAtLS0tLVsgSUYgXS0tLS0tICovXG5cbnZhciBBU1RfSWYgPSBERUZOT0RFKFwiSWZcIiwgXCJjb25kaXRpb24gYWx0ZXJuYXRpdmVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGlmYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgYGlmYCBjb25kaXRpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiW0FTVF9TdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0aXZlKSB0aGlzLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgU1dJVENIIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N3aXRjaCA9IERFRk5PREUoXCJTd2l0Y2hcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBzd2l0Y2hgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHN3aXRjaGAg4oCcZGlzY3JpbWluYW504oCdXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1N3aXRjaEJyYW5jaCA9IERFRk5PREUoXCJTd2l0Y2hCcmFuY2hcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGBzd2l0Y2hgIGJyYW5jaGVzXCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0RlZmF1bHQgPSBERUZOT0RFKFwiRGVmYXVsdFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZGVmYXVsdGAgc3dpdGNoIGJyYW5jaFwiLFxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbnZhciBBU1RfQ2FzZSA9IERFRk5PREUoXCJDYXNlXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2FzZWAgc3dpdGNoIGJyYW5jaFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYGNhc2VgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Td2l0Y2hCcmFuY2gpO1xuXG4vKiAtLS0tLVsgRVhDRVBUSU9OUyBdLS0tLS0gKi9cblxudmFyIEFTVF9UcnkgPSBERUZOT0RFKFwiVHJ5XCIsIFwiYmNhdGNoIGJmaW5hbGx5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJjYXRjaDogXCJbQVNUX0NhdGNoP10gdGhlIGNhdGNoIGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCIsXG4gICAgICAgIGJmaW5hbGx5OiBcIltBU1RfRmluYWxseT9dIHRoZSBmaW5hbGx5IGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSB0aGlzLmJjYXRjaC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG4vLyBYWFg6IHRoaXMgaXMgd3JvbmcgYWNjb3JkaW5nIHRvIEVDTUEtMjYyICgxMi40KS4gIHRoZSBjYXRjaCBibG9ja1xuLy8gc2hvdWxkIGludHJvZHVjZSBhbm90aGVyIHNjb3BlLCBhcyB0aGUgYXJnbmFtZSBzaG91bGQgYmUgdmlzaWJsZVxuLy8gb25seSBpbnNpZGUgdGhlIGNhdGNoIGJsb2NrLiAgSG93ZXZlciwgZG9pbmcgaXQgdGhpcyB3YXkgYmVjYXVzZSBvZlxuLy8gSUUgd2hpY2ggc2ltcGx5IGludHJvZHVjZXMgdGhlIG5hbWUgaW4gdGhlIHN1cnJvdW5kaW5nIHNjb3BlLiAgSWZcbi8vIHdlIGV2ZXIgd2FudCB0byBmaXggdGhpcyB0aGVuIEFTVF9DYXRjaCBzaG91bGQgaW5oZXJpdCBmcm9tXG4vLyBBU1RfU2NvcGUuXG52YXIgQVNUX0NhdGNoID0gREVGTk9ERShcIkNhdGNoXCIsIFwiYXJnbmFtZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2F0Y2hgIG5vZGU7IG9ubHkgbWFrZXMgc2Vuc2UgYXMgcGFydCBvZiBhIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGFyZ25hbWU6IFwiW0FTVF9TeW1ib2xDYXRjaF0gc3ltYm9sIGZvciB0aGUgZXhjZXB0aW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0ZpbmFsbHkgPSBERUZOT0RFKFwiRmluYWxseVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZmluYWxseWAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCJcbn0sIEFTVF9CbG9jayk7XG5cbi8qIC0tLS0tWyBWQVIvQ09OU1QgXS0tLS0tICovXG5cbnZhciBBU1RfRGVmaW5pdGlvbnMgPSBERUZOT0RFKFwiRGVmaW5pdGlvbnNcIiwgXCJkZWZpbml0aW9uc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYHZhcmAgb3IgYGNvbnN0YCBub2RlcyAodmFyaWFibGUgZGVjbGFyYXRpb25zL2luaXRpYWxpemF0aW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkZWZpbml0aW9uczogXCJbQVNUX1ZhckRlZipdIGFycmF5IG9mIHZhcmlhYmxlIGRlZmluaXRpb25zXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgZGVmLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1ZhciA9IERFRk5PREUoXCJWYXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHZhcmAgc3RhdGVtZW50XCJcbn0sIEFTVF9EZWZpbml0aW9ucyk7XG5cbnZhciBBU1RfQ29uc3QgPSBERUZOT0RFKFwiQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNvbnN0YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0RlZmluaXRpb25zKTtcblxudmFyIEFTVF9WYXJEZWYgPSBERUZOT0RFKFwiVmFyRGVmXCIsIFwibmFtZSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSB2YXJpYWJsZSBkZWNsYXJhdGlvbjsgb25seSBhcHBlYXJzIGluIGEgQVNUX0RlZmluaXRpb25zIG5vZGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sVmFyfEFTVF9TeW1ib2xDb25zdF0gbmFtZSBvZiB0aGUgdmFyaWFibGVcIixcbiAgICAgICAgdmFsdWU6IFwiW0FTVF9Ob2RlP10gaW5pdGlhbGl6ZXIsIG9yIG51bGwgb2YgdGhlcmUncyBubyBpbml0aWFsaXplclwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIE9USEVSIF0tLS0tLSAqL1xuXG52YXIgQVNUX0NhbGwgPSBERUZOT0RFKFwiQ2FsbFwiLCBcImV4cHJlc3Npb24gYXJnc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBjYWxsIGV4cHJlc3Npb25cIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0byBpbnZva2UgYXMgZnVuY3Rpb25cIixcbiAgICAgICAgYXJnczogXCJbQVNUX05vZGUqXSBhcnJheSBvZiBhcmd1bWVudHNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9OZXcgPSBERUZOT0RFKFwiTmV3XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3QgaW5zdGFudGlhdGlvbi4gIERlcml2ZXMgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgc2luY2UgaXQgaGFzIGV4YWN0bHkgdGhlIHNhbWUgcHJvcGVydGllc1wiXG59LCBBU1RfQ2FsbCk7XG5cbnZhciBBU1RfU2VxID0gREVGTk9ERShcIlNlcVwiLCBcImNhciBjZHJcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2VxdWVuY2UgZXhwcmVzc2lvbiAodHdvIGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjYXI6IFwiW0FTVF9Ob2RlXSBmaXJzdCBlbGVtZW50IGluIHNlcXVlbmNlXCIsXG4gICAgICAgIGNkcjogXCJbQVNUX05vZGVdIHNlY29uZCBlbGVtZW50IGluIHNlcXVlbmNlXCJcbiAgICB9LFxuICAgICRjb25zOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBzZXEgPSBuZXcgQVNUX1NlcSh4KTtcbiAgICAgICAgc2VxLmNhciA9IHg7XG4gICAgICAgIHNlcS5jZHIgPSB5O1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH0sXG4gICAgJGZyb21fYXJyYXk6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMSkgcmV0dXJuIGFycmF5WzBdLmNsb25lKCk7XG4gICAgICAgIHZhciBsaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBsaXN0ID0gQVNUX1NlcS5jb25zKGFycmF5W2ldLCBsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IGxpc3Q7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIXAuY2RyLmNkcikge1xuICAgICAgICAgICAgICAgIHAuY2RyID0gcC5jZHIuY2FyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG4gICAgdG9fYXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMsIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGEucHVzaChwLmNhcik7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKHAuY2RyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLmNkcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAoIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBBU1RfU2VxLmNvbnMocC5jZHIsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmNkciA9IGNlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5jZHI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5jYXIuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZHIpIHRoaXMuY2RyLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Qcm9wQWNjZXNzID0gREVGTk9ERShcIlByb3BBY2Nlc3NcIiwgXCJleHByZXNzaW9uIHByb3BlcnR5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbnMsIGkuZS4gYGEuZm9vYCBvciBgYVtcXFwiZm9vXFxcIl1gXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSDigJxjb250YWluZXLigJ0gZXhwcmVzc2lvblwiLFxuICAgICAgICBwcm9wZXJ0eTogXCJbQVNUX05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiAgRm9yIEFTVF9Eb3QgdGhpcyBpcyBhbHdheXMgYSBwbGFpbiBzdHJpbmcsIHdoaWxlIGZvciBBU1RfU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlXCJcbiAgICB9XG59KTtcblxudmFyIEFTVF9Eb3QgPSBERUZOT0RFKFwiRG90XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRvdHRlZCBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvblwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfUHJvcEFjY2Vzcyk7XG5cbnZhciBBU1RfU3ViID0gREVGTk9ERShcIlN1YlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiSW5kZXgtc3R5bGUgcHJvcGVydHkgYWNjZXNzLCBpLmUuIGBhW1xcXCJmb29cXFwiXWBcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9VbmFyeSA9IERFRk5PREUoXCJVbmFyeVwiLCBcIm9wZXJhdG9yIGV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIHVuYXJ5IGV4cHJlc3Npb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSBleHByZXNzaW9uIHRoYXQgdGhpcyB1bmFyeSBvcGVyYXRvciBhcHBsaWVzIHRvXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9VbmFyeVByZWZpeCA9IERFRk5PREUoXCJVbmFyeVByZWZpeFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVW5hcnkgcHJlZml4IGV4cHJlc3Npb24sIGkuZS4gYHR5cGVvZiBpYCBvciBgKytpYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX1VuYXJ5UG9zdGZpeCA9IERFRk5PREUoXCJVbmFyeVBvc3RmaXhcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlVuYXJ5IHBvc3RmaXggZXhwcmVzc2lvbiwgaS5lLiBgaSsrYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX0JpbmFyeSA9IERFRk5PREUoXCJCaW5hcnlcIiwgXCJsZWZ0IG9wZXJhdG9yIHJpZ2h0XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCaW5hcnkgZXhwcmVzc2lvbiwgaS5lLiBgYSArIGJgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbGVmdDogXCJbQVNUX05vZGVdIGxlZnQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIixcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIHJpZ2h0OiBcIltBU1RfTm9kZV0gcmlnaHQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxlZnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Db25kaXRpb25hbCA9IERFRk5PREUoXCJDb25kaXRpb25hbFwiLCBcImNvbmRpdGlvbiBjb25zZXF1ZW50IGFsdGVybmF0aXZlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJDb25kaXRpb25hbCBleHByZXNzaW9uIHVzaW5nIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yLCBpLmUuIGBhID8gYiA6IGNgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV1cIixcbiAgICAgICAgY29uc2VxdWVudDogXCJbQVNUX05vZGVdXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIltBU1RfTm9kZV1cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX0Fzc2lnbiA9IERFRk5PREUoXCJBc3NpZ25cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiDigJQgYGEgPSBiICsgNWBcIixcbn0sIEFTVF9CaW5hcnkpO1xuXG4vKiAtLS0tLVsgTElURVJBTFMgXS0tLS0tICovXG5cbnZhciBBU1RfQXJyYXkgPSBERUZOT0RFKFwiQXJyYXlcIiwgXCJlbGVtZW50c1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYXJyYXkgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGVsZW1lbnRzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgICAgICBlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3QgPSBERUZOT0RFKFwiT2JqZWN0XCIsIFwicHJvcGVydGllc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBwcm9wZXJ0aWVzOiBcIltBU1RfT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgcHJvcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3RQcm9wZXJ0eSA9IERFRk5PREUoXCJPYmplY3RQcm9wZXJ0eVwiLCBcImtleSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgbGl0ZXJhbCBvYmplY3QgcHJvcGVydGllc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGtleTogXCJbc3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZTsgaXQncyBhbHdheXMgYSBwbGFpbiBzdHJpbmcgaW4gb3VyIEFTVCwgbm8gbWF0dGVyIGlmIGl0IHdhcyBhIHN0cmluZywgbnVtYmVyIG9yIGlkZW50aWZpZXIgaW4gb3JpZ2luYWwgY29kZVwiLFxuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGVdIHByb3BlcnR5IHZhbHVlLiAgRm9yIHNldHRlcnMgYW5kIGdldHRlcnMgdGhpcyBpcyBhbiBBU1RfRnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBBU1RfT2JqZWN0S2V5VmFsID0gREVGTk9ERShcIk9iamVjdEtleVZhbFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBrZXk6IHZhbHVlIG9iamVjdCBwcm9wZXJ0eVwiLFxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9PYmplY3RTZXR0ZXIgPSBERUZOT0RFKFwiT2JqZWN0U2V0dGVyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3Qgc2V0dGVyIHByb3BlcnR5XCIsXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX09iamVjdEdldHRlciA9IERFRk5PREUoXCJPYmplY3RHZXR0ZXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBnZXR0ZXIgcHJvcGVydHlcIixcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfU3ltYm9sID0gREVGTk9ERShcIlN5bWJvbFwiLCBcInNjb3BlIG5hbWUgdGhlZGVmXCIsIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixcbiAgICAgICAgc2NvcGU6IFwiW0FTVF9TY29wZS9TXSB0aGUgY3VycmVudCBzY29wZSAobm90IG5lY2Vzc2FyaWx5IHRoZSBkZWZpbml0aW9uIHNjb3BlKVwiLFxuICAgICAgICB0aGVkZWY6IFwiW1N5bWJvbERlZi9TXSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHN5bWJvbFwiXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3ltYm9sc1wiLFxufSk7XG5cbnZhciBBU1RfU3ltYm9sQWNjZXNzb3IgPSBERUZOT0RFKFwiU3ltYm9sQWNjZXNzb3JcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBuYW1lIG9mIGEgcHJvcGVydHkgYWNjZXNzb3IgKHNldHRlci9nZXR0ZXIgZnVuY3Rpb24pXCJcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gREVGTk9ERShcIlN5bWJvbERlY2xhcmF0aW9uXCIsIFwiaW5pdFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBkZWNsYXJhdGlvbiBzeW1ib2wgKHN5bWJvbCBpbiB2YXIvY29uc3QsIGZ1bmN0aW9uIG5hbWUgb3IgYXJndW1lbnQsIHN5bWJvbCBpbiBjYXRjaClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZSovU10gYXJyYXkgb2YgaW5pdGlhbGl6ZXJzIGZvciB0aGlzIGRlY2xhcmF0aW9uLlwiXG4gICAgfVxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sVmFyID0gREVGTk9ERShcIlN5bWJvbFZhclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIGRlZmluaW5nIGEgdmFyaWFibGVcIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFwiU3ltYm9sQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY29uc3RhbnQgZGVjbGFyYXRpb25cIlxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xGdW5hcmcgPSBERUZOT0RFKFwiU3ltYm9sRnVuYXJnXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gYXJndW1lbnRcIixcbn0sIEFTVF9TeW1ib2xWYXIpO1xuXG52YXIgQVNUX1N5bWJvbERlZnVuID0gREVGTk9ERShcIlN5bWJvbERlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSBmdW5jdGlvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xMYW1iZGEgPSBERUZOT0RFKFwiU3ltYm9sTGFtYmRhXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xDYXRjaCA9IERFRk5PREUoXCJTeW1ib2xDYXRjaFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyB0aGUgZXhjZXB0aW9uIGluIGNhdGNoXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX0xhYmVsID0gREVGTk9ERShcIkxhYmVsXCIsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyBhIGxhYmVsIChkZWNsYXJhdGlvbilcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICByZWZlcmVuY2VzOiBcIltBU1RfTGFiZWxSZWYqXSBhIGxpc3Qgb2Ygbm9kZXMgcmVmZXJyaW5nIHRvIHRoaXMgbGFiZWxcIlxuICAgIH1cbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbFJlZiA9IERFRk5PREUoXCJTeW1ib2xSZWZcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlZmVyZW5jZSB0byBzb21lIHN5bWJvbCAobm90IGRlZmluaXRpb24vZGVjbGFyYXRpb24pXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9MYWJlbFJlZiA9IERFRk5PREUoXCJMYWJlbFJlZlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVmZXJlbmNlIHRvIGEgbGFiZWwgc3ltYm9sXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9UaGlzID0gREVGTk9ERShcIlRoaXNcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdGhpc2Agc3ltYm9sXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9Db25zdGFudCA9IERFRk5PREUoXCJDb25zdGFudFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIGNvbnN0YW50c1wiLFxuICAgIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufSk7XG5cbnZhciBBU1RfU3RyaW5nID0gREVGTk9ERShcIlN0cmluZ1wiLCBcInZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHN0cmluZyBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW3N0cmluZ10gdGhlIGNvbnRlbnRzIG9mIHRoaXMgc3RyaW5nXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX051bWJlciA9IERFRk5PREUoXCJOdW1iZXJcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBudW1iZXIgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltudW1iZXJdIHRoZSBudW1lcmljIHZhbHVlXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX1JlZ0V4cCA9IERFRk5PREUoXCJSZWdFeHBcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSByZWdleHAgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltSZWdFeHBdIHRoZSBhY3R1YWwgcmVnZXhwXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX0F0b20gPSBERUZOT0RFKFwiQXRvbVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYXRvbXNcIixcbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfTnVsbCA9IERFRk5PREUoXCJOdWxsXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYG51bGxgIGF0b21cIixcbiAgICB2YWx1ZTogbnVsbFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX05hTiA9IERFRk5PREUoXCJOYU5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBpbXBvc3NpYmxlIHZhbHVlXCIsXG4gICAgdmFsdWU6IDAvMFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX1VuZGVmaW5lZCA9IERFRk5PREUoXCJVbmRlZmluZWRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdW5kZWZpbmVkYCB2YWx1ZVwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24oKXt9KCkpXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfSG9sZSA9IERFRk5PREUoXCJIb2xlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGhvbGUgaW4gYW4gYXJyYXlcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCl7fSgpKVxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0luZmluaXR5ID0gREVGTk9ERShcIkluZmluaXR5XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYEluZmluaXR5YCB2YWx1ZVwiLFxuICAgIHZhbHVlOiAxLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Cb29sZWFuID0gREVGTk9ERShcIkJvb2xlYW5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGJvb2xlYW5zXCIsXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfRmFsc2UgPSBERUZOT0RFKFwiRmFsc2VcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgZmFsc2VgIGF0b21cIixcbiAgICB2YWx1ZTogZmFsc2Vcbn0sIEFTVF9Cb29sZWFuKTtcblxudmFyIEFTVF9UcnVlID0gREVGTk9ERShcIlRydWVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdHJ1ZWAgYXRvbVwiLFxuICAgIHZhbHVlOiB0cnVlXG59LCBBU1RfQm9vbGVhbik7XG5cbi8qIC0tLS0tWyBUcmVlV2Fsa2VyIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBUcmVlV2Fsa2VyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy52aXNpdCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbn07XG5UcmVlV2Fsa2VyLnByb3RvdHlwZSA9IHtcbiAgICBfdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy52aXNpdChub2RlLCBkZXNjZW5kID8gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcbiAgICAgICAgfSA6IG5vb3ApO1xuICAgICAgICBpZiAoIXJldCAmJiBkZXNjZW5kKSB7XG4gICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDIgLSAobiB8fCAwKV07XG4gICAgfSxcbiAgICBwdXNoOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgfSxcbiAgICBwb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9LFxuICAgIHNlbGY6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH0sXG4gICAgZmluZF9wYXJlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGFzX2RpcmVjdGl2ZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kX3BhcmVudChBU1RfU2NvcGUpLmhhc19kaXJlY3RpdmUodHlwZSk7XG4gICAgfSxcbiAgICBpbl9ib29sZWFuX2NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCwgc2VsZiA9IHN0YWNrWy0taV07XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgdmFyIHAgPSBzdGFja1stLWldO1xuICAgICAgICAgICAgaWYgKChwIGluc3RhbmNlb2YgQVNUX0lmICAgICAgICAgICAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAgJiYgcC5jb25kaXRpb24gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRFdMb29wICAgICAgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0ZvciAgICAgICAgICAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAgJiYgcC5vcGVyYXRvciA9PSBcIiFcIiAmJiBwLmV4cHJlc3Npb24gPT09IHNlbGYpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgKHAub3BlcmF0b3IgPT0gXCImJlwiIHx8IHAub3BlcmF0b3IgPT0gXCJ8fFwiKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgc2VsZiA9IHA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxvb3Bjb250cm9sX3RhcmdldDogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQgJiYgeC5sYWJlbC5uYW1lID09IGxhYmVsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHguYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX1N3aXRjaFxuICAgICAgICAgICAgICAgICAgICB8fCB4IGluc3RhbmNlb2YgQVNUX0ZvclxuICAgICAgICAgICAgICAgICAgICB8fCB4IGluc3RhbmNlb2YgQVNUX0ZvckluXG4gICAgICAgICAgICAgICAgICAgIHx8IHggaW5zdGFuY2VvZiBBU1RfRFdMb29wKSByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICBQYXJzZXIgYmFzZWQgb24gcGFyc2UtanMgKGh0dHA6Ly9tYXJpam4uaGF2ZXJiZWtlLm5sL3BhcnNlLWpzLykuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgS0VZV09SRFMgPSAnYnJlYWsgY2FzZSBjYXRjaCBjb25zdCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRlbGV0ZSBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGluIGluc3RhbmNlb2YgbmV3IHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHR5cGVvZiB2YXIgdm9pZCB3aGlsZSB3aXRoJztcbnZhciBLRVlXT1JEU19BVE9NID0gJ2ZhbHNlIG51bGwgdHJ1ZSc7XG52YXIgUkVTRVJWRURfV09SRFMgPSAnYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhpcyB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlJ1xuICAgICsgXCIgXCIgKyBLRVlXT1JEU19BVE9NICsgXCIgXCIgKyBLRVlXT1JEUztcbnZhciBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9ICdyZXR1cm4gbmV3IGRlbGV0ZSB0aHJvdyBlbHNlIGNhc2UnO1xuXG5LRVlXT1JEUyA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFMpO1xuUkVTRVJWRURfV09SRFMgPSBtYWtlUHJlZGljYXRlKFJFU0VSVkVEX1dPUkRTKTtcbktFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTik7XG5LRVlXT1JEU19BVE9NID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEU19BVE9NKTtcblxudmFyIE9QRVJBVE9SX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiKy0qJiU9PD4hP3x+XlwiKSk7XG5cbnZhciBSRV9IRVhfTlVNQkVSID0gL14weFswLTlhLWZdKyQvaTtcbnZhciBSRV9PQ1RfTlVNQkVSID0gL14wWzAtN10rJC87XG52YXIgUkVfREVDX05VTUJFUiA9IC9eXFxkKlxcLj9cXGQqKD86ZVsrLV0/XFxkKig/OlxcZFxcLj98XFwuP1xcZClcXGQqKT8kL2k7XG5cbnZhciBPUEVSQVRPUlMgPSBtYWtlUHJlZGljYXRlKFtcbiAgICBcImluXCIsXG4gICAgXCJpbnN0YW5jZW9mXCIsXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcIm5ld1wiLFxuICAgIFwidm9pZFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCIrK1wiLFxuICAgIFwiLS1cIixcbiAgICBcIitcIixcbiAgICBcIi1cIixcbiAgICBcIiFcIixcbiAgICBcIn5cIixcbiAgICBcIiZcIixcbiAgICBcInxcIixcbiAgICBcIl5cIixcbiAgICBcIipcIixcbiAgICBcIi9cIixcbiAgICBcIiVcIixcbiAgICBcIj4+XCIsXG4gICAgXCI8PFwiLFxuICAgIFwiPj4+XCIsXG4gICAgXCI8XCIsXG4gICAgXCI+XCIsXG4gICAgXCI8PVwiLFxuICAgIFwiPj1cIixcbiAgICBcIj09XCIsXG4gICAgXCI9PT1cIixcbiAgICBcIiE9XCIsXG4gICAgXCIhPT1cIixcbiAgICBcIj9cIixcbiAgICBcIj1cIixcbiAgICBcIis9XCIsXG4gICAgXCItPVwiLFxuICAgIFwiLz1cIixcbiAgICBcIio9XCIsXG4gICAgXCIlPVwiLFxuICAgIFwiPj49XCIsXG4gICAgXCI8PD1cIixcbiAgICBcIj4+Pj1cIixcbiAgICBcInw9XCIsXG4gICAgXCJePVwiLFxuICAgIFwiJj1cIixcbiAgICBcIiYmXCIsXG4gICAgXCJ8fFwiXG5dKTtcblxudmFyIFdISVRFU1BBQ0VfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCIgXFx1MDBhMFxcblxcclxcdFxcZlxcdTAwMGJcXHUyMDBiXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXCIpKTtcblxudmFyIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJbeygsLjs6XCIpKTtcblxudmFyIFBVTkNfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJbXXt9KCksOzpcIikpO1xuXG52YXIgUkVHRVhQX01PRElGSUVSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcImdtc2l5XCIpKTtcblxuLyogLS0tLS1bIFRva2VuaXplciBdLS0tLS0gKi9cblxuLy8gcmVnZXhwcyBhZGFwdGVkIGZyb20gaHR0cDovL3hyZWdleHAuY29tL3BsdWdpbnMvI3VuaWNvZGVcbnZhciBVTklDT0RFID0ge1xuICAgIGxldHRlcjogbmV3IFJlZ0V4cChcIltcXFxcdTAwNDEtXFxcXHUwMDVBXFxcXHUwMDYxLVxcXFx1MDA3QVxcXFx1MDBBQVxcXFx1MDBCNVxcXFx1MDBCQVxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyM1xcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjEtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MVxcXFx1MDk3MlxcXFx1MDk3Qi1cXFxcdTA5N0ZcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzM1xcXFx1MEMzNS1cXFxcdTBDMzlcXFxcdTBDM0RcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQyOFxcXFx1MEQyQS1cXFxcdTBEMzlcXFxcdTBEM0RcXFxcdTBENjBcXFxcdTBENjFcXFxcdTBEN0EtXFxcXHUwRDdGXFxcXHUwRDg1LVxcXFx1MEQ5NlxcXFx1MEQ5QS1cXFxcdTBEQjFcXFxcdTBEQjMtXFxcXHUwREJCXFxcXHUwREJEXFxcXHUwREMwLVxcXFx1MERDNlxcXFx1MEUwMS1cXFxcdTBFMzBcXFxcdTBFMzJcXFxcdTBFMzNcXFxcdTBFNDAtXFxcXHUwRTQ2XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCMFxcXFx1MEVCMlxcXFx1MEVCM1xcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFQzZcXFxcdTBFRENcXFxcdTBFRERcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOEJcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDXFxcXHUxMTAwLVxcXFx1MTE1OVxcXFx1MTE1Ri1cXFxcdTExQTJcXFxcdTExQTgtXFxcXHUxMUY5XFxcXHUxMjAwLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzODAtXFxcXHUxMzhGXFxcXHUxM0EwLVxcXFx1MTNGNFxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjc2XFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE5MDAtXFxcXHUxOTFDXFxcXHUxOTUwLVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUE5XFxcXHUxOUMxLVxcXFx1MTlDN1xcXFx1MUEwMC1cXFxcdTFBMTZcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFEMDAtXFxcXHUxREJGXFxcXHUxRTAwLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5NFxcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFEXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJBLVxcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzlcXFxcdTIxM0MtXFxcXHUyMTNGXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE4M1xcXFx1MjE4NFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkM2RlxcXFx1MkM3MS1cXFxcdTJDN0RcXFxcdTJDODAtXFxcXHUyQ0U0XFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQzMC1cXFxcdTJENjVcXFxcdTJENkZcXFxcdTJEODAtXFxcXHUyRDk2XFxcXHUyREEwLVxcXFx1MkRBNlxcXFx1MkRBOC1cXFxcdTJEQUVcXFxcdTJEQjAtXFxcXHUyREI2XFxcXHUyREI4LVxcXFx1MkRCRVxcXFx1MkRDMC1cXFxcdTJEQzZcXFxcdTJEQzgtXFxcXHUyRENFXFxcXHUyREQwLVxcXFx1MkRENlxcXFx1MkREOC1cXFxcdTJEREVcXFxcdTJFMkZcXFxcdTMwMDVcXFxcdTMwMDZcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDNCXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCN1xcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDBcXFxcdTREQjVcXFxcdTRFMDBcXFxcdTlGQzNcXFxcdUEwMDAtXFxcXHVBNDhDXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjVGXFxcXHVBNjYyLVxcXFx1QTY2RVxcXFx1QTY3Ri1cXFxcdUE2OTdcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4QlxcXFx1QTc4Q1xcXFx1QTdGQi1cXFxcdUE4MDFcXFxcdUE4MDMtXFxcXHVBODA1XFxcXHVBODA3LVxcXFx1QTgwQVxcXFx1QTgwQy1cXFxcdUE4MjJcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgyLVxcXFx1QThCM1xcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBQTAwLVxcXFx1QUEyOFxcXFx1QUE0MC1cXFxcdUFBNDJcXFxcdUFBNDQtXFxcXHVBQTRCXFxcXHVBQzAwXFxcXHVEN0EzXFxcXHVGOTAwLVxcXFx1RkEyRFxcXFx1RkEzMC1cXFxcdUZBNkFcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ11cIiksXG4gICAgbm9uX3NwYWNpbmdfbWFyazogbmV3IFJlZ0V4cChcIltcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA2MTAtXFxcXHUwNjFBXFxcXHUwNjRCLVxcXFx1MDY1RVxcXFx1MDY3MFxcXFx1MDZENi1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU0XFxcXHUwNkU3XFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZFRFxcXFx1MDcxMVxcXFx1MDczMC1cXFxcdTA3NEFcXFxcdTA3QTYtXFxcXHUwN0IwXFxcXHUwN0VCLVxcXFx1MDdGM1xcXFx1MDgxNi1cXFxcdTA4MTlcXFxcdTA4MUItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MkRcXFxcdTA5MDAtXFxcXHUwOTAyXFxcXHUwOTNDXFxcXHUwOTQxLVxcXFx1MDk0OFxcXFx1MDk0RFxcXFx1MDk1MS1cXFxcdTA5NTVcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODFcXFxcdTA5QkNcXFxcdTA5QzEtXFxcXHUwOUM0XFxcXHUwOUNEXFxcXHUwOUUyXFxcXHUwOUUzXFxcXHUwQTAxXFxcXHUwQTAyXFxcXHUwQTNDXFxcXHUwQTQxXFxcXHUwQTQyXFxcXHUwQTQ3XFxcXHUwQTQ4XFxcXHUwQTRCLVxcXFx1MEE0RFxcXFx1MEE1MVxcXFx1MEE3MFxcXFx1MEE3MVxcXFx1MEE3NVxcXFx1MEE4MVxcXFx1MEE4MlxcXFx1MEFCQ1xcXFx1MEFDMS1cXFxcdTBBQzVcXFxcdTBBQzdcXFxcdTBBQzhcXFxcdTBBQ0RcXFxcdTBBRTJcXFxcdTBBRTNcXFxcdTBCMDFcXFxcdTBCM0NcXFxcdTBCM0ZcXFxcdTBCNDEtXFxcXHUwQjQ0XFxcXHUwQjREXFxcXHUwQjU2XFxcXHUwQjYyXFxcXHUwQjYzXFxcXHUwQjgyXFxcXHUwQkMwXFxcXHUwQkNEXFxcXHUwQzNFLVxcXFx1MEM0MFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzYyXFxcXHUwQzYzXFxcXHUwQ0JDXFxcXHUwQ0JGXFxcXHUwQ0M2XFxcXHUwQ0NDXFxcXHUwQ0NEXFxcXHUwQ0UyXFxcXHUwQ0UzXFxcXHUwRDQxLVxcXFx1MEQ0NFxcXFx1MEQ0RFxcXFx1MEQ2MlxcXFx1MEQ2M1xcXFx1MERDQVxcXFx1MEREMi1cXFxcdTBERDRcXFxcdTBERDZcXFxcdTBFMzFcXFxcdTBFMzQtXFxcXHUwRTNBXFxcXHUwRTQ3LVxcXFx1MEU0RVxcXFx1MEVCMVxcXFx1MEVCNC1cXFxcdTBFQjlcXFxcdTBFQkJcXFxcdTBFQkNcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjcxLVxcXFx1MEY3RVxcXFx1MEY4MC1cXFxcdTBGODRcXFxcdTBGODZcXFxcdTBGODdcXFxcdTBGOTAtXFxcXHUwRjk3XFxcXHUwRjk5LVxcXFx1MEZCQ1xcXFx1MEZDNlxcXFx1MTAyRC1cXFxcdTEwMzBcXFxcdTEwMzItXFxcXHUxMDM3XFxcXHUxMDM5XFxcXHUxMDNBXFxcXHUxMDNEXFxcXHUxMDNFXFxcXHUxMDU4XFxcXHUxMDU5XFxcXHUxMDVFLVxcXFx1MTA2MFxcXFx1MTA3MS1cXFxcdTEwNzRcXFxcdTEwODJcXFxcdTEwODVcXFxcdTEwODZcXFxcdTEwOERcXFxcdTEwOURcXFxcdTEzNUZcXFxcdTE3MTItXFxcXHUxNzE0XFxcXHUxNzMyLVxcXFx1MTczNFxcXFx1MTc1MlxcXFx1MTc1M1xcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTdCNy1cXFxcdTE3QkRcXFxcdTE3QzZcXFxcdTE3QzktXFxcXHUxN0QzXFxcXHUxN0REXFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MThBOVxcXFx1MTkyMC1cXFxcdTE5MjJcXFxcdTE5MjdcXFxcdTE5MjhcXFxcdTE5MzJcXFxcdTE5MzktXFxcXHUxOTNCXFxcXHUxQTE3XFxcXHUxQTE4XFxcXHUxQTU2XFxcXHUxQTU4LVxcXFx1MUE1RVxcXFx1MUE2MFxcXFx1MUE2MlxcXFx1MUE2NS1cXFxcdTFBNkNcXFxcdTFBNzMtXFxcXHUxQTdDXFxcXHUxQTdGXFxcXHUxQjAwLVxcXFx1MUIwM1xcXFx1MUIzNFxcXFx1MUIzNi1cXFxcdTFCM0FcXFxcdTFCM0NcXFxcdTFCNDJcXFxcdTFCNkItXFxcXHUxQjczXFxcXHUxQjgwXFxcXHUxQjgxXFxcXHUxQkEyLVxcXFx1MUJBNVxcXFx1MUJBOFxcXFx1MUJBOVxcXFx1MUMyQy1cXFxcdTFDMzNcXFxcdTFDMzZcXFxcdTFDMzdcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNFMFxcXFx1MUNFMi1cXFxcdTFDRThcXFxcdTFDRURcXFxcdTFEQzAtXFxcXHUxREU2XFxcXHUxREZELVxcXFx1MURGRlxcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyQ0VGLVxcXFx1MkNGMVxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTMwMkEtXFxcXHUzMDJGXFxcXHUzMDk5XFxcXHUzMDlBXFxcXHVBNjZGXFxcXHVBNjdDXFxcXHVBNjdEXFxcXHVBNkYwXFxcXHVBNkYxXFxcXHVBODAyXFxcXHVBODA2XFxcXHVBODBCXFxcXHVBODI1XFxcXHVBODI2XFxcXHVBOEM0XFxcXHVBOEUwLVxcXFx1QThGMVxcXFx1QTkyNi1cXFxcdUE5MkRcXFxcdUE5NDctXFxcXHVBOTUxXFxcXHVBOTgwLVxcXFx1QTk4MlxcXFx1QTlCM1xcXFx1QTlCNi1cXFxcdUE5QjlcXFxcdUE5QkNcXFxcdUFBMjktXFxcXHVBQTJFXFxcXHVBQTMxXFxcXHVBQTMyXFxcXHVBQTM1XFxcXHVBQTM2XFxcXHVBQTQzXFxcXHVBQTRDXFxcXHVBQUIwXFxcXHVBQUIyLVxcXFx1QUFCNFxcXFx1QUFCN1xcXFx1QUFCOFxcXFx1QUFCRVxcXFx1QUFCRlxcXFx1QUFDMVxcXFx1QUJFNVxcXFx1QUJFOFxcXFx1QUJFRFxcXFx1RkIxRVxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTI2XVwiKSxcbiAgICBzcGFjZV9jb21iaW5pbmdfbWFyazogbmV3IFJlZ0V4cChcIltcXFxcdTA5MDNcXFxcdTA5M0UtXFxcXHUwOTQwXFxcXHUwOTQ5LVxcXFx1MDk0Q1xcXFx1MDk0RVxcXFx1MDk4MlxcXFx1MDk4M1xcXFx1MDlCRS1cXFxcdTA5QzBcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0JcXFxcdTA5Q0NcXFxcdTA5RDdcXFxcdTBBMDNcXFxcdTBBM0UtXFxcXHUwQTQwXFxcXHUwQTgzXFxcXHUwQUJFLVxcXFx1MEFDMFxcXFx1MEFDOVxcXFx1MEFDQlxcXFx1MEFDQ1xcXFx1MEIwMlxcXFx1MEIwM1xcXFx1MEIzRVxcXFx1MEI0MFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0QlxcXFx1MEI0Q1xcXFx1MEI1N1xcXFx1MEJCRVxcXFx1MEJCRlxcXFx1MEJDMVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNDXFxcXHUwQkQ3XFxcXHUwQzAxLVxcXFx1MEMwM1xcXFx1MEM0MS1cXFxcdTBDNDRcXFxcdTBDODJcXFxcdTBDODNcXFxcdTBDQkVcXFxcdTBDQzAtXFxcXHUwQ0M0XFxcXHUwQ0M3XFxcXHUwQ0M4XFxcXHUwQ0NBXFxcXHUwQ0NCXFxcXHUwQ0Q1XFxcXHUwQ0Q2XFxcXHUwRDAyXFxcXHUwRDAzXFxcXHUwRDNFLVxcXFx1MEQ0MFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDRDXFxcXHUwRDU3XFxcXHUwRDgyXFxcXHUwRDgzXFxcXHUwRENGLVxcXFx1MEREMVxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBGM0VcXFxcdTBGM0ZcXFxcdTBGN0ZcXFxcdTEwMkJcXFxcdTEwMkNcXFxcdTEwMzFcXFxcdTEwMzhcXFxcdTEwM0JcXFxcdTEwM0NcXFxcdTEwNTZcXFxcdTEwNTdcXFxcdTEwNjItXFxcXHUxMDY0XFxcXHUxMDY3LVxcXFx1MTA2RFxcXFx1MTA4M1xcXFx1MTA4NFxcXFx1MTA4Ny1cXFxcdTEwOENcXFxcdTEwOEZcXFxcdTEwOUEtXFxcXHUxMDlDXFxcXHUxN0I2XFxcXHUxN0JFLVxcXFx1MTdDNVxcXFx1MTdDN1xcXFx1MTdDOFxcXFx1MTkyMy1cXFxcdTE5MjZcXFxcdTE5MjktXFxcXHUxOTJCXFxcXHUxOTMwXFxcXHUxOTMxXFxcXHUxOTMzLVxcXFx1MTkzOFxcXFx1MTlCMC1cXFxcdTE5QzBcXFxcdTE5QzhcXFxcdTE5QzlcXFxcdTFBMTktXFxcXHUxQTFCXFxcXHUxQTU1XFxcXHUxQTU3XFxcXHUxQTYxXFxcXHUxQTYzXFxcXHUxQTY0XFxcXHUxQTZELVxcXFx1MUE3MlxcXFx1MUIwNFxcXFx1MUIzNVxcXFx1MUIzQlxcXFx1MUIzRC1cXFxcdTFCNDFcXFxcdTFCNDNcXFxcdTFCNDRcXFxcdTFCODJcXFxcdTFCQTFcXFxcdTFCQTZcXFxcdTFCQTdcXFxcdTFCQUFcXFxcdTFDMjQtXFxcXHUxQzJCXFxcXHUxQzM0XFxcXHUxQzM1XFxcXHUxQ0UxXFxcXHUxQ0YyXFxcXHVBODIzXFxcXHVBODI0XFxcXHVBODI3XFxcXHVBODgwXFxcXHVBODgxXFxcXHVBOEI0LVxcXFx1QThDM1xcXFx1QTk1MlxcXFx1QTk1M1xcXFx1QTk4M1xcXFx1QTlCNFxcXFx1QTlCNVxcXFx1QTlCQVxcXFx1QTlCQlxcXFx1QTlCRC1cXFxcdUE5QzBcXFxcdUFBMkZcXFxcdUFBMzBcXFxcdUFBMzNcXFxcdUFBMzRcXFxcdUFBNERcXFxcdUFBN0JcXFxcdUFCRTNcXFxcdUFCRTRcXFxcdUFCRTZcXFxcdUFCRTdcXFxcdUFCRTlcXFxcdUFCRUFcXFxcdUFCRUNdXCIpLFxuICAgIGNvbm5lY3Rvcl9wdW5jdHVhdGlvbjogbmV3IFJlZ0V4cChcIltcXFxcdTAwNUZcXFxcdTIwM0ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdUZFMzNcXFxcdUZFMzRcXFxcdUZFNEQtXFxcXHVGRTRGXFxcXHVGRjNGXVwiKVxufTtcblxuZnVuY3Rpb24gaXNfbGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpXG4gICAgICAgIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApXG4gICAgICAgIHx8IChjb2RlID49IDB4YWEgJiYgVU5JQ09ERS5sZXR0ZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSk7XG59O1xuXG5mdW5jdGlvbiBpc19kaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NzsgLy9YWFg6IGZpbmQgb3V0IGlmIFwiVW5pY29kZURpZ2l0XCIgbWVhbnMgc29tZXRoaW5nIGVsc2UgdGhhbiAwLi45XG59O1xuXG5mdW5jdGlvbiBpc19hbHBoYW51bWVyaWNfY2hhcihjb2RlKSB7XG4gICAgcmV0dXJuIGlzX2RpZ2l0KGNvZGUpIHx8IGlzX2xldHRlcihjb2RlKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfY29tYmluaW5nX21hcmsoY2gpIHtcbiAgICByZXR1cm4gVU5JQ09ERS5ub25fc3BhY2luZ19tYXJrLnRlc3QoY2gpIHx8IFVOSUNPREUuc3BhY2VfY29tYmluaW5nX21hcmsudGVzdChjaCk7XG59O1xuXG5mdW5jdGlvbiBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbihjaCkge1xuICAgIHJldHVybiBVTklDT0RFLmNvbm5lY3Rvcl9wdW5jdHVhdGlvbi50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXIobmFtZSkge1xuICAgIHJldHVybiAhUkVTRVJWRURfV09SRFMobmFtZSkgJiYgL15bYS16XyRdW2EtejAtOV8kXSokL2kudGVzdChuYW1lKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfc3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09IDM2IHx8IGNvZGUgPT0gOTUgfHwgaXNfbGV0dGVyKGNvZGUpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9jaGFyKGNoKSB7XG4gICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBpc19pZGVudGlmaWVyX3N0YXJ0KGNvZGUpXG4gICAgICAgIHx8IGlzX2RpZ2l0KGNvZGUpXG4gICAgICAgIHx8IGNvZGUgPT0gODIwNCAvLyBcXHUyMDBjOiB6ZXJvLXdpZHRoIG5vbi1qb2luZXIgPFpXTko+XG4gICAgICAgIHx8IGNvZGUgPT0gODIwNSAvLyBcXHUyMDBkOiB6ZXJvLXdpZHRoIGpvaW5lciA8WldKPiAoaW4gbXkgRUNNQS0yNjIgUERGLCB0aGlzIGlzIGFsc28gMjAwYylcbiAgICAgICAgfHwgaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaClcbiAgICAgICAgfHwgaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb24oY2gpXG4gICAgO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdHJpbmcoc3RyKXtcbiAgICB2YXIgaSA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpc19kaWdpdChzdHIuY2hhckNvZGVBdCgwKSkpIHJldHVybiBmYWxzZTtcbiAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX2NoYXIoc3RyLmNoYXJBdChpKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gcGFyc2VfanNfbnVtYmVyKG51bSkge1xuICAgIGlmIChSRV9IRVhfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgMTYpO1xuICAgIH0gZWxzZSBpZiAoUkVfT0NUX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMSksIDgpO1xuICAgIH0gZWxzZSBpZiAoUkVfREVDX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBKU19QYXJzZV9FcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wsIHBvcykge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG59O1xuXG5KU19QYXJzZV9FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgXCIgKGxpbmU6IFwiICsgdGhpcy5saW5lICsgXCIsIGNvbDogXCIgKyB0aGlzLmNvbCArIFwiLCBwb3M6IFwiICsgdGhpcy5wb3MgKyBcIilcIiArIFwiXFxuXFxuXCIgKyB0aGlzLnN0YWNrO1xufTtcblxuZnVuY3Rpb24ganNfZXJyb3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgdGhyb3cgbmV3IEpTX1BhcnNlX0Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3Rva2VuKHRva2VuLCB0eXBlLCB2YWwpIHtcbiAgICByZXR1cm4gdG9rZW4udHlwZSA9PSB0eXBlICYmICh2YWwgPT0gbnVsbCB8fCB0b2tlbi52YWx1ZSA9PSB2YWwpO1xufTtcblxudmFyIEVYX0VPRiA9IHt9O1xuXG5mdW5jdGlvbiB0b2tlbml6ZXIoJFRFWFQsIGZpbGVuYW1lKSB7XG5cbiAgICB2YXIgUyA9IHtcbiAgICAgICAgdGV4dCAgICAgICAgICAgIDogJFRFWFQucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpLFxuICAgICAgICBmaWxlbmFtZSAgICAgICAgOiBmaWxlbmFtZSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rcG9zICAgICAgICAgIDogMCxcbiAgICAgICAgbGluZSAgICAgICAgICAgIDogMSxcbiAgICAgICAgdG9rbGluZSAgICAgICAgIDogMCxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rY29sICAgICAgICAgIDogMCxcbiAgICAgICAgbmV3bGluZV9iZWZvcmUgIDogZmFsc2UsXG4gICAgICAgIHJlZ2V4X2FsbG93ZWQgICA6IGZhbHNlLFxuICAgICAgICBjb21tZW50c19iZWZvcmUgOiBbXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy50ZXh0LmNoYXJBdChTLnBvcyk7IH07XG5cbiAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICB2YXIgY2ggPSBTLnRleHQuY2hhckF0KFMucG9zKyspO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiAhY2gpXG4gICAgICAgICAgICB0aHJvdyBFWF9FT0Y7XG4gICAgICAgIGlmIChjaCA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgKytTLmxpbmU7XG4gICAgICAgICAgICBTLmNvbCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK1MuY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmluZCh3aGF0LCBzaWduYWxfZW9mKSB7XG4gICAgICAgIHZhciBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XG4gICAgICAgIGlmIChzaWduYWxfZW9mICYmIHBvcyA9PSAtMSkgdGhyb3cgRVhfRU9GO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzdGFydF90b2tlbigpIHtcbiAgICAgICAgUy50b2tsaW5lID0gUy5saW5lO1xuICAgICAgICBTLnRva2NvbCA9IFMuY29sO1xuICAgICAgICBTLnRva3BvcyA9IFMucG9zO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2tlbih0eXBlLCB2YWx1ZSwgaXNfY29tbWVudCkge1xuICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSAoKHR5cGUgPT0gXCJvcGVyYXRvclwiICYmICFVTkFSWV9QT1NURklYKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwia2V5d29yZFwiICYmIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwicHVuY1wiICYmIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpKSk7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICB0eXBlICAgOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWUgIDogdmFsdWUsXG4gICAgICAgICAgICBsaW5lICAgOiBTLnRva2xpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBTLnRva2NvbCxcbiAgICAgICAgICAgIHBvcyAgICA6IFMudG9rcG9zLFxuICAgICAgICAgICAgZW5kcG9zIDogUy5wb3MsXG4gICAgICAgICAgICBubGIgICAgOiBTLm5ld2xpbmVfYmVmb3JlLFxuICAgICAgICAgICAgZmlsZSAgIDogZmlsZW5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc19jb21tZW50KSB7XG4gICAgICAgICAgICByZXQuY29tbWVudHNfYmVmb3JlID0gUy5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgLy8gbWFrZSBub3RlIG9mIGFueSBuZXdsaW5lcyBpbiB0aGUgY29tbWVudHMgdGhhdCBjYW1lIGJlZm9yZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJldC5jb21tZW50c19iZWZvcmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQubmxiID0gcmV0Lm5sYiB8fCByZXQuY29tbWVudHNfYmVmb3JlW2ldLm5sYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHJldCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNraXBfd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUgKFdISVRFU1BBQ0VfQ0hBUlMocGVlaygpKSlcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBjaCwgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICYmIHByZWQoY2gsIGkrKykpXG4gICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZV9lcnJvcihlcnIpIHtcbiAgICAgICAganNfZXJyb3IoZXJyLCBmaWxlbmFtZSwgUy50b2tsaW5lLCBTLnRva2NvbCwgUy50b2twb3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWFkX251bShwcmVmaXgpIHtcbiAgICAgICAgdmFyIGhhc19lID0gZmFsc2UsIGFmdGVyX2UgPSBmYWxzZSwgaGFzX3ggPSBmYWxzZSwgaGFzX2RvdCA9IHByZWZpeCA9PSBcIi5cIjtcbiAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpe1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTIwOiBjYXNlIDg4OiAvLyB4WFxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNfeCA/IGZhbHNlIDogKGhhc194ID0gdHJ1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgMTAxOiBjYXNlIDY5OiAvLyBlRVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNfeCA/IHRydWUgOiBoYXNfZSA/IGZhbHNlIDogKGhhc19lID0gYWZ0ZXJfZSA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDQ1OiAvLyAtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2UgfHwgKGkgPT0gMCAmJiAhcHJlZml4KTtcbiAgICAgICAgICAgICAgY2FzZSA0MzogLy8gK1xuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlcl9lO1xuICAgICAgICAgICAgICBjYXNlIChhZnRlcl9lID0gZmFsc2UsIDQ2KTogLy8gLlxuICAgICAgICAgICAgICAgIHJldHVybiAoIWhhc19kb3QgJiYgIWhhc194ICYmICFoYXNfZSkgPyAoaGFzX2RvdCA9IHRydWUpIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNfYWxwaGFudW1lcmljX2NoYXIoY29kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlZml4KSBudW0gPSBwcmVmaXggKyBudW07XG4gICAgICAgIHZhciB2YWxpZCA9IHBhcnNlX2pzX251bWJlcihudW0pO1xuICAgICAgICBpZiAoIWlzTmFOKHZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwibnVtXCIsIHZhbGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBzeW50YXg6IFwiICsgbnVtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWFkX2VzY2FwZWRfY2hhcihpbl9zdHJpbmcpIHtcbiAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xuICAgICAgICBzd2l0Y2ggKGNoLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBjYXNlIDExMCA6IHJldHVybiBcIlxcblwiO1xuICAgICAgICAgIGNhc2UgMTE0IDogcmV0dXJuIFwiXFxyXCI7XG4gICAgICAgICAgY2FzZSAxMTYgOiByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgICBjYXNlIDk4ICA6IHJldHVybiBcIlxcYlwiO1xuICAgICAgICAgIGNhc2UgMTE4IDogcmV0dXJuIFwiXFx1MDAwYlwiOyAvLyBcXHZcbiAgICAgICAgICBjYXNlIDEwMiA6IHJldHVybiBcIlxcZlwiO1xuICAgICAgICAgIGNhc2UgNDggIDogcmV0dXJuIFwiXFwwXCI7XG4gICAgICAgICAgY2FzZSAxMjAgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoMikpOyAvLyBcXHhcbiAgICAgICAgICBjYXNlIDExNyA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleF9ieXRlcyg0KSk7IC8vIFxcdVxuICAgICAgICAgIGNhc2UgMTAgIDogcmV0dXJuIFwiXCI7IC8vIG5ld2xpbmVcbiAgICAgICAgICBkZWZhdWx0ICA6IHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoZXhfYnl0ZXMobikge1xuICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgZm9yICg7IG4gPiAwOyAtLW4pIHtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHBhcnNlSW50KG5leHQodHJ1ZSksIDE2KTtcbiAgICAgICAgICAgIGlmIChpc05hTihkaWdpdCkpXG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJJbnZhbGlkIGhleC1jaGFyYWN0ZXIgcGF0dGVybiBpbiBzdHJpbmdcIik7XG4gICAgICAgICAgICBudW0gPSAobnVtIDw8IDQpIHwgZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfc3RyaW5nID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBxdW90ZSA9IG5leHQoKSwgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlYWQgT2N0YWxFc2NhcGVTZXF1ZW5jZSAoWFhYOiBkZXByZWNhdGVkIGlmIFwic3RyaWN0IG1vZGVcIilcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8xNzhcbiAgICAgICAgICAgICAgICB2YXIgb2N0YWxfbGVuID0gMCwgZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF93aGlsZShmdW5jdGlvbihjaCl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPD0gXCIzXCIgJiYgb2N0YWxfbGVuIDw9IDIpIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID49IFwiNFwiICYmIG9jdGFsX2xlbiA8PSAxKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvY3RhbF9sZW4gPiAwKSBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY2gsIDgpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBxdW90ZSkgYnJlYWs7XG4gICAgICAgICAgICByZXQgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuKFwic3RyaW5nXCIsIHJldCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWFkX2xpbmVfY29tbWVudCgpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICB2YXIgaSA9IGZpbmQoXCJcXG5cIiksIHJldDtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHIoUy5wb3MpO1xuICAgICAgICAgICAgUy5wb3MgPSBTLnRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICBTLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuKFwiY29tbWVudDFcIiwgcmV0LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfbXVsdGlsaW5lX2NvbW1lbnQgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBtdWx0aWxpbmUgY29tbWVudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHZhciBpID0gZmluZChcIiovXCIsIHRydWUpO1xuICAgICAgICB2YXIgdGV4dCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICB2YXIgYSA9IHRleHQuc3BsaXQoXCJcXG5cIiksIG4gPSBhLmxlbmd0aDtcbiAgICAgICAgLy8gdXBkYXRlIHN0cmVhbSBwb3NpdGlvblxuICAgICAgICBTLnBvcyA9IGkgKyAyO1xuICAgICAgICBTLmxpbmUgKz0gbiAtIDE7XG4gICAgICAgIGlmIChuID4gMSkgUy5jb2wgPSBhW24gLSAxXS5sZW5ndGg7XG4gICAgICAgIGVsc2UgUy5jb2wgKz0gYVtuIC0gMV0ubGVuZ3RoO1xuICAgICAgICBTLmNvbCArPSAyO1xuICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPj0gMDtcbiAgICAgICAgcmV0dXJuIHRva2VuKFwiY29tbWVudDJcIiwgdGV4dCwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWFkX25hbWUoKSB7XG4gICAgICAgIHZhciBiYWNrc2xhc2ggPSBmYWxzZSwgbmFtZSA9IFwiXCIsIGNoLCBlc2NhcGVkID0gZmFsc2UsIGhleDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIGVzY2FwZWQgPSBiYWNrc2xhc2ggPSB0cnVlLCBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgbmFtZSArPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCAhPSBcInVcIikgcGFyc2VfZXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYXCIpO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHBhcnNlX2Vycm9yKFwiVW5pY29kZSBjaGFyOiBcIiArIGNoLmNoYXJDb2RlQXQoMCkgKyBcIiBpcyBub3QgdmFsaWQgaW4gaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgICAgICBuYW1lICs9IGNoO1xuICAgICAgICAgICAgICAgIGJhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChLRVlXT1JEUyhuYW1lKSAmJiBlc2NhcGVkKSB7XG4gICAgICAgICAgICBoZXggPSBuYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYW1lID0gXCJcXFxcdVwiICsgXCIwMDAwXCIuc3Vic3RyKGhleC5sZW5ndGgpICsgaGV4ICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfcmVnZXhwID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIsIGZ1bmN0aW9uKHJlZ2V4cCl7XG4gICAgICAgIHZhciBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlLCBjaCwgaW5fY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChjaCA9IG5leHQodHJ1ZSkpKSBpZiAocHJldl9iYWNrc2xhc2gpIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIltcIikge1xuICAgICAgICAgICAgaW5fY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiXVwiICYmIGluX2NsYXNzKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmICFpbl9jbGFzcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kcyA9IHJlYWRfbmFtZSgpO1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgbmV3IFJlZ0V4cChyZWdleHAsIG1vZHMpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfb3BlcmF0b3IocHJlZml4KSB7XG4gICAgICAgIGZ1bmN0aW9uIGdyb3cob3ApIHtcbiAgICAgICAgICAgIGlmICghcGVlaygpKSByZXR1cm4gb3A7XG4gICAgICAgICAgICB2YXIgYmlnZ2VyID0gb3AgKyBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoT1BFUkFUT1JTKGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJvcGVyYXRvclwiLCBncm93KHByZWZpeCB8fCBuZXh0KCkpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3NsYXNoKCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHZhciByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xuICAgICAgICBzd2l0Y2ggKHBlZWsoKSkge1xuICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZS5wdXNoKHJlYWRfbGluZV9jb21tZW50KCkpO1xuICAgICAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2gocmVhZF9tdWx0aWxpbmVfY29tbWVudCgpKTtcbiAgICAgICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTLnJlZ2V4X2FsbG93ZWQgPyByZWFkX3JlZ2V4cChcIlwiKSA6IHJlYWRfb3BlcmF0b3IoXCIvXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBpc19kaWdpdChwZWVrKCkuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgICAgID8gcmVhZF9udW0oXCIuXCIpXG4gICAgICAgICAgICA6IHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfd29yZCgpIHtcbiAgICAgICAgdmFyIHdvcmQgPSByZWFkX25hbWUoKTtcbiAgICAgICAgcmV0dXJuIEtFWVdPUkRTX0FUT00od29yZCkgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgIDogIUtFWVdPUkRTKHdvcmQpID8gdG9rZW4oXCJuYW1lXCIsIHdvcmQpXG4gICAgICAgICAgICA6IE9QRVJBVE9SUyh3b3JkKSA/IHRva2VuKFwib3BlcmF0b3JcIiwgd29yZClcbiAgICAgICAgICAgIDogdG9rZW4oXCJrZXl3b3JkXCIsIHdvcmQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX2VvZl9lcnJvcihlb2ZfZXJyb3IsIGNvbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoeCk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4ID09PSBFWF9FT0YpIHBhcnNlX2Vycm9yKGVvZl9lcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dF90b2tlbihmb3JjZV9yZWdleHApIHtcbiAgICAgICAgaWYgKGZvcmNlX3JlZ2V4cCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRfcmVnZXhwKGZvcmNlX3JlZ2V4cCk7XG4gICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICBzdGFydF90b2tlbigpO1xuICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgIGlmICghY2gpIHJldHVybiB0b2tlbihcImVvZlwiKTtcbiAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDM0OiBjYXNlIDM5OiByZXR1cm4gcmVhZF9zdHJpbmcoKTtcbiAgICAgICAgICBjYXNlIDQ2OiByZXR1cm4gaGFuZGxlX2RvdCgpO1xuICAgICAgICAgIGNhc2UgNDc6IHJldHVybiBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZGlnaXQoY29kZSkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICBpZiAoUFVOQ19DSEFSUyhjaCkpIHJldHVybiB0b2tlbihcInB1bmNcIiwgbmV4dCgpKTtcbiAgICAgICAgaWYgKE9QRVJBVE9SX0NIQVJTKGNoKSkgcmV0dXJuIHJlYWRfb3BlcmF0b3IoKTtcbiAgICAgICAgaWYgKGNvZGUgPT0gOTIgfHwgaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICBwYXJzZV9lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgIH07XG5cbiAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXh0X3Rva2VuO1xuXG59O1xuXG4vKiAtLS0tLVsgUGFyc2VyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgVU5BUllfUFJFRklYID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiLS1cIixcbiAgICBcIisrXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCItXCIsXG4gICAgXCIrXCJcbl0pO1xuXG52YXIgVU5BUllfUE9TVEZJWCA9IG1ha2VQcmVkaWNhdGUoWyBcIi0tXCIsIFwiKytcIiBdKTtcblxudmFyIEFTU0lHTk1FTlQgPSBtYWtlUHJlZGljYXRlKFsgXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIi89XCIsIFwiKj1cIiwgXCIlPVwiLCBcIj4+PVwiLCBcIjw8PVwiLCBcIj4+Pj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJj1cIiBdKTtcblxudmFyIFBSRUNFREVOQ0UgPSAoZnVuY3Rpb24oYSwgcmV0KXtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDE7IGkgPCBhLmxlbmd0aDsgKytpLCArK24pIHtcbiAgICAgICAgdmFyIGIgPSBhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtiW2pdXSA9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn0pKFxuICAgIFtcbiAgICAgICAgW1wifHxcIl0sXG4gICAgICAgIFtcIiYmXCJdLFxuICAgICAgICBbXCJ8XCJdLFxuICAgICAgICBbXCJeXCJdLFxuICAgICAgICBbXCImXCJdLFxuICAgICAgICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICAgICAgICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gICAgICAgIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gICAgICAgIFtcIitcIiwgXCItXCJdLFxuICAgICAgICBbXCIqXCIsIFwiL1wiLCBcIiVcIl1cbiAgICBdLFxuICAgIHt9XG4pO1xuXG52YXIgU1RBVEVNRU5UU19XSVRIX0xBQkVMUyA9IGFycmF5X3RvX2hhc2goWyBcImZvclwiLCBcImRvXCIsIFwid2hpbGVcIiwgXCJzd2l0Y2hcIiBdKTtcblxudmFyIEFUT01JQ19TVEFSVF9UT0tFTiA9IGFycmF5X3RvX2hhc2goWyBcImF0b21cIiwgXCJudW1cIiwgXCJzdHJpbmdcIiwgXCJyZWdleHBcIiwgXCJuYW1lXCIgXSk7XG5cbi8qIC0tLS0tWyBQYXJzZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIHBhcnNlKCRURVhULCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzdHJpY3QgICAgIDogZmFsc2UsXG4gICAgICAgIGZpbGVuYW1lICAgOiBudWxsLFxuICAgICAgICB0b3BsZXZlbCAgIDogbnVsbCxcbiAgICAgICAgZXhwcmVzc2lvbiA6IGZhbHNlXG4gICAgfSk7XG5cbiAgICB2YXIgUyA9IHtcbiAgICAgICAgaW5wdXQgICAgICAgICA6IHR5cGVvZiAkVEVYVCA9PSBcInN0cmluZ1wiID8gdG9rZW5pemVyKCRURVhULCBvcHRpb25zLmZpbGVuYW1lKSA6ICRURVhULFxuICAgICAgICB0b2tlbiAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHBlZWtlZCAgICAgICAgOiBudWxsLFxuICAgICAgICBpbl9mdW5jdGlvbiAgIDogMCxcbiAgICAgICAgaW5fZGlyZWN0aXZlcyA6IHRydWUsXG4gICAgICAgIGluX2xvb3AgICAgICAgOiAwLFxuICAgICAgICBsYWJlbHMgICAgICAgIDogW11cbiAgICB9O1xuXG4gICAgUy50b2tlbiA9IG5leHQoKTtcblxuICAgIGZ1bmN0aW9uIGlzKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc190b2tlbihTLnRva2VuLCB0eXBlLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpOyB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgUy5wcmV2ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKFMucGVla2VkKSB7XG4gICAgICAgICAgICBTLnRva2VuID0gUy5wZWVrZWQ7XG4gICAgICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXG4gICAgICAgICAgICBTLnRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICByZXR1cm4gUy5wcmV2O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcm9hayhtc2csIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgIHZhciBjdHggPSBTLmlucHV0LmNvbnRleHQoKTtcbiAgICAgICAganNfZXJyb3IobXNnLFxuICAgICAgICAgICAgICAgICBjdHguZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgIGxpbmUgIT0gbnVsbCA/IGxpbmUgOiBjdHgudG9rbGluZSxcbiAgICAgICAgICAgICAgICAgY29sICE9IG51bGwgPyBjb2wgOiBjdHgudG9rY29sLFxuICAgICAgICAgICAgICAgICBwb3MgIT0gbnVsbCA/IHBvcyA6IGN0eC50b2twb3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2tlbl9lcnJvcih0b2tlbiwgbXNnKSB7XG4gICAgICAgIGNyb2FrKG1zZywgdG9rZW4ubGluZSwgdG9rZW4uY29sKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgIHRva2VuID0gUy50b2tlbjtcbiAgICAgICAgdG9rZW5fZXJyb3IodG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbjogXCIgKyB0b2tlbi50eXBlICsgXCIgKFwiICsgdG9rZW4udmFsdWUgKyBcIilcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cGVjdF90b2tlbih0eXBlLCB2YWwpIHtcbiAgICAgICAgaWYgKGlzKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5fZXJyb3IoUy50b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgUy50b2tlbi50eXBlICsgXCIgwqtcIiArIFMudG9rZW4udmFsdWUgKyBcIsK7XCIgKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlICsgXCIgwqtcIiArIHZhbCArIFwiwrtcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIHB1bmMpOyB9O1xuXG4gICAgZnVuY3Rpb24gY2FuX2luc2VydF9zZW1pY29sb24oKSB7XG4gICAgICAgIHJldHVybiAhb3B0aW9ucy5zdHJpY3QgJiYgKFxuICAgICAgICAgICAgUy50b2tlbi5ubGIgfHwgaXMoXCJlb2ZcIikgfHwgaXMoXCJwdW5jXCIsIFwifVwiKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCI7XCIpKSBuZXh0KCk7XG4gICAgICAgIGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2lzZWQoKSB7XG4gICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgIHZhciBleHAgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbWJlZF90b2tlbnMocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlcigpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIGV4cHIuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGV4cHIuZW5kID0gZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZW1lbnQgPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0bXA7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiL1wiKSB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiLz1cIikpIHtcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChTLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB2YXIgZGlyID0gUy5pbl9kaXJlY3RpdmVzLCBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgLy8gWFhYdjI6IGRlY2lkZSBob3cgdG8gZml4IGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChkaXIgJiYgc3RhdC5ib2R5IGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiAhaXMoXCJwdW5jXCIsIFwiLFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EaXJlY3RpdmUoeyB2YWx1ZTogc3RhdC5ib2R5LnZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCI6XCIpXG4gICAgICAgICAgICAgICAgPyBsYWJlbGVkX3N0YXRlbWVudCgpXG4gICAgICAgICAgICAgICAgOiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICBjYXNlIFwicHVuY1wiOlxuICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmxvY2tTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgc3dpdGNoICh0bXAgPSBTLnRva2VuLnZhbHVlLCBuZXh0KCksIHRtcCkge1xuICAgICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChBU1RfQnJlYWspO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KEFTVF9Db250aW51ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImRlYnVnZ2VyXCI6XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZG9cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ebyh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogKGV4cGVjdF90b2tlbihcImtleXdvcmRcIiwgXCJ3aGlsZVwiKSwgdG1wID0gcGFyZW50aGVzaXNlZCgpLCBzZW1pY29sb24oKSwgdG1wKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1doaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKHN0YXRlbWVudClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcl8oKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fKHRydWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBpZl8oKTtcblxuICAgICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICAgICAgaWYgKFMuaW5fZnVuY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoIGlzKFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobmV4dCgpLCBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbl9pbnNlcnRfc2VtaWNvbG9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApIClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwic3dpdGNoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3dpdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHBhcmVudGhlc2lzZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGluX2xvb3Aoc3dpdGNoX2JvZHlfKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgICAgICAgIGlmIChTLnRva2VuLm5sYilcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgJ3Rocm93J1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9UaHJvdyh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAodG1wID0gZXhwcmVzc2lvbih0cnVlKSwgc2VtaWNvbG9uKCksIHRtcClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwidHJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeV8oKTtcblxuICAgICAgICAgICAgICBjYXNlIFwidmFyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcCA9IHZhcl8oKSwgc2VtaWNvbG9uKCksIHRtcDtcblxuICAgICAgICAgICAgICBjYXNlIFwiY29uc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wID0gY29uc3RfKCksIHNlbWljb2xvbigpLCB0bXA7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIndpdGhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9XaXRoKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHBhcmVudGhlc2lzZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IHN0YXRlbWVudCgpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxhYmVsZWRfc3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBhc19zeW1ib2woQVNUX0xhYmVsKTtcbiAgICAgICAgaWYgKGZpbmRfaWYoZnVuY3Rpb24obCl7IHJldHVybiBsLm5hbWUgPT0gbGFiZWwubmFtZSB9LCBTLmxhYmVscykpIHtcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyLCAxMi4xMjogQW4gRUNNQVNjcmlwdCBwcm9ncmFtIGlzIGNvbnNpZGVyZWRcbiAgICAgICAgICAgIC8vIHN5bnRhY3RpY2FsbHkgaW5jb3JyZWN0IGlmIGl0IGNvbnRhaW5zIGFcbiAgICAgICAgICAgIC8vIExhYmVsbGVkU3RhdGVtZW50IHRoYXQgaXMgZW5jbG9zZWQgYnkgYVxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgd2l0aCB0aGUgc2FtZSBJZGVudGlmaWVyIGFzIGxhYmVsLlxuICAgICAgICAgICAgY3JvYWsoXCJMYWJlbCBcIiArIGxhYmVsLm5hbWUgKyBcIiBkZWZpbmVkIHR3aWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgIFMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudCgpO1xuICAgICAgICBTLmxhYmVscy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfTGFiZWxlZFN0YXRlbWVudCh7IGJvZHk6IHN0YXQsIGxhYmVsOiBsYWJlbCB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2ltcGxlX3N0YXRlbWVudCh0bXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2ltcGxlU3RhdGVtZW50KHsgYm9keTogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBicmVha19jb250KHR5cGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcbiAgICAgICAgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGFzX3N5bWJvbChBU1RfTGFiZWxSZWYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWZpbmRfaWYoZnVuY3Rpb24obCl7IHJldHVybiBsLm5hbWUgPT0gbGFiZWwubmFtZSB9LCBTLmxhYmVscykpXG4gICAgICAgICAgICAgICAgY3JvYWsoXCJVbmRlZmluZWQgbGFiZWwgXCIgKyBsYWJlbC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTLmluX2xvb3AgPT0gMClcbiAgICAgICAgICAgIGNyb2FrKHR5cGUuVFlQRSArIFwiIG5vdCBpbnNpZGUgYSBsb29wIG9yIHN3aXRjaFwiKTtcbiAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZSh7IGxhYmVsOiBsYWJlbCB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yXygpIHtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgdmFyIGluaXQgPSBudWxsO1xuICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIjtcIikpIHtcbiAgICAgICAgICAgIGluaXQgPSBpcyhcImtleXdvcmRcIiwgXCJ2YXJcIilcbiAgICAgICAgICAgICAgICA/IChuZXh0KCksIHZhcl8odHJ1ZSkpXG4gICAgICAgICAgICAgICAgOiBleHByZXNzaW9uKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJpblwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgQVNUX1ZhciAmJiBpbml0LmRlZmluaXRpb25zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiT25seSBvbmUgdmFyaWFibGUgZGVjbGFyYXRpb24gYWxsb3dlZCBpbiBmb3IuLmluIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JfaW4oaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ3VsYXJfZm9yKGluaXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWd1bGFyX2Zvcihpbml0KSB7XG4gICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgIHZhciB0ZXN0ID0gaXMoXCJwdW5jXCIsIFwiO1wiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCI7XCIpO1xuICAgICAgICB2YXIgc3RlcCA9IGlzKFwicHVuY1wiLCBcIilcIikgPyBudWxsIDogZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRm9yKHtcbiAgICAgICAgICAgIGluaXQgICAgICA6IGluaXQsXG4gICAgICAgICAgICBjb25kaXRpb24gOiB0ZXN0LFxuICAgICAgICAgICAgc3RlcCAgICAgIDogc3RlcCxcbiAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yX2luKGluaXQpIHtcbiAgICAgICAgdmFyIGxocyA9IGluaXQgaW5zdGFuY2VvZiBBU1RfVmFyID8gaW5pdC5kZWZpbml0aW9uc1swXS5uYW1lIDogbnVsbDtcbiAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBuYW1lICAgOiBsaHMsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKHN0YXRlbWVudClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbihpbl9zdGF0ZW1lbnQsIGN0b3IpIHtcbiAgICAgICAgdmFyIGlzX2FjY2Vzc29yID0gY3RvciA9PT0gQVNUX0FjY2Vzc29yO1xuICAgICAgICB2YXIgbmFtZSA9IChpcyhcIm5hbWVcIikgPyBhc19zeW1ib2woaW5fc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBBU1RfU3ltYm9sRGVmdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGlzX2FjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBBU1RfU3ltYm9sQWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEFTVF9TeW1ib2xMYW1iZGEpXG4gICAgICAgICAgICAgICAgICAgIDogaXNfYWNjZXNzb3IgJiYgKGlzKFwic3RyaW5nXCIpIHx8IGlzKFwibnVtXCIpKSA/IGFzX2F0b21fbm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgIGlmIChpbl9zdGF0ZW1lbnQgJiYgIW5hbWUpXG4gICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgIGlmICghY3RvcikgY3RvciA9IGluX3N0YXRlbWVudCA/IEFTVF9EZWZ1biA6IEFTVF9GdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmduYW1lczogKGZ1bmN0aW9uKGZpcnN0LCBhKXtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChhc19zeW1ib2woQVNUX1N5bWJvbEZ1bmFyZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9KSh0cnVlLCBbXSksXG4gICAgICAgICAgICBib2R5OiAoZnVuY3Rpb24obG9vcCwgbGFiZWxzKXtcbiAgICAgICAgICAgICAgICArK1MuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICAgICAgICAgIFMubGFiZWxzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBibG9ja18oKTtcbiAgICAgICAgICAgICAgICAtLVMuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcbiAgICAgICAgICAgICAgICBTLmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0pKFMuaW5fbG9vcCwgUy5sYWJlbHMpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpZl8oKSB7XG4gICAgICAgIHZhciBjb25kID0gcGFyZW50aGVzaXNlZCgpLCBib2R5ID0gc3RhdGVtZW50KCksIGJlbHNlID0gbnVsbDtcbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImVsc2VcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJlbHNlID0gc3RhdGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfSWYoe1xuICAgICAgICAgICAgY29uZGl0aW9uICAgOiBjb25kLFxuICAgICAgICAgICAgYm9keSAgICAgICAgOiBib2R5LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBiZWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYmxvY2tfKCkge1xuICAgICAgICBleHBlY3QoXCJ7XCIpO1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgYS5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hfYm9keV8oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW10sIGN1ciA9IG51bGwsIGJyYW5jaCA9IG51bGwsIHRtcDtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXNlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0Nhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogKHRtcCA9IFMudG9rZW4sIG5leHQoKSwgdG1wKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHJlc3Npb24odHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBjdXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gbmV3IEFTVF9EZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiAodG1wID0gUy50b2tlbiwgbmV4dCgpLCBleHBlY3QoXCI6XCIpLCB0bXApLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGN1clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICBjdXIucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJ5XygpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBibG9ja18oKSwgYmNhdGNoID0gbnVsbCwgYmZpbmFsbHkgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2F0Y2hcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19zeW1ib2woQVNUX1N5bWJvbENhdGNoKTtcbiAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICBiY2F0Y2ggPSBuZXcgQVNUX0NhdGNoKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgYXJnbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgYm9keSAgICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmaW5hbGx5XCIpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYmZpbmFsbHkgPSBuZXcgQVNUX0ZpbmFsbHkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgYm9keSAgOiBibG9ja18oKSxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiY2F0Y2ggJiYgIWJmaW5hbGx5KVxuICAgICAgICAgICAgY3JvYWsoXCJNaXNzaW5nIGNhdGNoL2ZpbmFsbHkgYmxvY2tzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ucnkoe1xuICAgICAgICAgICAgYm9keSAgICAgOiBib2R5LFxuICAgICAgICAgICAgYmNhdGNoICAgOiBiY2F0Y2gsXG4gICAgICAgICAgICBiZmluYWxseSA6IGJmaW5hbGx5XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YXJkZWZzKG5vX2luLCBpbl9jb25zdCkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9WYXJEZWYoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgICAgICBuYW1lICA6IGFzX3N5bWJvbChpbl9jb25zdCA/IEFTVF9TeW1ib2xDb25zdCA6IEFTVF9TeW1ib2xWYXIpLFxuICAgICAgICAgICAgICAgIHZhbHVlIDogaXMoXCJvcGVyYXRvclwiLCBcIj1cIikgPyAobmV4dCgpLCBleHByZXNzaW9uKGZhbHNlLCBub19pbikpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICB2YXIgdmFyXyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Zhcih7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhub19pbiwgZmFsc2UpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjb25zdF8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uc3Qoe1xuICAgICAgICAgICAgc3RhcnQgICAgICAgOiBwcmV2KCksXG4gICAgICAgICAgICBkZWZpbml0aW9ucyA6IHZhcmRlZnMoZmFsc2UsIHRydWUpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdfID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGV4cGVjdF90b2tlbihcIm9wZXJhdG9yXCIsIFwibmV3XCIpO1xuICAgICAgICB2YXIgbmV3ZXhwID0gZXhwcl9hdG9tKGZhbHNlKSwgYXJncztcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGFyZ3MgPSBleHByX2xpc3QoXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfTmV3KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBuZXdleHAsXG4gICAgICAgICAgICBhcmdzICAgICAgIDogYXJncyxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSksIHRydWUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19hdG9tX25vZGUoKSB7XG4gICAgICAgIHZhciB0b2sgPSBTLnRva2VuLCByZXQ7XG4gICAgICAgIHN3aXRjaCAodG9rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGFzX3N5bWJvbChBU1RfU3ltYm9sUmVmKTtcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bWJlcih7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9TdHJpbmcoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHRvay52YWx1ZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfUmVnRXhwKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2ssIHZhbHVlOiB0b2sudmFsdWUgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgc3dpdGNoICh0b2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9GYWxzZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfVHJ1ZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfTnVsbCh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwcl9hdG9tID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJuZXdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgc3dpdGNoIChzdGFydC52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXggPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgZXguZW5kID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGV4LCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXJyYXlfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhvYmplY3RfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb25fKGZhbHNlKTtcbiAgICAgICAgICAgIGZ1bmMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGZ1bmMuZW5kID0gcHJldigpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZnVuYywgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBVE9NSUNfU1RBUlRfVE9LRU5bUy50b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXNfYXRvbV9ub2RlKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cHJfbGlzdChjbG9zaW5nLCBhbGxvd190cmFpbGluZ19jb21tYSwgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBjbG9zaW5nKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICBpZiAoYWxsb3dfdHJhaWxpbmdfY29tbWEgJiYgaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSBicmVhaztcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfSG9sZSh7IHN0YXJ0OiBTLnRva2VuLCBlbmQ6IFMudG9rZW4gfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHZhciBhcnJheV8gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChcIltcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0FycmF5KHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBleHByX2xpc3QoXCJdXCIsICFvcHRpb25zLnN0cmljdCwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JqZWN0XyA9IGVtYmVkX3Rva2VucyhmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpcyhcInB1bmNcIiwgXCJ9XCIpKVxuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIGNvbW1hXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBzdGFydC50eXBlO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hbWVcIiAmJiAhaXMoXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0R2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uXyhmYWxzZSwgQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0U2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uXyhmYWxzZSwgQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0KHsgcHJvcGVydGllczogYSB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFzX3Byb3BlcnR5X25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRtcC52YWx1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19zeW1ib2wodHlwZSwgbm9lcnJvcikge1xuICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCFub2Vycm9yKSBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgIHZhciBzeW0gPSBuZXcgKG5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpcyA6IHR5cGUpKHtcbiAgICAgICAgICAgIG5hbWUgIDogU3RyaW5nKFMudG9rZW4udmFsdWUpLFxuICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgZW5kICAgOiBTLnRva2VuXG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBzeW07XG4gICAgfTtcblxuICAgIHZhciBzdWJzY3JpcHRzID0gZnVuY3Rpb24oZXhwciwgYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXhwci5zdGFydDtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIi5cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfRG90KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IGFzX25hbWUoKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogcHJvcCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd19jYWxscyAmJiBpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBhcmdzICAgICAgIDogZXhwcl9saXN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIHZhciBtYXliZV91bmFyeSA9IGZ1bmN0aW9uKGFsbG93X2NhbGxzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BSRUZJWChzdGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBleCA9IG1ha2VfdW5hcnkoQVNUX1VuYXJ5UHJlZml4LCBzdGFydC52YWx1ZSwgbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpKTtcbiAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IGV4cHJfYXRvbShhbGxvd19jYWxscyk7XG4gICAgICAgIHdoaWxlIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BPU1RGSVgoUy50b2tlbi52YWx1ZSkgJiYgIVMudG9rZW4ubmxiKSB7XG4gICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVBvc3RmaXgsIFMudG9rZW4udmFsdWUsIHZhbCk7XG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkoY3Rvciwgb3AsIGV4cHIpIHtcbiAgICAgICAgaWYgKChvcCA9PSBcIisrXCIgfHwgb3AgPT0gXCItLVwiKSAmJiAhaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCB1c2Ugb2YgXCIgKyBvcCArIFwiIG9wZXJhdG9yXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IoeyBvcGVyYXRvcjogb3AsIGV4cHJlc3Npb246IGV4cHIgfSk7XG4gICAgfTtcblxuICAgIHZhciBleHByX29wID0gZnVuY3Rpb24obGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgaWYgKG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICB2YXIgcHJlYyA9IG9wICE9IG51bGwgPyBQUkVDRURFTkNFW29wXSA6IG51bGw7XG4gICAgICAgIGlmIChwcmVjICE9IG51bGwgJiYgcHJlYyA+IG1pbl9wcmVjKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCBwcmVjLCBub19pbik7XG4gICAgICAgICAgICByZXR1cm4gZXhwcl9vcChuZXcgQVNUX0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgOiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogcmlnaHQsXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiByaWdodC5lbmRcbiAgICAgICAgICAgIH0pLCBtaW5fcHJlYywgbm9faW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHByX29wcyhub19pbikge1xuICAgICAgICByZXR1cm4gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgMCwgbm9faW4pO1xuICAgIH07XG5cbiAgICB2YXIgbWF5YmVfY29uZGl0aW9uYWwgPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJfb3BzKG5vX2luKTtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uZGl0aW9uYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogeWVzLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogcGVlaygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfYXNzaWduYWJsZShleHByKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKTtcbiAgICB9O1xuXG4gICAgdmFyIG1heWJlX2Fzc2lnbiA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pLCB2YWwgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBBU1NJR05NRU5UKHZhbCkpIHtcbiAgICAgICAgICAgIGlmIChpc19hc3NpZ25hYmxlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogbWF5YmVfYXNzaWduKG5vX2luKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBhc3NpZ25tZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbW1hcywgbm9faW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGV4cHIgPSBtYXliZV9hc3NpZ24obm9faW4pO1xuICAgICAgICBpZiAoY29tbWFzICYmIGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1NlcSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY2FyICAgIDogZXhwcixcbiAgICAgICAgICAgICAgICBjZHIgICAgOiBleHByZXNzaW9uKHRydWUsIG5vX2luKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBwZWVrKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbl9sb29wKGNvbnQpIHtcbiAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIC0tUy5pbl9sb29wO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcImVvZlwiKSlcbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG4gICAgICAgIHZhciB0b3BsZXZlbCA9IG9wdGlvbnMudG9wbGV2ZWw7XG4gICAgICAgIGlmICh0b3BsZXZlbCkge1xuICAgICAgICAgICAgdG9wbGV2ZWwuYm9keSA9IHRvcGxldmVsLmJvZHkuY29uY2F0KGJvZHkpO1xuICAgICAgICAgICAgdG9wbGV2ZWwuZW5kID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSBuZXcgQVNUX1RvcGxldmVsKHsgc3RhcnQ6IHN0YXJ0LCBib2R5OiBib2R5LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wbGV2ZWw7XG4gICAgfSkoKTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gVHJlZSB0cmFuc2Zvcm1lciBoZWxwZXJzLlxuXG5mdW5jdGlvbiBUcmVlVHJhbnNmb3JtZXIoYmVmb3JlLCBhZnRlcikge1xuICAgIFRyZWVXYWxrZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmJlZm9yZSA9IGJlZm9yZTtcbiAgICB0aGlzLmFmdGVyID0gYWZ0ZXI7XG59XG5UcmVlVHJhbnNmb3JtZXIucHJvdG90eXBlID0gbmV3IFRyZWVXYWxrZXI7XG5cbihmdW5jdGlvbih1bmRlZmluZWQpe1xuXG4gICAgZnVuY3Rpb24gXyhub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKHR3LCBpbl9saXN0KXtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgdHcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0dy5iZWZvcmUpIHggPSB0dy5iZWZvcmUodGhpcywgZGVzY2VuZCwgaW5fbGlzdCk7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0dy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCh4LCB0dyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHcuc3RhY2tbdHcuc3RhY2subGVuZ3RoIC0gMV0gPSB4ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKHgsIHR3KTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHR3LmFmdGVyKHgsIGluX2xpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9fbGlzdChsaXN0LCB0dykge1xuICAgICAgICByZXR1cm4gTUFQKGxpc3QsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHJhbnNmb3JtKHR3LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIF8oQVNUX05vZGUsIG5vb3ApO1xuXG4gICAgXyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmxhYmVsID0gc2VsZi5sYWJlbC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EV0xvb3AsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBpZiAoc2VsZi5pbml0KSBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnN0ZXApIHNlbGYuc3RlcCA9IHNlbGYuc3RlcC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvckluLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuaW5pdCA9IHNlbGYuaW5pdC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLm9iamVjdCA9IHNlbGYub2JqZWN0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9FeGl0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTG9vcENvbnRyb2wsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgaWYgKHNlbGYubGFiZWwpIHNlbGYubGFiZWwgPSBzZWxmLmxhYmVsLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9UcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICAgICAgaWYgKHNlbGYuYmNhdGNoKSBzZWxmLmJjYXRjaCA9IHNlbGYuYmNhdGNoLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSBzZWxmLmJmaW5hbGx5ID0gc2VsZi5iZmluYWxseS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5hcmduYW1lID0gc2VsZi5hcmduYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmRlZmluaXRpb25zID0gZG9fbGlzdChzZWxmLmRlZmluaXRpb25zLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTGFtYmRhLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHNlbGYubmFtZSA9IHNlbGYubmFtZS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ25hbWVzID0gZG9fbGlzdChzZWxmLmFyZ25hbWVzLCB0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ3MgPSBkb19saXN0KHNlbGYuYXJncywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU2VxLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuY2FyID0gc2VsZi5jYXIudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRG90LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLnByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0eS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfVW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5sZWZ0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQXJyYXksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5lbGVtZW50cyA9IGRvX2xpc3Qoc2VsZi5lbGVtZW50cywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYucHJvcGVydGllcyA9IGRvX2xpc3Qoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBTeW1ib2xEZWYoc2NvcGUsIGluZGV4LCBvcmlnKSB7XG4gICAgdGhpcy5uYW1lID0gb3JpZy5uYW1lO1xuICAgIHRoaXMub3JpZyA9IFsgb3JpZyBdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gbnVsbDtcbiAgICB0aGlzLnVuZGVjbGFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxuU3ltYm9sRGVmLnByb3RvdHlwZSA9IHtcbiAgICB1bm1hbmdsZWFibGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdsb2JhbCAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy50b3BsZXZlbCkpXG4gICAgICAgICAgICB8fCB0aGlzLnVuZGVjbGFyZWRcbiAgICAgICAgICAgIHx8ICghKG9wdGlvbnMgJiYgb3B0aW9ucy5ldmFsKSAmJiAodGhpcy5zY29wZS51c2VzX2V2YWwgfHwgdGhpcy5zY29wZS51c2VzX3dpdGgpKTtcbiAgICB9LFxuICAgIG1hbmdsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMubWFuZ2xlZF9uYW1lICYmICF0aGlzLnVubWFuZ2xlYWJsZShvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGEgJiYgIW9wdGlvbnMuc2NyZXdfaWU4KVxuICAgICAgICAgICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICAgICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gcy5uZXh0X21hbmdsZWQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZmlndXJlX291dF9zY29wZVwiLCBmdW5jdGlvbigpe1xuICAgIC8vIFRoaXMgZG9lcyB3aGF0IGFzdF9hZGRfc2NvcGUgZGlkIGluIFVnbGlmeUpTIHYxLlxuICAgIC8vXG4gICAgLy8gUGFydCBvZiBpdCBjb3VsZCBiZSBkb25lIGF0IHBhcnNlIHRpbWUsIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlXG4gICAgLy8gdGhlIHBhcnNlciAoYW5kIGl0J3MgYWxyZWFkeSBraW5kYSBjb21wbGV4KS4gIEl0J3MgYWxzbyB3b3J0aFxuICAgIC8vIGhhdmluZyBpdCBzZXBhcmF0ZWQgYmVjYXVzZSB3ZSBtaWdodCBuZWVkIHRvIGNhbGwgaXQgbXVsdGlwbGVcbiAgICAvLyB0aW1lcyBvbiB0aGUgc2FtZSB0cmVlLlxuXG4gICAgLy8gcGFzcyAxOiBzZXR1cCBzY29wZSBjaGFpbmluZyBhbmQgaGFuZGxlIGRlZmluaXRpb25zXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY29wZSA9IHNlbGYucGFyZW50X3Njb3BlID0gbnVsbDtcbiAgICB2YXIgbGFiZWxzID0gbmV3IERpY3Rpb25hcnkoKTtcbiAgICB2YXIgbmVzdGluZyA9IDA7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCl7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLmluaXRfc2NvcGVfdmFycyhuZXN0aW5nKTtcbiAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gbm9kZS5wYXJlbnRfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHZhciBzYXZlX2xhYmVscyA9IGxhYmVscztcbiAgICAgICAgICAgICsrbmVzdGluZztcbiAgICAgICAgICAgIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgIGxhYmVscyA9IG5ldyBEaWN0aW9uYXJ5KCk7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBsYWJlbHMgPSBzYXZlX2xhYmVscztcbiAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgIC0tbmVzdGluZztcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgLy8gZG9uJ3QgZGVzY2VuZCBhZ2FpbiBpbiBUcmVlV2Fsa2VyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBub2RlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBwdXNoX3VuaXEoc2NvcGUuZGlyZWN0aXZlcywgbm9kZS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gc2NvcGU7IHM7IHMgPSBzLnBhcmVudF9zY29wZSlcbiAgICAgICAgICAgICAgICBzLnVzZXNfd2l0aCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSBub2RlLmxhYmVsO1xuICAgICAgICAgICAgaWYgKGxhYmVscy5oYXMobC5uYW1lKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiTGFiZWwge25hbWV9IGRlZmluZWQgdHdpY2VcIiwgbCkpO1xuICAgICAgICAgICAgbGFiZWxzLnNldChsLm5hbWUsIGwpO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgbGFiZWxzLmRlbChsLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAvLyBubyBkZXNjZW5kIGFnYWluXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICBub2RlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpIHtcbiAgICAgICAgICAgIG5vZGUudGhlZGVmID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUuaW5pdF9zY29wZV92YXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKSB7XG4gICAgICAgICAgICBzY29wZS5kZWZfZnVuY3Rpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1bikge1xuICAgICAgICAgICAgLy8gQ2FyZWZ1bCBoZXJlLCB0aGUgc2NvcGUgd2hlcmUgdGhpcyBzaG91bGQgYmUgZGVmaW5lZCBpc1xuICAgICAgICAgICAgLy8gdGhlIHBhcmVudCBzY29wZS4gIFRoZSByZWFzb24gaXMgdGhhdCB3ZSBlbnRlciBhIG5ld1xuICAgICAgICAgICAgLy8gc2NvcGUgd2hlbiB3ZSBlbmNvdW50ZXIgdGhlIEFTVF9EZWZ1biBub2RlICh3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zdGFuY2VvZiBBU1RfU2NvcGUpIGJ1dCB3ZSBnZXQgdG8gdGhlIHN5bWJvbCBhIGJpdFxuICAgICAgICAgICAgLy8gbGF0ZXIuXG4gICAgICAgICAgICAobm9kZS5zY29wZSA9IHNjb3BlLnBhcmVudF9zY29wZSkuZGVmX2Z1bmN0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sVmFyXG4gICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBzY29wZS5kZWZfdmFyaWFibGUobm9kZSk7XG4gICAgICAgICAgICBkZWYuY29uc3RhbnQgPSBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0O1xuICAgICAgICAgICAgZGVmLmluaXQgPSB0dy5wYXJlbnQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAvLyBYWFg6IHRoaXMgaXMgd3JvbmcgYWNjb3JkaW5nIHRvIEVDTUEtMjYyICgxMi40KS4gIHRoZVxuICAgICAgICAgICAgLy8gYGNhdGNoYCBhcmd1bWVudCBuYW1lIHNob3VsZCBiZSB2aXNpYmxlIG9ubHkgaW5zaWRlIHRoZVxuICAgICAgICAgICAgLy8gY2F0Y2ggYmxvY2suICBGb3IgYSBxdWljayBmaXggQVNUX0NhdGNoIHNob3VsZCBpbmhlcml0XG4gICAgICAgICAgICAvLyBmcm9tIEFTVF9TY29wZS4gIEtlZXBpbmcgaXQgdGhpcyB3YXkgYmVjYXVzZSBvZiBJRSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXNuJ3Qgb2JleSB0aGUgc3RhbmRhcmQuIChpdCBpbnRyb2R1Y2VzIHRoZVxuICAgICAgICAgICAgLy8gaWRlbnRpZmllciBpbiB0aGUgZW5jbG9zaW5nIHNjb3BlKVxuICAgICAgICAgICAgc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsUmVmKSB7XG4gICAgICAgICAgICB2YXIgc3ltID0gbGFiZWxzLmdldChub2RlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzeW0pIHRocm93IG5ldyBFcnJvcihzdHJpbmdfdGVtcGxhdGUoXCJVbmRlZmluZWQgbGFiZWwge25hbWV9IFt7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5vZGUudGhlZGVmID0gc3ltO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZi53YWxrKHR3KTtcblxuICAgIC8vIHBhc3MgMjogZmluZCBiYWNrIHJlZmVyZW5jZXMgYW5kIGV2YWxcbiAgICB2YXIgZnVuYyA9IG51bGw7XG4gICAgdmFyIGdsb2JhbHMgPSBzZWxmLmdsb2JhbHMgPSBuZXcgRGljdGlvbmFyeSgpO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2X2Z1bmMgPSBmdW5jO1xuICAgICAgICAgICAgZnVuYyA9IG5vZGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBmdW5jID0gcHJldl9mdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxSZWYpIHtcbiAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgdmFyIHN5bSA9IG5vZGUuc2NvcGUuZmluZF92YXJpYWJsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICghc3ltKSB7XG4gICAgICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSBnbG9iYWxzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnID0gbmV3IFN5bWJvbERlZihzZWxmLCBnbG9iYWxzLnNpemUoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGcudW5kZWNsYXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGcuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFscy5zZXQobmFtZSwgZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gZztcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcImV2YWxcIiAmJiB0dy5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBub2RlLnNjb3BlOyBzICYmICFzLnVzZXNfZXZhbDsgcyA9IHMucGFyZW50X3Njb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcy51c2VzX2V2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMudXNlc19hcmd1bWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBzeW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxmLndhbGsodHcpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJpbml0X3Njb3BlX3ZhcnNcIiwgZnVuY3Rpb24obmVzdGluZyl7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gW107ICAgICAvLyBjb250YWlucyB0aGUgZGlyZWN0aXZlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGUsIGkuZS4gXCJ1c2Ugc3RyaWN0XCJcbiAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBEaWN0aW9uYXJ5KCk7IC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xWYXIgKHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGU7IGluY2x1ZGVzIGZ1bmN0aW9ucylcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG5ldyBEaWN0aW9uYXJ5KCk7IC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xEZWZ1biAoZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBzY29wZSlcbiAgICB0aGlzLnVzZXNfd2l0aCA9IGZhbHNlOyAgIC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhpcyBvciBzb21lIG5lc3RlZCBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XG4gICAgdGhpcy51c2VzX2V2YWwgPSBmYWxzZTsgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3IgbmVzdGVkIHNjb3BlIHVzZXMgdGhlIGdsb2JhbCBgZXZhbGBcbiAgICB0aGlzLnBhcmVudF9zY29wZSA9IG51bGw7IC8vIHRoZSBwYXJlbnQgc2NvcGVcbiAgICB0aGlzLmVuY2xvc2VkID0gW107ICAgICAgIC8vIGEgbGlzdCBvZiB2YXJpYWJsZXMgZnJvbSB0aGlzIG9yIG91dGVyIHNjb3BlKHMpIHRoYXQgYXJlIHJlZmVyZW5jZWQgZnJvbSB0aGlzIG9yIGlubmVyIHNjb3Blc1xuICAgIHRoaXMuY25hbWUgPSAtMTsgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgaW5kZXggZm9yIG1hbmdsaW5nIGZ1bmN0aW9ucy92YXJpYWJsZXNcbiAgICB0aGlzLm5lc3RpbmcgPSBuZXN0aW5nOyAgIC8vIHRoZSBuZXN0aW5nIGxldmVsIG9mIHRoaXMgc2NvcGUgKDAgbWVhbnMgdG9wbGV2ZWwpXG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcInN0cmljdFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xufSk7XG5cbkFTVF9MYW1iZGEuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKCl7XG4gICAgQVNUX1Njb3BlLnByb3RvdHlwZS5pbml0X3Njb3BlX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnVzZXNfYXJndW1lbnRzID0gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbFJlZi5ERUZNRVRIT0QoXCJyZWZlcmVuY2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZGVmaW5pdGlvbigpO1xuICAgIGRlZi5yZWZlcmVuY2VzLnB1c2godGhpcyk7XG4gICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgIHdoaWxlIChzKSB7XG4gICAgICAgIHB1c2hfdW5pcShzLmVuY2xvc2VkLCBkZWYpO1xuICAgICAgICBpZiAocyA9PT0gZGVmLnNjb3BlKSBicmVhaztcbiAgICAgICAgcyA9IHMucGFyZW50X3Njb3BlO1xuICAgIH1cbiAgICB0aGlzLmZyYW1lID0gdGhpcy5zY29wZS5uZXN0aW5nIC0gZGVmLnNjb3BlLm5lc3Rpbmc7XG59KTtcblxuQVNUX0xhYmVsLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLCBmdW5jdGlvbigpe1xuICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xufSk7XG5cbkFTVF9MYWJlbFJlZi5ERUZNRVRIT0QoXCJyZWZlcmVuY2VcIiwgZnVuY3Rpb24oKXtcbiAgICB0aGlzLnRoZWRlZi5yZWZlcmVuY2VzLnB1c2godGhpcyk7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImZpbmRfdmFyaWFibGVcIiwgZnVuY3Rpb24obmFtZSl7XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBuYW1lID0gbmFtZS5uYW1lO1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmZpbmRfdmFyaWFibGUobmFtZSkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJoYXNfZGlyZWN0aXZlXCIsIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRfc2NvcGUgJiYgdGhpcy5wYXJlbnRfc2NvcGUuaGFzX2RpcmVjdGl2ZSh2YWx1ZSlcbiAgICAgICAgfHwgKHRoaXMuZGlyZWN0aXZlcy5pbmRleE9mKHZhbHVlKSA+PSAwID8gdGhpcyA6IG51bGwpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfZnVuY3Rpb25cIiwgZnVuY3Rpb24oc3ltYm9sKXtcbiAgICB0aGlzLmZ1bmN0aW9ucy5zZXQoc3ltYm9sLm5hbWUsIHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfdmFyaWFibGVcIiwgZnVuY3Rpb24oc3ltYm9sKXtcbiAgICB2YXIgZGVmO1xuICAgIGlmICghdGhpcy52YXJpYWJsZXMuaGFzKHN5bWJvbC5uYW1lKSkge1xuICAgICAgICBkZWYgPSBuZXcgU3ltYm9sRGVmKHRoaXMsIHRoaXMudmFyaWFibGVzLnNpemUoKSwgc3ltYm9sKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KHN5bWJvbC5uYW1lLCBkZWYpO1xuICAgICAgICBkZWYuZ2xvYmFsID0gIXRoaXMucGFyZW50X3Njb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZiA9IHRoaXMudmFyaWFibGVzLmdldChzeW1ib2wubmFtZSk7XG4gICAgICAgIGRlZi5vcmlnLnB1c2goc3ltYm9sKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbC50aGVkZWYgPSBkZWY7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcIm5leHRfbWFuZ2xlZFwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICB2YXIgZXh0ID0gdGhpcy5lbmNsb3NlZDtcbiAgICBvdXQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBtID0gYmFzZTU0KCsrdGhpcy5jbmFtZSk7XG4gICAgICAgIGlmICghaXNfaWRlbnRpZmllcihtKSkgY29udGludWU7IC8vIHNraXAgb3ZlciBcImRvXCJcbiAgICAgICAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbWFuZ2xlZCBuYW1lIGRvZXMgbm90IHNoYWRvdyBhIG5hbWVcbiAgICAgICAgLy8gZnJvbSBzb21lIHBhcmVudCBzY29wZSB0aGF0IGlzIHJlZmVyZW5jZWQgaW4gdGhpcyBvciBpblxuICAgICAgICAvLyBpbm5lciBzY29wZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSBleHQubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBzeW0gPSBleHRbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHN5bS5tYW5nbGVkX25hbWUgfHwgKHN5bS51bm1hbmdsZWFibGUob3B0aW9ucykgJiYgc3ltLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG0gPT0gbmFtZSkgY29udGludWUgb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwicmVmZXJlbmNlc1wiLCBmdW5jdGlvbihzeW0pe1xuICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBzeW0gPSBzeW0uZGVmaW5pdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmVuY2xvc2VkLmluZGV4T2Yoc3ltKSA8IDAgPyBudWxsIDogc3ltO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24oKS51bm1hbmdsZWFibGUob3B0aW9ucyk7XG59KTtcblxuLy8gcHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgbWFuZ2xlYWJsZVxuQVNUX1N5bWJvbEFjY2Vzc29yLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbi8vIGxhYmVscyBhcmUgYWx3YXlzIG1hbmdsZWFibGVcbkFTVF9MYWJlbC5ERUZNRVRIT0QoXCJ1bm1hbmdsZWFibGVcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJ1bnJlZmVyZW5jZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5sZW5ndGggPT0gMFxuICAgICAgICAmJiAhKHRoaXMuc2NvcGUudXNlc19ldmFsIHx8IHRoaXMuc2NvcGUudXNlc193aXRoKTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVuZGVjbGFyZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkudW5kZWNsYXJlZDtcbn0pO1xuXG5BU1RfTGFiZWxSZWYuREVGTUVUSE9EKFwidW5kZWNsYXJlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG5BU1RfTGFiZWwuREVGTUVUSE9EKFwidW5kZWNsYXJlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcImRlZmluaXRpb25cIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy50aGVkZWY7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJnbG9iYWxcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkuZ2xvYmFsO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJfZGVmYXVsdF9tYW5nbGVyX29wdGlvbnNcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgcmV0dXJuIGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZXhjZXB0ICAgOiBbXSxcbiAgICAgICAgZXZhbCAgICAgOiBmYWxzZSxcbiAgICAgICAgc29ydCAgICAgOiBmYWxzZSxcbiAgICAgICAgdG9wbGV2ZWwgOiBmYWxzZSxcbiAgICAgICAgc2NyZXdfaWU4IDogZmFsc2VcbiAgICB9KTtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwibWFuZ2xlX25hbWVzXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKTtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gbWFuZ2xlIGRlY2xhcmF0aW9uIG5vZGVzLiAgU3BlY2lhbCBsb2dpYyB3aXJlZFxuICAgIC8vIGludG8gdGhlIGNvZGUgZ2VuZXJhdG9yIHdpbGwgZGlzcGxheSB0aGUgbWFuZ2xlZCBuYW1lIGlmIGl0J3NcbiAgICAvLyBwcmVzZW50IChhbmQgZm9yIEFTVF9TeW1ib2xSZWYtcyBpdCdsbCB1c2UgdGhlIG1hbmdsZWQgbmFtZSBvZlxuICAgIC8vIHRoZSBBU1RfU3ltYm9sRGVjbGFyYXRpb24gdGhhdCBpdCBwb2ludHMgdG8pLlxuICAgIHZhciBsbmFtZSA9IC0xO1xuICAgIHZhciB0b19tYW5nbGUgPSBbXTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkge1xuICAgICAgICAgICAgLy8gbG5hbWUgaXMgaW5jcmVtZW50ZWQgd2hlbiB3ZSBnZXQgdG8gdGhlIEFTVF9MYWJlbFxuICAgICAgICAgICAgdmFyIHNhdmVfbmVzdGluZyA9IGxuYW1lO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgbG5hbWUgPSBzYXZlX25lc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgIC8vIGRvbid0IGRlc2NlbmQgYWdhaW4gaW4gVHJlZVdhbGtlclxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHR3LnBhcmVudCgpLCBhID0gW107XG4gICAgICAgICAgICBub2RlLnZhcmlhYmxlcy5lYWNoKGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhjZXB0LmluZGV4T2Yoc3ltYm9sLm5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQpIGEuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5yZWZlcmVuY2VzLmxlbmd0aCAtIGEucmVmZXJlbmNlcy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvX21hbmdsZS5wdXNoLmFwcGx5KHRvX21hbmdsZSwgYSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgZG8gbmFtZSA9IGJhc2U1NCgrK2xuYW1lKTsgd2hpbGUgKCFpc19pZGVudGlmaWVyKG5hbWUpKTtcbiAgICAgICAgICAgIG5vZGUubWFuZ2xlZF9uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrKHR3KTtcbiAgICB0b19tYW5nbGUuZm9yRWFjaChmdW5jdGlvbihkZWYpeyBkZWYubWFuZ2xlKG9wdGlvbnMpIH0pO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJjb21wdXRlX2NoYXJfZnJlcXVlbmN5XCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSB0aGlzLl9kZWZhdWx0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5wcmludF90b19zdHJpbmcoKSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwicmV0dXJuXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Rocm93KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwidGhyb3dcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29udGludWUpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjb250aW51ZVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhaylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImJyZWFrXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlYnVnZ2VyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZGVidWdnZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUudmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1doaWxlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwid2hpbGVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG8pXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJkbyB3aGlsZVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiaWZcIik7XG4gICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGl2ZSkgYmFzZTU0LmNvbnNpZGVyKFwiZWxzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1ZhcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInZhclwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Db25zdClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImNvbnN0XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZ1bmN0aW9uXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZvclwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3JJbilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZvciBpblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJzd2l0Y2hcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FzZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImNhc2VcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImRlZmF1bHRcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfV2l0aClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcIndpdGhcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0U2V0dGVyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwic2V0XCIgKyBub2RlLmtleSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0R2V0dGVyKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZ2V0XCIgKyBub2RlLmtleSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUua2V5KTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9OZXcpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJuZXdcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInRoaXNcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ5KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwidHJ5XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NhdGNoKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiY2F0Y2hcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRmluYWxseSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImZpbmFsbHlcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sICYmIG5vZGUudW5tYW5nbGVhYmxlKG9wdGlvbnMpKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUubmFtZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnkgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5vcGVyYXRvcik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG90KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUucHJvcGVydHkpO1xuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG4gICAgYmFzZTU0LnNvcnQoKTtcbn0pO1xuXG52YXIgYmFzZTU0ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXzAxMjM0NTY3ODlcIjtcbiAgICB2YXIgY2hhcnMsIGZyZXF1ZW5jeTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgZnJlcXVlbmN5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY2hhcnMgPSBzdHJpbmcuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGNoKXsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgfSk7XG4gICAgICAgIGNoYXJzLmZvckVhY2goZnVuY3Rpb24oY2gpeyBmcmVxdWVuY3lbY2hdID0gMCB9KTtcbiAgICB9XG4gICAgYmFzZTU0LmNvbnNpZGVyID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlIGluIGZyZXF1ZW5jeSkgKytmcmVxdWVuY3lbY29kZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGJhc2U1NC5zb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNoYXJzID0gbWVyZ2VTb3J0KGNoYXJzLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgIGlmIChpc19kaWdpdChhKSAmJiAhaXNfZGlnaXQoYikpIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGlzX2RpZ2l0KGIpICYmICFpc19kaWdpdChhKSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIGZyZXF1ZW5jeVtiXSAtIGZyZXF1ZW5jeVthXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBiYXNlNTQucmVzZXQgPSByZXNldDtcbiAgICByZXNldCgpO1xuICAgIGJhc2U1NC5nZXQgPSBmdW5jdGlvbigpeyByZXR1cm4gY2hhcnMgfTtcbiAgICBiYXNlNTQuZnJlcSA9IGZ1bmN0aW9uKCl7IHJldHVybiBmcmVxdWVuY3kgfTtcbiAgICBmdW5jdGlvbiBiYXNlNTQobnVtKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBiYXNlID0gNTQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJzW251bSAlIGJhc2VdKTtcbiAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gYmFzZSk7XG4gICAgICAgICAgICBiYXNlID0gNjQ7XG4gICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgcmV0dXJuIGJhc2U1NDtcbn0pKCk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJzY29wZV93YXJuaW5nc1wiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICB1bmRlY2xhcmVkICAgICAgIDogZmFsc2UsIC8vIHRoaXMgbWFrZXMgYSBsb3Qgb2Ygbm9pc2VcbiAgICAgICAgdW5yZWZlcmVuY2VkICAgICA6IHRydWUsXG4gICAgICAgIGFzc2lnbl90b19nbG9iYWwgOiB0cnVlLFxuICAgICAgICBmdW5jX2FyZ3VtZW50cyAgIDogdHJ1ZSxcbiAgICAgICAgbmVzdGVkX2RlZnVucyAgICA6IHRydWUsXG4gICAgICAgIGV2YWwgICAgICAgICAgICAgOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIGlmIChvcHRpb25zLnVuZGVjbGFyZWRcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBub2RlLnVuZGVjbGFyZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gWFhYOiB0aGlzIGFsc28gd2FybnMgYWJvdXQgSlMgc3RhbmRhcmQgbmFtZXMsXG4gICAgICAgICAgICAvLyBpLmUuIE9iamVjdCwgQXJyYXksIHBhcnNlSW50IGV0Yy4gIFNob3VsZCBhZGQgYSBsaXN0IG9mXG4gICAgICAgICAgICAvLyBleGNlcHRpb25zLlxuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIlVuZGVjbGFyZWQgc3ltYm9sOiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ25fdG9fZ2xvYmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3ltID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiBub2RlLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgIHN5bSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgbm9kZS5pbml0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICBzeW0gPSBub2RlLmluaXQ7XG4gICAgICAgICAgICBpZiAoc3ltXG4gICAgICAgICAgICAgICAgJiYgKHN5bS51bmRlY2xhcmVkKClcbiAgICAgICAgICAgICAgICAgICAgfHwgKHN5bS5nbG9iYWwoKSAmJiBzeW0uc2NvcGUgIT09IHN5bS5kZWZpbml0aW9uKCkuc2NvcGUpKSkge1xuICAgICAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJ7bXNnfToge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogc3ltLnVuZGVjbGFyZWQoKSA/IFwiQWNjaWRlbnRhbCBnbG9iYWw/XCIgOiBcIkFzc2lnbm1lbnQgdG8gZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiBzeW0uc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3ltLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogc3ltLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV2YWxcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBub2RlLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgJiYgbm9kZS5uYW1lID09IFwiZXZhbFwiKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiRXZhbCBpcyB1c2VkIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy51bnJlZmVyZW5jZWRcbiAgICAgICAgICAgICYmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpXG4gICAgICAgICAgICAmJiBub2RlLnVucmVmZXJlbmNlZCgpKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwie3R5cGV9IHtuYW1lfSBpcyBkZWNsYXJlZCBidXQgbm90IHJlZmVyZW5jZWQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsID8gXCJMYWJlbFwiIDogXCJTeW1ib2xcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mdW5jX2FyZ3VtZW50c1xuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICYmIG5vZGUudXNlc19hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJhcmd1bWVudHMgdXNlZCBpbiBmdW5jdGlvbiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUgPyBub2RlLm5hbWUubmFtZSA6IFwiYW5vbnltb3VzXCIsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5uZXN0ZWRfZGVmdW5zXG4gICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuXG4gICAgICAgICAgICAmJiAhKHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1Njb3BlKSkge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIkZ1bmN0aW9uIHtuYW1lfSBkZWNsYXJlZCBpbiBuZXN0ZWQgc3RhdGVtZW50IFxcXCJ7dHlwZX1cXFwiIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHcucGFyZW50KCkuVFlQRSxcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrKHR3KTtcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBPdXRwdXRTdHJlYW0ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgaW5kZW50X3N0YXJ0ICA6IDAsXG4gICAgICAgIGluZGVudF9sZXZlbCAgOiA0LFxuICAgICAgICBxdW90ZV9rZXlzICAgIDogZmFsc2UsXG4gICAgICAgIHNwYWNlX2NvbG9uICAgOiB0cnVlLFxuICAgICAgICBhc2NpaV9vbmx5ICAgIDogZmFsc2UsXG4gICAgICAgIGlubGluZV9zY3JpcHQgOiBmYWxzZSxcbiAgICAgICAgd2lkdGggICAgICAgICA6IDgwLFxuICAgICAgICBtYXhfbGluZV9sZW4gIDogMzIwMDAsXG4gICAgICAgIGJlYXV0aWZ5ICAgICAgOiBmYWxzZSxcbiAgICAgICAgc291cmNlX21hcCAgICA6IG51bGwsXG4gICAgICAgIGJyYWNrZXRpemUgICAgOiBmYWxzZSxcbiAgICAgICAgc2VtaWNvbG9ucyAgICA6IHRydWUsXG4gICAgICAgIGNvbW1lbnRzICAgICAgOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVfbGluZSA6IGZhbHNlLFxuICAgICAgICBzY3Jld19pZTggICAgIDogZmFsc2UsXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5kZW50YXRpb24gPSAwO1xuICAgIHZhciBjdXJyZW50X2NvbCA9IDA7XG4gICAgdmFyIGN1cnJlbnRfbGluZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRfcG9zID0gMDtcbiAgICB2YXIgT1VUUFVUID0gXCJcIjtcblxuICAgIGZ1bmN0aW9uIHRvX2FzY2lpKHN0ciwgaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHUwMDgwLVxcdWZmZmZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoIDw9IDIgJiYgIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCAyKSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx4XCIgKyBjb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCA0KSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9zdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBkcSA9IDAsIHNxID0gMDtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXFxcXFxiXFxmXFxuXFxyXFx0XFx4MjJcXHgyN1xcdTIwMjhcXHUyMDI5XFwwXS9nLCBmdW5jdGlvbihzKXtcbiAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxiXCI6IHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXGZcIjogcmV0dXJuIFwiXFxcXGZcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6IHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOiByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgICAgY2FzZSAnXCInOiArK2RxOyByZXR1cm4gJ1wiJztcbiAgICAgICAgICAgICAgY2FzZSBcIidcIjogKytzcTsgcmV0dXJuIFwiJ1wiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFwwXCI6IHJldHVybiBcIlxcXFx4MDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNjaWlfb25seSkgc3RyID0gdG9fYXNjaWkoc3RyKTtcbiAgICAgICAgaWYgKGRxID4gc3EpIHJldHVybiBcIidcIiArIHN0ci5yZXBsYWNlKC9cXHgyNy9nLCBcIlxcXFwnXCIpICsgXCInXCI7XG4gICAgICAgIGVsc2UgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgvXFx4MjIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5jb2RlX3N0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHJldCA9IG1ha2Vfc3RyaW5nKHN0cik7XG4gICAgICAgIGlmIChvcHRpb25zLmlubGluZV9zY3JpcHQpXG4gICAgICAgICAgICByZXQgPSByZXQucmVwbGFjZSgvPFxceDJmc2NyaXB0KFs+XFwvXFx0XFxuXFxmXFxyIF0pL2dpLCBcIjxcXFxcL3NjcmlwdCQxXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX25hbWUobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICBpZiAob3B0aW9ucy5hc2NpaV9vbmx5KVxuICAgICAgICAgICAgbmFtZSA9IHRvX2FzY2lpKG5hbWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9pbmRlbnQoYmFjaykge1xuICAgICAgICByZXR1cm4gcmVwZWF0X3N0cmluZyhcIiBcIiwgb3B0aW9ucy5pbmRlbnRfc3RhcnQgKyBpbmRlbnRhdGlvbiAtIGJhY2sgKiBvcHRpb25zLmluZGVudF9sZXZlbCk7XG4gICAgfTtcblxuICAgIC8qIC0tLS0tWyBiZWF1dGlmaWNhdGlvbi9taW5pZmljYXRpb24gXS0tLS0tICovXG5cbiAgICB2YXIgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgIHZhciBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgIHZhciBsYXN0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGxhc3RfY2hhcigpIHtcbiAgICAgICAgcmV0dXJuIGxhc3QuY2hhckF0KGxhc3QubGVuZ3RoIC0gMSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlX25ld2xpbmUoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1heF9saW5lX2xlbiAmJiBjdXJyZW50X2NvbCA+IG9wdGlvbnMubWF4X2xpbmVfbGVuKVxuICAgICAgICAgICAgcHJpbnQoXCJcXG5cIik7XG4gICAgfTtcblxuICAgIHZhciByZXF1aXJlU2VtaWNvbG9uQ2hhcnMgPSBtYWtlUHJlZGljYXRlKFwiKCBbICsgKiAvIC0gLCAuXCIpO1xuXG4gICAgZnVuY3Rpb24gcHJpbnQoc3RyKSB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckF0KDApO1xuICAgICAgICBpZiAobWlnaHRfbmVlZF9zZW1pY29sb24pIHtcbiAgICAgICAgICAgIGlmICgoIWNoIHx8IFwiO31cIi5pbmRleE9mKGNoKSA8IDApICYmICEvWztdJC8udGVzdChsYXN0KSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNlbWljb2xvbnMgfHwgcmVxdWlyZVNlbWljb2xvbkNoYXJzKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSsrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5iZWF1dGlmeSlcbiAgICAgICAgICAgICAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG1heWJlX25ld2xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iZWF1dGlmeSAmJiBvcHRpb25zLnByZXNlcnZlX2xpbmUgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRfbGluZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudF9saW5lIDwgdGFyZ2V0X2xpbmUpIHtcbiAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sID0gMDtcbiAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWlnaHRfbmVlZF9zcGFjZSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBsYXN0X2NoYXIoKTtcbiAgICAgICAgICAgIGlmICgoaXNfaWRlbnRpZmllcl9jaGFyKHByZXYpXG4gICAgICAgICAgICAgICAgICYmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpIHx8IGNoID09IFwiXFxcXFwiKSlcbiAgICAgICAgICAgICAgICB8fCAoL15bXFwrXFwtXFwvXSQvLnRlc3QoY2gpICYmIGNoID09IHByZXYpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBzdHIuc3BsaXQoL1xccj9cXG4vKSwgbiA9IGEubGVuZ3RoIC0gMTtcbiAgICAgICAgY3VycmVudF9saW5lICs9IG47XG4gICAgICAgIGlmIChuID09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRfY29sICs9IGFbbl0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudF9jb2wgPSBhW25dLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50X3BvcyArPSBzdHIubGVuZ3RoO1xuICAgICAgICBsYXN0ID0gc3RyO1xuICAgICAgICBPVVRQVVQgKz0gc3RyO1xuICAgIH07XG5cbiAgICB2YXIgc3BhY2UgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiIFwiKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZW50ID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKGhhbGYpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVhdXRpZnkpIHtcbiAgICAgICAgICAgIHByaW50KG1ha2VfaW5kZW50KGhhbGYgPyAwLjUgOiAwKSk7XG4gICAgICAgIH1cbiAgICB9IDogbm9vcDtcblxuICAgIHZhciB3aXRoX2luZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihjb2wsIGNvbnQpIHtcbiAgICAgICAgaWYgKGNvbCA9PT0gdHJ1ZSkgY29sID0gbmV4dF9pbmRlbnQoKTtcbiAgICAgICAgdmFyIHNhdmVfaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgaW5kZW50YXRpb24gPSBjb2w7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIGluZGVudGF0aW9uID0gc2F2ZV9pbmRlbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9IDogZnVuY3Rpb24oY29sLCBjb250KSB7IHJldHVybiBjb250KCkgfTtcblxuICAgIHZhciBuZXdsaW5lID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICB9IDogbm9vcDtcblxuICAgIHZhciBzZW1pY29sb24gPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiO1wiKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yY2Vfc2VtaWNvbG9uKCkge1xuICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICBwcmludChcIjtcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5leHRfaW5kZW50KCkge1xuICAgICAgICByZXR1cm4gaW5kZW50YXRpb24gKyBvcHRpb25zLmluZGVudF9sZXZlbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2l0aF9ibG9jayhjb250KSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHByaW50KFwie1wiKTtcbiAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB3aXRoX2luZGVudChuZXh0X2luZGVudCgpLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0ID0gY29udCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgICAgIHByaW50KFwifVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2l0aF9wYXJlbnMoY29udCkge1xuICAgICAgICBwcmludChcIihcIik7XG4gICAgICAgIC8vWFhYOiBzdGlsbCBuaWNlIHRvIGhhdmUgdGhhdCBmb3IgYXJndW1lbnQgbGlzdHNcbiAgICAgICAgLy92YXIgcmV0ID0gd2l0aF9pbmRlbnQoY3VycmVudF9jb2wsIGNvbnQpO1xuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICBwcmludChcIilcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdpdGhfc3F1YXJlKGNvbnQpIHtcbiAgICAgICAgcHJpbnQoXCJbXCIpO1xuICAgICAgICAvL3ZhciByZXQgPSB3aXRoX2luZGVudChjdXJyZW50X2NvbCwgY29udCk7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIHByaW50KFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29tbWEoKSB7XG4gICAgICAgIHByaW50KFwiLFwiKTtcbiAgICAgICAgc3BhY2UoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29sb24oKSB7XG4gICAgICAgIHByaW50KFwiOlwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3BhY2VfY29sb24pIHNwYWNlKCk7XG4gICAgfTtcblxuICAgIHZhciBhZGRfbWFwcGluZyA9IG9wdGlvbnMuc291cmNlX21hcCA/IGZ1bmN0aW9uKHRva2VuLCBuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodG9rZW4pIG9wdGlvbnMuc291cmNlX21hcC5hZGQoXG4gICAgICAgICAgICAgICAgdG9rZW4uZmlsZSB8fCBcIj9cIixcbiAgICAgICAgICAgICAgICBjdXJyZW50X2xpbmUsIGN1cnJlbnRfY29sLFxuICAgICAgICAgICAgICAgIHRva2VuLmxpbmUsIHRva2VuLmNvbCxcbiAgICAgICAgICAgICAgICAoIW5hbWUgJiYgdG9rZW4udHlwZSA9PSBcIm5hbWVcIikgPyB0b2tlbi52YWx1ZSA6IG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJDb3VsZG4ndCBmaWd1cmUgb3V0IG1hcHBpbmcgZm9yIHtmaWxlfTp7bGluZX0se2NvbH0g4oaSIHtjbGluZX0se2Njb2x9IFt7bmFtZX1dXCIsIHtcbiAgICAgICAgICAgICAgICBmaWxlOiB0b2tlbi5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiB0b2tlbi5jb2wsXG4gICAgICAgICAgICAgICAgY2xpbmU6IGN1cnJlbnRfbGluZSxcbiAgICAgICAgICAgICAgICBjY29sOiBjdXJyZW50X2NvbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IFwiXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9IDogbm9vcDtcblxuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE9VVFBVVDtcbiAgICB9O1xuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0ICAgICAgICAgICAgIDogZ2V0LFxuICAgICAgICB0b1N0cmluZyAgICAgICAgOiBnZXQsXG4gICAgICAgIGluZGVudCAgICAgICAgICA6IGluZGVudCxcbiAgICAgICAgaW5kZW50YXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBpbmRlbnRhdGlvbiB9LFxuICAgICAgICBjdXJyZW50X3dpZHRoICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfY29sIC0gaW5kZW50YXRpb24gfSxcbiAgICAgICAgc2hvdWxkX2JyZWFrICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBvcHRpb25zLndpZHRoICYmIHRoaXMuY3VycmVudF93aWR0aCgpID49IG9wdGlvbnMud2lkdGggfSxcbiAgICAgICAgbmV3bGluZSAgICAgICAgIDogbmV3bGluZSxcbiAgICAgICAgcHJpbnQgICAgICAgICAgIDogcHJpbnQsXG4gICAgICAgIHNwYWNlICAgICAgICAgICA6IHNwYWNlLFxuICAgICAgICBjb21tYSAgICAgICAgICAgOiBjb21tYSxcbiAgICAgICAgY29sb24gICAgICAgICAgIDogY29sb24sXG4gICAgICAgIGxhc3QgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdCB9LFxuICAgICAgICBzZW1pY29sb24gICAgICAgOiBzZW1pY29sb24sXG4gICAgICAgIGZvcmNlX3NlbWljb2xvbiA6IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgdG9fYXNjaWkgICAgICAgIDogdG9fYXNjaWksXG4gICAgICAgIHByaW50X25hbWUgICAgICA6IGZ1bmN0aW9uKG5hbWUpIHsgcHJpbnQobWFrZV9uYW1lKG5hbWUpKSB9LFxuICAgICAgICBwcmludF9zdHJpbmcgICAgOiBmdW5jdGlvbihzdHIpIHsgcHJpbnQoZW5jb2RlX3N0cmluZyhzdHIpKSB9LFxuICAgICAgICBuZXh0X2luZGVudCAgICAgOiBuZXh0X2luZGVudCxcbiAgICAgICAgd2l0aF9pbmRlbnQgICAgIDogd2l0aF9pbmRlbnQsXG4gICAgICAgIHdpdGhfYmxvY2sgICAgICA6IHdpdGhfYmxvY2ssXG4gICAgICAgIHdpdGhfcGFyZW5zICAgICA6IHdpdGhfcGFyZW5zLFxuICAgICAgICB3aXRoX3NxdWFyZSAgICAgOiB3aXRoX3NxdWFyZSxcbiAgICAgICAgYWRkX21hcHBpbmcgICAgIDogYWRkX21hcHBpbmcsXG4gICAgICAgIG9wdGlvbiAgICAgICAgICA6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gb3B0aW9uc1tvcHRdIH0sXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9saW5lIH0sXG4gICAgICAgIGNvbCAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9jb2wgfSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X3BvcyB9LFxuICAgICAgICBwdXNoX25vZGUgICAgICAgOiBmdW5jdGlvbihub2RlKSB7IHN0YWNrLnB1c2gobm9kZSkgfSxcbiAgICAgICAgcG9wX25vZGUgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzdGFjay5wb3AoKSB9LFxuICAgICAgICBzdGFjayAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrIH0sXG4gICAgICAgIHBhcmVudCAgICAgICAgICA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgICAgICB9XG4gICAgfTtcblxufTtcblxuLyogLS0tLS1bIGNvZGUgZ2VuZXJhdG9ycyBdLS0tLS0gKi9cblxuKGZ1bmN0aW9uKCl7XG5cbiAgICAvKiAtLS0tLVsgdXRpbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZQUklOVChub2RldHlwZSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIl9jb2RlZ2VuXCIsIGdlbmVyYXRvcik7XG4gICAgfTtcblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcInByaW50XCIsIGZ1bmN0aW9uKHN0cmVhbSwgZm9yY2VfcGFyZW5zKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBnZW5lcmF0b3IgPSBzZWxmLl9jb2RlZ2VuO1xuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgc2VsZi5hZGRfY29tbWVudHMoc3RyZWFtKTtcbiAgICAgICAgICAgIHNlbGYuYWRkX3NvdXJjZV9tYXAoc3RyZWFtKTtcbiAgICAgICAgICAgIGdlbmVyYXRvcihzZWxmLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wdXNoX25vZGUoc2VsZik7XG4gICAgICAgIGlmIChmb3JjZV9wYXJlbnMgfHwgc2VsZi5uZWVkc19wYXJlbnMoc3RyZWFtKSkge1xuICAgICAgICAgICAgc3RyZWFtLndpdGhfcGFyZW5zKGRvaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3Bfbm9kZSgpO1xuICAgIH0pO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRfdG9fc3RyaW5nXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICB2YXIgcyA9IE91dHB1dFN0cmVhbShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wcmludChzKTtcbiAgICAgICAgcmV0dXJuIHMuZ2V0KCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgY29tbWVudHMgXS0tLS0tICovXG5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJhZGRfY29tbWVudHNcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIGMgPSBvdXRwdXQub3B0aW9uKFwiY29tbWVudHNcIiksIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2VsZi5zdGFydDtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiAhc3RhcnQuX2NvbW1lbnRzX2R1bXBlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Ll9jb21tZW50c19kdW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcblxuICAgICAgICAgICAgICAgIC8vIFhYWDogdWdseSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8xMTJcbiAgICAgICAgICAgICAgICAvLyAgICAgIGlmIHRoaXMgbm9kZSBpcyBgcmV0dXJuYCBvciBgdGhyb3dgLCB3ZSBjYW5ub3QgYWxsb3cgY29tbWVudHMgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gICAgICB0aGUgcmV0dXJuZWQgb3IgdGhyb3duIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX0V4aXQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52YWx1ZSAmJiBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gKGNvbW1lbnRzIHx8IFtdKS5jb25jYXQoc2VsZi52YWx1ZS5zdGFydC5jb21tZW50c19iZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5maWx0ZXIoZnVuY3Rpb24oY29tbWVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy50ZXN0KGNvbW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmZpbHRlcihmdW5jdGlvbihjb21tZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjKHNlbGYsIGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWVudHMuZm9yRWFjaChmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PSBcImNvbW1lbnQxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi8vXCIgKyBjLnZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYy50eXBlID09IFwiY29tbWVudDJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLypcIiArIGMudmFsdWUgKyBcIiovXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Lm5sYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBQQVJFTlRIRVNFUyBdLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIFBBUkVOUyhub2RldHlwZSwgZnVuYykge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJuZWVkc19wYXJlbnNcIiwgZnVuYyk7XG4gICAgfTtcblxuICAgIFBBUkVOUyhBU1RfTm9kZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gYSBmdW5jdGlvbiBleHByZXNzaW9uIG5lZWRzIHBhcmVucyBhcm91bmQgaXQgd2hlbiBpdCdzIHByb3ZhYmx5XG4gICAgLy8gdGhlIGZpcnN0IHRva2VuIHRvIGFwcGVhciBpbiBhIHN0YXRlbWVudC5cbiAgICBQQVJFTlMoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICByZXR1cm4gZmlyc3RfaW5fc3RhdGVtZW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBzYW1lIGdvZXMgZm9yIGFuIG9iamVjdCBsaXRlcmFsLCBiZWNhdXNlIG90aGVyd2lzZSBpdCB3b3VsZCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIGEgYmxvY2sgb2YgY29kZS5cbiAgICBQQVJFTlMoQVNUX09iamVjdCwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgcmV0dXJuIGZpcnN0X2luX3N0YXRlbWVudChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9VbmFyeSwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9TZXEsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9DYWxsICAgICAgICAgICAgIC8vIChmb28sIGJhcikoKSBvciBmb28oMSwgKDIsIDMpLCA0KVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeSAgICAgICAgICAgIC8vICEoZm9vLCBiYXIsIGJheilcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAgICAvLyAxICsgKDIsIDMpICsgNCA9PT4gOFxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9WYXJEZWYgICAgICAgICAgIC8vIHZhciBhID0gKDEsIDIpLCBiID0gYSArIGE7ID09PiBiID09IDRcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRG90ICAgICAgICAgICAgICAvLyAoMSwge2ZvbzoyfSkuZm9vID09PiAyXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0FycmF5ICAgICAgICAgICAgLy8gWyAxLCAoMiwgMyksIDQgXSA9PT4gWyAxLCAzLCA0IF1cbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkgICAvLyB7IGZvbzogKDEsIDIpIH0uZm9vID09PiAyXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICAgICAgLyogKGZhbHNlLCB0cnVlKSA/IChhID0gMTAsIGIgPSAyMCkgOiAoYyA9IDMwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqID09PiAyMCAoc2lkZSBlZmZlY3QsIHNldCBhIDo9IDEwIGFuZCBiIDo9IDIwKSAqL1xuICAgICAgICA7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0JpbmFyeSwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vIChmb28gJiYgYmFyKSgpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHR5cGVvZiAoZm9vICYmIGJhcilcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGZvbyAmJiBiYXIpW1wicHJvcFwiXSwgKGZvbyAmJiBiYXIpLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcyBkZWFscyB3aXRoIHByZWNlZGVuY2U6IDMgKiAoMiArIDEpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSkge1xuICAgICAgICAgICAgdmFyIHBvID0gcC5vcGVyYXRvciwgcHAgPSBQUkVDRURFTkNFW3BvXTtcbiAgICAgICAgICAgIHZhciBzbyA9IHRoaXMub3BlcmF0b3IsIHNwID0gUFJFQ0VERU5DRVtzb107XG4gICAgICAgICAgICBpZiAocHAgPiBzcFxuICAgICAgICAgICAgICAgIHx8IChwcCA9PSBzcFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzID09PSBwLnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICYmICEoc28gPT0gcG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAoc28gPT0gXCIqXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc28gPT0gXCImJlwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNvID09IFwifHxcIikpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1Byb3BBY2Nlc3MsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9OZXcgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBpLmUuIG5ldyAoZm9vLmJhcigpLmJheilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG9uZSBjYWxsIGludG8gdGhpcyBzdWJ0cmVlLCB0aGVuIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHBhcmVucyBhcm91bmQgaXQgdG9vLCBvdGhlcndpc2UgdGhlIGNhbGwgd2lsbCBiZVxuICAgICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgcGFzc2luZyB0aGUgYXJndW1lbnRzIHRvIHRoZSB1cHBlciBOZXdcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCkgdGhyb3cgcDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4ICE9PSBwKSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9DYWxsLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcztcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTmV3LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKG5vX2NvbnN0cnVjdG9yX3BhcmVucyh0aGlzLCBvdXRwdXQpXG4gICAgICAgICAgICAmJiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIC8vIChuZXcgRGF0ZSkuZ2V0VGltZSgpLCAobmV3IERhdGUpW1wiZ2V0VGltZVwiXSgpXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykpIC8vIChuZXcgZm9vKShiYXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTnVtYmVyLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA8IDAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9OYU4sIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYXNzaWduX2FuZF9jb25kaXRpb25hbF9wYXJlbl9ydWxlcyhvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vICEoYSA9IGZhbHNlKSDihpIgdHJ1ZVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAxICsgKGEgPSAyKSArIDMg4oaSIDYsIHNpZGUgZWZmZWN0IHNldHRpbmcgYSA9IDJcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmICEocCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZnVuYykoKSDigJRvcuKAlCBuZXcgKGEgPSBPYmplY3QpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmb28pID8gYmFyIDogYmF6XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZm9vKVtcInByb3BcIl0g4oCUb3LigJQgKGEgPSBmb28pLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgUEFSRU5TKEFTVF9Bc3NpZ24sIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuICAgIFBBUkVOUyhBU1RfQ29uZGl0aW9uYWwsIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuXG4gICAgLyogLS0tLS1bIFBSSU5URVJTIF0tLS0tLSAqL1xuXG4gICAgREVGUFJJTlQoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLnZhbHVlKTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVidWdnZXJcIik7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheV9ib2R5KGJvZHksIGlzX3RvcGxldmVsLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKXtcbiAgICAgICAgICAgIGlmICghKHN0bXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpID09IGxhc3QgJiYgaXNfdG9wbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc190b3BsZXZlbCkgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBU1RfU3RhdGVtZW50V2l0aEJvZHkuREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHRoaXMuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1RvcGxldmVsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHJpbnRfYnJhY2tldGVkKGJvZHksIG91dHB1dCkge1xuICAgICAgICBpZiAoYm9keS5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGlzcGxheV9ib2R5KGJvZHksIGZhbHNlLCBvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRG8sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImRvXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1doaWxlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aGlsZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZm9yXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoc2VsZi5pbml0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi5pbml0LCBvdXRwdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc3RlcCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RlcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRm9ySW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImluXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2l0aFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGZ1bmN0aW9ucyBdLS0tLS0gKi9cbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIG5va2V5d29yZCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFub2tleXdvcmQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgYXJnLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhpdHMgXS0tLS0tICovXG4gICAgQVNUX0V4aXQuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUmV0dXJuLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwicmV0dXJuXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UaHJvdywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInRocm93XCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxvb3AgY29udHJvbCBdLS0tLS0gKi9cbiAgICBBU1RfTG9vcENvbnRyb2wuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQnJlYWssIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJicmVha1wiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29udGludWUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb250aW51ZVwiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBpZiBdLS0tLS0gKi9cbiAgICBmdW5jdGlvbiBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYnJhY2tldGl6ZVwiKSkge1xuICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2tldHMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXNlbGYuYm9keSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRG9cbiAgICAgICAgICAgICYmICFvdXRwdXQub3B0aW9uKFwic2NyZXdfaWU4XCIpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8jaXNzdWUvNTcgSUVcbiAgICAgICAgICAgIC8vIGNyb2FrcyB3aXRoIFwic3ludGF4IGVycm9yXCIgb24gY29kZSBsaWtlIHRoaXM6IGlmIChmb28pXG4gICAgICAgICAgICAvLyBkbyAuLi4gd2hpbGUoY29uZCk7IGVsc2UgLi4uICB3ZSBuZWVkIGJsb2NrIGJyYWNrZXRzXG4gICAgICAgICAgICAvLyBhcm91bmQgZG8vd2hpbGVcbiAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gc2VsZi5ib2R5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IGIuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFdpdGhCb2R5KSB7XG4gICAgICAgICAgICAgICAgYiA9IGIuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaWZcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIG1ha2VfdGhlbihzZWxmLCBvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJlbHNlXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBmb3JjZV9zdGF0ZW1lbnQoc2VsZi5hbHRlcm5hdGl2ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHN3aXRjaCBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJzd2l0Y2hcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgIH0pO1xuICAgIEFTVF9Td2l0Y2hCcmFuY2guREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCl7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRGVmYXVsdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVmYXVsdDpcIik7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiY2FzZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI6XCIpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhjZXB0aW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ0cnlcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5iY2F0Y2gucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmJmaW5hbGx5LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhdGNoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9GaW5hbGx5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmaW5hbGx5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyB2YXIvY29uc3QgXS0tLS0tICovXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpKXtcbiAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIGRlZi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHZhciBpbl9mb3IgPSBwIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBwIGluc3RhbmNlb2YgQVNUX0ZvckluO1xuICAgICAgICB2YXIgYXZvaWRfc2VtaWNvbG9uID0gaW5fZm9yICYmIHAuaW5pdCA9PT0gdGhpcztcbiAgICAgICAgaWYgKCFhdm9pZF9zZW1pY29sb24pXG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ZhciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInZhclwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uc3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb25zdFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZV9mb3Jfbm9pbihub2RlLCBvdXRwdXQsIG5vaW4pIHtcbiAgICAgICAgaWYgKCFub2luKSBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgIGVsc2UgdHJ5IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdGFrZSBzb21lIHByZWNhdXRpb25zIGhlcmU6XG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNjBcbiAgICAgICAgICAgIG5vZGUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PSBcImluXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG91dHB1dDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5vZGUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBvdXRwdXQpIHRocm93IGV4O1xuICAgICAgICAgICAgbm9kZS5wcmludChvdXRwdXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERFRlBSSU5UKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoMSk7XG4gICAgICAgICAgICB2YXIgbm9pbiA9IHAgaW5zdGFuY2VvZiBBU1RfRm9yIHx8IHAgaW5zdGFuY2VvZiBBU1RfRm9ySW47XG4gICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi52YWx1ZSwgb3V0cHV0LCBub2luKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIG90aGVyIGV4cHJlc3Npb25zIF0tLS0tLSAqL1xuICAgIERFRlBSSU5UKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIG5vX2NvbnN0cnVjdG9yX3BhcmVucyhzZWxmLCBvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwibmV3XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgQVNUX0NhbGwucHJvdG90eXBlLl9jb2RlZ2VuKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBBU1RfU2VxLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB0aGlzLmNhci5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5jZHIpIHtcbiAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5zaG91bGRfYnJlYWsoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TZXEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gICAgIG91dHB1dC53aXRoX2luZGVudChvdXRwdXQubmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIGV4cHIuZ2V0VmFsdWUoKSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoIS9beGEtZi5dL2kudGVzdChvdXRwdXQubGFzdCgpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgLy8gdGhlIG5hbWUgYWZ0ZXIgZG90IHdvdWxkIGJlIG1hcHBlZCBhYm91dCBoZXJlLlxuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5lbmQpO1xuICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShzZWxmLnByb3BlcnR5KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiW1wiKTtcbiAgICAgICAgc2VsZi5wcm9wZXJ0eS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJdXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5vcGVyYXRvcjtcbiAgICAgICAgb3V0cHV0LnByaW50KG9wKTtcbiAgICAgICAgaWYgKC9eW2Etel0vaS50ZXN0KG9wKSlcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYub3BlcmF0b3IpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5yaWdodC5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIj9cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmNvbnNlcXVlbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgbGl0ZXJhbHMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBhID0gc2VsZi5lbGVtZW50cywgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24oZXhwLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgZXhwLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbmFsIGVsZW1lbnQgaXMgYSBob2xlLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbG9vayBsaWtlIGEgdHJhaWxpbmcgY29tbWEsIGJ5IGluc2VydGluZyBhbiBhY3R1YWxcbiAgICAgICAgICAgICAgICAvLyB0cmFpbGluZyBjb21tYS5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMSAmJiBleHAgaW5zdGFuY2VvZiBBU1RfSG9sZSlcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBwcm9wLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3RLZXlWYWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBrZXkgPSBzZWxmLmtleTtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJxdW90ZV9rZXlzXCIpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2Yga2V5ID09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgfHwgIW91dHB1dC5vcHRpb24oXCJiZWF1dGlmeVwiKVxuICAgICAgICAgICAgICAgICAgICAmJiAra2V5ICsgXCJcIiA9PSBrZXkpXG4gICAgICAgICAgICAgICAgICAgJiYgcGFyc2VGbG9hdChrZXkpID49IDApIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChSRVNFUlZFRF9XT1JEUyhrZXkpID8gb3V0cHV0Lm9wdGlvbihcInNjcmV3X2llOFwiKSA6IGlzX2lkZW50aWZpZXJfc3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9uYW1lKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0U2V0dGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJzZXRcIik7XG4gICAgICAgIHNlbGYudmFsdWUuX2RvX3ByaW50KG91dHB1dCwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdEdldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZ2V0XCIpO1xuICAgICAgICBzZWxmLnZhbHVlLl9kb19wcmludChvdXRwdXQsIHRydWUpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TeW1ib2wsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBkZWYgPSBzZWxmLmRlZmluaXRpb24oKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUoZGVmID8gZGVmLm1hbmdsZWRfbmFtZSB8fCBkZWYubmFtZSA6IHNlbGYubmFtZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VuZGVmaW5lZCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwidm9pZCAwXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ib2xlLCBub29wKTtcbiAgICBERUZQUklOVChBU1RfSW5maW5pdHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcIjEvMFwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTmFOLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCIwLzBcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1RoaXMsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcInRoaXNcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3RyaW5nLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX051bWJlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KG1ha2VfbnVtKHNlbGYuZ2V0VmFsdWUoKSkpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9SZWdFeHAsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBzdHIgPSBzZWxmLmdldFZhbHVlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJhc2NpaV9vbmx5XCIpKVxuICAgICAgICAgICAgc3RyID0gb3V0cHV0LnRvX2FzY2lpKHN0cik7XG4gICAgICAgIG91dHB1dC5wcmludChzdHIpO1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIC9eaW4vLnRlc3QocC5vcGVyYXRvcikgJiYgcC5sZWZ0ID09PSBzZWxmKVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiIFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3N0YXRlbWVudChzdGF0LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJicmFja2V0aXplXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudClcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgZWxzZSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBzdGF0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdGF0IHx8IHN0YXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHN0YXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjayAodGhhdCBtZWFucyB0aGVcbiAgICAvLyBpbm5lcm1vc3Qgbm9kZSBpbiB0aGUgY3VycmVudCBvdXRwdXQpIGlzIGxleGljYWxseSB0aGUgZmlyc3QgaW5cbiAgICAvLyBhIHN0YXRlbWVudC5cbiAgICBmdW5jdGlvbiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KSB7XG4gICAgICAgIHZhciBhID0gb3V0cHV0LnN0YWNrKCksIGkgPSBhLmxlbmd0aCwgbm9kZSA9IGFbLS1pXSwgcCA9IGFbLS1pXTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQgJiYgcC5ib2R5ID09PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKChwIGluc3RhbmNlb2YgQVNUX1NlcSAgICAgICAgICAgJiYgcC5jYXIgPT09IG5vZGUgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICAgICAgICAgICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSAmJiAhKHAgaW5zdGFuY2VvZiBBU1RfTmV3KSApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRG90ICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1N1YiAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAgICYmIHAuY29uZGl0aW9uID09PSBub2RlICApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAmJiBwLmxlZnQgPT09IG5vZGUgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5UG9zdGZpeCAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHA7XG4gICAgICAgICAgICAgICAgcCA9IGFbLS1pXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNlbGYgc2hvdWxkIGJlIEFTVF9OZXcuICBkZWNpZGUgaWYgd2Ugd2FudCB0byBzaG93IHBhcmVucyBvciBub3QuXG4gICAgZnVuY3Rpb24gbm9fY29uc3RydWN0b3JfcGFyZW5zKHNlbGYsIG91dHB1dCkge1xuICAgICAgICByZXR1cm4gc2VsZi5hcmdzLmxlbmd0aCA9PSAwICYmICFvdXRwdXQub3B0aW9uKFwiYmVhdXRpZnlcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJlc3Rfb2YoYSkge1xuICAgICAgICB2YXIgYmVzdCA9IGFbMF0sIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhW2ldLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxMCksIGEgPSBbIHN0ci5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKCdlKycsICdlJykgXSwgbTtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IobnVtKSA9PT0gbnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCIweFwiICsgbnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCAvLyBwcm9iYWJseSBwb2ludGxlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIgKyBudW0udG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCItMHhcIiArICgtbnVtKS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgIFwiLTBcIiArICgtbnVtKS50b1N0cmluZyg4KSk7IC8vIHNhbWUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG0gPSAvXiguKj8pKDArKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2gobVsxXSArIFwiZVwiICsgbVsyXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14wP1xcLigwKykoLiopJC8uZXhlYyhudW0pKSkge1xuICAgICAgICAgICAgYS5wdXNoKG1bMl0gKyBcImUtXCIgKyAobVsxXS5sZW5ndGggKyBtWzJdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgc3RyLnN1YnN0cihzdHIuaW5kZXhPZihcIi5cIikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdF9vZihhKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ibG9jayhzdG10LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qIC0tLS0tWyBzb3VyY2UgbWFwIGdlbmVyYXRvcnMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZNQVAobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJhZGRfc291cmNlX21hcFwiLCBmdW5jdGlvbihzdHJlYW0pe1xuICAgICAgICAgICAgZ2VuZXJhdG9yKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBXZSBjb3VsZCBlYXNpbHkgYWRkIGluZm8gZm9yIEFMTCBub2RlcywgYnV0IGl0IHNlZW1zIHRvIG1lIHRoYXRcbiAgICAvLyB3b3VsZCBiZSBxdWl0ZSB3YXN0ZWZ1bCwgaGVuY2UgdGhpcyBub29wIGluIHRoZSBiYXNlIGNsYXNzLlxuICAgIERFRk1BUChBU1RfTm9kZSwgbm9vcCk7XG5cbiAgICBmdW5jdGlvbiBiYXNpY19zb3VyY2VtYXBfZ2VuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5zdGFydCk7XG4gICAgfTtcblxuICAgIC8vIFhYWDogSSdtIG5vdCBleGFjdGx5IHN1cmUgaWYgd2UgbmVlZCBpdCBmb3IgYWxsIG9mIHRoZXNlIG5vZGVzLFxuICAgIC8vIG9yIGlmIHdlIHNob3VsZCBhZGQgZXZlbiBtb3JlLlxuXG4gICAgREVGTUFQKEFTVF9EaXJlY3RpdmUsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVidWdnZXIsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3ltYm9sLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0p1bXAsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3RhdGVtZW50V2l0aEJvZHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfTGFiZWxlZFN0YXRlbWVudCwgbm9vcCk7IC8vIHNpbmNlIHRoZSBsYWJlbCBzeW1ib2wgd2lsbCBtYXJrIGl0XG4gICAgREVGTUFQKEFTVF9MYW1iZGEsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3dpdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N3aXRjaEJyYW5jaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9CbG9ja1N0YXRlbWVudCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9Ub3BsZXZlbCwgbm9vcCk7XG4gICAgREVGTUFQKEFTVF9OZXcsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfVHJ5LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0NhdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0ZpbmFsbHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVmaW5pdGlvbnMsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfQ29uc3RhbnQsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLnN0YXJ0LCBzZWxmLmtleSk7XG4gICAgfSk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIENvbXByZXNzb3Iob3B0aW9ucywgZmFsc2VfYnlfZGVmYXVsdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wcmVzc29yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc29yKG9wdGlvbnMsIGZhbHNlX2J5X2RlZmF1bHQpO1xuICAgIFRyZWVUcmFuc2Zvcm1lci5jYWxsKHRoaXMsIHRoaXMuYmVmb3JlLCB0aGlzLmFmdGVyKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHNlcXVlbmNlcyAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllcyAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBkZWFkX2NvZGUgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGRyb3BfZGVidWdnZXIgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgdW5zYWZlICAgICAgICA6IGZhbHNlLFxuICAgICAgICB1bnNhZmVfY29tcHMgIDogZmFsc2UsXG4gICAgICAgIGNvbmRpdGlvbmFscyAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgY29tcGFyaXNvbnMgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBldmFsdWF0ZSAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGJvb2xlYW5zICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgbG9vcHMgICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICB1bnVzZWQgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGhvaXN0X2Z1bnMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgaG9pc3RfdmFycyAgICA6IGZhbHNlLFxuICAgICAgICBpZl9yZXR1cm4gICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGpvaW5fdmFycyAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgY2FzY2FkZSAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBzaWRlX2VmZmVjdHMgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIG5lZ2F0ZV9paWZlICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgc2NyZXdfaWU4ICAgICA6IGZhbHNlLFxuXG4gICAgICAgIHdhcm5pbmdzICAgICAgOiB0cnVlLFxuICAgICAgICBnbG9iYWxfZGVmcyAgIDoge31cbiAgICB9LCB0cnVlKTtcbn07XG5cbkNvbXByZXNzb3IucHJvdG90eXBlID0gbmV3IFRyZWVUcmFuc2Zvcm1lcjtcbm1lcmdlKENvbXByZXNzb3IucHJvdG90eXBlLCB7XG4gICAgb3B0aW9uOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldIH0sXG4gICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FybmluZ3MpXG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuLmFwcGx5KEFTVF9Ob2RlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbihub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgIGlmIChub2RlLl9zcXVlZXplZCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLmRyb3BfdW51c2VkKHRoaXMpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaG9pc3RfZGVjbGFyYXRpb25zKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIG5vZGUgPSBub2RlLm9wdGltaXplKHRoaXMpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgLy8gZGVhZCBjb2RlIHJlbW92YWwgbWlnaHQgbGVhdmUgZnVydGhlciB1bnVzZWQgZGVjbGFyYXRpb25zLlxuICAgICAgICAgICAgLy8gdGhpcydsbCB1c3VhbGx5IHNhdmUgdmVyeSBmZXcgYnl0ZXMsIGJ1dCB0aGUgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGhpdCBzZWVtcyBuZWdsaWdpYmxlIHNvIEknbGwganVzdCBkcm9wIGl0IGhlcmUuXG5cbiAgICAgICAgICAgIC8vIG5vIHBvaW50IHRvIHJlcGVhdCB3YXJuaW5ncy5cbiAgICAgICAgICAgIHZhciBzYXZlX3dhcm5pbmdzID0gdGhpcy5vcHRpb25zLndhcm5pbmdzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLndhcm5pbmdzID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLmRyb3BfdW51c2VkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLndhcm5pbmdzID0gc2F2ZV93YXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgICBub2RlLl9zcXVlZXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn0pO1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIGZ1bmN0aW9uIE9QVChub2RlLCBvcHRpbWl6ZXIpIHtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJvcHRpbWl6ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLl9vcHRpbWl6ZWQpIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGltaXplcihzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIG9wdC5fb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHQgPT09IHNlbGYpIHJldHVybiBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gb3B0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE9QVChBU1RfTm9kZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwiZXF1aXZhbGVudF90b1wiLCBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgLy8gWFhYOiB0aGlzIGlzIGEgcmF0aGVyIGV4cGVuc2l2ZSB3YXkgdG8gdGVzdCB0d28gbm9kZSdzIGVxdWl2YWxlbmNlOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmludF90b19zdHJpbmcoKSA9PSBub2RlLnByaW50X3RvX3N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ub2RlKGN0b3IsIG9yaWcsIHByb3BzKSB7XG4gICAgICAgIGlmICghcHJvcHMpIHByb3BzID0ge307XG4gICAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLnN0YXJ0KSBwcm9wcy5zdGFydCA9IG9yaWcuc3RhcnQ7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmVuZCkgcHJvcHMuZW5kID0gb3JpZy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHByb3BzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCBvcmlnKSB7XG4gICAgICAgIC8vIFhYWDogV0lQLlxuICAgICAgICAvLyBpZiAodmFsIGluc3RhbmNlb2YgQVNUX05vZGUpIHJldHVybiB2YWwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIobnVsbCwgZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIC8vICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIgc2NvcGUgPSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9TY29wZSk7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUobm9kZSk7XG4gICAgICAgIC8vICAgICAgICAgbm9kZS50aGVkZWYgPSBkZWY7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH0pKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG5cbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm4gdmFsLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShpc05hTih2YWwpID8gQVNUX05hTiA6IEFTVF9OdW1iZXIsIG9yaWcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZSh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBvcmlnKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX051bGwsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1JlZ0V4cCwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiQ2FuJ3QgaGFuZGxlIGNvbnN0YW50IG9mIHR5cGU6IHt0eXBlfVwiLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX3N0YXRlbWVudF9hcnJheSh0aGluZykge1xuICAgICAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSByZXR1cm4gW107XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHJldHVybiBbIHRoaW5nIF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdGhpbmcgdG8gc3RhdGVtZW50IGFycmF5XCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc19lbXB0eSh0aGluZykge1xuICAgICAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHJldHVybiB0aGluZy5ib2R5Lmxlbmd0aCA9PSAwO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvb3BfYm9keSh4KSB7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX1N3aXRjaCkgcmV0dXJuIHg7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0ZvciB8fCB4IGluc3RhbmNlb2YgQVNUX0ZvckluIHx8IHggaW5zdGFuY2VvZiBBU1RfRFdMb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gKHguYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCA/IHguYm9keSA6IHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0aWdodGVuX2JvZHkoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgQ0hBTkdFRDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgQ0hBTkdFRCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGVtZW50cyA9IGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdGVtZW50cyk7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gZWxpbWluYXRlX2RlYWRfY29kZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImlmX3JldHVyblwiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBoYW5kbGVfaWZfcmV0dXJuKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2VxdWVuY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IHNlcXVlbmNlc2l6ZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImpvaW5fdmFyc1wiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBqb2luX2NvbnNlY3V0aXZlX3ZhcnMoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKENIQU5HRUQpO1xuXG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcIm5lZ2F0ZV9paWZlXCIpKSB7XG4gICAgICAgICAgICBuZWdhdGVfaWlmZXMoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcblxuICAgICAgICBmdW5jdGlvbiBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBzZWVuX2RpcnMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdC5ib2R5KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5fZGlycy5pbmRleE9mKHN0YXQudmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbl9kaXJzLnB1c2goc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICAgICAgdmFyIGluX2xhbWJkYSA9IHNlbGYgaW5zdGFuY2VvZiBBU1RfTGFtYmRhO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IHN0YXRlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIChpbl9sYW1iZGEgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIXN0YXQudmFsdWUgJiYgcmV0Lmxlbmd0aCA9PSAwKTpcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGUsIHJldC5sZW5ndGggaXMgcHJvYmFibHkgYWx3YXlzIHplcm9cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkcm9wIHVucmVhY2hhYmxlIGNvZGUgYmVmb3JlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcC4gIG5ldmVydGhlbGVzcywgaXQncyBnb29kIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgY2FzZSBzdGF0IGluc3RhbmNlb2YgQVNUX0lmOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5ib2R5IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXR0eSBzaWxseSBjYXNlLCBidXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybjsgcmV0dXJuOyA9PT4gZm9vKCk7IHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGluX2xhbWJkYSAmJiByZXQubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmICFyZXRbMF0udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZCA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzdGF0LmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzdGF0LmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KGNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgcmV0dXJuIHk7ID09PiByZXR1cm4gZm9vKCkgPyB4IDogeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmIHN0YXQuYm9keS52YWx1ZSAmJiByZXRbMF0udmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0WzBdID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybiB4OyBbIHJldHVybiA7IF0gPT0+IHJldHVybiBmb28oKSA/IHggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJldC5sZW5ndGggPT0gMCB8fCByZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSAmJiBzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gcmV0WzBdIHx8IG1ha2Vfbm9kZShBU1RfUmV0dXJuLCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc3RhdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbMF0gPSBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuOyBbIGVsc2UgeC4uLiBdOyB5Li4uID09PiBpZiAoIWZvbygpKSB7IHguLi47IHkuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0LmJvZHkudmFsdWUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmNvbmRpdGlvbiA9IHN0YXQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFsgc3RhdC50cmFuc2Zvcm0oY29tcHJlc3NvcikgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoID09IDEgJiYgaW5fbGFtYmRhICYmIHJldFswXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoIXN0YXQuYWx0ZXJuYXRpdmUgfHwgc3RhdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9SZXR1cm4sIHJldFswXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHJldFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3NvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsY3QgPSBhYiBpbnN0YW5jZW9mIEFTVF9Mb29wQ29udHJvbCA/IGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGFiLmxhYmVsKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYiAmJiAoKGFiIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhYWIudmFsdWUgJiYgaW5fbGFtYmRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChhYiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSAmJiBzZWxmID09PSBsb29wX2JvZHkobGN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ICYmIHNlbGYgPT09IGxjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWIubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoYWIubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIGFiLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5jb25kaXRpb24gPSBzdGF0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbIHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gYWIgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgPyBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChhYi5sYWJlbCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWIgJiYgKChhYiBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIWFiLnZhbHVlICYmIGluX2xhbWJkYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQ29udGludWUgJiYgc2VsZiA9PT0gbG9vcF9ib2R5KGxjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGFiIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxjdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCAmJiBzZWxmID09PSBsY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGFiLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBhYi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5hbHRlcm5hdGl2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gWyBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgdmFyIGhhc19xdWl0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb3JpZyA9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX3F1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHN0YXQsIGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSB8fCAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Db250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShzdGF0LmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBzdGF0LmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRzKHN0YXQpKSBoYXNfcXVpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgQ0hBTkdFRCA9IHN0YXRlbWVudHMubGVuZ3RoICE9IG9yaWc7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgICAgICB2YXIgc2VxID0gW10sIHJldCA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHVzaF9zZXEoKSB7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHNlcSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcSkgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlcSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZXFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgc2VxID0gW107XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkgc2VxLnB1c2goc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHB1c2hfc2VxKCksIHJldC5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwdXNoX3NlcSgpO1xuICAgICAgICAgICAgcmV0ID0gc2VxdWVuY2VzaXplXzIocmV0LCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIENIQU5HRUQgPSByZXQubGVuZ3RoICE9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemVfMihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjb25zX3NlcShyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldC5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHByZXYuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5hZGQocmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBBU1RfU2VxLmNvbnMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmJvZHkud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3BlcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmluaXQgJiYgIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IGNvbnNfc2VxKHN0YXQuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzdGF0LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCAhPT0gb3BlcmEpIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gY29uc19zZXEoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gY29uc19zZXEoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQgJiYgc3RhdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKHN0YXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzdGF0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGNvbnNfc2VxKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgcHJldiA9IHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ID8gc3RhdCA6IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiBwcmV2ICYmIHByZXYuVFlQRSA9PSBzdGF0LlRZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwcmV2IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCFzdGF0LmluaXQgfHwgc3RhdC5pbml0LlRZUEUgPT0gcHJldi5UWVBFKSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0LmRlZmluaXRpb25zID0gcHJldi5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBzdGF0O1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5lZ2F0ZV9paWZlcyhzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYm9keSA9IChmdW5jdGlvbiB0cmFuc2Zvcm0odGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZy50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRyYW5zZm9ybShub2RlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhciA9IHRyYW5zZm9ybShub2RlLmNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0cmFuc2Zvcm0obm9kZS5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciAhPT0gbm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBiZWVuIG5lZ2F0ZWQsIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZGl0aW9uID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQgPSBub2RlLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGl2ZSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVucmVhY2hhYmxlIGNvZGUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHN0YXQuc3RhcnQpO1xuICAgICAgICBzdGF0LndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRlY2xhcmF0aW9ucyBpbiB1bnJlYWNoYWJsZSBjb2RlISBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVfaW5pdGlhbGl6ZXJzKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH07XG5cbiAgICAvKiAtLS0tLVsgYm9vbGVhbi9uZWdhdGlvbiBoZWxwZXJzIF0tLS0tLSAqL1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBleHByZXNzaW9uIGhhcyBhIGJvb2xlYW4gcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIHZhciB1bmFyeV9ib29sID0gWyBcIiFcIiwgXCJkZWxldGVcIiBdO1xuICAgICAgICB2YXIgYmluYXJ5X2Jvb2wgPSBbIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLCBcIjxcIiwgXCI8PVwiLCBcIj49XCIsIFwiPlwiIF07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCB1bmFyeV9ib29sKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCBiaW5hcnlfYm9vbCkgfHxcbiAgICAgICAgICAgICAgICAoICh0aGlzLm9wZXJhdG9yID09IFwiJiZcIiB8fCB0aGlzLm9wZXJhdG9yID09IFwifHxcIikgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pc19ib29sZWFuKCkgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX2Jvb2xlYW4oKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX2Jvb2xlYW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXNzaWduLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNkci5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1RydWUsIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICBkZWYoQVNUX0ZhbHNlLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19ib29sZWFuXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiBoYXMgYSBzdHJpbmcgcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1N0cmluZywgZnVuY3Rpb24oKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGRlZihBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInR5cGVvZlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCIrXCIgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSB8fCB0aGlzLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIis9XCIpICYmIHRoaXMucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TZXEsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RyLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19zdHJpbmcoY29tcHJlc3NvcikgJiYgdGhpcy5hbHRlcm5hdGl2ZS5pc19zdHJpbmcoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NhbGwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICYmIHRoaXMuZXhwcmVzc2lvbi5uYW1lID09IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmV4cHJlc3Npb24udW5kZWNsYXJlZCgpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19zdHJpbmdcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBiZXN0X29mKGFzdDEsIGFzdDIpIHtcbiAgICAgICAgcmV0dXJuIGFzdDEucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoID5cbiAgICAgICAgICAgIGFzdDIucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoXG4gICAgICAgICAgICA/IGFzdDIgOiBhc3QxO1xuICAgIH07XG5cbiAgICAvLyBtZXRob2RzIHRvIGV2YWx1YXRlIGEgY29uc3RhbnQgZXhwcmVzc2lvblxuICAgIChmdW5jdGlvbiAoZGVmKXtcbiAgICAgICAgLy8gVGhlIGV2YWx1YXRlIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IHdpdGggb25lIG9yIHR3b1xuICAgICAgICAvLyBlbGVtZW50cy4gIElmIHRoZSBub2RlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZWR1Y2VkIHRvIGFcbiAgICAgICAgLy8gY29uc3RhbnQsIHRoZW4gdGhlIHNlY29uZCBlbGVtZW50IHRlbGxzIHVzIHRoZSB2YWx1ZTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBtaXNzaW5nLiAgVGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgLy8gb2YgdGhlIGFycmF5IGlzIGFsd2F5cyBhbiBBU1RfTm9kZSBkZXNjZW5kYW50OyB3aGVuXG4gICAgICAgIC8vIGV2YWx1YXRpb24gd2FzIHN1Y2Nlc3NmdWwgaXQncyBhIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZVxuICAgICAgICAvLyBjb25zdGFudDsgb3RoZXJ3aXNlIGl0J3MgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImV2YWx1YXRlXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpKSByZXR1cm4gWyB0aGlzIF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9ldmFsKCksIGFzdCA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIHZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgYmVzdF9vZihhc3QsIHRoaXMpLCB2YWwgXTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggIT09IGRlZikgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpcyBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiQ2Fubm90IGV2YWx1YXRlIGEgc3RhdGVtZW50IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB0aGlzLnN0YXJ0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gWFhYOiBBU1RfRnVuY3Rpb24gaW5oZXJpdHMgZnJvbSBBU1RfU2NvcGUsIHdoaWNoIGl0c2VsZlxuICAgICAgICAgICAgLy8gaW5oZXJpdHMgZnJvbSBBU1RfU3RhdGVtZW50OyBob3dldmVyLCBhbiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGlzbid0IHJlYWxseSBhIHN0YXRlbWVudC4gIFRoaXMgY291bGQgYnl0ZSBpbiBvdGhlclxuICAgICAgICAgICAgLy8gcGxhY2VzIHRvby4gOi0oIFdpc2ggSlMgaGFkIG11bHRpcGxlIGluaGVyaXRhbmNlLlxuICAgICAgICAgICAgdGhyb3cgZGVmO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXYobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuX2V2YWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmKEFTVF9Ob2RlLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhyb3cgZGVmOyAgICAgICAgICAvLyBub3QgY29uc3RhbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uc3RhbnQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIhXCI6IHJldHVybiAhZXYoZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiB3b3VsZCBiZSBldmFsdWF0ZWQgdG8gYW4gYXJyYXkgYW5kIHNvIHR5cGVvZiB3b3VsZFxuICAgICAgICAgICAgICAgIC8vIGluY29ycmVjdGx5IHJldHVybiAnb2JqZWN0Jy4gSGVuY2UgbWFraW5nIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uKSByZXR1cm4gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICAgICAgICAgIGUgPSBldihlKTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGVvZiA8UmVnRXhwPiByZXR1cm5zIFwib2JqZWN0XCIgb3IgXCJmdW5jdGlvblwiIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvLyBzbyBjYW5ub3QgZXZhbHVhdGUgcmVsaWFibHlcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlZ0V4cCkgdGhyb3cgZGVmO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICBjYXNlIFwidm9pZFwiOiByZXR1cm4gdm9pZCBldihlKTtcbiAgICAgICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIH5ldihlKTtcbiAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICBlID0gZXYoZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IDApIHRocm93IGRlZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLWU7XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiArZXYoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0JpbmFyeSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0LCByaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIiYmXCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAmJiAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcInx8XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSB8fCAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcInxcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSB8ICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIiZcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAmICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIl5cIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSBeICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIitcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSArICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIipcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAqICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIi9cIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAvICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIiVcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAlICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIi1cIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAtICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIjw8XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA8PCAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj4+XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA+PiAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj4+PlwiICAgICAgICA6IHJldHVybiBldihsZWZ0KSA+Pj4gICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj09XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA9PSAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj09PVwiICAgICAgICA6IHJldHVybiBldihsZWZ0KSA9PT0gICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSAhPSAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIiE9PVwiICAgICAgICA6IHJldHVybiBldihsZWZ0KSAhPT0gICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA8ICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIjw9XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA8PSAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj5cIiAgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA+ICAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcIj49XCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSA+PSAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcImluXCIgICAgICAgICA6IHJldHVybiBldihsZWZ0KSBpbiAgICAgICAgIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgICAgY2FzZSBcImluc3RhbmNlb2ZcIiA6IHJldHVybiBldihsZWZ0KSBpbnN0YW5jZW9mIGV2KHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGRlZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gZXYodGhpcy5jb25kaXRpb24pXG4gICAgICAgICAgICAgICAgPyBldih0aGlzLmNvbnNlcXVlbnQpXG4gICAgICAgICAgICAgICAgOiBldih0aGlzLmFsdGVybmF0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChkICYmIGQuY29uc3RhbnQgJiYgZC5pbml0KSByZXR1cm4gZXYoZC5pbml0KTtcbiAgICAgICAgICAgIHRocm93IGRlZjtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiX2V2YWxcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvLyBtZXRob2QgdG8gbmVnYXRlIGFuIGV4cHJlc3Npb25cbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZnVuY3Rpb24gYmFzaWNfbmVnYXRpb24oZXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3RhdGVtZW50LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG5lZ2F0ZSBhIHN0YXRlbWVudFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU2VxLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYmFzaWNfbmVnYXRpb24odGhpcyksIHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCksIG9wID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9jb21wc1wiKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiPlwiICA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgOiBzZWxmLm9wZXJhdG9yID0gXCI+PVwiIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiPj1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIjxcIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPD1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBcIj09XCIgOiBzZWxmLm9wZXJhdG9yID0gXCIhPVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIj09PVwiOiBzZWxmLm9wZXJhdG9yID0gXCIhPT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPT1cIjogc2VsZi5vcGVyYXRvciA9IFwiPT09XCI7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gXCJ8fFwiO1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGJhc2ljX25lZ2F0aW9uKHRoaXMpLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwiJiZcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihiYXNpY19uZWdhdGlvbih0aGlzKSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcIm5lZ2F0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpcywgY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaGFzIHNpZGUgZWZmZWN0c1xuICAgIChmdW5jdGlvbihkZWYpe1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuXG4gICAgICAgIGRlZihBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1RoaXMsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9KTtcblxuICAgICAgICBkZWYoQVNUX0Jsb2NrLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYm9keS5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlbaV0uaGFzX3NpZGVfZWZmZWN0cygpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRGVmdW4sIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICBkZWYoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2UgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnJpZ2h0Lmhhc19zaWRlX2VmZmVjdHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXNzaWduLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbi5oYXNfc2lkZV9lZmZlY3RzKClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmNvbnNlcXVlbnQuaGFzX3NpZGVfZWZmZWN0cygpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5oYXNfc2lkZV9lZmZlY3RzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMub3BlcmF0b3IgPT0gXCIrK1wiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PSBcIi0tXCJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9PYmplY3QsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNbaV0uaGFzX3NpZGVfZWZmZWN0cygpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0FycmF5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uaGFzX3NpZGVfZWZmZWN0cygpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRlZihBU1RfRG90LCBmdW5jdGlvbigpe1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBkZWYoQVNUX1N1YiwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cygpXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5wcm9wZXJ0eS5oYXNfc2lkZV9lZmZlY3RzKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICBkZWYoQVNUX1Byb3BBY2Nlc3MsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU2VxLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FyLmhhc19zaWRlX2VmZmVjdHMoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY2RyLmhhc19zaWRlX2VmZmVjdHMoKTtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiaGFzX3NpZGVfZWZmZWN0c1wiLCBmdW5jKTtcbiAgICB9KTtcblxuICAgIC8vIHRlbGwgbWUgaWYgYSBzdGF0ZW1lbnQgYWJvcnRzXG4gICAgZnVuY3Rpb24gYWJvcnRzKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGluZyAmJiB0aGluZy5hYm9ydHMoKTtcbiAgICB9O1xuICAgIChmdW5jdGlvbihkZWYpe1xuICAgICAgICBkZWYoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKXsgcmV0dXJuIG51bGwgfSk7XG4gICAgICAgIGRlZihBU1RfSnVtcCwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJsb2NrX2Fib3J0cygpe1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG4gPiAwICYmIGFib3J0cyh0aGlzLmJvZHlbbiAtIDFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmKEFTVF9CbG9ja1N0YXRlbWVudCwgYmxvY2tfYWJvcnRzKTtcbiAgICAgICAgZGVmKEFTVF9Td2l0Y2hCcmFuY2gsIGJsb2NrX2Fib3J0cyk7XG4gICAgICAgIGRlZihBU1RfSWYsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHRlcm5hdGl2ZSAmJiBhYm9ydHModGhpcy5ib2R5KSAmJiBhYm9ydHModGhpcy5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcImFib3J0c1wiLCBmdW5jKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBvcHRpbWl6ZXJzIF0tLS0tLSAqL1xuXG4gICAgT1BUKEFTVF9EaXJlY3RpdmUsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi5zY29wZS5oYXNfZGlyZWN0aXZlKHNlbGYudmFsdWUpICE9PSBzZWxmLnNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0RlYnVnZ2VyLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZHJvcF9kZWJ1Z2dlclwiKSlcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAmJiBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChzZWxmLmJvZHkubGFiZWwpID09PSBzZWxmLmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5sYWJlbC5yZWZlcmVuY2VzLmxlbmd0aCA9PSAwID8gc2VsZi5ib2R5IDogc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQmxvY2ssIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmLmJvZHkgPSB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Jsb2NrU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHNlbGYuYm9keVswXTtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIEFTVF9TY29wZS5ERUZNRVRIT0QoXCJkcm9wX3VudXNlZFwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIilcbiAgICAgICAgICAgICYmICEoc2VsZiBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbClcbiAgICAgICAgICAgICYmICFzZWxmLnVzZXNfZXZhbFxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBpbl91c2UgPSBbXTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXphdGlvbnMgPSBuZXcgRGljdGlvbmFyeSgpO1xuICAgICAgICAgICAgLy8gcGFzcyAxOiBmaW5kIG91dCB3aGljaCBzeW1ib2xzIGFyZSBkaXJlY3RseSB1c2VkIGluXG4gICAgICAgICAgICAvLyB0aGlzIHNjb3BlIChub3QgaW4gbmVzdGVkIHNjb3BlcykuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCl7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9ucy5hZGQobm9kZS5uYW1lLm5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGRvbid0IGdvIGluIG5lc3RlZCBzY29wZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiBzY29wZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvbnMuYWRkKGRlZi5uYW1lLm5hbWUsIGRlZi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUuaGFzX3NpZGVfZWZmZWN0cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF91bmlxKGluX3VzZSwgbm9kZS5kZWZpbml0aW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi53YWxrKHR3KTtcbiAgICAgICAgICAgIC8vIHBhc3MgMjogZm9yIGV2ZXJ5IHVzZWQgc3ltYm9sIHdlIG5lZWQgdG8gd2FsayBpdHNcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uIGNvZGUgdG8gZmlndXJlIG91dCBpZiBpdCB1c2VzIG90aGVyXG4gICAgICAgICAgICAvLyBzeW1ib2xzICh0aGF0IG1heSBub3QgYmUgaW5fdXNlKS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5fdXNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5fdXNlW2ldLm9yaWcuZm9yRWFjaChmdW5jdGlvbihkZWNsKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWNsYXJlZCBnbG9iYWxzIHdpbGwgYmUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gaW5pdGlhbGl6YXRpb25zLmdldChkZWNsLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdCkgaW5pdC5mb3JFYWNoKGZ1bmN0aW9uKGluaXQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfdW5pcShpbl91c2UsIG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGFzcyAzOiB3ZSBzaG91bGQgZHJvcCBkZWNsYXJhdGlvbnMgbm90IGluX3VzZVxuICAgICAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiZWZvcmUobm9kZSwgZGVzY2VuZCwgaW5fbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgIShub2RlIGluc3RhbmNlb2YgQVNUX0FjY2Vzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5vZGUuYXJnbmFtZXMsIGkgPSBhLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bS51bnJlZmVyZW5jZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnVzZWQgZnVuY3Rpb24gYXJndW1lbnQge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogc3ltLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIDogc3ltLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIDogc3ltLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogc3ltLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biAmJiBub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lbWJlcihub2RlLm5hbWUuZGVmaW5pdGlvbigpLCBpbl91c2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiRHJvcHBpbmcgdW51c2VkIGZ1bmN0aW9uIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogbm9kZS5uYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgOiBub2RlLm5hbWUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA6IG5vZGUubmFtZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogbm9kZS5uYW1lLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zICYmICEodHQucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfRm9ySW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gbm9kZS5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKGRlZi5uYW1lLmRlZmluaXRpb24oKSwgaW5fdXNlKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgOiBkZWYubmFtZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIDogZGVmLm5hbWUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA6IGRlZi5uYW1lLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAgOiBkZWYubmFtZS5zdGFydC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUgJiYgZGVmLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuX3VudXNlZF9zaWRlX2VmZmVjdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJTaWRlIGVmZmVjdHMgaW4gaW5pdGlhbGl6YXRpb24gb2YgdW51c2VkIHZhcmlhYmxlIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnVzZWQgdmFyaWFibGUge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIHVuaW5pdGlhbGl6ZWQgbmFtZXMgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYgPSBtZXJnZVNvcnQoZGVmLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEudmFsdWUgJiYgYi52YWx1ZSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYi52YWx1ZSAmJiBhLnZhbHVlKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVudXNlZCBuYW1lcyB3aG9zZSBpbml0aWFsaXphdGlvbiBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZGUgZWZmZWN0cywgd2UgY2FuIGNhc2NhZGUgdGhlIGluaXQuIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIG5leHQgb25lLCBvciBuZXh0IHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlX2VmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGRlZltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeC5fdW51c2VkX3NpZGVfZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZV9lZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cy5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC52YWx1ZSA9IEFTVF9TZXEuZnJvbV9hcnJheShzaWRlX2VmZmVjdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cyA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogWyBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogQVNUX1NlcS5mcm9tX2FycmF5KHNpZGVfZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPT0gMCAmJiAhc2lkZV9lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlX2VmZmVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlZmluaXRpb25zID0gZGVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cy5ib2R5LnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNpZGVfZWZmZWN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvciAmJiBub2RlLmluaXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbWJpbmF0aW9uIG9mIHVudXNlZCBuYW1lICsgc2lkZSBlZmZlY3QgbGVhZHMgdG86XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNDRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQncyBhbiBpbnZhbGlkIEFTVC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZpeCBpdCBhdCB0aGlzIHN0YWdlIGJ5IG1vdmluZyB0aGUgYHZhcmAgb3V0c2lkZSB0aGUgYGZvcmAuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG5vZGUuaW5pdC5ib2R5LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5pdCA9IG5vZGUuaW5pdC5ib2R5LnNsaWNlKC0xKVswXS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc3BsaWNlKGJvZHkpIDogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm0odHQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBBU1RfU2NvcGUuREVGTUVUSE9EKFwiaG9pc3RfZGVjbGFyYXRpb25zXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgaG9pc3RfZnVucyA9IGNvbXByZXNzb3Iub3B0aW9uKFwiaG9pc3RfZnVuc1wiKTtcbiAgICAgICAgdmFyIGhvaXN0X3ZhcnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3ZhcnNcIik7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGhvaXN0X2Z1bnMgfHwgaG9pc3RfdmFycykge1xuICAgICAgICAgICAgdmFyIGRpcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBob2lzdGVkID0gW107XG4gICAgICAgICAgICB2YXIgdmFycyA9IG5ldyBEaWN0aW9uYXJ5KCksIHZhcnNfZm91bmQgPSAwLCB2YXJfZGVjbCA9IDA7XG4gICAgICAgICAgICAvLyBsZXQncyBjb3VudCB2YXJfZGVjbCBmaXJzdCwgd2Ugc2VlbSB0byB3YXN0ZSBhIGxvdCBvZlxuICAgICAgICAgICAgLy8gc3BhY2UgaWYgd2UgaG9pc3QgYHZhcmAgd2hlbiB0aGVyZSdzIG9ubHkgb25lLlxuICAgICAgICAgICAgc2VsZi53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Zhcikge1xuICAgICAgICAgICAgICAgICAgICArK3Zhcl9kZWNsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBob2lzdF92YXJzID0gaG9pc3RfdmFycyAmJiB2YXJfZGVjbCA+IDE7XG4gICAgICAgICAgICB2YXIgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gJiYgaG9pc3RfZnVucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0ZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXIgJiYgaG9pc3RfdmFycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChkZWYubmFtZS5uYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3ZhcnNfZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcSA9IG5vZGUudG9fYXNzaWdubWVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHR0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0ZvckluICYmIHAuaW5pdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxID09IG51bGwpIHJldHVybiBub2RlLmRlZmluaXRpb25zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0ZvciAmJiBwLmluaXQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXEpIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTsgLy8gdG8gYXZvaWQgZGVzY2VuZGluZyBpbiBuZXN0ZWQgc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZiA9IHNlbGYudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgIGlmICh2YXJzX2ZvdW5kID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Qgb25seSB2YXJzIHdoaWNoIGRvbid0IHNob3cgdXAgaW4gc2VsZidzIGFyZ3VtZW50cyBsaXN0XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXJzLmVhY2goZnVuY3Rpb24oZGVmLCBuYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBmaW5kX2lmKGZ1bmN0aW9uKHgpeyByZXR1cm4geC5uYW1lID09IGRlZi5uYW1lLm5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmduYW1lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuZGVsKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gZGVmLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gbWVyZ2UgaW4gYXNzaWdubWVudHNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmJvZHkubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHNlbGYuYm9keVtpXS5ib2R5LCBzeW0sIGFzc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXhwci5vcGVyYXRvciA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc3ltID0gZXhwci5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmFycy5oYXMoc3ltLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHZhcnMuZ2V0KHN5bS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGV4cHIucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShkZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX1NlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYXNzaWduID0gZXhwci5jYXIpIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhc3NpZ24ub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSA9IGFzc2lnbi5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmFycy5oYXMoc3ltLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHZhcnMuZ2V0KHN5bS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGFzc2lnbi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGRlZnMsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHlbaV0uYm9keSA9IGV4cHIuY2RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gWyBpLCAxIF0uY29uY2F0KHNlbGYuYm9keVtpXS5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlLmFwcGx5KHNlbGYuYm9keSwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBtYWtlX25vZGUoQVNUX1Zhciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IGRlZnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0ZWQucHVzaChkZWZzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5ib2R5ID0gZGlycy5jb25jYXQoaG9pc3RlZCwgc2VsZi5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuYm9keS5oYXNfc2lkZV9lZmZlY3RzKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyBzaWRlLWVmZmVjdC1mcmVlIHN0YXRlbWVudCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9EV0xvb3AsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGNvbmRbMF07XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRm9yLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuYm9keVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX1doaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmJvZHksIGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBmdW5jdGlvbiBkcm9wX2l0KHJlc3QpIHtcbiAgICAgICAgICAgIHJlc3QgPSBhc19zdGF0ZW1lbnRfYXJyYXkocmVzdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5LmJvZHkgPSByZXN0LmNvbmNhdChzZWxmLmJvZHkuYm9keS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZi5ib2R5LCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlc3RcbiAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9IHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCA/IHNlbGYuYm9keS5ib2R5WzBdIDogc2VsZi5ib2R5O1xuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdC5ib2R5IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoZmlyc3QuYm9keS5sYWJlbCkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmaXJzdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGZpcnN0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3BfaXQoZmlyc3QuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGZpcnN0LmFsdGVybmF0aXZlLmxhYmVsKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZpcnN0LmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBmaXJzdC5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3BfaXQoZmlyc3QuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgT1BUKEFTVF9XaGlsZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwibG9vcHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBzZWxmID0gQVNUX0RXTG9vcC5wcm90b3R5cGUub3B0aW1pemUuY2FsbChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfV2hpbGUpIHtcbiAgICAgICAgICAgIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHNlbGYpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRm9yLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQpIHtcbiAgICAgICAgICAgIGNvbmQgPSBjb25kLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBjb25kWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjb25kKSB7XG4gICAgICAgICAgICBpZiAoY29uZC5sZW5ndGggPiAxICYmICFjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmluaXQgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5pbml0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5pbml0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICAvLyBpZiBjb25kaXRpb24gY2FuIGJlIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCwgd2FybiBhbmQgZHJvcFxuICAgICAgICAvLyBvbmUgb2YgdGhlIGJsb2Nrcy4gIG5vdGUsIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCBpbXBsaWVzXG4gICAgICAgIC8vIOKAnGhhcyBubyBzaWRlIGVmZmVjdHPigJ07IGFsc28gaXQgZG9lc24ndCB3b3JrIGZvciBjYXNlcyBsaWtlXG4gICAgICAgIC8vIGB4ICYmIHRydWVgLCB0aG91Z2ggaXQgcHJvYmFibHkgc2hvdWxkLlxuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGNvbmRbMF07XG4gICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLmNvbmRpdGlvbi5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5hbHRlcm5hdGl2ZSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHNlbGYuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5jb25kaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIGEucHVzaChzZWxmLmFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYSB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc19lbXB0eShzZWxmLmFsdGVybmF0aXZlKSkgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgIHZhciBuZWdhdGVkID0gc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICB2YXIgbmVnYXRlZF9pc19iZXN0ID0gYmVzdF9vZihzZWxmLmNvbmRpdGlvbiwgbmVnYXRlZCkgPT09IG5lZ2F0ZWQ7XG4gICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlICYmIG5lZ2F0ZWRfaXNfYmVzdCkge1xuICAgICAgICAgICAgbmVnYXRlZF9pc19iZXN0ID0gZmFsc2U7IC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgc3dpdGNoIGhlcmUuXG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG5lZ2F0ZWQ7XG4gICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5ib2R5O1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5hbHRlcm5hdGl2ZSB8fCBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50KTtcbiAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2VtcHR5KHNlbGYuYm9keSkgJiYgaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS5ib2R5LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IHNlbGYuYWx0ZXJuYXRpdmUuYm9keVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2VtcHR5KHNlbGYuYWx0ZXJuYXRpdmUpICYmIHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChuZWdhdGVkX2lzX2Jlc3QpIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IG5lZ2F0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnRcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwifHxcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmFsdGVybmF0aXZlLmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9FeGl0XG4gICAgICAgICAgICAmJiBzZWxmLmJvZHkuVFlQRSA9PSBzZWxmLmFsdGVybmF0aXZlLlRZUEUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoc2VsZi5ib2R5LkNUT1IsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS52YWx1ZSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5ib2R5KS5vcHRpbWl6ZShjb21wcmVzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBzZWxmLmFsdGVybmF0aXZlLnZhbHVlIHx8IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmLmFsdGVybmF0aXZlKS5vcHRpbWl6ZShjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9JZlxuICAgICAgICAgICAgJiYgIXNlbGYuYm9keS5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgJiYgIXNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodDogc2VsZi5ib2R5LmNvbmRpdGlvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0cyhzZWxmLmJvZHkpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbHQgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYWx0IF1cbiAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0cyhzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBzZWxmLmJvZHk7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBuZWdhdGVkX2lzX2Jlc3QgPyBuZWdhdGVkIDogc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYm9keSBdXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID09IDAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuZXhwcmVzc2lvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgdmFyIGxhc3RfYnJhbmNoID0gc2VsZi5ib2R5W3NlbGYuYm9keS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2JyYW5jaCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gbGFzdF9icmFuY2guYm9keVtsYXN0X2JyYW5jaC5ib2R5Lmxlbmd0aCAtIDFdOyAvLyBsYXN0IHN0YXRlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxvb3BfYm9keShjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChzdGF0LmxhYmVsKSkgPT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfYnJhbmNoLmJvZHkucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfYnJhbmNoIGluc3RhbmNlb2YgQVNUX0RlZmF1bHQgJiYgbGFzdF9icmFuY2guYm9keS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIG91dDogaWYgKGV4cC5sZW5ndGggPT0gMikgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnN0YW50IGV4cHJlc3Npb25cbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IGV4cFswXTtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIGJyZWFrIG91dDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cFsxXTtcbiAgICAgICAgICAgIHZhciBpbl9pZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGluX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBydWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0dCA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCwgaW5fbGlzdCl7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gZGVzY2VuZCB0aGVzZSBub2RlIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaCAmJiBub2RlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWluZWQgPyBub2RlIDogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbm9kZS5ib2R5LnJlZHVjZShmdW5jdGlvbihhLCBicmFuY2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChicmFuY2guYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0lmIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYXZlID0gaW5faWY7XG4gICAgICAgICAgICAgICAgICAgIGluX2lmID0gIWluX2Jsb2NrO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpbl9pZiA9IHNhdmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFdpdGhCb2R5IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYXZlID0gaW5fYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGluX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5fYmxvY2sgPSBzYXZlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiB0aGlzLmxvb3Bjb250cm9sX3RhcmdldChub2RlLmxhYmVsKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5faWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1aW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5fYmxvY2spIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaEJyYW5jaCAmJiB0aGlzLnBhcmVudCgpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wcGVkKSByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Nhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBub2RlLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnb3QgYSBjYXNlIHdpdGggbm9uLWNvbnN0YW50IGV4cHJlc3Npb24sIGJhbGluZyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFsxXSA9PT0gdmFsdWUgfHwgc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydHMobm9kZSkpIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0dC5zdGFjayA9IGNvbXByZXNzb3Iuc3RhY2suc2xpY2UoKTsgLy8gc28gdGhhdCdzIGFibGUgdG8gc2VlIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgc2VsZiA9IHNlbGYudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBzZWxmKSB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcInJlbW92ZV9pbml0aWFsaXplcnNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7IGRlZi52YWx1ZSA9IG51bGwgfSk7XG4gICAgfSk7XG5cbiAgICBBU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwidG9fYXNzaWdubWVudHNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gdGhpcy5kZWZpbml0aW9ucy5yZWR1Y2UoZnVuY3Rpb24oYSwgZGVmKXtcbiAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBkZWYubmFtZSwgZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX25vZGUoQVNUX0Fzc2lnbiwgZGVmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBkZWYudmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAoYXNzaWdubWVudHMubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gQVNUX1NlcS5mcm9tX2FycmF5KGFzc2lnbm1lbnRzKTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi5kZWZpbml0aW9ucy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZiA9IEFTVF9MYW1iZGEucHJvdG90eXBlLm9wdGltaXplLmNhbGwoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYubmFtZSAmJiBzZWxmLm5hbWUudW5yZWZlcmVuY2VkKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgZXhwLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9BcnJheSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBzZWxmLmFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9PYmplY3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGwoc2VsZi5hcmdzLCBmdW5jdGlvbih4KXsgcmV0dXJuIHggaW5zdGFuY2VvZiBBU1RfU3RyaW5nIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBxdWl0ZSBhIGNvcm5lci1jYXNlLCBidXQgd2UgY2FuIGhhbmRsZSBpdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzIwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvZGUgYXJndW1lbnQgaXMgYSBjb25zdGFudCwgdGhlbiB3ZSBjYW4gbWluaWZ5IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IFwiKGZ1bmN0aW9uKFwiICsgc2VsZi5hcmdzLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24oYXJnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiKXtcIiArIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0udmFsdWUgKyBcIn0pKClcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gcGFyc2UoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IG5ldyBDb21wcmVzc29yKGNvbXByZXNzb3Iub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0ID0gYXN0LnRyYW5zZm9ybShjb21wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5tYW5nbGVfbmFtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuID0gYXN0LmJvZHlbMF0uYm9keS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gZnVuLmFyZ25hbWVzLm1hcChmdW5jdGlvbihhcmcsIGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYuYXJnc1tpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZy5wcmludF90b19zdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IE91dHB1dFN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFTVF9CbG9ja1N0YXRlbWVudC5wcm90b3R5cGUuX2NvZGVnZW4uY2FsbChmdW4sIGZ1biwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUudG9TdHJpbmcoKS5yZXBsYWNlKC9eXFx7fFxcfSQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgSlNfUGFyc2VfRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiRXJyb3IgcGFyc2luZyBjb2RlIHBhc3NlZCB0byBuZXcgRnVuY3Rpb24gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0uc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oZXgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfRG90ICYmIGV4cC5wcm9wZXJ0eSA9PSBcInRvU3RyaW5nXCIgJiYgc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHAuZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAmJiBzZWxmLmFyZ3MubGVuZ3RoID09IDBcbiAgICAgICAgICAgICAgICAmJiAhQVNUX0Jsb2NrLnByb3RvdHlwZS5oYXNfc2lkZV9lZmZlY3RzLmNhbGwoc2VsZi5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZikudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9OZXcsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiBleHAudW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChleHAubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIlJlZ0V4cFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9DYWxsLCBzZWxmLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9TZXEsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmICghc2VsZi5jYXIuaGFzX3NpZGVfZWZmZWN0cygpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3QgY29tcHJlc3MgKDEsZXZhbCkoc29tZXRoaW5nKSB0b1xuICAgICAgICAgICAgLy8gZXZhbChzb21ldGhpbmcpIGJlY2F1c2UgdGhhdCBjaGFuZ2VzIHRoZSBtZWFuaW5nIG9mXG4gICAgICAgICAgICAvLyBldmFsIChiZWNvbWVzIGxleGljYWwgaW5zdGVhZCBvZiBnbG9iYWwpLlxuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAoIShzZWxmLmNkciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLm5hbWUgPT0gXCJldmFsXCJcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgICAgICAgJiYgKHAgPSBjb21wcmVzc29yLnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNhc2NhZGVcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5jYXIubGVmdC5oYXNfc2lkZV9lZmZlY3RzKClcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmNhci5sZWZ0LmVxdWl2YWxlbnRfdG8oc2VsZi5jZHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNhci5oYXNfc2lkZV9lZmZlY3RzKClcbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5jZHIuaGFzX3NpZGVfZWZmZWN0cygpXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5jYXIuZXF1aXZhbGVudF90byhzZWxmLmNkcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfVW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9VbmFyeVBvc3RmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICByZXR1cm4gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICAgICAgdmFyIGUgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIGUub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gISFmb28gPT0+IGZvbywgaWYgd2UncmUgaW4gYm9vbGVhbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gdHlwZW9mIGFsd2F5cyByZXR1cm5zIGEgbm9uLWVtcHR5IHN0cmluZywgdGh1cyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIHRydWUgaW4gYm9vbGVhbnNcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuIGV4cHJlc3Npb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHNlbGYub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBlLm5lZ2F0ZShjb21wcmVzc29yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBBU1RfQmluYXJ5LkRFRk1FVEhPRChcImxpZnRfc2VxdWVuY2VzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzZXF1ZW5jZXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNlcS50b19hcnJheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IHgucG9wKCk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNlcSA9IEFTVF9TZXEuZnJvbV9hcnJheSh4KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1NlcVxuICAgICAgICAgICAgICAgICYmICEodGhpcy5vcGVyYXRvciA9PSBcInx8XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIiYmXCIpXG4gICAgICAgICAgICAgICAgJiYgIXRoaXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5yaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNlcS50b19hcnJheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSB4LnBvcCgpO1xuICAgICAgICAgICAgICAgIHgucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICBzZXEgPSBBU1RfU2VxLmZyb21fYXJyYXkoeCkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICB2YXIgY29tbXV0YXRpdmVPcGVyYXRvcnMgPSBtYWtlUHJlZGljYXRlKFwiPT0gPT09ICE9ICE9PSAqICYgfCBeXCIpO1xuXG4gICAgT1BUKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgcmV2ZXJzZSA9IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBhc21cIikgPyBub29wXG4gICAgICAgICAgICA6IGZ1bmN0aW9uKG9wLCBmb3JjZSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSB8fCAhKHNlbGYubGVmdC5oYXNfc2lkZV9lZmZlY3RzKCkgfHwgc2VsZi5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcCkgc2VsZi5vcGVyYXRvciA9IG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmIChjb21tdXRhdGl2ZU9wZXJhdG9ycyhzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiByaWdodCBpcyBhIGNvbnN0YW50LCB3aGF0ZXZlciBzaWRlIGVmZmVjdHMgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVmdCBzaWRlIG1pZ2h0IGhhdmUgY291bGQgbm90IGluZmx1ZW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXN1bHQuICBoZW5jZSwgZm9yY2Ugc3dpdGNoLlxuICAgICAgICAgICAgICAgIHJldmVyc2UobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZiA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNvbXBhcmlzb25zXCIpKSBzd2l0Y2ggKHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiPT09XCI6XG4gICAgICAgICAgY2FzZSBcIiE9PVwiOlxuICAgICAgICAgICAgaWYgKChzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpICYmIHNlbGYucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmxlZnQuaXNfYm9vbGVhbigpICYmIHNlbGYucmlnaHQuaXNfYm9vbGVhbigpKSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBzZWxmLm9wZXJhdG9yLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFhYWDogaW50ZW50aW9uYWxseSBmYWxsaW5nIGRvd24gdG8gdGhlIG5leHQgY2FzZVxuICAgICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQudmFsdWUgPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwidHlwZW9mXCJcbiAgICAgICAgICAgICAgICAmJiBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghKHNlbGYucmlnaHQuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFzZWxmLnJpZ2h0LmV4cHJlc3Npb24udW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdCA9IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmLmxlZnQpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvci5sZW5ndGggPT0gMikgc2VsZi5vcGVyYXRvciArPSBcIj1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJib29sZWFuc1wiKSAmJiBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSBzd2l0Y2ggKHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgIHZhciBsbCA9IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHZhciByciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoKGxsLmxlbmd0aCA+IDEgJiYgIWxsWzFdKSB8fCAocnIubGVuZ3RoID4gMSAmJiAhcnJbMV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQm9vbGVhbiAmJiBhbHdheXMgZmFsc2UgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0ZhbHNlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsbC5sZW5ndGggPiAxICYmIGxsWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJyWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJyLmxlbmd0aCA+IDEgJiYgcnJbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGxbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwifHxcIjpcbiAgICAgICAgICAgIHZhciBsbCA9IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHZhciByciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoKGxsLmxlbmd0aCA+IDEgJiYgbGxbMV0pIHx8IChyci5sZW5ndGggPiAxICYmIHJyWzFdKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkJvb2xlYW4gfHwgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxsLmxlbmd0aCA+IDEgJiYgIWxsWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJyWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJyLmxlbmd0aCA+IDEgJiYgIXJyWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxsWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIHZhciBsbCA9IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHZhciByciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoKGxsLmxlbmd0aCA+IDEgJiYgbGxbMF0gaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIGxsWzFdKSB8fFxuICAgICAgICAgICAgICAgIChyci5sZW5ndGggPiAxICYmIHJyWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiByclsxXSkpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCIrIGluIGJvb2xlYW4gY29udGV4dCBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwID0gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGV4cC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoYmVzdF9vZihleHBbMF0sIHNlbGYpICE9PSBzZWxmKVxuICAgICAgICAgICAgICAgIHJldHVybiBleHBbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29tcGFyaXNvbnNcIikpIHtcbiAgICAgICAgICAgIGlmICghKGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KVxuICAgICAgICAgICAgICAgIHx8IGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZWQgPSBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5uZWdhdGUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBuZWdhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiOiByZXZlcnNlKFwiPlwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiOiByZXZlcnNlKFwiPj1cIik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmdldFZhbHVlKCkgPT09IFwiXCIgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgdmFyIGRlZmluZXMgPSBjb21wcmVzc29yLm9wdGlvbihcImdsb2JhbF9kZWZzXCIpO1xuICAgICAgICAgICAgaWYgKGRlZmluZXMgJiYgZGVmaW5lcy5oYXNPd25Qcm9wZXJ0eShzZWxmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIGRlZmluZXNbc2VsZi5uYW1lXSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX05hTiwgc2VsZik7XG4gICAgICAgICAgICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0luZmluaXR5LCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5kZWZpbmVkLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9TY29wZSk7XG4gICAgICAgICAgICB2YXIgdW5kZWYgPSBzY29wZS5maW5kX3ZhcmlhYmxlKFwidW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgaWYgKHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgICA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICA6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICB0aGVkZWYgOiB1bmRlZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlZi5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgdmFyIEFTU0lHTl9PUFMgPSBbICcrJywgJy0nLCAnLycsICcqJywgJyUnLCAnPj4nLCAnPDwnLCAnPj4+JywgJ3wnLCAnXicsICcmJyBdO1xuICAgIE9QVChBU1RfQXNzaWduLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZiA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0Lm5hbWUgPT0gc2VsZi5sZWZ0Lm5hbWVcbiAgICAgICAgICAgICYmIG1lbWJlcihzZWxmLnJpZ2h0Lm9wZXJhdG9yLCBBU1NJR05fT1BTKSkge1xuICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IHNlbGYucmlnaHQub3BlcmF0b3IgKyBcIj1cIjtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24gaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICB2YXIgY2FyID0gc2VsZi5jb25kaXRpb24uY2FyO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi5jZHI7XG4gICAgICAgICAgICByZXR1cm4gQVNUX1NlcS5jb25zKGNhciwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGNvbmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvbmRbMV0pIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkNvbmRpdGlvbiBhbHdheXMgZmFsc2UgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZWdhdGVkID0gY29uZFswXS5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChiZXN0X29mKGNvbmRbMF0sIG5lZ2F0ZWQpID09PSBuZWdhdGVkKSB7XG4gICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogbmVnYXRlZCxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBzZWxmLmFsdGVybmF0aXZlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBzZWxmLmNvbnNlcXVlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zZXF1ZW50ID0gc2VsZi5jb25zZXF1ZW50O1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICBpZiAoY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmIGFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5vcGVyYXRvciA9PSBhbHRlcm5hdGl2ZS5vcGVyYXRvclxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5sZWZ0LmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUubGVmdClcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogU3R1ZmYgbGlrZSB0aGlzOlxuICAgICAgICAgICAgICogaWYgKGZvbykgZXhwID0gc29tZXRoaW5nOyBlbHNlIGV4cCA9IHNvbWV0aGluZ19lbHNlO1xuICAgICAgICAgICAgICogPT0+XG4gICAgICAgICAgICAgKiBleHAgPSBmb28gPyBzb21ldGhpbmcgOiBzb21ldGhpbmdfZWxzZTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQXNzaWduLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvbnNlcXVlbnQub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdDogY29uc2VxdWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRlcm5hdGl2ZS5yaWdodFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQm9vbGVhbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgKHAub3BlcmF0b3IgPT0gXCI9PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCIhPVwiKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIk5vbi1zdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCBib29sZWFuOiB7b3BlcmF0b3J9IHt2YWx1ZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBwLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHNlbGYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUgICAgIDogcC5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lICAgICA6IHAuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sICAgICAgOiBwLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICtzZWxmLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMSAtIHNlbGYudmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIGNvbXByZXNzb3Iub3B0aW9uKFwicHJvcGVydGllc1wiKSkge1xuICAgICAgICAgICAgcHJvcCA9IHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUyhwcm9wKSA/IGNvbXByZXNzb3Iub3B0aW9uKFwic2NyZXdfaWU4XCIpIDogaXNfaWRlbnRpZmllcl9zdHJpbmcocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Eb3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHNlbGYuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3BcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgT1BUKEFTVF9BcnJheSwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcbiAgICBPUFQoQVNUX09iamVjdCwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcbiAgICBPUFQoQVNUX1JlZ0V4cCwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcblxufSkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBmaXR6Z2VuJ3Mgc291cmNlLW1hcCBsaWJyYXJ5XG5mdW5jdGlvbiBTb3VyY2VNYXAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGZpbGUgOiBudWxsLFxuICAgICAgICByb290IDogbnVsbCxcbiAgICAgICAgb3JpZyA6IG51bGwsXG4gICAgfSk7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBNT1pfU291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGUgICAgICAgOiBvcHRpb25zLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3QgOiBvcHRpb25zLnJvb3RcbiAgICB9KTtcbiAgICB2YXIgb3JpZ19tYXAgPSBvcHRpb25zLm9yaWcgJiYgbmV3IE1PWl9Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIob3B0aW9ucy5vcmlnKTtcbiAgICBmdW5jdGlvbiBhZGQoc291cmNlLCBnZW5fbGluZSwgZ2VuX2NvbCwgb3JpZ19saW5lLCBvcmlnX2NvbCwgbmFtZSkge1xuICAgICAgICBpZiAob3JpZ19tYXApIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gb3JpZ19tYXAub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ19saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ19jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc291cmNlID0gaW5mby5zb3VyY2U7XG4gICAgICAgICAgICBvcmlnX2xpbmUgPSBpbmZvLmxpbmU7XG4gICAgICAgICAgICBvcmlnX2NvbCA9IGluZm8uY29sdW1uO1xuICAgICAgICAgICAgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBnZW5lcmF0ZWQgOiB7IGxpbmU6IGdlbl9saW5lLCBjb2x1bW46IGdlbl9jb2wgfSxcbiAgICAgICAgICAgIG9yaWdpbmFsICA6IHsgbGluZTogb3JpZ19saW5lLCBjb2x1bW46IG9yaWdfY29sIH0sXG4gICAgICAgICAgICBzb3VyY2UgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICBuYW1lICAgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkICAgICAgICA6IGFkZCxcbiAgICAgICAgZ2V0ICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2VuZXJhdG9yIH0sXG4gICAgICAgIHRvU3RyaW5nICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdlbmVyYXRvci50b1N0cmluZygpIH1cbiAgICB9O1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgTU9aX1RPX01FID0ge1xuICAgICAgICBUcnlTdGF0ZW1lbnQgOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ucnkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYm9keSAgICAgOiBmcm9tX21veihNLmJsb2NrKS5ib2R5LFxuICAgICAgICAgICAgICAgIGJjYXRjaCAgIDogZnJvbV9tb3ooTS5oYW5kbGVyc1swXSksXG4gICAgICAgICAgICAgICAgYmZpbmFsbHkgOiBNLmZpbmFsaXplciA/IG5ldyBBU1RfRmluYWxseShmcm9tX21veihNLmZpbmFsaXplcikpIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIENhdGNoQ2xhdXNlIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2F0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGFyZ25hbWUgOiBmcm9tX21veihNLnBhcmFtKSxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogZnJvbV9tb3ooTS5ib2R5KS5ib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbiA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA6IE0ucHJvcGVydGllcy5tYXAoZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBrZXkudHlwZSA9PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKHByb3AudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICAgICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBmcm9tX21veihwcm9wLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3Aua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RLZXlWYWwoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy52YWx1ZS5uYW1lID0gZnJvbV9tb3ooa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdFNldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnZhbHVlLm5hbWUgPSBmcm9tX21veihrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0R2V0dGVyKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gQVNUX1NlcS5mcm9tX2FycmF5KE0uZXhwcmVzc2lvbnMubWFwKGZyb21fbW96KSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLmNvbXB1dGVkID8gQVNUX1N1YiA6IEFTVF9Eb3QpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogTS5jb21wdXRlZCA/IGZyb21fbW96KE0ucHJvcGVydHkpIDogTS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLm9iamVjdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBTd2l0Y2hDYXNlIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS50ZXN0ID8gQVNUX0Nhc2UgOiBBU1RfRGVmYXVsdCkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLnRlc3QpLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBNLmNvbnNlcXVlbnQubWFwKGZyb21fbW96KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIExpdGVyYWwgOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gTS52YWx1ZSwgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBteV9lbmRfdG9rZW4oTSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gbmV3IEFTVF9OdWxsKGFyZ3MpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N0cmluZyhhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfTnVtYmVyKGFyZ3MpO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHZhbCA/IEFTVF9UcnVlIDogQVNUX0ZhbHNlKShhcmdzKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JlZ0V4cChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBGcm9tX01vel9VbmFyeSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogRnJvbV9Nb3pfVW5hcnksXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBwID0gRlJPTV9NT1pfU1RBQ0tbRlJPTV9NT1pfU1RBQ0subGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLm5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJMYWJlbGVkU3RhdGVtZW50XCIgPyBBU1RfTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIgJiYgcC5pZCA9PT0gTSA/IChwLmtpbmQgPT0gXCJjb25zdFwiID8gQVNUX1N5bWJvbENvbnN0IDogQVNUX1N5bWJvbFZhcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPyAocC5pZCA9PT0gTSA/IEFTVF9TeW1ib2xMYW1iZGEgOiBBU1RfU3ltYm9sRnVuYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyAocC5pZCA9PT0gTSA/IEFTVF9TeW1ib2xEZWZ1biA6IEFTVF9TeW1ib2xGdW5hcmcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkNhdGNoQ2xhdXNlXCIgPyBBU1RfU3ltYm9sQ2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiQnJlYWtTdGF0ZW1lbnRcIiB8fCBwLnR5cGUgPT0gXCJDb250aW51ZVN0YXRlbWVudFwiID8gQVNUX0xhYmVsUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEFTVF9TeW1ib2xSZWYpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgIDogTS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGcm9tX01vel9VbmFyeShNKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBcInByZWZpeFwiIGluIE0gPyBNLnByZWZpeFxuICAgICAgICAgICAgOiBNLnR5cGUgPT0gXCJVbmFyeUV4cHJlc3Npb25cIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyAocHJlZml4ID8gQVNUX1VuYXJ5UHJlZml4IDogQVNUX1VuYXJ5UG9zdGZpeCkoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgIG9wZXJhdG9yICAgOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGZyb21fbW96KE0uYXJndW1lbnQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgTUVfVE9fTU9aID0ge307XG5cbiAgICBtYXAoXCJOb2RlXCIsIEFTVF9Ob2RlKTtcbiAgICBtYXAoXCJQcm9ncmFtXCIsIEFTVF9Ub3BsZXZlbCwgXCJib2R5QGJvZHlcIik7XG4gICAgbWFwKFwiRnVuY3Rpb25cIiwgQVNUX0Z1bmN0aW9uLCBcImlkPm5hbWUsIHBhcmFtc0BhcmduYW1lcywgYm9keSVib2R5XCIpO1xuICAgIG1hcChcIkVtcHR5U3RhdGVtZW50XCIsIEFTVF9FbXB0eVN0YXRlbWVudCk7XG4gICAgbWFwKFwiQmxvY2tTdGF0ZW1lbnRcIiwgQVNUX0Jsb2NrU3RhdGVtZW50LCBcImJvZHlAYm9keVwiKTtcbiAgICBtYXAoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIEFTVF9TaW1wbGVTdGF0ZW1lbnQsIFwiZXhwcmVzc2lvbj5ib2R5XCIpO1xuICAgIG1hcChcIklmU3RhdGVtZW50XCIsIEFTVF9JZiwgXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5ib2R5LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIik7XG4gICAgbWFwKFwiTGFiZWxlZFN0YXRlbWVudFwiLCBBU1RfTGFiZWxlZFN0YXRlbWVudCwgXCJsYWJlbD5sYWJlbCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkJyZWFrU3RhdGVtZW50XCIsIEFTVF9CcmVhaywgXCJsYWJlbD5sYWJlbFwiKTtcbiAgICBtYXAoXCJDb250aW51ZVN0YXRlbWVudFwiLCBBU1RfQ29udGludWUsIFwibGFiZWw+bGFiZWxcIik7XG4gICAgbWFwKFwiV2l0aFN0YXRlbWVudFwiLCBBU1RfV2l0aCwgXCJvYmplY3Q+ZXhwcmVzc2lvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIlN3aXRjaFN0YXRlbWVudFwiLCBBU1RfU3dpdGNoLCBcImRpc2NyaW1pbmFudD5leHByZXNzaW9uLCBjYXNlc0Bib2R5XCIpO1xuICAgIG1hcChcIlJldHVyblN0YXRlbWVudFwiLCBBU1RfUmV0dXJuLCBcImFyZ3VtZW50PnZhbHVlXCIpO1xuICAgIG1hcChcIlRocm93U3RhdGVtZW50XCIsIEFTVF9UaHJvdywgXCJhcmd1bWVudD52YWx1ZVwiKTtcbiAgICBtYXAoXCJXaGlsZVN0YXRlbWVudFwiLCBBU1RfV2hpbGUsIFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJEb1doaWxlU3RhdGVtZW50XCIsIEFTVF9EbywgXCJ0ZXN0PmNvbmRpdGlvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkZvclN0YXRlbWVudFwiLCBBU1RfRm9yLCBcImluaXQ+aW5pdCwgdGVzdD5jb25kaXRpb24sIHVwZGF0ZT5zdGVwLCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRm9ySW5TdGF0ZW1lbnRcIiwgQVNUX0ZvckluLCBcImxlZnQ+aW5pdCwgcmlnaHQ+b2JqZWN0LCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgQVNUX0RlYnVnZ2VyKTtcbiAgICBtYXAoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIEFTVF9EZWZ1biwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIEFTVF9WYXIsIFwiZGVjbGFyYXRpb25zQGRlZmluaXRpb25zXCIpO1xuICAgIG1hcChcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCBBU1RfVmFyRGVmLCBcImlkPm5hbWUsIGluaXQ+dmFsdWVcIik7XG5cbiAgICBtYXAoXCJUaGlzRXhwcmVzc2lvblwiLCBBU1RfVGhpcyk7XG4gICAgbWFwKFwiQXJyYXlFeHByZXNzaW9uXCIsIEFTVF9BcnJheSwgXCJlbGVtZW50c0BlbGVtZW50c1wiKTtcbiAgICBtYXAoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgQVNUX0Z1bmN0aW9uLCBcImlkPm5hbWUsIHBhcmFtc0BhcmduYW1lcywgYm9keSVib2R5XCIpO1xuICAgIG1hcChcIkJpbmFyeUV4cHJlc3Npb25cIiwgQVNUX0JpbmFyeSwgXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKTtcbiAgICBtYXAoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBBU1RfQXNzaWduLCBcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpO1xuICAgIG1hcChcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIEFTVF9CaW5hcnksIFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIik7XG4gICAgbWFwKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIEFTVF9Db25kaXRpb25hbCwgXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5jb25zZXF1ZW50LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIik7XG4gICAgbWFwKFwiTmV3RXhwcmVzc2lvblwiLCBBU1RfTmV3LCBcImNhbGxlZT5leHByZXNzaW9uLCBhcmd1bWVudHNAYXJnc1wiKTtcbiAgICBtYXAoXCJDYWxsRXhwcmVzc2lvblwiLCBBU1RfQ2FsbCwgXCJjYWxsZWU+ZXhwcmVzc2lvbiwgYXJndW1lbnRzQGFyZ3NcIik7XG5cbiAgICAvKiAtLS0tLVsgdG9vbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBteV9zdGFydF90b2tlbihtb3pub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHtcbiAgICAgICAgICAgIGZpbGUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnNvdXJjZSxcbiAgICAgICAgICAgIGxpbmUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBwb3MgICAgOiBtb3pub2RlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kcG9zIDogbW96bm9kZS5zdGFydFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbXlfZW5kX3Rva2VuKG1vem5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oe1xuICAgICAgICAgICAgZmlsZSAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2Muc291cmNlLFxuICAgICAgICAgICAgbGluZSAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2MuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2wgICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5lbmQuY29sdW1uLFxuICAgICAgICAgICAgcG9zICAgIDogbW96bm9kZS5lbmQsXG4gICAgICAgICAgICBlbmRwb3MgOiBtb3pub2RlLmVuZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwKG1venR5cGUsIG15dHlwZSwgcHJvcG1hcCkge1xuICAgICAgICB2YXIgbW96X3RvX21lID0gXCJmdW5jdGlvbiBGcm9tX01vel9cIiArIG1venR5cGUgKyBcIihNKXtcXG5cIjtcbiAgICAgICAgbW96X3RvX21lICs9IFwicmV0dXJuIG5ldyBteXR5cGUoe1xcblwiICtcbiAgICAgICAgICAgIFwic3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxcblwiICtcbiAgICAgICAgICAgIFwiZW5kOiBteV9lbmRfdG9rZW4oTSlcIjtcblxuICAgICAgICBpZiAocHJvcG1hcCkgcHJvcG1hcC5zcGxpdCgvXFxzKixcXHMqLykuZm9yRWFjaChmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHZhciBtID0gLyhbYS16MC05JF9dKykoPXxAfD58JSkoW2EtejAtOSRfXSspL2kuZXhlYyhwcm9wKTtcbiAgICAgICAgICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdW5kZXJzdGFuZCBwcm9wZXJ0eSBtYXA6IFwiICsgcHJvcCk7XG4gICAgICAgICAgICB2YXIgbW96ID0gXCJNLlwiICsgbVsxXSwgaG93ID0gbVsyXSwgbXkgPSBtWzNdO1xuICAgICAgICAgICAgbW96X3RvX21lICs9IFwiLFxcblwiICsgbXkgKyBcIjogXCI7XG4gICAgICAgICAgICBpZiAoaG93ID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IG1veiArIFwiLm1hcChmcm9tX21veilcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooXCIgKyBtb3ogKyBcIilcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IG1vejtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiJVwiKSB7XG4gICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooXCIgKyBtb3ogKyBcIikuYm9keVwiO1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVuZGVyc3RhbmQgb3BlcmF0b3IgaW4gcHJvcG1hcDogXCIgKyBwcm9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vel90b19tZSArPSBcIlxcbn0pfVwiO1xuXG4gICAgICAgIC8vIG1vel90b19tZSA9IHBhcnNlKG1vel90b19tZSkucHJpbnRfdG9fc3RyaW5nKHsgYmVhdXRpZnk6IHRydWUgfSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1vel90b19tZSk7XG5cbiAgICAgICAgbW96X3RvX21lID0gbmV3IEZ1bmN0aW9uKFwibXl0eXBlXCIsIFwibXlfc3RhcnRfdG9rZW5cIiwgXCJteV9lbmRfdG9rZW5cIiwgXCJmcm9tX21velwiLCBcInJldHVybihcIiArIG1vel90b19tZSArIFwiKVwiKShcbiAgICAgICAgICAgIG15dHlwZSwgbXlfc3RhcnRfdG9rZW4sIG15X2VuZF90b2tlbiwgZnJvbV9tb3pcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIE1PWl9UT19NRVttb3p0eXBlXSA9IG1vel90b19tZTtcbiAgICB9O1xuXG4gICAgdmFyIEZST01fTU9aX1NUQUNLID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGZyb21fbW96KG5vZGUpIHtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sucHVzaChub2RlKTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUgIT0gbnVsbCA/IE1PWl9UT19NRVtub2RlLnR5cGVdKG5vZGUpIDogbnVsbDtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sucG9wKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIEFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QgPSBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHNhdmVfc3RhY2sgPSBGUk9NX01PWl9TVEFDSztcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sgPSBbXTtcbiAgICAgICAgdmFyIGFzdCA9IGZyb21fbW96KG5vZGUpO1xuICAgICAgICBGUk9NX01PWl9TVEFDSyA9IHNhdmVfc3RhY2s7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcblxufSkoKTtcblxuXG5leHBvcnRzLnN5cyA9IHN5cztcbmV4cG9ydHMuTU9aX1NvdXJjZU1hcCA9IE1PWl9Tb3VyY2VNYXA7XG5leHBvcnRzLlVnbGlmeUpTID0gVWdsaWZ5SlM7XG5leHBvcnRzLmFycmF5X3RvX2hhc2ggPSBhcnJheV90b19oYXNoO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy5jaGFyYWN0ZXJzID0gY2hhcmFjdGVycztcbmV4cG9ydHMubWVtYmVyID0gbWVtYmVyO1xuZXhwb3J0cy5maW5kX2lmID0gZmluZF9pZjtcbmV4cG9ydHMucmVwZWF0X3N0cmluZyA9IHJlcGVhdF9zdHJpbmc7XG5leHBvcnRzLkRlZmF1bHRzRXJyb3IgPSBEZWZhdWx0c0Vycm9yO1xuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuTUFQID0gTUFQO1xuZXhwb3J0cy5wdXNoX3VuaXEgPSBwdXNoX3VuaXE7XG5leHBvcnRzLnN0cmluZ190ZW1wbGF0ZSA9IHN0cmluZ190ZW1wbGF0ZTtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZXhwb3J0cy5tZXJnZVNvcnQgPSBtZXJnZVNvcnQ7XG5leHBvcnRzLnNldF9kaWZmZXJlbmNlID0gc2V0X2RpZmZlcmVuY2U7XG5leHBvcnRzLnNldF9pbnRlcnNlY3Rpb24gPSBzZXRfaW50ZXJzZWN0aW9uO1xuZXhwb3J0cy5tYWtlUHJlZGljYXRlID0gbWFrZVByZWRpY2F0ZTtcbmV4cG9ydHMuYWxsID0gYWxsO1xuZXhwb3J0cy5EaWN0aW9uYXJ5ID0gRGljdGlvbmFyeTtcbmV4cG9ydHMuREVGTk9ERSA9IERFRk5PREU7XG5leHBvcnRzLkFTVF9Ub2tlbiA9IEFTVF9Ub2tlbjtcbmV4cG9ydHMuQVNUX05vZGUgPSBBU1RfTm9kZTtcbmV4cG9ydHMuQVNUX1N0YXRlbWVudCA9IEFTVF9TdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9EZWJ1Z2dlciA9IEFTVF9EZWJ1Z2dlcjtcbmV4cG9ydHMuQVNUX0RpcmVjdGl2ZSA9IEFTVF9EaXJlY3RpdmU7XG5leHBvcnRzLkFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBBU1RfU2ltcGxlU3RhdGVtZW50O1xuZXhwb3J0cy53YWxrX2JvZHkgPSB3YWxrX2JvZHk7XG5leHBvcnRzLkFTVF9CbG9jayA9IEFTVF9CbG9jaztcbmV4cG9ydHMuQVNUX0Jsb2NrU3RhdGVtZW50ID0gQVNUX0Jsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRW1wdHlTdGF0ZW1lbnQgPSBBU1RfRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9TdGF0ZW1lbnRXaXRoQm9keSA9IEFTVF9TdGF0ZW1lbnRXaXRoQm9keTtcbmV4cG9ydHMuQVNUX0xhYmVsZWRTdGF0ZW1lbnQgPSBBU1RfTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuQVNUX0RXTG9vcCA9IEFTVF9EV0xvb3A7XG5leHBvcnRzLkFTVF9EbyA9IEFTVF9EbztcbmV4cG9ydHMuQVNUX1doaWxlID0gQVNUX1doaWxlO1xuZXhwb3J0cy5BU1RfRm9yID0gQVNUX0ZvcjtcbmV4cG9ydHMuQVNUX0ZvckluID0gQVNUX0ZvckluO1xuZXhwb3J0cy5BU1RfV2l0aCA9IEFTVF9XaXRoO1xuZXhwb3J0cy5BU1RfU2NvcGUgPSBBU1RfU2NvcGU7XG5leHBvcnRzLkFTVF9Ub3BsZXZlbCA9IEFTVF9Ub3BsZXZlbDtcbmV4cG9ydHMuQVNUX0xhbWJkYSA9IEFTVF9MYW1iZGE7XG5leHBvcnRzLkFTVF9BY2Nlc3NvciA9IEFTVF9BY2Nlc3NvcjtcbmV4cG9ydHMuQVNUX0Z1bmN0aW9uID0gQVNUX0Z1bmN0aW9uO1xuZXhwb3J0cy5BU1RfRGVmdW4gPSBBU1RfRGVmdW47XG5leHBvcnRzLkFTVF9KdW1wID0gQVNUX0p1bXA7XG5leHBvcnRzLkFTVF9FeGl0ID0gQVNUX0V4aXQ7XG5leHBvcnRzLkFTVF9SZXR1cm4gPSBBU1RfUmV0dXJuO1xuZXhwb3J0cy5BU1RfVGhyb3cgPSBBU1RfVGhyb3c7XG5leHBvcnRzLkFTVF9Mb29wQ29udHJvbCA9IEFTVF9Mb29wQ29udHJvbDtcbmV4cG9ydHMuQVNUX0JyZWFrID0gQVNUX0JyZWFrO1xuZXhwb3J0cy5BU1RfQ29udGludWUgPSBBU1RfQ29udGludWU7XG5leHBvcnRzLkFTVF9JZiA9IEFTVF9JZjtcbmV4cG9ydHMuQVNUX1N3aXRjaCA9IEFTVF9Td2l0Y2g7XG5leHBvcnRzLkFTVF9Td2l0Y2hCcmFuY2ggPSBBU1RfU3dpdGNoQnJhbmNoO1xuZXhwb3J0cy5BU1RfRGVmYXVsdCA9IEFTVF9EZWZhdWx0O1xuZXhwb3J0cy5BU1RfQ2FzZSA9IEFTVF9DYXNlO1xuZXhwb3J0cy5BU1RfVHJ5ID0gQVNUX1RyeTtcbmV4cG9ydHMuQVNUX0NhdGNoID0gQVNUX0NhdGNoO1xuZXhwb3J0cy5BU1RfRmluYWxseSA9IEFTVF9GaW5hbGx5O1xuZXhwb3J0cy5BU1RfRGVmaW5pdGlvbnMgPSBBU1RfRGVmaW5pdGlvbnM7XG5leHBvcnRzLkFTVF9WYXIgPSBBU1RfVmFyO1xuZXhwb3J0cy5BU1RfQ29uc3QgPSBBU1RfQ29uc3Q7XG5leHBvcnRzLkFTVF9WYXJEZWYgPSBBU1RfVmFyRGVmO1xuZXhwb3J0cy5BU1RfQ2FsbCA9IEFTVF9DYWxsO1xuZXhwb3J0cy5BU1RfTmV3ID0gQVNUX05ldztcbmV4cG9ydHMuQVNUX1NlcSA9IEFTVF9TZXE7XG5leHBvcnRzLkFTVF9Qcm9wQWNjZXNzID0gQVNUX1Byb3BBY2Nlc3M7XG5leHBvcnRzLkFTVF9Eb3QgPSBBU1RfRG90O1xuZXhwb3J0cy5BU1RfU3ViID0gQVNUX1N1YjtcbmV4cG9ydHMuQVNUX1VuYXJ5ID0gQVNUX1VuYXJ5O1xuZXhwb3J0cy5BU1RfVW5hcnlQcmVmaXggPSBBU1RfVW5hcnlQcmVmaXg7XG5leHBvcnRzLkFTVF9VbmFyeVBvc3RmaXggPSBBU1RfVW5hcnlQb3N0Zml4O1xuZXhwb3J0cy5BU1RfQmluYXJ5ID0gQVNUX0JpbmFyeTtcbmV4cG9ydHMuQVNUX0NvbmRpdGlvbmFsID0gQVNUX0NvbmRpdGlvbmFsO1xuZXhwb3J0cy5BU1RfQXNzaWduID0gQVNUX0Fzc2lnbjtcbmV4cG9ydHMuQVNUX0FycmF5ID0gQVNUX0FycmF5O1xuZXhwb3J0cy5BU1RfT2JqZWN0ID0gQVNUX09iamVjdDtcbmV4cG9ydHMuQVNUX09iamVjdFByb3BlcnR5ID0gQVNUX09iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5BU1RfT2JqZWN0S2V5VmFsID0gQVNUX09iamVjdEtleVZhbDtcbmV4cG9ydHMuQVNUX09iamVjdFNldHRlciA9IEFTVF9PYmplY3RTZXR0ZXI7XG5leHBvcnRzLkFTVF9PYmplY3RHZXR0ZXIgPSBBU1RfT2JqZWN0R2V0dGVyO1xuZXhwb3J0cy5BU1RfU3ltYm9sID0gQVNUX1N5bWJvbDtcbmV4cG9ydHMuQVNUX1N5bWJvbEFjY2Vzc29yID0gQVNUX1N5bWJvbEFjY2Vzc29yO1xuZXhwb3J0cy5BU1RfU3ltYm9sRGVjbGFyYXRpb24gPSBBU1RfU3ltYm9sRGVjbGFyYXRpb247XG5leHBvcnRzLkFTVF9TeW1ib2xWYXIgPSBBU1RfU3ltYm9sVmFyO1xuZXhwb3J0cy5BU1RfU3ltYm9sQ29uc3QgPSBBU1RfU3ltYm9sQ29uc3Q7XG5leHBvcnRzLkFTVF9TeW1ib2xGdW5hcmcgPSBBU1RfU3ltYm9sRnVuYXJnO1xuZXhwb3J0cy5BU1RfU3ltYm9sRGVmdW4gPSBBU1RfU3ltYm9sRGVmdW47XG5leHBvcnRzLkFTVF9TeW1ib2xMYW1iZGEgPSBBU1RfU3ltYm9sTGFtYmRhO1xuZXhwb3J0cy5BU1RfU3ltYm9sQ2F0Y2ggPSBBU1RfU3ltYm9sQ2F0Y2g7XG5leHBvcnRzLkFTVF9MYWJlbCA9IEFTVF9MYWJlbDtcbmV4cG9ydHMuQVNUX1N5bWJvbFJlZiA9IEFTVF9TeW1ib2xSZWY7XG5leHBvcnRzLkFTVF9MYWJlbFJlZiA9IEFTVF9MYWJlbFJlZjtcbmV4cG9ydHMuQVNUX1RoaXMgPSBBU1RfVGhpcztcbmV4cG9ydHMuQVNUX0NvbnN0YW50ID0gQVNUX0NvbnN0YW50O1xuZXhwb3J0cy5BU1RfU3RyaW5nID0gQVNUX1N0cmluZztcbmV4cG9ydHMuQVNUX051bWJlciA9IEFTVF9OdW1iZXI7XG5leHBvcnRzLkFTVF9SZWdFeHAgPSBBU1RfUmVnRXhwO1xuZXhwb3J0cy5BU1RfQXRvbSA9IEFTVF9BdG9tO1xuZXhwb3J0cy5BU1RfTnVsbCA9IEFTVF9OdWxsO1xuZXhwb3J0cy5BU1RfTmFOID0gQVNUX05hTjtcbmV4cG9ydHMuQVNUX1VuZGVmaW5lZCA9IEFTVF9VbmRlZmluZWQ7XG5leHBvcnRzLkFTVF9Ib2xlID0gQVNUX0hvbGU7XG5leHBvcnRzLkFTVF9JbmZpbml0eSA9IEFTVF9JbmZpbml0eTtcbmV4cG9ydHMuQVNUX0Jvb2xlYW4gPSBBU1RfQm9vbGVhbjtcbmV4cG9ydHMuQVNUX0ZhbHNlID0gQVNUX0ZhbHNlO1xuZXhwb3J0cy5BU1RfVHJ1ZSA9IEFTVF9UcnVlO1xuZXhwb3J0cy5UcmVlV2Fsa2VyID0gVHJlZVdhbGtlcjtcbmV4cG9ydHMuS0VZV09SRFMgPSBLRVlXT1JEUztcbmV4cG9ydHMuS0VZV09SRFNfQVRPTSA9IEtFWVdPUkRTX0FUT007XG5leHBvcnRzLlJFU0VSVkVEX1dPUkRTID0gUkVTRVJWRURfV09SRFM7XG5leHBvcnRzLktFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT047XG5leHBvcnRzLk9QRVJBVE9SX0NIQVJTID0gT1BFUkFUT1JfQ0hBUlM7XG5leHBvcnRzLlJFX0hFWF9OVU1CRVIgPSBSRV9IRVhfTlVNQkVSO1xuZXhwb3J0cy5SRV9PQ1RfTlVNQkVSID0gUkVfT0NUX05VTUJFUjtcbmV4cG9ydHMuUkVfREVDX05VTUJFUiA9IFJFX0RFQ19OVU1CRVI7XG5leHBvcnRzLk9QRVJBVE9SUyA9IE9QRVJBVE9SUztcbmV4cG9ydHMuV0hJVEVTUEFDRV9DSEFSUyA9IFdISVRFU1BBQ0VfQ0hBUlM7XG5leHBvcnRzLlBVTkNfQkVGT1JFX0VYUFJFU1NJT04gPSBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OO1xuZXhwb3J0cy5QVU5DX0NIQVJTID0gUFVOQ19DSEFSUztcbmV4cG9ydHMuUkVHRVhQX01PRElGSUVSUyA9IFJFR0VYUF9NT0RJRklFUlM7XG5leHBvcnRzLlVOSUNPREUgPSBVTklDT0RFO1xuZXhwb3J0cy5pc19sZXR0ZXIgPSBpc19sZXR0ZXI7XG5leHBvcnRzLmlzX2RpZ2l0ID0gaXNfZGlnaXQ7XG5leHBvcnRzLmlzX2FscGhhbnVtZXJpY19jaGFyID0gaXNfYWxwaGFudW1lcmljX2NoYXI7XG5leHBvcnRzLmlzX3VuaWNvZGVfY29tYmluaW5nX21hcmsgPSBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrO1xuZXhwb3J0cy5pc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbiA9IGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyID0gaXNfaWRlbnRpZmllcjtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9zdGFydCA9IGlzX2lkZW50aWZpZXJfc3RhcnQ7XG5leHBvcnRzLmlzX2lkZW50aWZpZXJfY2hhciA9IGlzX2lkZW50aWZpZXJfY2hhcjtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9zdHJpbmcgPSBpc19pZGVudGlmaWVyX3N0cmluZztcbmV4cG9ydHMucGFyc2VfanNfbnVtYmVyID0gcGFyc2VfanNfbnVtYmVyO1xuZXhwb3J0cy5KU19QYXJzZV9FcnJvciA9IEpTX1BhcnNlX0Vycm9yO1xuZXhwb3J0cy5qc19lcnJvciA9IGpzX2Vycm9yO1xuZXhwb3J0cy5pc190b2tlbiA9IGlzX3Rva2VuO1xuZXhwb3J0cy5FWF9FT0YgPSBFWF9FT0Y7XG5leHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbmV4cG9ydHMuVU5BUllfUFJFRklYID0gVU5BUllfUFJFRklYO1xuZXhwb3J0cy5VTkFSWV9QT1NURklYID0gVU5BUllfUE9TVEZJWDtcbmV4cG9ydHMuQVNTSUdOTUVOVCA9IEFTU0lHTk1FTlQ7XG5leHBvcnRzLlBSRUNFREVOQ0UgPSBQUkVDRURFTkNFO1xuZXhwb3J0cy5TVEFURU1FTlRTX1dJVEhfTEFCRUxTID0gU1RBVEVNRU5UU19XSVRIX0xBQkVMUztcbmV4cG9ydHMuQVRPTUlDX1NUQVJUX1RPS0VOID0gQVRPTUlDX1NUQVJUX1RPS0VOO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5UcmVlVHJhbnNmb3JtZXIgPSBUcmVlVHJhbnNmb3JtZXI7XG5leHBvcnRzLlN5bWJvbERlZiA9IFN5bWJvbERlZjtcbmV4cG9ydHMuYmFzZTU0ID0gYmFzZTU0O1xuZXhwb3J0cy5PdXRwdXRTdHJlYW0gPSBPdXRwdXRTdHJlYW07XG5leHBvcnRzLkNvbXByZXNzb3IgPSBDb21wcmVzc29yO1xuZXhwb3J0cy5Tb3VyY2VNYXAgPSBTb3VyY2VNYXA7XG5cbmV4cG9ydHMuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IGZ1bmN0aW9uICh0eHQpIHsgaWYgKHR5cGVvZiBjb25zb2xlICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSBjb25zb2xlLndhcm4odHh0KSB9XG5cbmV4cG9ydHMubWluaWZ5ID0gZnVuY3Rpb24gKGZpbGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFVnbGlmeUpTLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgb3V0U291cmNlTWFwIDogbnVsbCxcbiAgICAgICAgc291cmNlUm9vdCAgIDogbnVsbCxcbiAgICAgICAgaW5Tb3VyY2VNYXAgIDogbnVsbCxcbiAgICAgICAgZnJvbVN0cmluZyAgIDogZmFsc2UsXG4gICAgICAgIHdhcm5pbmdzICAgICA6IGZhbHNlLFxuICAgICAgICBtYW5nbGUgICAgICAgOiB7fSxcbiAgICAgICAgb3V0cHV0ICAgICAgIDogbnVsbCxcbiAgICAgICAgY29tcHJlc3MgICAgIDoge31cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGZpbGVzID09IFwic3RyaW5nXCIpXG4gICAgICAgIGZpbGVzID0gWyBmaWxlcyBdO1xuXG4gICAgVWdsaWZ5SlMuYmFzZTU0LnJlc2V0KCk7XG5cbiAgICAvLyAxLiBwYXJzZVxuICAgIHZhciB0b3BsZXZlbCA9IG51bGw7XG4gICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgdmFyIGNvZGUgPSBvcHRpb25zLmZyb21TdHJpbmdcbiAgICAgICAgICAgID8gZmlsZVxuICAgICAgICAgICAgOiBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgXCJ1dGY4XCIpO1xuICAgICAgICB0b3BsZXZlbCA9IFVnbGlmeUpTLnBhcnNlKGNvZGUsIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBvcHRpb25zLmZyb21TdHJpbmcgPyBcIj9cIiA6IGZpbGUsXG4gICAgICAgICAgICB0b3BsZXZlbDogdG9wbGV2ZWxcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyAyLiBjb21wcmVzc1xuICAgIGlmIChvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgIHZhciBjb21wcmVzcyA9IHsgd2FybmluZ3M6IG9wdGlvbnMud2FybmluZ3MgfTtcbiAgICAgICAgVWdsaWZ5SlMubWVyZ2UoY29tcHJlc3MsIG9wdGlvbnMuY29tcHJlc3MpO1xuICAgICAgICB0b3BsZXZlbC5maWd1cmVfb3V0X3Njb3BlKCk7XG4gICAgICAgIHZhciBzcSA9IFVnbGlmeUpTLkNvbXByZXNzb3IoY29tcHJlc3MpO1xuICAgICAgICB0b3BsZXZlbCA9IHRvcGxldmVsLnRyYW5zZm9ybShzcSk7XG4gICAgfVxuXG4gICAgLy8gMy4gbWFuZ2xlXG4gICAgaWYgKG9wdGlvbnMubWFuZ2xlKSB7XG4gICAgICAgIHRvcGxldmVsLmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgdG9wbGV2ZWwuY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeSgpO1xuICAgICAgICB0b3BsZXZlbC5tYW5nbGVfbmFtZXMob3B0aW9ucy5tYW5nbGUpO1xuICAgIH1cblxuICAgIC8vIDQuIG91dHB1dFxuICAgIHZhciBpbk1hcCA9IG9wdGlvbnMuaW5Tb3VyY2VNYXA7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pblNvdXJjZU1hcCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGluTWFwID0gZnMucmVhZEZpbGVTeW5jKG9wdGlvbnMuaW5Tb3VyY2VNYXAsIFwidXRmOFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0U291cmNlTWFwKSB7XG4gICAgICAgIG91dHB1dC5zb3VyY2VfbWFwID0gVWdsaWZ5SlMuU291cmNlTWFwKHtcbiAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMub3V0U291cmNlTWFwLFxuICAgICAgICAgICAgb3JpZzogaW5NYXAsXG4gICAgICAgICAgICByb290OiBvcHRpb25zLnNvdXJjZVJvb3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm91dHB1dCkge1xuICAgICAgICBVZ2xpZnlKUy5tZXJnZShvdXRwdXQsIG9wdGlvbnMub3V0cHV0KTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbSA9IFVnbGlmeUpTLk91dHB1dFN0cmVhbShvdXRwdXQpO1xuICAgIHRvcGxldmVsLnByaW50KHN0cmVhbSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZSA6IHN0cmVhbSArIFwiXCIsXG4gICAgICAgIG1hcCAgOiBvdXRwdXQuc291cmNlX21hcCArIFwiXCJcbiAgICB9O1xufTtcblxuZXhwb3J0cy5kZXNjcmliZV9hc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFVnbGlmeUpTLk91dHB1dFN0cmVhbSh7IGJlYXV0aWZ5OiB0cnVlIH0pO1xuICAgIGZ1bmN0aW9uIGRvaXRlbShjdG9yKSB7XG4gICAgICAgIG91dC5wcmludChcIkFTVF9cIiArIGN0b3IuVFlQRSk7XG4gICAgICAgIHZhciBwcm9wcyA9IGN0b3IuU0VMRl9QUk9QUy5maWx0ZXIoZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gIS9eXFwkLy50ZXN0KHByb3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXQucHJpbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Rvci5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dC5wcmludF9zdHJpbmcoY3Rvci5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Rvci5TVUJDTEFTU0VTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjdG9yLlNVQkNMQVNTRVMuZm9yRWFjaChmdW5jdGlvbihjdG9yLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBkb2l0ZW0oY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIG91dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG9pdGVtKFVnbGlmeUpTLkFTVF9Ob2RlKTtcbiAgICByZXR1cm4gb3V0ICsgXCJcIjtcbn07IiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuaGFzKGFTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1NldFN0cmluZyhhU3RyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgaWYgKHRoaXMuaGFzKGFTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogaXMgcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIGlzIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckF0KGkrKykpO1xuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGZyb21WTFFTaWduZWQocmVzdWx0KSxcbiAgICAgIHJlc3Q6IGFTdHIuc2xpY2UoaSlcbiAgICB9O1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGNoYXJUb0ludE1hcCA9IHt9O1xuICB2YXIgaW50VG9DaGFyTWFwID0ge307XG5cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gICAgLnNwbGl0KCcnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaCwgaW5kZXgpIHtcbiAgICAgIGNoYXJUb0ludE1hcFtjaF0gPSBpbmRleDtcbiAgICAgIGludFRvQ2hhck1hcFtpbmRleF0gPSBjaDtcbiAgICB9KTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0X2VuY29kZShhTnVtYmVyKSB7XG4gICAgaWYgKGFOdW1iZXIgaW4gaW50VG9DaGFyTWFwKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW2FOdW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBkaWdpdCB0byBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XG4gICAgaWYgKGFDaGFyIGluIGNoYXJUb0ludE1hcCkge1xuICAgICAgcmV0dXJuIGNoYXJUb0ludE1hcFthQ2hhcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcIiArIGFDaGFyKTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgbmV4dFxuICAgIC8vICAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgbGVzcyB0aGFuIHRoYXQgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHdoaWNoIGlzIGxlc3MgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZVxuICAgIC8vICAgICAgcmV0dXJuIG51bGwuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gYUhheXN0YWNrW21pZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIGFIYXlzdGFja1ttaWRdIGlzIGdyZWF0ZXIgdGhhbiBvdXIgbmVlZGxlLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpZCBub3QgZmluZCBhbiBleGFjdCBtYXRjaCwgcmV0dXJuIHRoZSBuZXh0IGNsb3Nlc3Qgb25lXG4gICAgICAvLyAodGVybWluYXRpb24gY2FzZSAyKS5cbiAgICAgIHJldHVybiBhSGF5c3RhY2tbbWlkXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBsZXNzIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMikgb3IgKDMpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgcmV0dXJuIGFMb3cgPCAwXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGFIYXlzdGFja1thTG93XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBuZXh0IGxvd2VzdCB2YWx1ZSBjaGVja2VkIGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgcmV0dXJuIGFIYXlzdGFjay5sZW5ndGggPiAwXG4gICAgICA/IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSlcbiAgICAgIDogbnVsbDtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuXG4gIC8qKlxuICAgKiBBIFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBtYXBwaW5nU2VwYXJhdG9yID0gL15bLDtdLztcbiAgICAgIHZhciBzdHIgPSBhU3RyO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgdGVtcDtcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChwcmV2aW91c1NvdXJjZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgbWFwcGluZ1NlcGFyYXRvci50ZXN0KHN0ci5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChwcmV2aW91c05hbWUgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICYmIHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsaWJsZS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3RcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290KSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgc291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBUbyBjcmVhdGUgYSBuZXcgb25lLCB5b3UgbXVzdCBwYXNzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIHNvdXJjZVJvb3Q6IEFuIG9wdGlvbmFsIHJvb3QgZm9yIGFsbCBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG5cbiAgICAgIGlmIChzb3VyY2UgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLnB1c2goe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlKSB7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoIWFTb3VyY2VGaWxlKSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwiYVNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgYVNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIGFTb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcImFTb3VyY2VGaWxlXCJcbiAgICAgIHRoaXMuX21hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBhU291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgb3JpZ2luYWwuc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9PSBudWxsICYmIG1hcHBpbmcubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGUgaWRlbnRpZmllciBuYW1lIGlmIGl0J3MgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAvLyBpbiBib3RoIFNvdXJjZU1hcHNcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICAvLyBUaGUgbWFwcGluZ3MgbXVzdCBiZSBndWFyYW50ZWVkIHRvIGJlIGluIHNvcnRlZCBvcmRlciBiZWZvcmUgd2Ugc3RhcnRcbiAgICAgIC8vIHNlcmlhbGl6aW5nIHRoZW0gb3IgZWxzZSB0aGUgZ2VuZXJhdGVkIGxpbmUgbnVtYmVycyAod2hpY2ggYXJlIGRlZmluZWRcbiAgICAgIC8vIHZpYSB0aGUgJzsnIHNlcGFyYXRvcnMpIHdpbGwgYmUgYWxsIG1lc3NlZCB1cC4gTm90ZTogaXQgbWlnaHQgYmUgbW9yZVxuICAgICAgLy8gcGVyZm9ybWFudCB0byBtYWludGFpbiB0aGUgc29ydGluZyBhcyB3ZSBpbnNlcnQgdGhlbSwgcmF0aGVyIHRoYW4gYXMgd2VcbiAgICAgIC8vIHNlcmlhbGl6ZSB0aGVtLCBidXQgdGhlIGJpZyBPIGlzIHRoZSBzYW1lIGVpdGhlciB3YXkuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX21hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcHBpbmcgPSB0aGlzLl9tYXBwaW5nc1tpXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsnO1xuICAgICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtYXBwaW5nLCB0aGlzLl9tYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290KSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkpXG4gICAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgICB2YXIgbWFwID0ge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICBmaWxlOiB0aGlzLl9maWxlLFxuICAgICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09PSB1bmRlZmluZWQgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09PSB1bmRlZmluZWQgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09PSB1bmRlZmluZWQgPyBudWxsIDogYU5hbWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXkuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZnVsbCBsaW5lcyB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjb2RlICs9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgKyBcIlxcblwiO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKTtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgcmVhY2hlZCB0aGUgY29ycmVjdCBsaW5lLCB3ZSBhZGQgY29kZSB1bnRpbCB3ZVxuICAgICAgICAgICAgLy8gcmVhY2ggdGhlIGNvcnJlY3QgY29sdW1uIHRvby5cbiAgICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICAgIGNvZGUgKz0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIFNvdXJjZU5vZGUuXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCByZW1haW5pbmdMaW5lcy5qb2luKFwiXFxuXCIpKTtcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNodW5rLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gLyhbXFx3K1xcLS5dKyk6XFwvXFwvKChcXHcrOlxcdyspQCk/KFtcXHcuXSspPyg6KFxcZCspKT8oXFxTKyk/LztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKy87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFszXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzRdLFxuICAgICAgcG9ydDogbWF0Y2hbNl0sXG4gICAgICBwYXRoOiBtYXRjaFs3XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gYVBhcnNlZFVybC5zY2hlbWUgKyBcIjovL1wiO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyBcIkBcIlxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICB2YXIgdXJsO1xuXG4gICAgaWYgKGFQYXRoLm1hdGNoKHVybFJlZ2V4cCkgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09PSAnLycgJiYgKHVybCA9IHVybFBhcnNlKGFSb290KSkpIHtcbiAgICAgIHVybC5wYXRoID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJyArIGFQYXRoO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwidmFyIHByb2Nlc3M9cmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLF9fZmlsZW5hbWU9XCIvLi4vLi4vbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanNcIjsvKiogdmltOiBldDp0cz00OnN3PTQ6c3RzPTRcbiAqIEBsaWNlbnNlIGFtZGVmaW5lIDAuMS4wIENvcHlyaWdodCAoYykgMjAxMSwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9hbWRlZmluZSBmb3IgZGV0YWlsc1xuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcHJvY2VzcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWZpbmUgZm9yIG5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBcIm1vZHVsZVwiIG9iamVjdCB0aGF0IGlzIGRlZmluZWQgYnkgTm9kZSBmb3IgdGhlXG4gKiBjdXJyZW50IG1vZHVsZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXF1aXJlRm5dLiBOb2RlJ3MgcmVxdWlyZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnQgbW9kdWxlLlxuICogSXQgb25seSBuZWVkcyB0byBiZSBwYXNzZWQgaW4gTm9kZSB2ZXJzaW9ucyBiZWZvcmUgMC41LCB3aGVuIG1vZHVsZS5yZXF1aXJlXG4gKiBkaWQgbm90IGV4aXN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGRlZmluZSBmdW5jdGlvbiB0aGF0IGlzIHVzYWJsZSBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICogbW9kdWxlLlxuICovXG5mdW5jdGlvbiBhbWRlZmluZShtb2R1bGUsIHJlcXVpcmVGbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGVmaW5lQ2FjaGUgPSB7fSxcbiAgICAgICAgbG9hZGVyQ2FjaGUgPSB7fSxcbiAgICAgICAgYWxyZWFkeUNhbGxlZCA9IGZhbHNlLFxuICAgICAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgICAgICBtYWtlUmVxdWlyZSwgc3RyaW5nUmVxdWlyZTtcblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSAuIGFuZCAuLiBmcm9tIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICogSXQgd2lsbCBrZWVwIGEgbGVhZGluZyBwYXRoIHNlZ21lbnQgaWYgYSAuLiB3aWxsIGJlY29tZVxuICAgICAqIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQsIHRvIGhlbHAgd2l0aCBtb2R1bGUgbmFtZSBsb29rdXBzLFxuICAgICAqIHdoaWNoIGFjdCBsaWtlIHBhdGhzLCBidXQgY2FuIGJlIHJlbWFwcGVkLiBCdXQgdGhlIGVuZCByZXN1bHQsXG4gICAgICogYWxsIHBhdGhzIHRoYXQgdXNlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGxvb2sgbm9ybWFsaXplZC5cbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBNT0RJRklFUyB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJ5IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xuICAgICAgICB2YXIgaSwgcGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgYXJ5W2ldOyBpKz0gMSkge1xuICAgICAgICAgICAgcGFydCA9IGFyeVtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChhcnlbMl0gPT09ICcuLicgfHwgYXJ5WzBdID09PSAnLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvL0VuZCBvZiB0aGUgbGluZS4gS2VlcCBhdCBsZWFzdCBvbmUgbm9uLWRvdFxuICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxuICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RseSB0byBkaXNrLiBPdGhlcndpc2UsIHRoZXJlIGlzIGxpa2VseVxuICAgICAgICAgICAgICAgICAgICAvL25vIHBhdGggbWFwcGluZyBmb3IgYSBwYXRoIHN0YXJ0aW5nIHdpdGggJy4uJy5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyBvZiAuLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XG4gICAgICAgIHZhciBiYXNlUGFydHM7XG5cbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxuICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZS5zcGxpdCgnLycpKTtcbiAgICAgICAgICAgICAgICB0cmltRG90cyhiYXNlUGFydHMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBub3JtYWxpemUoKSBmdW5jdGlvbiBwYXNzZWQgdG8gYSBsb2FkZXIgcGx1Z2luJ3NcbiAgICAgKiBub3JtYWxpemUgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoaWQpIHtcbiAgICAgICAgZnVuY3Rpb24gbG9hZCh2YWx1ZSkge1xuICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkLmZyb21UZXh0ID0gZnVuY3Rpb24gKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAvL1RoaXMgb25lIGlzIGRpZmZpY3VsdCBiZWNhdXNlIHRoZSB0ZXh0IGNhbi9wcm9iYWJseSB1c2VzXG4gICAgICAgICAgICAvL2RlZmluZSwgYW5kIGFueSByZWxhdGl2ZSBwYXRocyBhbmQgcmVxdWlyZXMgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgICAgICAvL3RvIHRoYXQgaWQgd2FzIGl0IHdvdWxkIGJlIGZvdW5kIG9uIGRpc2suIEJ1dCB0aGlzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwcGluZyBhIG1vZHVsZS9yZXF1aXJlIGZhaXJseSBkZWVwbHkgZnJvbSBub2RlIGNvcmUuXG4gICAgICAgICAgICAvL05vdCBzdXJlIGhvdyBiZXN0IHRvIGdvIGFib3V0IHRoYXQgeWV0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSBkb2VzIG5vdCBpbXBsZW1lbnQgbG9hZC5mcm9tVGV4dCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsb2FkO1xuICAgIH1cblxuICAgIG1ha2VSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpIHtcbiAgICAgICAgZnVuY3Rpb24gYW1kUmVxdWlyZShkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vU3luY2hyb25vdXMsIHNpbmdsZSBtb2R1bGUgcmVxdWlyZSgnJylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcHMsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9BcnJheSBvZiBkZXBlbmRlbmNpZXMgd2l0aCBhIGNhbGxiYWNrLlxuXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IHRoZSBkZXBlbmRlbmNpZXMgdG8gbW9kdWxlcy5cbiAgICAgICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBOYW1lLCByZWxJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL1dhaXQgZm9yIG5leHQgdGljayB0byBjYWxsIGJhY2sgdGhlIHJlcXVpcmUgY2FsbC5cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbWRSZXF1aXJlLnRvVXJsID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVBhdGguaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShmaWxlUGF0aCwgcGF0aC5kaXJuYW1lKG1vZHVsZS5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFtZFJlcXVpcmU7XG4gICAgfTtcblxuICAgIC8vRmF2b3IgZXhwbGljaXQgdmFsdWUsIHBhc3NlZCBpbiBpZiB0aGUgbW9kdWxlIHdhbnRzIHRvIHN1cHBvcnQgTm9kZSAwLjQuXG4gICAgcmVxdWlyZUZuID0gcmVxdWlyZUZuIHx8IGZ1bmN0aW9uIHJlcSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5yZXF1aXJlLmFwcGx5KG1vZHVsZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICB2YXIgciwgZSwgbSwgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgZSA9IGxvYWRlckNhY2hlW2lkXSA9IHt9O1xuICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdXJpOiBfX2ZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL09ubHkgc3VwcG9ydCBvbmUgZGVmaW5lIGNhbGwgcGVyIGZpbGVcbiAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSB3aXRoIG5vIG1vZHVsZSBJRCBjYW5ub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHBlciBmaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vVXNlIHRoZSByZWFsIHZhcmlhYmxlcyBmcm9tIG5vZGVcbiAgICAgICAgICAgIC8vVXNlIG1vZHVsZS5leHBvcnRzIGZvciBleHBvcnRzLCBzaW5jZVxuICAgICAgICAgICAgLy90aGUgZXhwb3J0cyBpbiBoZXJlIGlzIGFtZGVmaW5lIGV4cG9ydHMuXG4gICAgICAgICAgICBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgICBtID0gbW9kdWxlO1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgbW9kdWxlLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcywgdGhleSBhcmUgc3RyaW5ncywgc28gbmVlZFxuICAgICAgICAvL3RvIGNvbnZlcnQgdGhlbSB0byBkZXBlbmRlbmN5IHZhbHVlcy5cbiAgICAgICAgaWYgKGRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByKGRlcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0NhbGwgdGhlIGZhY3Rvcnkgd2l0aCB0aGUgcmlnaHQgZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnkuYXBwbHkobS5leHBvcnRzLCBkZXBzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG0uZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IG0uZXhwb3J0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZ1JlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBpZCwgcmVsSWQpIHtcbiAgICAgICAgLy9TcGxpdCB0aGUgSUQgYnkgYSAhIHNvIHRoYXRcbiAgICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZignIScpLFxuICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkLFxuICAgICAgICAgICAgcHJlZml4LCBwbHVnaW47XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcblxuICAgICAgICAgICAgLy9TdHJhaWdodCBtb2R1bGUgbG9va3VwLiBJZiBpdCBpcyBvbmUgb2YgdGhlIHNwZWNpYWwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgLy9kZWFsIHdpdGggaXQsIG90aGVyd2lzZSwgZGVsZWdhdGUgdG8gbm9kZS5cbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvYWRlckNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihzeXN0ZW1SZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1SZXF1aXJlKG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9kdWxlIHdpdGggSUQ6ICcgKyBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UaGVyZSBpcyBhIHBsdWdpbiBpbiBwbGF5LlxuICAgICAgICAgICAgcHJlZml4ID0gaWQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKGluZGV4ICsgMSwgaWQubGVuZ3RoKTtcblxuICAgICAgICAgICAgcGx1Z2luID0gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHByZWZpeCwgcmVsSWQpO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIGlkID0gcGx1Z2luLm5vcm1hbGl6ZShpZCwgbWFrZU5vcm1hbGl6ZShyZWxJZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgSUQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5sb2FkKGlkLCBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSwgbWFrZUxvYWQoaWQpLCB7fSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vQ3JlYXRlIGEgZGVmaW5lIGZ1bmN0aW9uIHNwZWNpZmljIHRvIHRoZSBtb2R1bGUgYXNraW5nIGZvciBhbWRlZmluZS5cbiAgICBmdW5jdGlvbiBkZWZpbmUoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBpZDtcbiAgICAgICAgICAgIGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBpZDtcbiAgICAgICAgICAgIGlkID0gZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXBzICYmICFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU2V0IHVwIHByb3BlcnRpZXMgZm9yIHRoaXMgbW9kdWxlLiBJZiBhbiBJRCwgdGhlbiB1c2VcbiAgICAgICAgLy9pbnRlcm5hbCBjYWNoZS4gSWYgbm8gSUQsIHRoZW4gdXNlIHRoZSBleHRlcm5hbCB2YXJpYWJsZXNcbiAgICAgICAgLy9mb3IgdGhpcyBub2RlIG1vZHVsZS5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAvL1B1dCB0aGUgbW9kdWxlIGluIGRlZXAgZnJlZXplIHVudGlsIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vcmVxdWlyZSBjYWxsIGZvciBpdC5cbiAgICAgICAgICAgIGRlZmluZUNhY2hlW2lkXSA9IFtpZCwgZGVwcywgZmFjdG9yeV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVmaW5lLnJlcXVpcmUsIHdoaWNoIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSB2YWx1ZXMgaW4gdGhlXG4gICAgLy9jYWNoZS4gVXNlZnVsIGZvciBBTUQgbW9kdWxlcyB0aGF0IGFsbCBoYXZlIElEcyBpbiB0aGUgZmlsZSxcbiAgICAvL2J1dCBuZWVkIHRvIGZpbmFsbHkgZXhwb3J0IGEgdmFsdWUgdG8gbm9kZSBiYXNlZCBvbiBvbmUgb2YgdGhvc2VcbiAgICAvL0lEcy5cbiAgICBkZWZpbmUucmVxdWlyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUuYW1kID0ge307XG5cbiAgICByZXR1cm4gZGVmaW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFtZGVmaW5lO1xuIiwidmFyIHN5cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIE1PWl9Tb3VyY2VNYXAgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKTtcbnZhciBVZ2xpZnlKUyA9IGV4cG9ydHM7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBhcnJheV90b19oYXNoKGEpIHtcbiAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHJldFthW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIHNsaWNlKGEsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIHN0YXJ0IHx8IDApO1xufTtcblxuZnVuY3Rpb24gY2hhcmFjdGVycyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KFwiXCIpO1xufTtcblxuZnVuY3Rpb24gbWVtYmVyKG5hbWUsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICBpZiAoYXJyYXlbaV0gPT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGZpbmRfaWYoZnVuYywgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoZnVuYyhhcnJheVtpXSkpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVwZWF0X3N0cmluZyhzdHIsIGkpIHtcbiAgICBpZiAoaSA8PSAwKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoaSA9PSAxKSByZXR1cm4gc3RyO1xuICAgIHZhciBkID0gcmVwZWF0X3N0cmluZyhzdHIsIGkgPj4gMSk7XG4gICAgZCArPSBkO1xuICAgIGlmIChpICYgMSkgZCArPSBzdHI7XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5mdW5jdGlvbiBEZWZhdWx0c0Vycm9yKG1zZywgZGVmcykge1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIHRoaXMuZGVmcyA9IGRlZnM7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0cyhhcmdzLCBkZWZzLCBjcm9haykge1xuICAgIGlmIChhcmdzID09PSB0cnVlKVxuICAgICAgICBhcmdzID0ge307XG4gICAgdmFyIHJldCA9IGFyZ3MgfHwge307XG4gICAgaWYgKGNyb2FrKSBmb3IgKHZhciBpIGluIHJldCkgaWYgKHJldC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhZGVmcy5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgdGhyb3cgbmV3IERlZmF1bHRzRXJyb3IoXCJgXCIgKyBpICsgXCJgIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cIiwgZGVmcyk7XG4gICAgZm9yICh2YXIgaSBpbiBkZWZzKSBpZiAoZGVmcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBhcmdzLmhhc093blByb3BlcnR5KGkpKSA/IGFyZ3NbaV0gOiBkZWZzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqLCBleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGV4dCkgaWYgKGV4dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBvYmpbaV0gPSBleHRbaV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBub29wKCkge307XG5cbnZhciBNQVAgPSAoZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBNQVAoYSwgZiwgYmFja3dhcmRzKSB7XG4gICAgICAgIHZhciByZXQgPSBbXSwgdG9wID0gW10sIGk7XG4gICAgICAgIGZ1bmN0aW9uIGRvaXQoKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZihhW2ldLCBpKTtcbiAgICAgICAgICAgIHZhciBpc19sYXN0ID0gdmFsIGluc3RhbmNlb2YgTGFzdDtcbiAgICAgICAgICAgIGlmIChpc19sYXN0KSB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBdFRvcCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC52O1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2guYXBwbHkodG9wLCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc19sYXN0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gYS5sZW5ndGg7IC0taSA+PSAwOykgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0b3AucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIGlmIChkb2l0KCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3AuY29uY2F0KHJldCk7XG4gICAgfTtcbiAgICBNQVAuYXRfdG9wID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXRUb3AodmFsKSB9O1xuICAgIE1BUC5zcGxpY2UgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBTcGxpY2UodmFsKSB9O1xuICAgIE1BUC5sYXN0ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgTGFzdCh2YWwpIH07XG4gICAgdmFyIHNraXAgPSBNQVAuc2tpcCA9IHt9O1xuICAgIGZ1bmN0aW9uIEF0VG9wKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcbiAgICBmdW5jdGlvbiBTcGxpY2UodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIGZ1bmN0aW9uIExhc3QodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIHJldHVybiBNQVA7XG59KSgpO1xuXG5mdW5jdGlvbiBwdXNoX3VuaXEoYXJyYXksIGVsKSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YoZWwpIDwgMClcbiAgICAgICAgYXJyYXkucHVzaChlbCk7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdfdGVtcGxhdGUodGV4dCwgcHJvcHMpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHsoLis/KVxcfS9nLCBmdW5jdGlvbihzdHIsIHApe1xuICAgICAgICByZXR1cm4gcHJvcHNbcF07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZWwpIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBtZXJnZVNvcnQoYXJyYXksIGNtcCkge1xuICAgIGlmIChhcnJheS5sZW5ndGggPCAyKSByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgICAgIHZhciByID0gW10sIGFpID0gMCwgYmkgPSAwLCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGFpIDwgYS5sZW5ndGggJiYgYmkgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgY21wKGFbYWldLCBiW2JpXSkgPD0gMFxuICAgICAgICAgICAgICAgID8gcltpKytdID0gYVthaSsrXVxuICAgICAgICAgICAgICAgIDogcltpKytdID0gYltiaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWkgPCBhLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGEuc2xpY2UoYWkpKTtcbiAgICAgICAgaWYgKGJpIDwgYi5sZW5ndGgpIHIucHVzaC5hcHBseShyLCBiLnNsaWNlKGJpKSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX21zKGEpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKGEubGVuZ3RoIC8gMiksIGxlZnQgPSBhLnNsaWNlKDAsIG0pLCByaWdodCA9IGEuc2xpY2UobSk7XG4gICAgICAgIGxlZnQgPSBfbXMobGVmdCk7XG4gICAgICAgIHJpZ2h0ID0gX21zKHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBfbXMoYXJyYXkpO1xufTtcblxuZnVuY3Rpb24gc2V0X2RpZmZlcmVuY2UoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpIDwgMDtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHNldF9pbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpID49IDA7XG4gICAgfSk7XG59O1xuXG4vLyB0aGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gQWNvcm4gWzFdLCB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2Vcbi8vIFsxXSBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29yblxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgIGlmICghKHdvcmRzIGluc3RhbmNlb2YgQXJyYXkpKSB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgICB2YXIgZiA9IFwiXCIsIGNhdHMgPSBbXTtcbiAgICBvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhdHNbal0ucHVzaCh3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG4gICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBsZW5ndGggY2F0ZWdvcmllcywgYW4gb3V0ZXJcbiAgICAvLyBzd2l0Y2ggZmlyc3QgZGlzcGF0Y2hlcyBvbiB0aGUgbGVuZ3RocywgdG8gc2F2ZSBvbiBjb21wYXJpc29ucy5cbiAgICBpZiAoY2F0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIGNhdHMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7fSk7XG4gICAgICAgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNhdCA9IGNhdHNbaV07XG4gICAgICAgICAgICBmICs9IFwiY2FzZSBcIiArIGNhdFswXS5sZW5ndGggKyBcIjpcIjtcbiAgICAgICAgICAgIGNvbXBhcmVUbyhjYXQpO1xuICAgICAgICB9XG4gICAgICAgIGYgKz0gXCJ9XCI7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2ltcGx5IGdlbmVyYXRlIGEgZmxhdCBgc3dpdGNoYCBzdGF0ZW1lbnQuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbn07XG5cbmZ1bmN0aW9uIGFsbChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuRGljdGlvbmFyeS5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpICsrdGhpcy5fc2l6ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmdldChrZXkpLnB1c2godmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgWyB2YWwgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSB9LFxuICAgIGRlbDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAtLXRoaXMuX3NpemU7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oa2V5KSB7IHJldHVybiAoXCIkXCIgKyBrZXkpIGluIHRoaXMuX3ZhbHVlcyB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICBmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICByZXQucHVzaChmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBERUZOT0RFKHR5cGUsIHByb3BzLCBtZXRob2RzLCBiYXNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBiYXNlID0gQVNUX05vZGU7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSBbXTtcbiAgICBlbHNlIHByb3BzID0gcHJvcHMuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgc2VsZl9wcm9wcyA9IHByb3BzO1xuICAgIGlmIChiYXNlICYmIGJhc2UuUFJPUFMpXG4gICAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KGJhc2UuUFJPUFMpO1xuICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24gQVNUX1wiICsgdHlwZSArIFwiKHByb3BzKXsgaWYgKHByb3BzKSB7IFwiO1xuICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5cIiArIHByb3BzW2ldICsgXCIgPSBwcm9wcy5cIiArIHByb3BzW2ldICsgXCI7XCI7XG4gICAgfVxuICAgIHZhciBwcm90byA9IGJhc2UgJiYgbmV3IGJhc2U7XG4gICAgaWYgKHByb3RvICYmIHByb3RvLmluaXRpYWxpemUgfHwgKG1ldGhvZHMgJiYgbWV0aG9kcy5pbml0aWFsaXplKSlcbiAgICAgICAgY29kZSArPSBcInRoaXMuaW5pdGlhbGl6ZSgpO1wiO1xuICAgIGNvZGUgKz0gXCJ9fVwiO1xuICAgIHZhciBjdG9yID0gbmV3IEZ1bmN0aW9uKGNvZGUpKCk7XG4gICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIGN0b3IuQkFTRSA9IGJhc2U7XG4gICAgfVxuICAgIGlmIChiYXNlKSBiYXNlLlNVQkNMQVNTRVMucHVzaChjdG9yKTtcbiAgICBjdG9yLnByb3RvdHlwZS5DVE9SID0gY3RvcjtcbiAgICBjdG9yLlBST1BTID0gcHJvcHMgfHwgbnVsbDtcbiAgICBjdG9yLlNFTEZfUFJPUFMgPSBzZWxmX3Byb3BzO1xuICAgIGN0b3IuU1VCQ0xBU1NFUyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLlRZUEUgPSBjdG9yLlRZUEUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAobWV0aG9kcykgZm9yIChpIGluIG1ldGhvZHMpIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmICgvXlxcJC8udGVzdChpKSkge1xuICAgICAgICAgICAgY3RvcltpLnN1YnN0cigxKV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0b3IuREVGTUVUSE9EID0gZnVuY3Rpb24obmFtZSwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgIH07XG4gICAgcmV0dXJuIGN0b3I7XG59O1xuXG52YXIgQVNUX1Rva2VuID0gREVGTk9ERShcIlRva2VuXCIsIFwidHlwZSB2YWx1ZSBsaW5lIGNvbCBwb3MgZW5kcG9zIG5sYiBjb21tZW50c19iZWZvcmUgZmlsZVwiLCB7XG59LCBudWxsKTtcblxudmFyIEFTVF9Ob2RlID0gREVGTk9ERShcIk5vZGVcIiwgXCJzdGFydCBlbmRcIiwge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNUT1IodGhpcyk7XG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBBU1Qgbm9kZXNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBzdGFydDogXCJbQVNUX1Rva2VuXSBUaGUgZmlyc3QgdG9rZW4gb2YgdGhpcyBub2RlXCIsXG4gICAgICAgIGVuZDogXCJbQVNUX1Rva2VuXSBUaGUgbGFzdCB0b2tlbiBvZiB0aGlzIG5vZGVcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH0sXG4gICAgd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Fsayh2aXNpdG9yKTsgLy8gbm90IHN1cmUgdGhlIGluZGlyZWN0aW9uIHdpbGwgYmUgYW55IGhlbHBcbiAgICB9XG59LCBudWxsKTtcblxuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IG51bGw7XG5BU1RfTm9kZS53YXJuID0gZnVuY3Rpb24odHh0LCBwcm9wcykge1xuICAgIGlmIChBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKVxuICAgICAgICBBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKHN0cmluZ190ZW1wbGF0ZSh0eHQsIHByb3BzKSk7XG59O1xuXG4vKiAtLS0tLVsgc3RhdGVtZW50cyBdLS0tLS0gKi9cblxudmFyIEFTVF9TdGF0ZW1lbnQgPSBERUZOT0RFKFwiU3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBzdGF0ZW1lbnRzXCIsXG59KTtcblxudmFyIEFTVF9EZWJ1Z2dlciA9IERFRk5PREUoXCJEZWJ1Z2dlclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVwcmVzZW50cyBhIGRlYnVnZ2VyIHN0YXRlbWVudFwiLFxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRGlyZWN0aXZlID0gREVGTk9ERShcIkRpcmVjdGl2ZVwiLCBcInZhbHVlIHNjb3BlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZXByZXNlbnRzIGEgZGlyZWN0aXZlLCBsaWtlIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSBUaGUgdmFsdWUgb2YgdGhpcyBkaXJlY3RpdmUgYXMgYSBwbGFpbiBzdHJpbmcgKGl0J3Mgbm90IGFuIEFTVF9TdHJpbmchKVwiLFxuICAgICAgICBzY29wZTogXCJbQVNUX1Njb3BlL1NdIFRoZSBzY29wZSB0aGF0IHRoaXMgZGlyZWN0aXZlIGFmZmVjdHNcIlxuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBERUZOT0RFKFwiU2ltcGxlU3RhdGVtZW50XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdGF0ZW1lbnQgY29uc2lzdGluZyBvZiBhbiBleHByZXNzaW9uLCBpLmUuIGEgPSAxICsgMlwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9Ob2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbmZ1bmN0aW9uIHdhbGtfYm9keShub2RlLCB2aXNpdG9yKSB7XG4gICAgaWYgKG5vZGUuYm9keSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgIH1cbiAgICBlbHNlIG5vZGUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICBzdGF0Ll93YWxrKHZpc2l0b3IpO1xuICAgIH0pO1xufTtcblxudmFyIEFTVF9CbG9jayA9IERFRk5PREUoXCJCbG9ja1wiLCBcImJvZHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNrZXRlZClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBib2R5OiBcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfQmxvY2tTdGF0ZW1lbnQgPSBERUZOT0RFKFwiQmxvY2tTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2sgc3RhdGVtZW50XCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0VtcHR5U3RhdGVtZW50ID0gREVGTk9ERShcIkVtcHR5U3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgZW1wdHkgc3RhdGVtZW50IChlbXB0eSBibG9jayBvciBzaW1wbHkgYSBzZW1pY29sb24pXCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1N0YXRlbWVudFdpdGhCb2R5ID0gREVGTk9ERShcIlN0YXRlbWVudFdpdGhCb2R5XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgdGhhdCBjb250YWluIG9uZSBuZXN0ZWQgYm9keTogYEZvcmAsIGBGb3JJbmAsIGBEb2AsIGBXaGlsZWAsIGBXaXRoYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEFTVF9FbXB0eVN0YXRlbWVudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfTGFiZWxlZFN0YXRlbWVudCA9IERFRk5PREUoXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwibGFiZWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCA9IERFRk5PREUoXCJJdGVyYXRpb25TdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkludGVybmFsIGNsYXNzLiAgQWxsIGxvb3BzIGluaGVyaXQgZnJvbSBpdC5cIlxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxudmFyIEFTVF9EV0xvb3AgPSBERUZOT0RFKFwiRFdMb29wXCIsIFwiY29uZGl0aW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBkby93aGlsZSBzdGF0ZW1lbnRzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV0gdGhlIGxvb3AgY29uZGl0aW9uLiAgU2hvdWxkIG5vdCBiZSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XG5cbnZhciBBU1RfRG8gPSBERUZOT0RFKFwiRG9cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGRvYCBzdGF0ZW1lbnRcIixcbn0sIEFTVF9EV0xvb3ApO1xuXG52YXIgQVNUX1doaWxlID0gREVGTk9ERShcIldoaWxlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB3aGlsZWAgc3RhdGVtZW50XCIsXG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9Gb3IgPSBERUZOT0RFKFwiRm9yXCIsIFwiaW5pdCBjb25kaXRpb24gc3RlcFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdGVybWluYXRpb24gY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIHN0ZXA6IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHVwZGF0ZSBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb24pIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcCkgdGhpcy5zdGVwLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9Gb3JJbiA9IERFRk5PREUoXCJGb3JJblwiLCBcImluaXQgbmFtZSBvYmplY3RcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGZvciAuLi4gaW5gIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGluaXQ6IFwiW0FTVF9Ob2RlXSB0aGUgYGZvci9pbmAgaW5pdGlhbGl6YXRpb24gY29kZVwiLFxuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sUmVmP10gdGhlIGxvb3AgdmFyaWFibGUsIG9ubHkgaWYgYGluaXRgIGlzIEFTVF9WYXJcIixcbiAgICAgICAgb2JqZWN0OiBcIltBU1RfTm9kZV0gdGhlIG9iamVjdCB0aGF0IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9XaXRoID0gREVGTk9ERShcIldpdGhcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB3aXRoYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIGB3aXRoYCBleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgc2NvcGUgYW5kIGZ1bmN0aW9ucyBdLS0tLS0gKi9cblxudmFyIEFTVF9TY29wZSA9IERFRk5PREUoXCJTY29wZVwiLCBcImRpcmVjdGl2ZXMgdmFyaWFibGVzIGZ1bmN0aW9ucyB1c2VzX3dpdGggdXNlc19ldmFsIHBhcmVudF9zY29wZSBlbmNsb3NlZCBjbmFtZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgaW50cm9kdWNpbmcgYSBsZXhpY2FsIHNjb3BlXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZGlyZWN0aXZlczogXCJbc3RyaW5nKi9TXSBhbiBhcnJheSBvZiBkaXJlY3RpdmVzIGRlY2xhcmVkIGluIHRoaXMgc2NvcGVcIixcbiAgICAgICAgdmFyaWFibGVzOiBcIltPYmplY3QvU10gYSBtYXAgb2YgbmFtZSAtPiBTeW1ib2xEZWYgZm9yIGFsbCB2YXJpYWJsZXMvZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBzY29wZVwiLFxuICAgICAgICBmdW5jdGlvbnM6IFwiW09iamVjdC9TXSBsaWtlIGB2YXJpYWJsZXNgLCBidXQgb25seSBsaXN0cyBmdW5jdGlvbiBkZWNsYXJhdGlvbnNcIixcbiAgICAgICAgdXNlc193aXRoOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XCIsXG4gICAgICAgIHVzZXNfZXZhbDogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgc2NvcGUgY29udGFpbnMgYSBkaXJlY3QgY2FsbCB0byB0aGUgZ2xvYmFsIGBldmFsYFwiLFxuICAgICAgICBwYXJlbnRfc2NvcGU6IFwiW0FTVF9TY29wZT8vU10gbGluayB0byB0aGUgcGFyZW50IHNjb3BlXCIsXG4gICAgICAgIGVuY2xvc2VkOiBcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXCIsXG4gICAgICAgIGNuYW1lOiBcIltpbnRlZ2VyL1NdIGN1cnJlbnQgaW5kZXggZm9yIG1hbmdsaW5nIHZhcmlhYmxlcyAodXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBtYW5nbGVyKVwiLFxuICAgIH0sXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1RvcGxldmVsID0gREVGTk9ERShcIlRvcGxldmVsXCIsIFwiZ2xvYmFsc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIHRvcGxldmVsIHNjb3BlXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZ2xvYmFsczogXCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1wiLFxuICAgIH0sXG4gICAgd3JhcF9lbmNsb3NlOiBmdW5jdGlvbihhcmdfcGFyYW1ldGVyX3BhaXJzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcblxuICAgICAgICBhcmdfcGFyYW1ldGVyX3BhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gcGFpci5zcGxpdChcIjpcIik7XG5cbiAgICAgICAgICAgIGFyZ3MucHVzaChzcGxpdFswXSk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goc3BsaXRbMV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgd3JhcHBlZF90bCA9IFwiKGZ1bmN0aW9uKFwiICsgcGFyYW1ldGVycy5qb2luKFwiLFwiKSArIFwiKXsgJyRPUklHJzsgfSkoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICAgIHdyYXBwZWRfdGwgPSBwYXJzZSh3cmFwcGVkX3RsKTtcbiAgICAgICAgd3JhcHBlZF90bCA9IHdyYXBwZWRfdGwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24gYmVmb3JlKG5vZGUpe1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmIG5vZGUudmFsdWUgPT0gXCIkT1JJR1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2Uoc2VsZi5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gd3JhcHBlZF90bDtcbiAgICB9LFxuICAgIHdyYXBfY29tbW9uanM6IGZ1bmN0aW9uKG5hbWUsIGV4cG9ydF9hbGwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdG9fZXhwb3J0ID0gW107XG4gICAgICAgIGlmIChleHBvcnRfYWxsKSB7XG4gICAgICAgICAgICBzZWxmLmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgICAgIHNlbGYud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiAmJiBub2RlLmRlZmluaXRpb24oKS5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5kX2lmKGZ1bmN0aW9uKG4peyByZXR1cm4gbi5uYW1lID09IG5vZGUubmFtZSB9LCB0b19leHBvcnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9fZXhwb3J0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwcGVkX3RsID0gXCIoZnVuY3Rpb24oZXhwb3J0cywgZ2xvYmFsKXsgZ2xvYmFsWydcIiArIG5hbWUgKyBcIiddID0gZXhwb3J0czsgJyRPUklHJzsgJyRFWFBPUlRTJzsgfSh7fSwgKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCkpKSlcIjtcbiAgICAgICAgd3JhcHBlZF90bCA9IHBhcnNlKHdyYXBwZWRfdGwpO1xuICAgICAgICB3cmFwcGVkX3RsID0gd3JhcHBlZF90bC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbiBiZWZvcmUobm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0cmluZykgc3dpdGNoIChub2RlLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCIkT1JJR1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShzZWxmLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIiRFWFBPUlRTXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRvX2V4cG9ydC5mb3JFYWNoKGZ1bmN0aW9uKHN5bSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobmV3IEFTVF9TaW1wbGVTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG5ldyBBU1RfQXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbmV3IEFTVF9TeW1ib2xSZWYoeyBuYW1lOiBcImV4cG9ydHNcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBuZXcgQVNUX1N0cmluZyh7IHZhbHVlOiBzeW0ubmFtZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG5ldyBBU1RfU3ltYm9sUmVmKHN5bSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRfdGw7XG4gICAgfVxufSwgQVNUX1Njb3BlKTtcblxudmFyIEFTVF9MYW1iZGEgPSBERUZOT0RFKFwiTGFtYmRhXCIsIFwibmFtZSBhcmduYW1lcyB1c2VzX2FyZ3VtZW50c1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgZnVuY3Rpb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbmFtZTogXCJbQVNUX1N5bWJvbERlY2xhcmF0aW9uP10gdGhlIG5hbWUgb2YgdGhpcyBmdW5jdGlvblwiLFxuICAgICAgICBhcmduYW1lczogXCJbQVNUX1N5bWJvbEZ1bmFyZypdIGFycmF5IG9mIGZ1bmN0aW9uIGFyZ3VtZW50c1wiLFxuICAgICAgICB1c2VzX2FyZ3VtZW50czogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgZnVuY3Rpb24gYWNjZXNzZXMgdGhlIGFyZ3VtZW50cyBhcnJheVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0FjY2Vzc29yID0gREVGTk9ERShcIkFjY2Vzc29yXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNldHRlci9nZXR0ZXIgZnVuY3Rpb24uICBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGFsd2F5cyBudWxsLlwiXG59LCBBU1RfTGFtYmRhKTtcblxudmFyIEFTVF9GdW5jdGlvbiA9IERFRk5PREUoXCJGdW5jdGlvblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0RlZnVuID0gREVGTk9ERShcIkRlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIlxufSwgQVNUX0xhbWJkYSk7XG5cbi8qIC0tLS0tWyBKVU1QUyBdLS0tLS0gKi9cblxudmFyIEFTVF9KdW1wID0gREVGTk9ERShcIkp1bXBcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGp1bXBz4oCdIChmb3Igbm93IHRoYXQncyBgcmV0dXJuYCwgYHRocm93YCwgYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIlxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRXhpdCA9IERFRk5PREUoXCJFeGl0XCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGV4aXRz4oCdIChgcmV0dXJuYCBhbmQgYHRocm93YClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGU/XSB0aGUgdmFsdWUgcmV0dXJuZWQgb3IgdGhyb3duIGJ5IHRoaXMgc3RhdGVtZW50OyBjb3VsZCBiZSBudWxsIGZvciBBU1RfUmV0dXJuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLnZhbHVlICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfUmV0dXJuID0gREVGTk9ERShcIlJldHVyblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgcmV0dXJuYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0V4aXQpO1xuXG52YXIgQVNUX1Rocm93ID0gREVGTk9ERShcIlRocm93XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0aHJvd2Agc3RhdGVtZW50XCJcbn0sIEFTVF9FeGl0KTtcblxudmFyIEFTVF9Mb29wQ29udHJvbCA9IERFRk5PREUoXCJMb29wQ29udHJvbFwiLCBcImxhYmVsXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBsb29wIGNvbnRyb2wgc3RhdGVtZW50cyAoYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsUmVmP10gdGhlIGxhYmVsLCBvciBudWxsIGlmIG5vbmVcIixcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLmxhYmVsICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfQnJlYWsgPSBERUZOT0RFKFwiQnJlYWtcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGJyZWFrYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0xvb3BDb250cm9sKTtcblxudmFyIEFTVF9Db250aW51ZSA9IERFRk5PREUoXCJDb250aW51ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29udGludWVgIHN0YXRlbWVudFwiXG59LCBBU1RfTG9vcENvbnRyb2wpO1xuXG4vKiAtLS0tLVsgSUYgXS0tLS0tICovXG5cbnZhciBBU1RfSWYgPSBERUZOT0RFKFwiSWZcIiwgXCJjb25kaXRpb24gYWx0ZXJuYXRpdmVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGlmYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgYGlmYCBjb25kaXRpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiW0FTVF9TdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0aXZlKSB0aGlzLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgU1dJVENIIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N3aXRjaCA9IERFRk5PREUoXCJTd2l0Y2hcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBzd2l0Y2hgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHN3aXRjaGAg4oCcZGlzY3JpbWluYW504oCdXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1N3aXRjaEJyYW5jaCA9IERFRk5PREUoXCJTd2l0Y2hCcmFuY2hcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGBzd2l0Y2hgIGJyYW5jaGVzXCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0RlZmF1bHQgPSBERUZOT0RFKFwiRGVmYXVsdFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZGVmYXVsdGAgc3dpdGNoIGJyYW5jaFwiLFxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbnZhciBBU1RfQ2FzZSA9IERFRk5PREUoXCJDYXNlXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2FzZWAgc3dpdGNoIGJyYW5jaFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYGNhc2VgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Td2l0Y2hCcmFuY2gpO1xuXG4vKiAtLS0tLVsgRVhDRVBUSU9OUyBdLS0tLS0gKi9cblxudmFyIEFTVF9UcnkgPSBERUZOT0RFKFwiVHJ5XCIsIFwiYmNhdGNoIGJmaW5hbGx5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJjYXRjaDogXCJbQVNUX0NhdGNoP10gdGhlIGNhdGNoIGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCIsXG4gICAgICAgIGJmaW5hbGx5OiBcIltBU1RfRmluYWxseT9dIHRoZSBmaW5hbGx5IGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSB0aGlzLmJjYXRjaC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG4vLyBYWFg6IHRoaXMgaXMgd3JvbmcgYWNjb3JkaW5nIHRvIEVDTUEtMjYyICgxMi40KS4gIHRoZSBjYXRjaCBibG9ja1xuLy8gc2hvdWxkIGludHJvZHVjZSBhbm90aGVyIHNjb3BlLCBhcyB0aGUgYXJnbmFtZSBzaG91bGQgYmUgdmlzaWJsZVxuLy8gb25seSBpbnNpZGUgdGhlIGNhdGNoIGJsb2NrLiAgSG93ZXZlciwgZG9pbmcgaXQgdGhpcyB3YXkgYmVjYXVzZSBvZlxuLy8gSUUgd2hpY2ggc2ltcGx5IGludHJvZHVjZXMgdGhlIG5hbWUgaW4gdGhlIHN1cnJvdW5kaW5nIHNjb3BlLiAgSWZcbi8vIHdlIGV2ZXIgd2FudCB0byBmaXggdGhpcyB0aGVuIEFTVF9DYXRjaCBzaG91bGQgaW5oZXJpdCBmcm9tXG4vLyBBU1RfU2NvcGUuXG52YXIgQVNUX0NhdGNoID0gREVGTk9ERShcIkNhdGNoXCIsIFwiYXJnbmFtZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2F0Y2hgIG5vZGU7IG9ubHkgbWFrZXMgc2Vuc2UgYXMgcGFydCBvZiBhIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGFyZ25hbWU6IFwiW0FTVF9TeW1ib2xDYXRjaF0gc3ltYm9sIGZvciB0aGUgZXhjZXB0aW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0ZpbmFsbHkgPSBERUZOT0RFKFwiRmluYWxseVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZmluYWxseWAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCJcbn0sIEFTVF9CbG9jayk7XG5cbi8qIC0tLS0tWyBWQVIvQ09OU1QgXS0tLS0tICovXG5cbnZhciBBU1RfRGVmaW5pdGlvbnMgPSBERUZOT0RFKFwiRGVmaW5pdGlvbnNcIiwgXCJkZWZpbml0aW9uc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYHZhcmAgb3IgYGNvbnN0YCBub2RlcyAodmFyaWFibGUgZGVjbGFyYXRpb25zL2luaXRpYWxpemF0aW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkZWZpbml0aW9uczogXCJbQVNUX1ZhckRlZipdIGFycmF5IG9mIHZhcmlhYmxlIGRlZmluaXRpb25zXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgZGVmLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1ZhciA9IERFRk5PREUoXCJWYXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHZhcmAgc3RhdGVtZW50XCJcbn0sIEFTVF9EZWZpbml0aW9ucyk7XG5cbnZhciBBU1RfQ29uc3QgPSBERUZOT0RFKFwiQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNvbnN0YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0RlZmluaXRpb25zKTtcblxudmFyIEFTVF9WYXJEZWYgPSBERUZOT0RFKFwiVmFyRGVmXCIsIFwibmFtZSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSB2YXJpYWJsZSBkZWNsYXJhdGlvbjsgb25seSBhcHBlYXJzIGluIGEgQVNUX0RlZmluaXRpb25zIG5vZGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sVmFyfEFTVF9TeW1ib2xDb25zdF0gbmFtZSBvZiB0aGUgdmFyaWFibGVcIixcbiAgICAgICAgdmFsdWU6IFwiW0FTVF9Ob2RlP10gaW5pdGlhbGl6ZXIsIG9yIG51bGwgb2YgdGhlcmUncyBubyBpbml0aWFsaXplclwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIE9USEVSIF0tLS0tLSAqL1xuXG52YXIgQVNUX0NhbGwgPSBERUZOT0RFKFwiQ2FsbFwiLCBcImV4cHJlc3Npb24gYXJnc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBjYWxsIGV4cHJlc3Npb25cIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0byBpbnZva2UgYXMgZnVuY3Rpb25cIixcbiAgICAgICAgYXJnczogXCJbQVNUX05vZGUqXSBhcnJheSBvZiBhcmd1bWVudHNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9OZXcgPSBERUZOT0RFKFwiTmV3XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3QgaW5zdGFudGlhdGlvbi4gIERlcml2ZXMgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgc2luY2UgaXQgaGFzIGV4YWN0bHkgdGhlIHNhbWUgcHJvcGVydGllc1wiXG59LCBBU1RfQ2FsbCk7XG5cbnZhciBBU1RfU2VxID0gREVGTk9ERShcIlNlcVwiLCBcImNhciBjZHJcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2VxdWVuY2UgZXhwcmVzc2lvbiAodHdvIGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjYXI6IFwiW0FTVF9Ob2RlXSBmaXJzdCBlbGVtZW50IGluIHNlcXVlbmNlXCIsXG4gICAgICAgIGNkcjogXCJbQVNUX05vZGVdIHNlY29uZCBlbGVtZW50IGluIHNlcXVlbmNlXCJcbiAgICB9LFxuICAgICRjb25zOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBzZXEgPSBuZXcgQVNUX1NlcSh4KTtcbiAgICAgICAgc2VxLmNhciA9IHg7XG4gICAgICAgIHNlcS5jZHIgPSB5O1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH0sXG4gICAgJGZyb21fYXJyYXk6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMSkgcmV0dXJuIGFycmF5WzBdLmNsb25lKCk7XG4gICAgICAgIHZhciBsaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBsaXN0ID0gQVNUX1NlcS5jb25zKGFycmF5W2ldLCBsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IGxpc3Q7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIXAuY2RyLmNkcikge1xuICAgICAgICAgICAgICAgIHAuY2RyID0gcC5jZHIuY2FyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG4gICAgdG9fYXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMsIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGEucHVzaChwLmNhcik7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKHAuY2RyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLmNkcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAoIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBBU1RfU2VxLmNvbnMocC5jZHIsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmNkciA9IGNlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5jZHI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5jYXIuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZHIpIHRoaXMuY2RyLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Qcm9wQWNjZXNzID0gREVGTk9ERShcIlByb3BBY2Nlc3NcIiwgXCJleHByZXNzaW9uIHByb3BlcnR5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbnMsIGkuZS4gYGEuZm9vYCBvciBgYVtcXFwiZm9vXFxcIl1gXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSDigJxjb250YWluZXLigJ0gZXhwcmVzc2lvblwiLFxuICAgICAgICBwcm9wZXJ0eTogXCJbQVNUX05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiAgRm9yIEFTVF9Eb3QgdGhpcyBpcyBhbHdheXMgYSBwbGFpbiBzdHJpbmcsIHdoaWxlIGZvciBBU1RfU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlXCJcbiAgICB9XG59KTtcblxudmFyIEFTVF9Eb3QgPSBERUZOT0RFKFwiRG90XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRvdHRlZCBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvblwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfUHJvcEFjY2Vzcyk7XG5cbnZhciBBU1RfU3ViID0gREVGTk9ERShcIlN1YlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiSW5kZXgtc3R5bGUgcHJvcGVydHkgYWNjZXNzLCBpLmUuIGBhW1xcXCJmb29cXFwiXWBcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9VbmFyeSA9IERFRk5PREUoXCJVbmFyeVwiLCBcIm9wZXJhdG9yIGV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIHVuYXJ5IGV4cHJlc3Npb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSBleHByZXNzaW9uIHRoYXQgdGhpcyB1bmFyeSBvcGVyYXRvciBhcHBsaWVzIHRvXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9VbmFyeVByZWZpeCA9IERFRk5PREUoXCJVbmFyeVByZWZpeFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVW5hcnkgcHJlZml4IGV4cHJlc3Npb24sIGkuZS4gYHR5cGVvZiBpYCBvciBgKytpYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX1VuYXJ5UG9zdGZpeCA9IERFRk5PREUoXCJVbmFyeVBvc3RmaXhcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlVuYXJ5IHBvc3RmaXggZXhwcmVzc2lvbiwgaS5lLiBgaSsrYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX0JpbmFyeSA9IERFRk5PREUoXCJCaW5hcnlcIiwgXCJsZWZ0IG9wZXJhdG9yIHJpZ2h0XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCaW5hcnkgZXhwcmVzc2lvbiwgaS5lLiBgYSArIGJgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbGVmdDogXCJbQVNUX05vZGVdIGxlZnQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIixcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIHJpZ2h0OiBcIltBU1RfTm9kZV0gcmlnaHQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxlZnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Db25kaXRpb25hbCA9IERFRk5PREUoXCJDb25kaXRpb25hbFwiLCBcImNvbmRpdGlvbiBjb25zZXF1ZW50IGFsdGVybmF0aXZlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJDb25kaXRpb25hbCBleHByZXNzaW9uIHVzaW5nIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yLCBpLmUuIGBhID8gYiA6IGNgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV1cIixcbiAgICAgICAgY29uc2VxdWVudDogXCJbQVNUX05vZGVdXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIltBU1RfTm9kZV1cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX0Fzc2lnbiA9IERFRk5PREUoXCJBc3NpZ25cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiDigJQgYGEgPSBiICsgNWBcIixcbn0sIEFTVF9CaW5hcnkpO1xuXG4vKiAtLS0tLVsgTElURVJBTFMgXS0tLS0tICovXG5cbnZhciBBU1RfQXJyYXkgPSBERUZOT0RFKFwiQXJyYXlcIiwgXCJlbGVtZW50c1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYXJyYXkgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGVsZW1lbnRzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgICAgICBlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3QgPSBERUZOT0RFKFwiT2JqZWN0XCIsIFwicHJvcGVydGllc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBwcm9wZXJ0aWVzOiBcIltBU1RfT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgcHJvcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3RQcm9wZXJ0eSA9IERFRk5PREUoXCJPYmplY3RQcm9wZXJ0eVwiLCBcImtleSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgbGl0ZXJhbCBvYmplY3QgcHJvcGVydGllc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGtleTogXCJbc3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIE9iamVjdEtleVZhbC4gIEZvciBzZXR0ZXJzIGFuZCBnZXR0ZXJzIHRoaXMgaXMgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlLlwiLFxuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGVdIHByb3BlcnR5IHZhbHVlLiAgRm9yIHNldHRlcnMgYW5kIGdldHRlcnMgdGhpcyBpcyBhbiBBU1RfRnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBBU1RfT2JqZWN0S2V5VmFsID0gREVGTk9ERShcIk9iamVjdEtleVZhbFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBrZXk6IHZhbHVlIG9iamVjdCBwcm9wZXJ0eVwiLFxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9PYmplY3RTZXR0ZXIgPSBERUZOT0RFKFwiT2JqZWN0U2V0dGVyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3Qgc2V0dGVyIHByb3BlcnR5XCIsXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX09iamVjdEdldHRlciA9IERFRk5PREUoXCJPYmplY3RHZXR0ZXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBnZXR0ZXIgcHJvcGVydHlcIixcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfU3ltYm9sID0gREVGTk9ERShcIlN5bWJvbFwiLCBcInNjb3BlIG5hbWUgdGhlZGVmXCIsIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixcbiAgICAgICAgc2NvcGU6IFwiW0FTVF9TY29wZS9TXSB0aGUgY3VycmVudCBzY29wZSAobm90IG5lY2Vzc2FyaWx5IHRoZSBkZWZpbml0aW9uIHNjb3BlKVwiLFxuICAgICAgICB0aGVkZWY6IFwiW1N5bWJvbERlZi9TXSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHN5bWJvbFwiXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3ltYm9sc1wiLFxufSk7XG5cbnZhciBBU1RfU3ltYm9sQWNjZXNzb3IgPSBERUZOT0RFKFwiU3ltYm9sQWNjZXNzb3JcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBuYW1lIG9mIGEgcHJvcGVydHkgYWNjZXNzb3IgKHNldHRlci9nZXR0ZXIgZnVuY3Rpb24pXCJcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gREVGTk9ERShcIlN5bWJvbERlY2xhcmF0aW9uXCIsIFwiaW5pdFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBkZWNsYXJhdGlvbiBzeW1ib2wgKHN5bWJvbCBpbiB2YXIvY29uc3QsIGZ1bmN0aW9uIG5hbWUgb3IgYXJndW1lbnQsIHN5bWJvbCBpbiBjYXRjaClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZSovU10gYXJyYXkgb2YgaW5pdGlhbGl6ZXJzIGZvciB0aGlzIGRlY2xhcmF0aW9uLlwiXG4gICAgfVxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sVmFyID0gREVGTk9ERShcIlN5bWJvbFZhclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIGRlZmluaW5nIGEgdmFyaWFibGVcIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFwiU3ltYm9sQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY29uc3RhbnQgZGVjbGFyYXRpb25cIlxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xGdW5hcmcgPSBERUZOT0RFKFwiU3ltYm9sRnVuYXJnXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gYXJndW1lbnRcIixcbn0sIEFTVF9TeW1ib2xWYXIpO1xuXG52YXIgQVNUX1N5bWJvbERlZnVuID0gREVGTk9ERShcIlN5bWJvbERlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSBmdW5jdGlvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xMYW1iZGEgPSBERUZOT0RFKFwiU3ltYm9sTGFtYmRhXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xDYXRjaCA9IERFRk5PREUoXCJTeW1ib2xDYXRjaFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyB0aGUgZXhjZXB0aW9uIGluIGNhdGNoXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX0xhYmVsID0gREVGTk9ERShcIkxhYmVsXCIsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyBhIGxhYmVsIChkZWNsYXJhdGlvbilcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICByZWZlcmVuY2VzOiBcIltBU1RfTG9vcENvbnRyb2wqXSBhIGxpc3Qgb2Ygbm9kZXMgcmVmZXJyaW5nIHRvIHRoaXMgbGFiZWxcIlxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHRoaXM7XG4gICAgfVxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sUmVmID0gREVGTk9ERShcIlN5bWJvbFJlZlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVmZXJlbmNlIHRvIHNvbWUgc3ltYm9sIChub3QgZGVmaW5pdGlvbi9kZWNsYXJhdGlvbilcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX0xhYmVsUmVmID0gREVGTk9ERShcIkxhYmVsUmVmXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZWZlcmVuY2UgdG8gYSBsYWJlbCBzeW1ib2xcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1RoaXMgPSBERUZOT0RFKFwiVGhpc1wiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB0aGlzYCBzeW1ib2xcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX0NvbnN0YW50ID0gREVGTk9ERShcIkNvbnN0YW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgY29uc3RhbnRzXCIsXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9TdHJpbmcgPSBERUZOT0RFKFwiU3RyaW5nXCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc3RyaW5nIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSB0aGUgY29udGVudHMgb2YgdGhpcyBzdHJpbmdcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfTnVtYmVyID0gREVGTk9ERShcIk51bWJlclwiLCBcInZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIG51bWJlciBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW251bWJlcl0gdGhlIG51bWVyaWMgdmFsdWVcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfUmVnRXhwID0gREVGTk9ERShcIlJlZ0V4cFwiLCBcInZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHJlZ2V4cCBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW1JlZ0V4cF0gdGhlIGFjdHVhbCByZWdleHBcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfQXRvbSA9IERFRk5PREUoXCJBdG9tXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhdG9tc1wiLFxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9OdWxsID0gREVGTk9ERShcIk51bGxcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgbnVsbGAgYXRvbVwiLFxuICAgIHZhbHVlOiBudWxsXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfTmFOID0gREVGTk9ERShcIk5hTlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGltcG9zc2libGUgdmFsdWVcIixcbiAgICB2YWx1ZTogMC8wXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfVW5kZWZpbmVkID0gREVGTk9ERShcIlVuZGVmaW5lZFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB1bmRlZmluZWRgIHZhbHVlXCIsXG4gICAgdmFsdWU6IChmdW5jdGlvbigpe30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Ib2xlID0gREVGTk9ERShcIkhvbGVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgaG9sZSBpbiBhbiBhcnJheVwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24oKXt9KCkpXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfSW5maW5pdHkgPSBERUZOT0RFKFwiSW5maW5pdHlcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgSW5maW5pdHlgIHZhbHVlXCIsXG4gICAgdmFsdWU6IDEvMFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0Jvb2xlYW4gPSBERUZOT0RFKFwiQm9vbGVhblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYm9vbGVhbnNcIixcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9GYWxzZSA9IERFRk5PREUoXCJGYWxzZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBmYWxzZWAgYXRvbVwiLFxuICAgIHZhbHVlOiBmYWxzZVxufSwgQVNUX0Jvb2xlYW4pO1xuXG52YXIgQVNUX1RydWUgPSBERUZOT0RFKFwiVHJ1ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB0cnVlYCBhdG9tXCIsXG4gICAgdmFsdWU6IHRydWVcbn0sIEFTVF9Cb29sZWFuKTtcblxuLyogLS0tLS1bIFRyZWVXYWxrZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIFRyZWVXYWxrZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLnZpc2l0ID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xufTtcblRyZWVXYWxrZXIucHJvdG90eXBlID0ge1xuICAgIF92aXNpdDogZnVuY3Rpb24obm9kZSwgZGVzY2VuZCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLnZpc2l0KG5vZGUsIGRlc2NlbmQgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGVzY2VuZC5jYWxsKG5vZGUpO1xuICAgICAgICB9IDogbm9vcCk7XG4gICAgICAgIGlmICghcmV0ICYmIGRlc2NlbmQpIHtcbiAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMiAtIChuIHx8IDApXTtcbiAgICB9LFxuICAgIHB1c2g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcbiAgICB9LFxuICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH0sXG4gICAgc2VsZjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBmaW5kX3BhcmVudDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIHR5cGUpIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXNfZGlyZWN0aXZlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRfcGFyZW50KEFTVF9TY29wZSkuaGFzX2RpcmVjdGl2ZSh0eXBlKTtcbiAgICB9LFxuICAgIGluX2Jvb2xlYW5fY29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoLCBzZWxmID0gc3RhY2tbLS1pXTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHN0YWNrWy0taV07XG4gICAgICAgICAgICBpZiAoKHAgaW5zdGFuY2VvZiBBU1RfSWYgICAgICAgICAgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9EV0xvb3AgICAgICAgJiYgcC5jb25kaXRpb24gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRm9yICAgICAgICAgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICAmJiBwLm9wZXJhdG9yID09IFwiIVwiICYmIHAuZXhwcmVzc2lvbiA9PT0gc2VsZikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiAocC5vcGVyYXRvciA9PSBcIiYmXCIgfHwgcC5vcGVyYXRvciA9PSBcInx8XCIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbG9vcGNvbnRyb2xfdGFyZ2V0OiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICBpZiAobGFiZWwpIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQgJiYgeC5sYWJlbC5uYW1lID09IGxhYmVsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBU1RfU3dpdGNoIHx8IHggaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgIFBhcnNlciBiYXNlZCBvbiBwYXJzZS1qcyAoaHR0cDovL21hcmlqbi5oYXZlcmJla2UubmwvcGFyc2UtanMvKS5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBLRVlXT1JEUyA9ICdicmVhayBjYXNlIGNhdGNoIGNvbnN0IGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVsZXRlIGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgaW4gaW5zdGFuY2VvZiBuZXcgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGgnO1xudmFyIEtFWVdPUkRTX0FUT00gPSAnZmFsc2UgbnVsbCB0cnVlJztcbnZhciBSRVNFUlZFRF9XT1JEUyA9ICdhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aGlzIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGUnXG4gICAgKyBcIiBcIiArIEtFWVdPUkRTX0FUT00gKyBcIiBcIiArIEtFWVdPUkRTO1xudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gJ3JldHVybiBuZXcgZGVsZXRlIHRocm93IGVsc2UgY2FzZSc7XG5cbktFWVdPUkRTID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEUyk7XG5SRVNFUlZFRF9XT1JEUyA9IG1ha2VQcmVkaWNhdGUoUkVTRVJWRURfV09SRFMpO1xuS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OKTtcbktFWVdPUkRTX0FUT00gPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTX0FUT00pO1xuXG52YXIgT1BFUkFUT1JfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCIrLSomJT08PiE/fH5eXCIpKTtcblxudmFyIFJFX0hFWF9OVU1CRVIgPSAvXjB4WzAtOWEtZl0rJC9pO1xudmFyIFJFX09DVF9OVU1CRVIgPSAvXjBbMC03XSskLztcbnZhciBSRV9ERUNfTlVNQkVSID0gL15cXGQqXFwuP1xcZCooPzplWystXT9cXGQqKD86XFxkXFwuP3xcXC4/XFxkKVxcZCopPyQvaTtcblxudmFyIE9QRVJBVE9SUyA9IG1ha2VQcmVkaWNhdGUoW1xuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcInR5cGVvZlwiLFxuICAgIFwibmV3XCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcIisrXCIsXG4gICAgXCItLVwiLFxuICAgIFwiK1wiLFxuICAgIFwiLVwiLFxuICAgIFwiIVwiLFxuICAgIFwiflwiLFxuICAgIFwiJlwiLFxuICAgIFwifFwiLFxuICAgIFwiXlwiLFxuICAgIFwiKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiJVwiLFxuICAgIFwiPj5cIixcbiAgICBcIjw8XCIsXG4gICAgXCI+Pj5cIixcbiAgICBcIjxcIixcbiAgICBcIj5cIixcbiAgICBcIjw9XCIsXG4gICAgXCI+PVwiLFxuICAgIFwiPT1cIixcbiAgICBcIj09PVwiLFxuICAgIFwiIT1cIixcbiAgICBcIiE9PVwiLFxuICAgIFwiP1wiLFxuICAgIFwiPVwiLFxuICAgIFwiKz1cIixcbiAgICBcIi09XCIsXG4gICAgXCIvPVwiLFxuICAgIFwiKj1cIixcbiAgICBcIiU9XCIsXG4gICAgXCI+Pj1cIixcbiAgICBcIjw8PVwiLFxuICAgIFwiPj4+PVwiLFxuICAgIFwifD1cIixcbiAgICBcIl49XCIsXG4gICAgXCImPVwiLFxuICAgIFwiJiZcIixcbiAgICBcInx8XCJcbl0pO1xuXG52YXIgV0hJVEVTUEFDRV9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIiBcXHUwMGEwXFxuXFxyXFx0XFxmXFx1MDAwYlxcdTIwMGJcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcIikpO1xuXG52YXIgUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIlt7KCwuOzpcIikpO1xuXG52YXIgUFVOQ19DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIltde30oKSw7OlwiKSk7XG5cbnZhciBSRUdFWFBfTU9ESUZJRVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiZ21zaXlcIikpO1xuXG4vKiAtLS0tLVsgVG9rZW5pemVyIF0tLS0tLSAqL1xuXG4vLyByZWdleHBzIGFkYXB0ZWQgZnJvbSBodHRwOi8veHJlZ2V4cC5jb20vcGx1Z2lucy8jdW5pY29kZVxudmFyIFVOSUNPREUgPSB7XG4gICAgbGV0dGVyOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA0MS1cXFxcdTAwNUFcXFxcdTAwNjEtXFxcXHUwMDdBXFxcXHUwMEFBXFxcXHUwMEI1XFxcXHUwMEJBXFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzNzAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdBLVxcXFx1MDM3RFxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEUtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0OEEtXFxcXHUwNTIzXFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MDU1OVxcXFx1MDU2MS1cXFxcdTA1ODdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYyMS1cXFxcdTA2NEFcXFxcdTA2NkVcXFxcdTA2NkZcXFxcdTA2NzEtXFxcXHUwNkQzXFxcXHUwNkQ1XFxcXHUwNkU1XFxcXHUwNkU2XFxcXHUwNkVFXFxcXHUwNkVGXFxcXHUwNkZBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMFxcXFx1MDcxMi1cXFxcdTA3MkZcXFxcdTA3NEQtXFxcXHUwN0E1XFxcXHUwN0IxXFxcXHUwN0NBLVxcXFx1MDdFQVxcXFx1MDdGNFxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M0RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcxXFxcXHUwOTcyXFxcXHUwOTdCLVxcXFx1MDk3RlxcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkRcXFxcdTA5Q0VcXFxcdTA5RENcXFxcdTA5RERcXFxcdTA5REYtXFxcXHUwOUUxXFxcXHUwOUYwXFxcXHUwOUYxXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE3Mi1cXFxcdTBBNzRcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCRFxcXFx1MEFEMFxcXFx1MEFFMFxcXFx1MEFFMVxcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0RcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYxXFxcXHUwQjcxXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCRDBcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzMzXFxcXHUwQzM1LVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDI4XFxcXHUwRDJBLVxcXFx1MEQzOVxcXFx1MEQzRFxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQ1xcXFx1MEVERFxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4QlxcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkNcXFxcdTExMDAtXFxcXHUxMTU5XFxcXHUxMTVGLVxcXFx1MTFBMlxcXFx1MTFBOC1cXFxcdTExRjlcXFxcdTEyMDAtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2NzZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3QjNcXFxcdTE3RDdcXFxcdTE3RENcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThBOFxcXFx1MThBQVxcXFx1MTkwMC1cXFxcdTE5MUNcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QTlcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUMwMC1cXFxcdTFDMjNcXFxcdTFDNEQtXFxcXHUxQzRGXFxcXHUxQzVBLVxcXFx1MUM3RFxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDk0XFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTgzXFxcXHUyMTg0XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQzZGXFxcXHUyQzcxLVxcXFx1MkM3RFxcXFx1MkM4MC1cXFxcdTJDRTRcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDMwLVxcXFx1MkQ2NVxcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNVxcXFx1MzAwNlxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwM0JcXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUI3XFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMFxcXFx1NERCNVxcXFx1NEUwMFxcXFx1OUZDM1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NUZcXFxcdUE2NjItXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5N1xcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCXFxcXHVBNzhDXFxcXHVBN0ZCLVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFDMDBcXFxcdUQ3QTNcXFxcdUY5MDAtXFxcXHVGQTJEXFxcXHVGQTMwLVxcXFx1RkE2QVxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXVwiKSxcbiAgICBub25fc3BhY2luZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2NEItXFxcXHUwNjVFXFxcXHUwNjcwXFxcXHUwNkQ2LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RTRcXFxcdTA2RTdcXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkVEXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0QVxcXFx1MDdBNi1cXFxcdTA3QjBcXFxcdTA3RUItXFxcXHUwN0YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxQi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyRFxcXFx1MDkwMC1cXFxcdTA5MDJcXFxcdTA5M0NcXFxcdTA5NDEtXFxcXHUwOTQ4XFxcXHUwOTREXFxcXHUwOTUxLVxcXFx1MDk1NVxcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MVxcXFx1MDlCQ1xcXFx1MDlDMS1cXFxcdTA5QzRcXFxcdTA5Q0RcXFxcdTA5RTJcXFxcdTA5RTNcXFxcdTBBMDFcXFxcdTBBMDJcXFxcdTBBM0NcXFxcdTBBNDFcXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTcwXFxcXHUwQTcxXFxcXHUwQTc1XFxcXHUwQTgxXFxcXHUwQTgyXFxcXHUwQUJDXFxcXHUwQUMxLVxcXFx1MEFDNVxcXFx1MEFDN1xcXFx1MEFDOFxcXFx1MEFDRFxcXFx1MEFFMlxcXFx1MEFFM1xcXFx1MEIwMVxcXFx1MEIzQ1xcXFx1MEIzRlxcXFx1MEI0MS1cXFxcdTBCNDRcXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQzBcXFxcdTBCQ0RcXFxcdTBDM0UtXFxcXHUwQzQwXFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNjJcXFxcdTBDNjNcXFxcdTBDQkNcXFxcdTBDQkZcXFxcdTBDQzZcXFxcdTBDQ0NcXFxcdTBDQ0RcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBENDEtXFxcXHUwRDQ0XFxcXHUwRDREXFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRENBXFxcXHUwREQyLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEUzMVxcXFx1MEUzNC1cXFxcdTBFM0FcXFxcdTBFNDctXFxcXHUwRTRFXFxcXHUwRUIxXFxcXHUwRUI0LVxcXFx1MEVCOVxcXFx1MEVCQlxcXFx1MEVCQ1xcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGNzEtXFxcXHUwRjdFXFxcXHUwRjgwLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY5MC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJELVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM0FcXFxcdTEwM0RcXFxcdTEwM0VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4RFxcXFx1MTA5RFxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I3LVxcXFx1MTdCRFxcXFx1MTdDNlxcXFx1MTdDOS1cXFxcdTE3RDNcXFxcdTE3RERcXFxcdTE4MEItXFxcXHUxODBEXFxcXHUxOEE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M0JcXFxcdTFBMTdcXFxcdTFBMThcXFxcdTFBNTZcXFxcdTFBNTgtXFxcXHUxQTVFXFxcXHUxQTYwXFxcXHUxQTYyXFxcXHUxQTY1LVxcXFx1MUE2Q1xcXFx1MUE3My1cXFxcdTFBN0NcXFxcdTFBN0ZcXFxcdTFCMDAtXFxcXHUxQjAzXFxcXHUxQjM0XFxcXHUxQjM2LVxcXFx1MUIzQVxcXFx1MUIzQ1xcXFx1MUI0MlxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODBcXFxcdTFCODFcXFxcdTFCQTItXFxcXHUxQkE1XFxcXHUxQkE4XFxcXHUxQkE5XFxcXHUxQzJDLVxcXFx1MUMzM1xcXFx1MUMzNlxcXFx1MUMzN1xcXFx1MUNEMC1cXFxcdTFDRDJcXFxcdTFDRDQtXFxcXHUxQ0UwXFxcXHUxQ0UyLVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MURDMC1cXFxcdTFERTZcXFxcdTFERkQtXFxcXHUxREZGXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkZcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkZcXFxcdUE2N0NcXFxcdUE2N0RcXFxcdUE2RjBcXFxcdUE2RjFcXFxcdUE4MDJcXFxcdUE4MDZcXFxcdUE4MEJcXFxcdUE4MjVcXFxcdUE4MjZcXFxcdUE4QzRcXFxcdUE4RTAtXFxcXHVBOEYxXFxcXHVBOTI2LVxcXFx1QTkyRFxcXFx1QTk0Ny1cXFxcdUE5NTFcXFxcdUE5ODAtXFxcXHVBOTgyXFxcXHVBOUIzXFxcXHVBOUI2LVxcXFx1QTlCOVxcXFx1QTlCQ1xcXFx1QUEyOS1cXFxcdUFBMkVcXFxcdUFBMzFcXFxcdUFBMzJcXFxcdUFBMzVcXFxcdUFBMzZcXFxcdUFBNDNcXFxcdUFBNENcXFxcdUFBQjBcXFxcdUFBQjItXFxcXHVBQUI0XFxcXHVBQUI3XFxcXHVBQUI4XFxcXHVBQUJFXFxcXHVBQUJGXFxcXHVBQUMxXFxcXHVBQkU1XFxcXHVBQkU4XFxcXHVBQkVEXFxcXHVGQjFFXFxcXHVGRTAwLVxcXFx1RkUwRlxcXFx1RkUyMC1cXFxcdUZFMjZdXCIpLFxuICAgIHNwYWNlX2NvbWJpbmluZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDkwM1xcXFx1MDkzRS1cXFxcdTA5NDBcXFxcdTA5NDktXFxcXHUwOTRDXFxcXHUwOTRFXFxcXHUwOTgyXFxcXHUwOTgzXFxcXHUwOUJFLVxcXFx1MDlDMFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQlxcXFx1MDlDQ1xcXFx1MDlEN1xcXFx1MEEwM1xcXFx1MEEzRS1cXFxcdTBBNDBcXFxcdTBBODNcXFxcdTBBQkUtXFxcXHUwQUMwXFxcXHUwQUM5XFxcXHUwQUNCXFxcXHUwQUNDXFxcXHUwQjAyXFxcXHUwQjAzXFxcXHUwQjNFXFxcXHUwQjQwXFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCXFxcXHUwQjRDXFxcXHUwQjU3XFxcXHUwQkJFXFxcXHUwQkJGXFxcXHUwQkMxXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0NcXFxcdTBCRDdcXFxcdTBDMDEtXFxcXHUwQzAzXFxcXHUwQzQxLVxcXFx1MEM0NFxcXFx1MEM4MlxcXFx1MEM4M1xcXFx1MENCRVxcXFx1MENDMC1cXFxcdTBDQzRcXFxcdTBDQzdcXFxcdTBDQzhcXFxcdTBDQ0FcXFxcdTBDQ0JcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBEMDJcXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQwXFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENENcXFxcdTBENTdcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEQ0YtXFxcXHUwREQxXFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3RlxcXFx1MTAyQlxcXFx1MTAyQ1xcXFx1MTAzMVxcXFx1MTAzOFxcXFx1MTAzQlxcXFx1MTAzQ1xcXFx1MTA1NlxcXFx1MTA1N1xcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDgzXFxcXHUxMDg0XFxcXHUxMDg3LVxcXFx1MTA4Q1xcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOUNcXFxcdTE3QjZcXFxcdTE3QkUtXFxcXHUxN0M1XFxcXHUxN0M3XFxcXHUxN0M4XFxcXHUxOTIzLVxcXFx1MTkyNlxcXFx1MTkyOS1cXFxcdTE5MkJcXFxcdTE5MzBcXFxcdTE5MzFcXFxcdTE5MzMtXFxcXHUxOTM4XFxcXHUxOUIwLVxcXFx1MTlDMFxcXFx1MTlDOFxcXFx1MTlDOVxcXFx1MUExOS1cXFxcdTFBMUJcXFxcdTFBNTVcXFxcdTFBNTdcXFxcdTFBNjFcXFxcdTFBNjNcXFxcdTFBNjRcXFxcdTFBNkQtXFxcXHUxQTcyXFxcXHUxQjA0XFxcXHUxQjM1XFxcXHUxQjNCXFxcXHUxQjNELVxcXFx1MUI0MVxcXFx1MUI0M1xcXFx1MUI0NFxcXFx1MUI4MlxcXFx1MUJBMVxcXFx1MUJBNlxcXFx1MUJBN1xcXFx1MUJBQVxcXFx1MUMyNC1cXFxcdTFDMkJcXFxcdTFDMzRcXFxcdTFDMzVcXFxcdTFDRTFcXFxcdTFDRjJcXFxcdUE4MjNcXFxcdUE4MjRcXFxcdUE4MjdcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEMzXFxcXHVBOTUyXFxcXHVBOTUzXFxcXHVBOTgzXFxcXHVBOUI0XFxcXHVBOUI1XFxcXHVBOUJBXFxcXHVBOUJCXFxcXHVBOUJELVxcXFx1QTlDMFxcXFx1QUEyRlxcXFx1QUEzMFxcXFx1QUEzM1xcXFx1QUEzNFxcXFx1QUE0RFxcXFx1QUE3QlxcXFx1QUJFM1xcXFx1QUJFNFxcXFx1QUJFNlxcXFx1QUJFN1xcXFx1QUJFOVxcXFx1QUJFQVxcXFx1QUJFQ11cIiksXG4gICAgY29ubmVjdG9yX3B1bmN0dWF0aW9uOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA1RlxcXFx1MjAzRlxcXFx1MjA0MFxcXFx1MjA1NFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZGM0ZdXCIpXG59O1xuXG5mdW5jdGlvbiBpc19sZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMilcbiAgICAgICAgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MClcbiAgICAgICAgfHwgKGNvZGUgPj0gMHhhYSAmJiBVTklDT0RFLmxldHRlci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3OyAvL1hYWDogZmluZCBvdXQgaWYgXCJVbmljb2RlRGlnaXRcIiBtZWFucyBzb21ldGhpbmcgZWxzZSB0aGFuIDAuLjlcbn07XG5cbmZ1bmN0aW9uIGlzX2FscGhhbnVtZXJpY19jaGFyKGNvZGUpIHtcbiAgICByZXR1cm4gaXNfZGlnaXQoY29kZSkgfHwgaXNfbGV0dGVyKGNvZGUpO1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaCkge1xuICAgIHJldHVybiBVTklDT0RFLm5vbl9zcGFjaW5nX21hcmsudGVzdChjaCkgfHwgVU5JQ09ERS5zcGFjZV9jb21iaW5pbmdfbWFyay50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uKGNoKSB7XG4gICAgcmV0dXJuIFVOSUNPREUuY29ubmVjdG9yX3B1bmN0dWF0aW9uLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuICFSRVNFUlZFRF9XT1JEUyhuYW1lKSAmJiAvXlthLXpfJF1bYS16MC05XyRdKiQvaS50ZXN0KG5hbWUpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gMzYgfHwgY29kZSA9PSA5NSB8fCBpc19sZXR0ZXIoY29kZSk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX2NoYXIoY2gpIHtcbiAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGlzX2lkZW50aWZpZXJfc3RhcnQoY29kZSlcbiAgICAgICAgfHwgaXNfZGlnaXQoY29kZSlcbiAgICAgICAgfHwgY29kZSA9PSA4MjA0IC8vIFxcdTIwMGM6IHplcm8td2lkdGggbm9uLWpvaW5lciA8WldOSj5cbiAgICAgICAgfHwgY29kZSA9PSA4MjA1IC8vIFxcdTIwMGQ6IHplcm8td2lkdGggam9pbmVyIDxaV0o+IChpbiBteSBFQ01BLTI2MiBQREYsIHRoaXMgaXMgYWxzbyAyMDBjKVxuICAgICAgICB8fCBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKVxuICAgICAgICB8fCBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbihjaClcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0cmluZyhzdHIpe1xuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoaSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc19pZGVudGlmaWVyX3N0YXJ0KHN0ci5jaGFyQ29kZUF0KDApKSkgcmV0dXJuIGZhbHNlO1xuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihzdHIuY2hhckF0KGkpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZV9qc19udW1iZXIobnVtKSB7XG4gICAgaWYgKFJFX0hFWF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDIpLCAxNik7XG4gICAgfSBlbHNlIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigxKSwgOCk7XG4gICAgfSBlbHNlIGlmIChSRV9ERUNfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEpTX1BhcnNlX0Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sID0gY29sO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbn07XG5cbkpTX1BhcnNlX0Vycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyBcIiAobGluZTogXCIgKyB0aGlzLmxpbmUgKyBcIiwgY29sOiBcIiArIHRoaXMuY29sICsgXCIsIHBvczogXCIgKyB0aGlzLnBvcyArIFwiKVwiICsgXCJcXG5cXG5cIiArIHRoaXMuc3RhY2s7XG59O1xuXG5mdW5jdGlvbiBqc19lcnJvcihtZXNzYWdlLCBmaWxlbmFtZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICB0aHJvdyBuZXcgSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpO1xufTtcblxuZnVuY3Rpb24gaXNfdG9rZW4odG9rZW4sIHR5cGUsIHZhbCkge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09IHR5cGUgJiYgKHZhbCA9PSBudWxsIHx8IHRva2VuLnZhbHVlID09IHZhbCk7XG59O1xuXG52YXIgRVhfRU9GID0ge307XG5cbmZ1bmN0aW9uIHRva2VuaXplcigkVEVYVCwgZmlsZW5hbWUsIGh0bWw1X2NvbW1lbnRzKSB7XG5cbiAgICB2YXIgUyA9IHtcbiAgICAgICAgdGV4dCAgICAgICAgICAgIDogJFRFWFQucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpLFxuICAgICAgICBmaWxlbmFtZSAgICAgICAgOiBmaWxlbmFtZSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rcG9zICAgICAgICAgIDogMCxcbiAgICAgICAgbGluZSAgICAgICAgICAgIDogMSxcbiAgICAgICAgdG9rbGluZSAgICAgICAgIDogMCxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rY29sICAgICAgICAgIDogMCxcbiAgICAgICAgbmV3bGluZV9iZWZvcmUgIDogZmFsc2UsXG4gICAgICAgIHJlZ2V4X2FsbG93ZWQgICA6IGZhbHNlLFxuICAgICAgICBjb21tZW50c19iZWZvcmUgOiBbXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy50ZXh0LmNoYXJBdChTLnBvcyk7IH07XG5cbiAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICB2YXIgY2ggPSBTLnRleHQuY2hhckF0KFMucG9zKyspO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiAhY2gpXG4gICAgICAgICAgICB0aHJvdyBFWF9FT0Y7XG4gICAgICAgIGlmIChjaCA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgKytTLmxpbmU7XG4gICAgICAgICAgICBTLmNvbCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK1MuY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yd2FyZChpKSB7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSBuZXh0KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvb2tpbmdfYXQoc3RyKSB7XG4gICAgICAgIHJldHVybiBTLnRleHQuc3Vic3RyKFMucG9zLCBzdHIubGVuZ3RoKSA9PSBzdHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbmQod2hhdCwgc2lnbmFsX2VvZikge1xuICAgICAgICB2YXIgcG9zID0gUy50ZXh0LmluZGV4T2Yod2hhdCwgUy5wb3MpO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT0gLTEpIHRocm93IEVYX0VPRjtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc3RhcnRfdG9rZW4oKSB7XG4gICAgICAgIFMudG9rbGluZSA9IFMubGluZTtcbiAgICAgICAgUy50b2tjb2wgPSBTLmNvbDtcbiAgICAgICAgUy50b2twb3MgPSBTLnBvcztcbiAgICB9O1xuXG4gICAgdmFyIHByZXZfd2FzX2RvdCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHRva2VuKHR5cGUsIHZhbHVlLCBpc19jb21tZW50KSB7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9ICgodHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgIVVOQVJZX1BPU1RGSVgodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJrZXl3b3JkXCIgJiYgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJwdW5jXCIgJiYgUFVOQ19CRUZPUkVfRVhQUkVTU0lPTih2YWx1ZSkpKTtcbiAgICAgICAgcHJldl93YXNfZG90ID0gKHR5cGUgPT0gXCJwdW5jXCIgJiYgdmFsdWUgPT0gXCIuXCIpO1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgdHlwZSAgIDogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlICA6IHZhbHVlLFxuICAgICAgICAgICAgbGluZSAgIDogUy50b2tsaW5lLFxuICAgICAgICAgICAgY29sICAgIDogUy50b2tjb2wsXG4gICAgICAgICAgICBwb3MgICAgOiBTLnRva3BvcyxcbiAgICAgICAgICAgIGVuZHBvcyA6IFMucG9zLFxuICAgICAgICAgICAgbmxiICAgIDogUy5uZXdsaW5lX2JlZm9yZSxcbiAgICAgICAgICAgIGZpbGUgICA6IGZpbGVuYW1lXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgcmV0LmNvbW1lbnRzX2JlZm9yZSA9IFMuY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgUy5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgICAgIC8vIG1ha2Ugbm90ZSBvZiBhbnkgbmV3bGluZXMgaW4gdGhlIGNvbW1lbnRzIHRoYXQgY2FtZSBiZWZvcmVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXQuY29tbWVudHNfYmVmb3JlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm5sYiA9IHJldC5ubGIgfHwgcmV0LmNvbW1lbnRzX2JlZm9yZVtpXS5ubGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub2tlbihyZXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBza2lwX3doaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlIChXSElURVNQQUNFX0NIQVJTKHBlZWsoKSkpXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfd2hpbGUocHJlZCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIiwgY2gsIGkgPSAwO1xuICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAmJiBwcmVkKGNoLCBpKyspKVxuICAgICAgICAgICAgcmV0ICs9IG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VfZXJyb3IoZXJyKSB7XG4gICAgICAgIGpzX2Vycm9yKGVyciwgZmlsZW5hbWUsIFMudG9rbGluZSwgUy50b2tjb2wsIFMudG9rcG9zKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXCIuXCI7XG4gICAgICAgIHZhciBudW0gPSByZWFkX3doaWxlKGZ1bmN0aW9uKGNoLCBpKXtcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDEyMDogY2FzZSA4ODogLy8geFhcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPyBmYWxzZSA6IChoYXNfeCA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDEwMTogY2FzZSA2OTogLy8gZUVcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPyB0cnVlIDogaGFzX2UgPyBmYWxzZSA6IChoYXNfZSA9IGFmdGVyX2UgPSB0cnVlKTtcbiAgICAgICAgICAgICAgY2FzZSA0NTogLy8gLVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlcl9lIHx8IChpID09IDAgJiYgIXByZWZpeCk7XG4gICAgICAgICAgICAgIGNhc2UgNDM6IC8vICtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJfZTtcbiAgICAgICAgICAgICAgY2FzZSAoYWZ0ZXJfZSA9IGZhbHNlLCA0Nik6IC8vIC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCFoYXNfZG90ICYmICFoYXNfeCAmJiAhaGFzX2UpID8gKGhhc19kb3QgPSB0cnVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzX2FscGhhbnVtZXJpY19jaGFyKGNvZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZWZpeCkgbnVtID0gcHJlZml4ICsgbnVtO1xuICAgICAgICB2YXIgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcbiAgICAgICAgaWYgKCFpc05hTih2YWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm51bVwiLCB2YWxpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgc3ludGF4OiBcIiArIG51bSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF9lc2NhcGVkX2NoYXIoaW5fc3RyaW5nKSB7XG4gICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSwgaW5fc3RyaW5nKTtcbiAgICAgICAgc3dpdGNoIChjaC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgY2FzZSAxMTAgOiByZXR1cm4gXCJcXG5cIjtcbiAgICAgICAgICBjYXNlIDExNCA6IHJldHVybiBcIlxcclwiO1xuICAgICAgICAgIGNhc2UgMTE2IDogcmV0dXJuIFwiXFx0XCI7XG4gICAgICAgICAgY2FzZSA5OCAgOiByZXR1cm4gXCJcXGJcIjtcbiAgICAgICAgICBjYXNlIDExOCA6IHJldHVybiBcIlxcdTAwMGJcIjsgLy8gXFx2XG4gICAgICAgICAgY2FzZSAxMDIgOiByZXR1cm4gXCJcXGZcIjtcbiAgICAgICAgICBjYXNlIDQ4ICA6IHJldHVybiBcIlxcMFwiO1xuICAgICAgICAgIGNhc2UgMTIwIDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDIpKTsgLy8gXFx4XG4gICAgICAgICAgY2FzZSAxMTcgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoNCkpOyAvLyBcXHVcbiAgICAgICAgICBjYXNlIDEwICA6IHJldHVybiBcIlwiOyAvLyBuZXdsaW5lXG4gICAgICAgICAgZGVmYXVsdCAgOiByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGV4X2J5dGVzKG4pIHtcbiAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgIGZvciAoOyBuID4gMDsgLS1uKSB7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBwYXJzZUludChuZXh0KHRydWUpLCAxNik7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGlnaXQpKVxuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgbnVtID0gKG51bSA8PCA0KSB8IGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfTtcblxuICAgIHZhciByZWFkX3N0cmluZyA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcXVvdGUgPSBuZXh0KCksIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIE9jdGFsRXNjYXBlU2VxdWVuY2UgKFhYWDogZGVwcmVjYXRlZCBpZiBcInN0cmljdCBtb2RlXCIpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvMTc4XG4gICAgICAgICAgICAgICAgdmFyIG9jdGFsX2xlbiA9IDAsIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaCA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0IDw9IFwiM1wiICYmIG9jdGFsX2xlbiA8PSAyKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA+PSBcIjRcIiAmJiBvY3RhbF9sZW4gPD0gMSkgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob2N0YWxfbGVuID4gMCkgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoLCA4KSk7XG4gICAgICAgICAgICAgICAgZWxzZSBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gcXVvdGUpIGJyZWFrO1xuICAgICAgICAgICAgcmV0ICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbihcInN0cmluZ1wiLCByZXQpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2tpcF9saW5lX2NvbW1lbnQodHlwZSkge1xuICAgICAgICB2YXIgcmVnZXhfYWxsb3dlZCA9IFMucmVnZXhfYWxsb3dlZDtcbiAgICAgICAgdmFyIGkgPSBmaW5kKFwiXFxuXCIpLCByZXQ7XG4gICAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyKFMucG9zKTtcbiAgICAgICAgICAgIFMucG9zID0gUy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICAgICAgUy5wb3MgPSBpO1xuICAgICAgICB9XG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4odHlwZSwgcmV0LCB0cnVlKSk7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgfTtcblxuICAgIHZhciBza2lwX211bHRpbGluZV9jb21tZW50ID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgbXVsdGlsaW5lIGNvbW1lbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHZhciBpID0gZmluZChcIiovXCIsIHRydWUpO1xuICAgICAgICB2YXIgdGV4dCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICB2YXIgYSA9IHRleHQuc3BsaXQoXCJcXG5cIiksIG4gPSBhLmxlbmd0aDtcbiAgICAgICAgLy8gdXBkYXRlIHN0cmVhbSBwb3NpdGlvblxuICAgICAgICBTLnBvcyA9IGkgKyAyO1xuICAgICAgICBTLmxpbmUgKz0gbiAtIDE7XG4gICAgICAgIGlmIChuID4gMSkgUy5jb2wgPSBhW24gLSAxXS5sZW5ndGg7XG4gICAgICAgIGVsc2UgUy5jb2wgKz0gYVtuIC0gMV0ubGVuZ3RoO1xuICAgICAgICBTLmNvbCArPSAyO1xuICAgICAgICB2YXIgbmxiID0gUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpID49IDA7XG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4oXCJjb21tZW50MlwiLCB0ZXh0LCB0cnVlKSk7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBubGI7XG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWFkX25hbWUoKSB7XG4gICAgICAgIHZhciBiYWNrc2xhc2ggPSBmYWxzZSwgbmFtZSA9IFwiXCIsIGNoLCBlc2NhcGVkID0gZmFsc2UsIGhleDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIGVzY2FwZWQgPSBiYWNrc2xhc2ggPSB0cnVlLCBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgbmFtZSArPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCAhPSBcInVcIikgcGFyc2VfZXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYXCIpO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHBhcnNlX2Vycm9yKFwiVW5pY29kZSBjaGFyOiBcIiArIGNoLmNoYXJDb2RlQXQoMCkgKyBcIiBpcyBub3QgdmFsaWQgaW4gaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgICAgICBuYW1lICs9IGNoO1xuICAgICAgICAgICAgICAgIGJhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChLRVlXT1JEUyhuYW1lKSAmJiBlc2NhcGVkKSB7XG4gICAgICAgICAgICBoZXggPSBuYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYW1lID0gXCJcXFxcdVwiICsgXCIwMDAwXCIuc3Vic3RyKGhleC5sZW5ndGgpICsgaGV4ICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfcmVnZXhwID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIsIGZ1bmN0aW9uKHJlZ2V4cCl7XG4gICAgICAgIHZhciBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlLCBjaCwgaW5fY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChjaCA9IG5leHQodHJ1ZSkpKSBpZiAocHJldl9iYWNrc2xhc2gpIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIltcIikge1xuICAgICAgICAgICAgaW5fY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiXVwiICYmIGluX2NsYXNzKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmICFpbl9jbGFzcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kcyA9IHJlYWRfbmFtZSgpO1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgbmV3IFJlZ0V4cChyZWdleHAsIG1vZHMpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfb3BlcmF0b3IocHJlZml4KSB7XG4gICAgICAgIGZ1bmN0aW9uIGdyb3cob3ApIHtcbiAgICAgICAgICAgIGlmICghcGVlaygpKSByZXR1cm4gb3A7XG4gICAgICAgICAgICB2YXIgYmlnZ2VyID0gb3AgKyBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoT1BFUkFUT1JTKGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJvcGVyYXRvclwiLCBncm93KHByZWZpeCB8fCBuZXh0KCkpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3NsYXNoKCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAocGVlaygpKSB7XG4gICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQxXCIpO1xuICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc2tpcF9tdWx0aWxpbmVfY29tbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTLnJlZ2V4X2FsbG93ZWQgPyByZWFkX3JlZ2V4cChcIlwiKSA6IHJlYWRfb3BlcmF0b3IoXCIvXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBpc19kaWdpdChwZWVrKCkuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgICAgID8gcmVhZF9udW0oXCIuXCIpXG4gICAgICAgICAgICA6IHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfd29yZCgpIHtcbiAgICAgICAgdmFyIHdvcmQgPSByZWFkX25hbWUoKTtcbiAgICAgICAgaWYgKHByZXZfd2FzX2RvdCkgcmV0dXJuIHRva2VuKFwibmFtZVwiLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIEtFWVdPUkRTX0FUT00od29yZCkgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgIDogIUtFWVdPUkRTKHdvcmQpID8gdG9rZW4oXCJuYW1lXCIsIHdvcmQpXG4gICAgICAgICAgICA6IE9QRVJBVE9SUyh3b3JkKSA/IHRva2VuKFwib3BlcmF0b3JcIiwgd29yZClcbiAgICAgICAgICAgIDogdG9rZW4oXCJrZXl3b3JkXCIsIHdvcmQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX2VvZl9lcnJvcihlb2ZfZXJyb3IsIGNvbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoeCk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4ID09PSBFWF9FT0YpIHBhcnNlX2Vycm9yKGVvZl9lcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dF90b2tlbihmb3JjZV9yZWdleHApIHtcbiAgICAgICAgaWYgKGZvcmNlX3JlZ2V4cCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRfcmVnZXhwKGZvcmNlX3JlZ2V4cCk7XG4gICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICBzdGFydF90b2tlbigpO1xuICAgICAgICBpZiAoaHRtbDVfY29tbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChsb29raW5nX2F0KFwiPCEtLVwiKSkge1xuICAgICAgICAgICAgICAgIGZvcndhcmQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBfbGluZV9jb21tZW50KFwiY29tbWVudDNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9va2luZ19hdChcIi0tPlwiKSAmJiBTLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZCgzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXCJjb21tZW50NFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgIGlmICghY2gpIHJldHVybiB0b2tlbihcImVvZlwiKTtcbiAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDM0OiBjYXNlIDM5OiByZXR1cm4gcmVhZF9zdHJpbmcoKTtcbiAgICAgICAgICBjYXNlIDQ2OiByZXR1cm4gaGFuZGxlX2RvdCgpO1xuICAgICAgICAgIGNhc2UgNDc6IHJldHVybiBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZGlnaXQoY29kZSkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICBpZiAoUFVOQ19DSEFSUyhjaCkpIHJldHVybiB0b2tlbihcInB1bmNcIiwgbmV4dCgpKTtcbiAgICAgICAgaWYgKE9QRVJBVE9SX0NIQVJTKGNoKSkgcmV0dXJuIHJlYWRfb3BlcmF0b3IoKTtcbiAgICAgICAgaWYgKGNvZGUgPT0gOTIgfHwgaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICBwYXJzZV9lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgIH07XG5cbiAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXh0X3Rva2VuO1xuXG59O1xuXG4vKiAtLS0tLVsgUGFyc2VyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgVU5BUllfUFJFRklYID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiLS1cIixcbiAgICBcIisrXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCItXCIsXG4gICAgXCIrXCJcbl0pO1xuXG52YXIgVU5BUllfUE9TVEZJWCA9IG1ha2VQcmVkaWNhdGUoWyBcIi0tXCIsIFwiKytcIiBdKTtcblxudmFyIEFTU0lHTk1FTlQgPSBtYWtlUHJlZGljYXRlKFsgXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIi89XCIsIFwiKj1cIiwgXCIlPVwiLCBcIj4+PVwiLCBcIjw8PVwiLCBcIj4+Pj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJj1cIiBdKTtcblxudmFyIFBSRUNFREVOQ0UgPSAoZnVuY3Rpb24oYSwgcmV0KXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGIgPSBhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtiW2pdXSA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59KShcbiAgICBbXG4gICAgICAgIFtcInx8XCJdLFxuICAgICAgICBbXCImJlwiXSxcbiAgICAgICAgW1wifFwiXSxcbiAgICAgICAgW1wiXlwiXSxcbiAgICAgICAgW1wiJlwiXSxcbiAgICAgICAgW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXSxcbiAgICAgICAgW1wiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdLFxuICAgICAgICBbXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCJdLFxuICAgICAgICBbXCIrXCIsIFwiLVwiXSxcbiAgICAgICAgW1wiKlwiLCBcIi9cIiwgXCIlXCJdXG4gICAgXSxcbiAgICB7fVxuKTtcblxudmFyIFNUQVRFTUVOVFNfV0lUSF9MQUJFTFMgPSBhcnJheV90b19oYXNoKFsgXCJmb3JcIiwgXCJkb1wiLCBcIndoaWxlXCIsIFwic3dpdGNoXCIgXSk7XG5cbnZhciBBVE9NSUNfU1RBUlRfVE9LRU4gPSBhcnJheV90b19oYXNoKFsgXCJhdG9tXCIsIFwibnVtXCIsIFwic3RyaW5nXCIsIFwicmVnZXhwXCIsIFwibmFtZVwiIF0pO1xuXG4vKiAtLS0tLVsgUGFyc2VyIF0tLS0tLSAqL1xuXG5mdW5jdGlvbiBwYXJzZSgkVEVYVCwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgc3RyaWN0ICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgZmlsZW5hbWUgICAgICAgOiBudWxsLFxuICAgICAgICB0b3BsZXZlbCAgICAgICA6IG51bGwsXG4gICAgICAgIGV4cHJlc3Npb24gICAgIDogZmFsc2UsXG4gICAgICAgIGh0bWw1X2NvbW1lbnRzIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHZhciBTID0ge1xuICAgICAgICBpbnB1dCAgICAgICAgIDogKHR5cGVvZiAkVEVYVCA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbml6ZXIoJFRFWFQsIG9wdGlvbnMuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5odG1sNV9jb21tZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgICA6ICRURVhUKSxcbiAgICAgICAgdG9rZW4gICAgICAgICA6IG51bGwsXG4gICAgICAgIHByZXYgICAgICAgICAgOiBudWxsLFxuICAgICAgICBwZWVrZWQgICAgICAgIDogbnVsbCxcbiAgICAgICAgaW5fZnVuY3Rpb24gICA6IDAsXG4gICAgICAgIGluX2RpcmVjdGl2ZXMgOiB0cnVlLFxuICAgICAgICBpbl9sb29wICAgICAgIDogMCxcbiAgICAgICAgbGFiZWxzICAgICAgICA6IFtdXG4gICAgfTtcblxuICAgIFMudG9rZW4gPSBuZXh0KCk7XG5cbiAgICBmdW5jdGlvbiBpcyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfdG9rZW4oUy50b2tlbiwgdHlwZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy5wZWVrZWQgfHwgKFMucGVla2VkID0gUy5pbnB1dCgpKTsgfTtcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIFMucHJldiA9IFMudG9rZW47XG4gICAgICAgIGlmIChTLnBlZWtlZCkge1xuICAgICAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xuICAgICAgICAgICAgUy5wZWVrZWQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSBTLmluX2RpcmVjdGl2ZXMgJiYgKFxuICAgICAgICAgICAgUy50b2tlbi50eXBlID09IFwic3RyaW5nXCIgfHwgaXMoXCJwdW5jXCIsIFwiO1wiKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gUy50b2tlbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJldigpIHtcbiAgICAgICAgcmV0dXJuIFMucHJldjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JvYWsobXNnLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICB2YXIgY3R4ID0gUy5pbnB1dC5jb250ZXh0KCk7XG4gICAgICAgIGpzX2Vycm9yKG1zZyxcbiAgICAgICAgICAgICAgICAgY3R4LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICBsaW5lICE9IG51bGwgPyBsaW5lIDogY3R4LnRva2xpbmUsXG4gICAgICAgICAgICAgICAgIGNvbCAhPSBudWxsID8gY29sIDogY3R4LnRva2NvbCxcbiAgICAgICAgICAgICAgICAgcG9zICE9IG51bGwgPyBwb3MgOiBjdHgudG9rcG9zKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9rZW5fZXJyb3IodG9rZW4sIG1zZykge1xuICAgICAgICBjcm9hayhtc2csIHRva2VuLmxpbmUsIHRva2VuLmNvbCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpXG4gICAgICAgICAgICB0b2tlbiA9IFMudG9rZW47XG4gICAgICAgIHRva2VuX2Vycm9yKHRva2VuLCBcIlVuZXhwZWN0ZWQgdG9rZW46IFwiICsgdG9rZW4udHlwZSArIFwiIChcIiArIHRva2VuLnZhbHVlICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHBlY3RfdG9rZW4odHlwZSwgdmFsKSB7XG4gICAgICAgIGlmIChpcyh0eXBlLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIFMudG9rZW4udHlwZSArIFwiIMKrXCIgKyBTLnRva2VuLnZhbHVlICsgXCLCu1wiICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSArIFwiIMKrXCIgKyB2YWwgKyBcIsK7XCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHBlY3QocHVuYykgeyByZXR1cm4gZXhwZWN0X3Rva2VuKFwicHVuY1wiLCBwdW5jKTsgfTtcblxuICAgIGZ1bmN0aW9uIGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkge1xuICAgICAgICByZXR1cm4gIW9wdGlvbnMuc3RyaWN0ICYmIChcbiAgICAgICAgICAgIFMudG9rZW4ubmxiIHx8IGlzKFwiZW9mXCIpIHx8IGlzKFwicHVuY1wiLCBcIn1cIilcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2VtaWNvbG9uKCkge1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiO1wiKSkgbmV4dCgpO1xuICAgICAgICBlbHNlIGlmICghY2FuX2luc2VydF9zZW1pY29sb24oKSkgdW5leHBlY3RlZCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRoZXNpc2VkKCkge1xuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICB2YXIgZXhwID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW1iZWRfdG9rZW5zKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZXIoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICBleHByLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleHByLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfcmVnZXhwKCkge1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIi9cIikgfHwgaXMoXCJvcGVyYXRvclwiLCBcIi89XCIpKSB7XG4gICAgICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgICAgICBTLnRva2VuID0gUy5pbnB1dChTLnRva2VuLnZhbHVlLnN1YnN0cigxKSk7IC8vIGZvcmNlIHJlZ2V4cFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZW1lbnQgPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0bXA7XG4gICAgICAgIGhhbmRsZV9yZWdleHAoKTtcbiAgICAgICAgc3dpdGNoIChTLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB2YXIgZGlyID0gUy5pbl9kaXJlY3RpdmVzLCBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgLy8gWFhYdjI6IGRlY2lkZSBob3cgdG8gZml4IGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChkaXIgJiYgc3RhdC5ib2R5IGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiAhaXMoXCJwdW5jXCIsIFwiLFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EaXJlY3RpdmUoeyB2YWx1ZTogc3RhdC5ib2R5LnZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCI6XCIpXG4gICAgICAgICAgICAgICAgPyBsYWJlbGVkX3N0YXRlbWVudCgpXG4gICAgICAgICAgICAgICAgOiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICBjYXNlIFwicHVuY1wiOlxuICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmxvY2tTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgc3dpdGNoICh0bXAgPSBTLnRva2VuLnZhbHVlLCBuZXh0KCksIHRtcCkge1xuICAgICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChBU1RfQnJlYWspO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KEFTVF9Db250aW51ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImRlYnVnZ2VyXCI6XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZG9cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ebyh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogKGV4cGVjdF90b2tlbihcImtleXdvcmRcIiwgXCJ3aGlsZVwiKSwgdG1wID0gcGFyZW50aGVzaXNlZCgpLCBzZW1pY29sb24oKSwgdG1wKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1doaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKHN0YXRlbWVudClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcl8oKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fKEFTVF9EZWZ1bik7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmXygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgICAgICBpZiAoUy5pbl9mdW5jdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfUmV0dXJuKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICggaXMoXCJwdW5jXCIsIFwiO1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0KCksIG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FuX2luc2VydF9zZW1pY29sb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAodG1wID0gZXhwcmVzc2lvbih0cnVlKSwgc2VtaWNvbG9uKCksIHRtcCkgKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJzd2l0Y2hcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Td2l0Y2goe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogaW5fbG9vcChzd2l0Y2hfYm9keV8pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgICAgICAgICAgaWYgKFMudG9rZW4ubmxiKVxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIklsbGVnYWwgbmV3bGluZSBhZnRlciAndGhyb3cnXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1Rocm93KHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ0cnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5XygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ2YXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wID0gdmFyXygpLCBzZW1pY29sb24oKSwgdG1wO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjb25zdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0bXAgPSBjb25zdF8oKSwgc2VtaWNvbG9uKCksIHRtcDtcblxuICAgICAgICAgICAgICBjYXNlIFwid2l0aFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1dpdGgoe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogc3RhdGVtZW50KClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGFiZWxlZF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGFzX3N5bWJvbChBU1RfTGFiZWwpO1xuICAgICAgICBpZiAoZmluZF9pZihmdW5jdGlvbihsKXsgcmV0dXJuIGwubmFtZSA9PSBsYWJlbC5uYW1lIH0sIFMubGFiZWxzKSkge1xuICAgICAgICAgICAgLy8gRUNNQS0yNjIsIDEyLjEyOiBBbiBFQ01BU2NyaXB0IHByb2dyYW0gaXMgY29uc2lkZXJlZFxuICAgICAgICAgICAgLy8gc3ludGFjdGljYWxseSBpbmNvcnJlY3QgaWYgaXQgY29udGFpbnMgYVxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgdGhhdCBpcyBlbmNsb3NlZCBieSBhXG4gICAgICAgICAgICAvLyBMYWJlbGxlZFN0YXRlbWVudCB3aXRoIHRoZSBzYW1lIElkZW50aWZpZXIgYXMgbGFiZWwuXG4gICAgICAgICAgICBjcm9hayhcIkxhYmVsIFwiICsgbGFiZWwubmFtZSArIFwiIGRlZmluZWQgdHdpY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgUy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50KCk7XG4gICAgICAgIFMubGFiZWxzLnBvcCgpO1xuICAgICAgICBpZiAoIShzdGF0IGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBgY29udGludWVgIHRoYXQgcmVmZXJzIHRvIHRoaXMgbGFiZWwuXG4gICAgICAgICAgICAvLyB0aG9zZSBzaG91bGQgYmUgcmVwb3J0ZWQgYXMgc3ludGF4IGVycm9ycy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8yODdcbiAgICAgICAgICAgIGxhYmVsLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbihyZWYpe1xuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBBU1RfQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gcmVmLmxhYmVsLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIkNvbnRpbnVlIGxhYmVsIGBcIiArIGxhYmVsLm5hbWUgKyBcImAgcmVmZXJzIHRvIG5vbi1JdGVyYXRpb25TdGF0ZW1lbnQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5saW5lLCByZWYuY29sLCByZWYucG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVF9MYWJlbGVkU3RhdGVtZW50KHsgYm9keTogc3RhdCwgbGFiZWw6IGxhYmVsIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzaW1wbGVfc3RhdGVtZW50KHRtcCkge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9TaW1wbGVTdGF0ZW1lbnQoeyBib2R5OiAodG1wID0gZXhwcmVzc2lvbih0cnVlKSwgc2VtaWNvbG9uKCksIHRtcCkgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJyZWFrX2NvbnQodHlwZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBsZGVmO1xuICAgICAgICBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbFJlZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxkZWYgPSBmaW5kX2lmKGZ1bmN0aW9uKGwpeyByZXR1cm4gbC5uYW1lID09IGxhYmVsLm5hbWUgfSwgUy5sYWJlbHMpO1xuICAgICAgICAgICAgaWYgKCFsZGVmKVxuICAgICAgICAgICAgICAgIGNyb2FrKFwiVW5kZWZpbmVkIGxhYmVsIFwiICsgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICBsYWJlbC50aGVkZWYgPSBsZGVmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFMuaW5fbG9vcCA9PSAwKVxuICAgICAgICAgICAgY3JvYWsodHlwZS5UWVBFICsgXCIgbm90IGluc2lkZSBhIGxvb3Agb3Igc3dpdGNoXCIpO1xuICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgdmFyIHN0YXQgPSBuZXcgdHlwZSh7IGxhYmVsOiBsYWJlbCB9KTtcbiAgICAgICAgaWYgKGxkZWYpIGxkZWYucmVmZXJlbmNlcy5wdXNoKHN0YXQpO1xuICAgICAgICByZXR1cm4gc3RhdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yXygpIHtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgdmFyIGluaXQgPSBudWxsO1xuICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIjtcIikpIHtcbiAgICAgICAgICAgIGluaXQgPSBpcyhcImtleXdvcmRcIiwgXCJ2YXJcIilcbiAgICAgICAgICAgICAgICA/IChuZXh0KCksIHZhcl8odHJ1ZSkpXG4gICAgICAgICAgICAgICAgOiBleHByZXNzaW9uKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJpblwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgQVNUX1ZhciAmJiBpbml0LmRlZmluaXRpb25zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiT25seSBvbmUgdmFyaWFibGUgZGVjbGFyYXRpb24gYWxsb3dlZCBpbiBmb3IuLmluIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JfaW4oaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ3VsYXJfZm9yKGluaXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWd1bGFyX2Zvcihpbml0KSB7XG4gICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgIHZhciB0ZXN0ID0gaXMoXCJwdW5jXCIsIFwiO1wiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCI7XCIpO1xuICAgICAgICB2YXIgc3RlcCA9IGlzKFwicHVuY1wiLCBcIilcIikgPyBudWxsIDogZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRm9yKHtcbiAgICAgICAgICAgIGluaXQgICAgICA6IGluaXQsXG4gICAgICAgICAgICBjb25kaXRpb24gOiB0ZXN0LFxuICAgICAgICAgICAgc3RlcCAgICAgIDogc3RlcCxcbiAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yX2luKGluaXQpIHtcbiAgICAgICAgdmFyIGxocyA9IGluaXQgaW5zdGFuY2VvZiBBU1RfVmFyID8gaW5pdC5kZWZpbml0aW9uc1swXS5uYW1lIDogbnVsbDtcbiAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBuYW1lICAgOiBsaHMsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKHN0YXRlbWVudClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbihjdG9yKSB7XG4gICAgICAgIHZhciBpbl9zdGF0ZW1lbnQgPSBjdG9yID09PSBBU1RfRGVmdW47XG4gICAgICAgIHZhciBuYW1lID0gaXMoXCJuYW1lXCIpID8gYXNfc3ltYm9sKGluX3N0YXRlbWVudCA/IEFTVF9TeW1ib2xEZWZ1biA6IEFTVF9TeW1ib2xMYW1iZGEpIDogbnVsbDtcbiAgICAgICAgaWYgKGluX3N0YXRlbWVudCAmJiAhbmFtZSlcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmduYW1lczogKGZ1bmN0aW9uKGZpcnN0LCBhKXtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChhc19zeW1ib2woQVNUX1N5bWJvbEZ1bmFyZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9KSh0cnVlLCBbXSksXG4gICAgICAgICAgICBib2R5OiAoZnVuY3Rpb24obG9vcCwgbGFiZWxzKXtcbiAgICAgICAgICAgICAgICArK1MuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICAgICAgICAgIFMubGFiZWxzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBibG9ja18oKTtcbiAgICAgICAgICAgICAgICAtLVMuaW5fZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcbiAgICAgICAgICAgICAgICBTLmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0pKFMuaW5fbG9vcCwgUy5sYWJlbHMpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpZl8oKSB7XG4gICAgICAgIHZhciBjb25kID0gcGFyZW50aGVzaXNlZCgpLCBib2R5ID0gc3RhdGVtZW50KCksIGJlbHNlID0gbnVsbDtcbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImVsc2VcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJlbHNlID0gc3RhdGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfSWYoe1xuICAgICAgICAgICAgY29uZGl0aW9uICAgOiBjb25kLFxuICAgICAgICAgICAgYm9keSAgICAgICAgOiBib2R5LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBiZWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYmxvY2tfKCkge1xuICAgICAgICBleHBlY3QoXCJ7XCIpO1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgYS5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hfYm9keV8oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW10sIGN1ciA9IG51bGwsIGJyYW5jaCA9IG51bGwsIHRtcDtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXNlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0Nhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogKHRtcCA9IFMudG9rZW4sIG5leHQoKSwgdG1wKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHJlc3Npb24odHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBjdXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gbmV3IEFTVF9EZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiAodG1wID0gUy50b2tlbiwgbmV4dCgpLCBleHBlY3QoXCI6XCIpLCB0bXApLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGN1clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICBjdXIucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJ5XygpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBibG9ja18oKSwgYmNhdGNoID0gbnVsbCwgYmZpbmFsbHkgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2F0Y2hcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19zeW1ib2woQVNUX1N5bWJvbENhdGNoKTtcbiAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICBiY2F0Y2ggPSBuZXcgQVNUX0NhdGNoKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgYXJnbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgYm9keSAgICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmaW5hbGx5XCIpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYmZpbmFsbHkgPSBuZXcgQVNUX0ZpbmFsbHkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgYm9keSAgOiBibG9ja18oKSxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiY2F0Y2ggJiYgIWJmaW5hbGx5KVxuICAgICAgICAgICAgY3JvYWsoXCJNaXNzaW5nIGNhdGNoL2ZpbmFsbHkgYmxvY2tzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ucnkoe1xuICAgICAgICAgICAgYm9keSAgICAgOiBib2R5LFxuICAgICAgICAgICAgYmNhdGNoICAgOiBiY2F0Y2gsXG4gICAgICAgICAgICBiZmluYWxseSA6IGJmaW5hbGx5XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YXJkZWZzKG5vX2luLCBpbl9jb25zdCkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9WYXJEZWYoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgICAgICBuYW1lICA6IGFzX3N5bWJvbChpbl9jb25zdCA/IEFTVF9TeW1ib2xDb25zdCA6IEFTVF9TeW1ib2xWYXIpLFxuICAgICAgICAgICAgICAgIHZhbHVlIDogaXMoXCJvcGVyYXRvclwiLCBcIj1cIikgPyAobmV4dCgpLCBleHByZXNzaW9uKGZhbHNlLCBub19pbikpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICB2YXIgdmFyXyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Zhcih7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhub19pbiwgZmFsc2UpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjb25zdF8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uc3Qoe1xuICAgICAgICAgICAgc3RhcnQgICAgICAgOiBwcmV2KCksXG4gICAgICAgICAgICBkZWZpbml0aW9ucyA6IHZhcmRlZnMoZmFsc2UsIHRydWUpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdfID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGV4cGVjdF90b2tlbihcIm9wZXJhdG9yXCIsIFwibmV3XCIpO1xuICAgICAgICB2YXIgbmV3ZXhwID0gZXhwcl9hdG9tKGZhbHNlKSwgYXJncztcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGFyZ3MgPSBleHByX2xpc3QoXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfTmV3KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBuZXdleHAsXG4gICAgICAgICAgICBhcmdzICAgICAgIDogYXJncyxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSksIHRydWUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19hdG9tX25vZGUoKSB7XG4gICAgICAgIHZhciB0b2sgPSBTLnRva2VuLCByZXQ7XG4gICAgICAgIHN3aXRjaCAodG9rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICByZXQgPSBfbWFrZV9zeW1ib2woQVNUX1N5bWJvbFJlZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bWJlcih7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9TdHJpbmcoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHRvay52YWx1ZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfUmVnRXhwKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2ssIHZhbHVlOiB0b2sudmFsdWUgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgc3dpdGNoICh0b2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9GYWxzZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfVHJ1ZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfTnVsbCh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwcl9hdG9tID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJuZXdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgc3dpdGNoIChzdGFydC52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXggPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgZXguZW5kID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGV4LCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXJyYXlfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhvYmplY3RfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb25fKEFTVF9GdW5jdGlvbik7XG4gICAgICAgICAgICBmdW5jLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBmdW5jLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGZ1bmMsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQVRPTUlDX1NUQVJUX1RPS0VOW1MudG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzX2F0b21fbm9kZSgpLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHByX2xpc3QoY2xvc2luZywgYWxsb3dfdHJhaWxpbmdfY29tbWEsIGFsbG93X2VtcHR5KSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWUsIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgY2xvc2luZykpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgaWYgKGFsbG93X3RyYWlsaW5nX2NvbW1hICYmIGlzKFwicHVuY1wiLCBjbG9zaW5nKSkgYnJlYWs7XG4gICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiLFwiKSAmJiBhbGxvd19lbXB0eSkge1xuICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX0hvbGUoeyBzdGFydDogUy50b2tlbiwgZW5kOiBTLnRva2VuIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICB2YXIgYXJyYXlfID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoXCJbXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJheSh7XG4gICAgICAgICAgICBlbGVtZW50czogZXhwcl9saXN0KFwiXVwiLCAhb3B0aW9ucy5zdHJpY3QsIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG9iamVjdF8gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWUsIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXMoXCJwdW5jXCIsIFwifVwiKSlcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0cmFpbGluZyBjb21tYVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc3RhcnQudHlwZTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJuYW1lXCIgJiYgIWlzKFwicHVuY1wiLCBcIjpcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcImdldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX09iamVjdEdldHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICAgOiBhc19hdG9tX25vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogZnVuY3Rpb25fKEFTVF9BY2Nlc3NvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX09iamVjdFNldHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICAgOiBhc19hdG9tX25vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogZnVuY3Rpb25fKEFTVF9BY2Nlc3NvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9PYmplY3RLZXlWYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAga2V5ICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlIDogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdCh7IHByb3BlcnRpZXM6IGEgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhc19wcm9wZXJ0eV9uYW1lKCkge1xuICAgICAgICB2YXIgdG1wID0gUy50b2tlbjtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHRtcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19uYW1lKCkge1xuICAgICAgICB2YXIgdG1wID0gUy50b2tlbjtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHRtcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICByZXR1cm4gdG1wLnZhbHVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX21ha2Vfc3ltYm9sKHR5cGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lID09IFwidGhpc1wiID8gQVNUX1RoaXMgOiB0eXBlKSh7XG4gICAgICAgICAgICBuYW1lICA6IFN0cmluZyhuYW1lKSxcbiAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgIGVuZCAgIDogUy50b2tlblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXNfc3ltYm9sKHR5cGUsIG5vZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpcyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmICghbm9lcnJvcikgY3JvYWsoXCJOYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bSA9IF9tYWtlX3N5bWJvbCh0eXBlKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gc3ltO1xuICAgIH07XG5cbiAgICB2YXIgc3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGV4cHIsIGFsbG93X2NhbGxzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGV4cHIuc3RhcnQ7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgQVNUX0RvdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgOiBhc19uYW1lKCksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiW1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfU3ViKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3AsXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dfY2FsbHMgJiYgaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9DYWxsKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgYXJncyAgICAgICA6IGV4cHJfbGlzdChcIilcIiksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG5cbiAgICB2YXIgbWF5YmVfdW5hcnkgPSBmdW5jdGlvbihhbGxvd19jYWxscykge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QUkVGSVgoc3RhcnQudmFsdWUpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBoYW5kbGVfcmVnZXhwKCk7XG4gICAgICAgICAgICB2YXIgZXggPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVByZWZpeCwgc3RhcnQudmFsdWUsIG1heWJlX3VuYXJ5KGFsbG93X2NhbGxzKSk7XG4gICAgICAgICAgICBleC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgZXguZW5kID0gcHJldigpO1xuICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSBleHByX2F0b20oYWxsb3dfY2FsbHMpO1xuICAgICAgICB3aGlsZSAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QT1NURklYKFMudG9rZW4udmFsdWUpICYmICFTLnRva2VuLm5sYikge1xuICAgICAgICAgICAgdmFsID0gbWFrZV91bmFyeShBU1RfVW5hcnlQb3N0Zml4LCBTLnRva2VuLnZhbHVlLCB2YWwpO1xuICAgICAgICAgICAgdmFsLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB2YWwuZW5kID0gUy50b2tlbjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX3VuYXJ5KGN0b3IsIG9wLCBleHByKSB7XG4gICAgICAgIGlmICgob3AgPT0gXCIrK1wiIHx8IG9wID09IFwiLS1cIikgJiYgIWlzX2Fzc2lnbmFibGUoZXhwcikpXG4gICAgICAgICAgICBjcm9hayhcIkludmFsaWQgdXNlIG9mIFwiICsgb3AgKyBcIiBvcGVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHsgb3BlcmF0b3I6IG9wLCBleHByZXNzaW9uOiBleHByIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXhwcl9vcCA9IGZ1bmN0aW9uKGxlZnQsIG1pbl9wcmVjLCBub19pbikge1xuICAgICAgICB2YXIgb3AgPSBpcyhcIm9wZXJhdG9yXCIpID8gUy50b2tlbi52YWx1ZSA6IG51bGw7XG4gICAgICAgIGlmIChvcCA9PSBcImluXCIgJiYgbm9faW4pIG9wID0gbnVsbDtcbiAgICAgICAgdmFyIHByZWMgPSBvcCAhPSBudWxsID8gUFJFQ0VERU5DRVtvcF0gOiBudWxsO1xuICAgICAgICBpZiAocHJlYyAhPSBudWxsICYmIHByZWMgPiBtaW5fcHJlYykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgcHJlYywgbm9faW4pO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AobmV3IEFTVF9CaW5hcnkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbGVmdC5zdGFydCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGxlZnQsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBvcCxcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogcmlnaHQuZW5kXG4gICAgICAgICAgICB9KSwgbWluX3ByZWMsIG5vX2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXhwcl9vcHMobm9faW4pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJfb3AobWF5YmVfdW5hcnkodHJ1ZSksIDAsIG5vX2luKTtcbiAgICB9O1xuXG4gICAgdmFyIG1heWJlX2NvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGV4cHIgPSBleHByX29wcyhub19pbik7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiP1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIHllcyA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NvbmRpdGlvbmFsKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiAgIDogZXhwcixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHllcyxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgICA6IHBlZWsoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzX2Fzc2lnbmFibGUoZXhwcikge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfVGhpcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gKGV4cHIgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyB8fCBleHByIGluc3RhbmNlb2YgQVNUX1N5bWJvbCk7XG4gICAgfTtcblxuICAgIHZhciBtYXliZV9hc3NpZ24gPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgbGVmdCA9IG1heWJlX2NvbmRpdGlvbmFsKG5vX2luKSwgdmFsID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIikgJiYgQVNTSUdOTUVOVCh2YWwpKSB7XG4gICAgICAgICAgICBpZiAoaXNfYXNzaWduYWJsZShsZWZ0KSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogdmFsLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IG1heWJlX2Fzc2lnbihub19pbiksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcm9hayhcIkludmFsaWQgYXNzaWdubWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGV4cHJlc3Npb24gPSBmdW5jdGlvbihjb21tYXMsIG5vX2luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBleHByID0gbWF5YmVfYXNzaWduKG5vX2luKTtcbiAgICAgICAgaWYgKGNvbW1hcyAmJiBpcyhcInB1bmNcIiwgXCIsXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9TZXEoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGNhciAgICA6IGV4cHIsXG4gICAgICAgICAgICAgICAgY2RyICAgIDogZXhwcmVzc2lvbih0cnVlLCBub19pbiksXG4gICAgICAgICAgICAgICAgZW5kICAgIDogcGVlaygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5fbG9vcChjb250KSB7XG4gICAgICAgICsrUy5pbl9sb29wO1xuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICAtLVMuaW5fbG9vcDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbih0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIHdoaWxlICghaXMoXCJlb2ZcIikpXG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICB2YXIgZW5kID0gcHJldigpO1xuICAgICAgICB2YXIgdG9wbGV2ZWwgPSBvcHRpb25zLnRvcGxldmVsO1xuICAgICAgICBpZiAodG9wbGV2ZWwpIHtcbiAgICAgICAgICAgIHRvcGxldmVsLmJvZHkgPSB0b3BsZXZlbC5ib2R5LmNvbmNhdChib2R5KTtcbiAgICAgICAgICAgIHRvcGxldmVsLmVuZCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcGxldmVsID0gbmV3IEFTVF9Ub3BsZXZlbCh7IHN0YXJ0OiBzdGFydCwgYm9keTogYm9keSwgZW5kOiBlbmQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xuICAgIH0pKCk7XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRyZWUgdHJhbnNmb3JtZXIgaGVscGVycy5cblxuZnVuY3Rpb24gVHJlZVRyYW5zZm9ybWVyKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBUcmVlV2Fsa2VyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5iZWZvcmUgPSBiZWZvcmU7XG4gICAgdGhpcy5hZnRlciA9IGFmdGVyO1xufVxuVHJlZVRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IG5ldyBUcmVlV2Fsa2VyO1xuXG4oZnVuY3Rpb24odW5kZWZpbmVkKXtcblxuICAgIGZ1bmN0aW9uIF8obm9kZSwgZGVzY2VuZCkge1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcInRyYW5zZm9ybVwiLCBmdW5jdGlvbih0dywgaW5fbGlzdCl7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHR3LnB1c2godGhpcyk7XG4gICAgICAgICAgICBpZiAodHcuYmVmb3JlKSB4ID0gdHcuYmVmb3JlKHRoaXMsIGRlc2NlbmQsIGluX2xpc3QpO1xuICAgICAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghdHcuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQoeCwgdHcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR3LnN0YWNrW3R3LnN0YWNrLmxlbmd0aCAtIDFdID0geCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCh4LCB0dyk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB0dy5hZnRlcih4LCBpbl9saXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgIT09IHVuZGVmaW5lZCkgeCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHcucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvX2xpc3QobGlzdCwgdHcpIHtcbiAgICAgICAgcmV0dXJuIE1BUChsaXN0LCBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnRyYW5zZm9ybSh0dywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfKEFTVF9Ob2RlLCBub29wKTtcblxuICAgIF8oQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5sYWJlbCA9IHNlbGYubGFiZWwudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9CbG9jaywgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRFdMb29wLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgaWYgKHNlbGYuaW5pdCkgc2VsZi5pbml0ID0gc2VsZi5pbml0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi5zdGVwKSBzZWxmLnN0ZXAgPSBzZWxmLnN0ZXAudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Gb3JJbiwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5vYmplY3QgPSBzZWxmLm9iamVjdC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1dpdGgsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRXhpdCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBpZiAoc2VsZi52YWx1ZSkgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0xvb3BDb250cm9sLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLmxhYmVsKSBzZWxmLmxhYmVsID0gc2VsZi5sYWJlbC50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfSWYsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHNlbGYuYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Td2l0Y2gsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9DYXNlLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgICAgIGlmIChzZWxmLmJjYXRjaCkgc2VsZi5iY2F0Y2ggPSBzZWxmLmJjYXRjaC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkgc2VsZi5iZmluYWxseSA9IHNlbGYuYmZpbmFsbHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0NhdGNoLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuYXJnbmFtZSA9IHNlbGYuYXJnbmFtZS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5kZWZpbml0aW9ucyA9IGRvX2xpc3Qoc2VsZi5kZWZpbml0aW9ucywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfVmFyRGVmLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYubmFtZSA9IHNlbGYubmFtZS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi52YWx1ZSkgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0xhbWJkYSwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBpZiAoc2VsZi5uYW1lKSBzZWxmLm5hbWUgPSBzZWxmLm5hbWUudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5hcmduYW1lcyA9IGRvX2xpc3Qoc2VsZi5hcmduYW1lcywgdHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQ2FsbCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5hcmdzID0gZG9fbGlzdChzZWxmLmFyZ3MsIHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1NlcSwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNhciA9IHNlbGYuY2FyLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuY2RyID0gc2VsZi5jZHIudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5wcm9wZXJ0eSA9IHNlbGYucHJvcGVydHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1VuYXJ5LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZWxlbWVudHMgPSBkb19saXN0KHNlbGYuZWxlbWVudHMsIHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX09iamVjdCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLnByb3BlcnRpZXMgPSBkb19saXN0KHNlbGYucHJvcGVydGllcywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxufSkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gU3ltYm9sRGVmKHNjb3BlLCBpbmRleCwgb3JpZykge1xuICAgIHRoaXMubmFtZSA9IG9yaWcubmFtZTtcbiAgICB0aGlzLm9yaWcgPSBbIG9yaWcgXTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgdGhpcy5nbG9iYWwgPSBmYWxzZTtcbiAgICB0aGlzLm1hbmdsZWRfbmFtZSA9IG51bGw7XG4gICAgdGhpcy51bmRlY2xhcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25zdGFudCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cblN5bWJvbERlZi5wcm90b3R5cGUgPSB7XG4gICAgdW5tYW5nbGVhYmxlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nbG9iYWwgJiYgIShvcHRpb25zICYmIG9wdGlvbnMudG9wbGV2ZWwpKVxuICAgICAgICAgICAgfHwgdGhpcy51bmRlY2xhcmVkXG4gICAgICAgICAgICB8fCAoIShvcHRpb25zICYmIG9wdGlvbnMuZXZhbCkgJiYgKHRoaXMuc2NvcGUudXNlc19ldmFsIHx8IHRoaXMuc2NvcGUudXNlc193aXRoKSk7XG4gICAgfSxcbiAgICBtYW5nbGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmdsZWRfbmFtZSAmJiAhdGhpcy51bm1hbmdsZWFibGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zY29wZTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zY3Jld19pZTggJiYgdGhpcy5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYSlcbiAgICAgICAgICAgICAgICBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgICAgICB0aGlzLm1hbmdsZWRfbmFtZSA9IHMubmV4dF9tYW5nbGVkKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcImZpZ3VyZV9vdXRfc2NvcGVcIiwgZnVuY3Rpb24oKXtcbiAgICAvLyBUaGlzIGRvZXMgd2hhdCBhc3RfYWRkX3Njb3BlIGRpZCBpbiBVZ2xpZnlKUyB2MS5cbiAgICAvL1xuICAgIC8vIFBhcnQgb2YgaXQgY291bGQgYmUgZG9uZSBhdCBwYXJzZSB0aW1lLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZVxuICAgIC8vIHRoZSBwYXJzZXIgKGFuZCBpdCdzIGFscmVhZHkga2luZGEgY29tcGxleCkuICBJdCdzIGFsc28gd29ydGhcbiAgICAvLyBoYXZpbmcgaXQgc2VwYXJhdGVkIGJlY2F1c2Ugd2UgbWlnaHQgbmVlZCB0byBjYWxsIGl0IG11bHRpcGxlXG4gICAgLy8gdGltZXMgb24gdGhlIHNhbWUgdHJlZS5cblxuICAgIC8vIHBhc3MgMTogc2V0dXAgc2NvcGUgY2hhaW5pbmcgYW5kIGhhbmRsZSBkZWZpbml0aW9uc1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2NvcGUgPSBzZWxmLnBhcmVudF9zY29wZSA9IG51bGw7XG4gICAgdmFyIG5lc3RpbmcgPSAwO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS5pbml0X3Njb3BlX3ZhcnMobmVzdGluZyk7XG4gICAgICAgICAgICB2YXIgc2F2ZV9zY29wZSA9IG5vZGUucGFyZW50X3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICArK25lc3Rpbmc7XG4gICAgICAgICAgICBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICAtLW5lc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgIC8vIGRvbid0IGRlc2NlbmQgYWdhaW4gaW4gVHJlZVdhbGtlclxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSkge1xuICAgICAgICAgICAgbm9kZS5zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgcHVzaF91bmlxKHNjb3BlLmRpcmVjdGl2ZXMsIG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IHNjb3BlOyBzOyBzID0gcy5wYXJlbnRfc2NvcGUpXG4gICAgICAgICAgICAgICAgcy51c2VzX3dpdGggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkge1xuICAgICAgICAgICAgbm9kZS5zY29wZSA9IHNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYSkge1xuICAgICAgICAgICAgc2NvcGUuZGVmX2Z1bmN0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pIHtcbiAgICAgICAgICAgIC8vIENhcmVmdWwgaGVyZSwgdGhlIHNjb3BlIHdoZXJlIHRoaXMgc2hvdWxkIGJlIGRlZmluZWQgaXNcbiAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgc2NvcGUuICBUaGUgcmVhc29uIGlzIHRoYXQgd2UgZW50ZXIgYSBuZXdcbiAgICAgICAgICAgIC8vIHNjb3BlIHdoZW4gd2UgZW5jb3VudGVyIHRoZSBBU1RfRGVmdW4gbm9kZSAod2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGluc3RhbmNlb2YgQVNUX1Njb3BlKSBidXQgd2UgZ2V0IHRvIHRoZSBzeW1ib2wgYSBiaXRcbiAgICAgICAgICAgIC8vIGxhdGVyLlxuICAgICAgICAgICAgKG5vZGUuc2NvcGUgPSBzY29wZS5wYXJlbnRfc2NvcGUpLmRlZl9mdW5jdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFZhclxuICAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0KSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICAgICAgZGVmLmNvbnN0YW50ID0gbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDb25zdDtcbiAgICAgICAgICAgIGRlZi5pbml0ID0gdHcucGFyZW50KCkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDYXRjaCkge1xuICAgICAgICAgICAgLy8gWFhYOiB0aGlzIGlzIHdyb25nIGFjY29yZGluZyB0byBFQ01BLTI2MiAoMTIuNCkuICB0aGVcbiAgICAgICAgICAgIC8vIGBjYXRjaGAgYXJndW1lbnQgbmFtZSBzaG91bGQgYmUgdmlzaWJsZSBvbmx5IGluc2lkZSB0aGVcbiAgICAgICAgICAgIC8vIGNhdGNoIGJsb2NrLiAgRm9yIGEgcXVpY2sgZml4IEFTVF9DYXRjaCBzaG91bGQgaW5oZXJpdFxuICAgICAgICAgICAgLy8gZnJvbSBBU1RfU2NvcGUuICBLZWVwaW5nIGl0IHRoaXMgd2F5IGJlY2F1c2Ugb2YgSUUsXG4gICAgICAgICAgICAvLyB3aGljaCBkb2Vzbid0IG9iZXkgdGhlIHN0YW5kYXJkLiAoaXQgaW50cm9kdWNlcyB0aGVcbiAgICAgICAgICAgIC8vIGlkZW50aWZpZXIgaW4gdGhlIGVuY2xvc2luZyBzY29wZSlcbiAgICAgICAgICAgIHNjb3BlLmRlZl92YXJpYWJsZShub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYud2Fsayh0dyk7XG5cbiAgICAvLyBwYXNzIDI6IGZpbmQgYmFjayByZWZlcmVuY2VzIGFuZCBldmFsXG4gICAgdmFyIGZ1bmMgPSBudWxsO1xuICAgIHZhciBnbG9iYWxzID0gc2VsZi5nbG9iYWxzID0gbmV3IERpY3Rpb25hcnkoKTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhKSB7XG4gICAgICAgICAgICB2YXIgcHJldl9mdW5jID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSBub2RlO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgZnVuYyA9IHByZXZfZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICB2YXIgc3ltID0gbm9kZS5zY29wZS5maW5kX3ZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzeW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZztcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZyA9IGdsb2JhbHMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgU3ltYm9sRGVmKHNlbGYsIGdsb2JhbHMuc2l6ZSgpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZy51bmRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZy5nbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLnNldChuYW1lLCBnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBnO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZXZhbFwiICYmIHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IG5vZGUuc2NvcGU7IHMgJiYgIXMudXNlc19ldmFsOyBzID0gcy5wYXJlbnRfc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnVzZXNfZXZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmdW5jICYmIG5hbWUgPT0gXCJhcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLnVzZXNfYXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gc3ltO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZi53YWxrKHR3KTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKG5lc3Rpbmcpe1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdOyAgICAgLy8gY29udGFpbnMgdGhlIGRpcmVjdGl2ZXMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlLCBpLmUuIFwidXNlIHN0cmljdFwiXG4gICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgRGljdGlvbmFyeSgpOyAvLyBtYXAgbmFtZSB0byBBU1RfU3ltYm9sVmFyICh2YXJpYWJsZXMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlOyBpbmNsdWRlcyBmdW5jdGlvbnMpXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBuZXcgRGljdGlvbmFyeSgpOyAvLyBtYXAgbmFtZSB0byBBU1RfU3ltYm9sRGVmdW4gKGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgc2NvcGUpXG4gICAgdGhpcy51c2VzX3dpdGggPSBmYWxzZTsgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3Igc29tZSBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgYHdpdGhgIHN0YXRlbWVudFxuICAgIHRoaXMudXNlc19ldmFsID0gZmFsc2U7ICAgLy8gd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGlzIG9yIG5lc3RlZCBzY29wZSB1c2VzIHRoZSBnbG9iYWwgYGV2YWxgXG4gICAgdGhpcy5wYXJlbnRfc2NvcGUgPSBudWxsOyAvLyB0aGUgcGFyZW50IHNjb3BlXG4gICAgdGhpcy5lbmNsb3NlZCA9IFtdOyAgICAgICAvLyBhIGxpc3Qgb2YgdmFyaWFibGVzIGZyb20gdGhpcyBvciBvdXRlciBzY29wZShzKSB0aGF0IGFyZSByZWZlcmVuY2VkIGZyb20gdGhpcyBvciBpbm5lciBzY29wZXNcbiAgICB0aGlzLmNuYW1lID0gLTE7ICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGluZGV4IGZvciBtYW5nbGluZyBmdW5jdGlvbnMvdmFyaWFibGVzXG4gICAgdGhpcy5uZXN0aW5nID0gbmVzdGluZzsgICAvLyB0aGUgbmVzdGluZyBsZXZlbCBvZiB0aGlzIHNjb3BlICgwIG1lYW5zIHRvcGxldmVsKVxufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJzdHJpY3RcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKTtcbn0pO1xuXG5BU1RfTGFtYmRhLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLCBmdW5jdGlvbigpe1xuICAgIEFTVF9TY29wZS5wcm90b3R5cGUuaW5pdF9zY29wZV92YXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy51c2VzX2FyZ3VtZW50cyA9IGZhbHNlO1xufSk7XG5cbkFTVF9TeW1ib2xSZWYuREVGTUVUSE9EKFwicmVmZXJlbmNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICBkZWYucmVmZXJlbmNlcy5wdXNoKHRoaXMpO1xuICAgIHZhciBzID0gdGhpcy5zY29wZTtcbiAgICB3aGlsZSAocykge1xuICAgICAgICBwdXNoX3VuaXEocy5lbmNsb3NlZCwgZGVmKTtcbiAgICAgICAgaWYgKHMgPT09IGRlZi5zY29wZSkgYnJlYWs7XG4gICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICB9XG4gICAgdGhpcy5mcmFtZSA9IHRoaXMuc2NvcGUubmVzdGluZyAtIGRlZi5zY29wZS5uZXN0aW5nO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJmaW5kX3ZhcmlhYmxlXCIsIGZ1bmN0aW9uKG5hbWUpe1xuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkgbmFtZSA9IG5hbWUubmFtZTtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpXG4gICAgICAgIHx8ICh0aGlzLnBhcmVudF9zY29wZSAmJiB0aGlzLnBhcmVudF9zY29wZS5maW5kX3ZhcmlhYmxlKG5hbWUpKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaGFzX2RpcmVjdGl2ZVwiLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmhhc19kaXJlY3RpdmUodmFsdWUpXG4gICAgICAgIHx8ICh0aGlzLmRpcmVjdGl2ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHRoaXMgOiBudWxsKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZGVmX2Z1bmN0aW9uXCIsIGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgdGhpcy5mdW5jdGlvbnMuc2V0KHN5bWJvbC5uYW1lLCB0aGlzLmRlZl92YXJpYWJsZShzeW1ib2wpKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZGVmX3ZhcmlhYmxlXCIsIGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgdmFyIGRlZjtcbiAgICBpZiAoIXRoaXMudmFyaWFibGVzLmhhcyhzeW1ib2wubmFtZSkpIHtcbiAgICAgICAgZGVmID0gbmV3IFN5bWJvbERlZih0aGlzLCB0aGlzLnZhcmlhYmxlcy5zaXplKCksIHN5bWJvbCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldChzeW1ib2wubmFtZSwgZGVmKTtcbiAgICAgICAgZGVmLmdsb2JhbCA9ICF0aGlzLnBhcmVudF9zY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWYgPSB0aGlzLnZhcmlhYmxlcy5nZXQoc3ltYm9sLm5hbWUpO1xuICAgICAgICBkZWYub3JpZy5wdXNoKHN5bWJvbCk7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2wudGhlZGVmID0gZGVmO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgdmFyIGV4dCA9IHRoaXMuZW5jbG9zZWQ7XG4gICAgb3V0OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbSA9IGJhc2U1NCgrK3RoaXMuY25hbWUpO1xuICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXIobSkpIGNvbnRpbnVlOyAvLyBza2lwIG92ZXIgXCJkb1wiXG4gICAgICAgIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIG1hbmdsZWQgbmFtZSBkb2VzIG5vdCBzaGFkb3cgYSBuYW1lXG4gICAgICAgIC8vIGZyb20gc29tZSBwYXJlbnQgc2NvcGUgdGhhdCBpcyByZWZlcmVuY2VkIGluIHRoaXMgb3IgaW5cbiAgICAgICAgLy8gaW5uZXIgc2NvcGVzLlxuICAgICAgICBmb3IgKHZhciBpID0gZXh0Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgc3ltID0gZXh0W2ldO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBzeW0ubWFuZ2xlZF9uYW1lIHx8IChzeW0udW5tYW5nbGVhYmxlKG9wdGlvbnMpICYmIHN5bS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtID09IG5hbWUpIGNvbnRpbnVlIG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG59KTtcblxuQVNUX0Z1bmN0aW9uLkRFRk1FVEhPRChcIm5leHRfbWFuZ2xlZFwiLCBmdW5jdGlvbihvcHRpb25zLCBkZWYpe1xuICAgIC8vICMxNzksICMzMjZcbiAgICAvLyBpbiBTYWZhcmkgc3RyaWN0IG1vZGUsIHNvbWV0aGluZyBsaWtlIChmdW5jdGlvbiB4KHgpey4uLn0pIGlzIGEgc3ludGF4IGVycm9yO1xuICAgIC8vIGEgZnVuY3Rpb24gZXhwcmVzc2lvbidzIGFyZ3VtZW50IGNhbm5vdCBzaGFkb3cgdGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24ncyBuYW1lXG5cbiAgICB2YXIgdHJpY2t5X2RlZiA9IGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyAmJiB0aGlzLm5hbWUgJiYgdGhpcy5uYW1lLmRlZmluaXRpb24oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbmFtZSA9IEFTVF9MYW1iZGEucHJvdG90eXBlLm5leHRfbWFuZ2xlZC5jYWxsKHRoaXMsIG9wdGlvbnMsIGRlZik7XG4gICAgICAgIGlmICghKHRyaWNreV9kZWYgJiYgdHJpY2t5X2RlZi5tYW5nbGVkX25hbWUgPT0gbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcInJlZmVyZW5jZXNcIiwgZnVuY3Rpb24oc3ltKXtcbiAgICBpZiAoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkgc3ltID0gc3ltLmRlZmluaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5lbmNsb3NlZC5pbmRleE9mKHN5bSkgPCAwID8gbnVsbCA6IHN5bTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uKCkudW5tYW5nbGVhYmxlKG9wdGlvbnMpO1xufSk7XG5cbi8vIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IG1hbmdsZWFibGVcbkFTVF9TeW1ib2xBY2Nlc3Nvci5ERUZNRVRIT0QoXCJ1bm1hbmdsZWFibGVcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG4vLyBsYWJlbHMgYXJlIGFsd2F5cyBtYW5nbGVhYmxlXG5BU1RfTGFiZWwuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZhbHNlO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5yZWZlcmVuY2VkXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoID09IDBcbiAgICAgICAgJiYgISh0aGlzLnNjb3BlLnVzZXNfZXZhbCB8fCB0aGlzLnNjb3BlLnVzZXNfd2l0aCk7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJ1bmRlY2xhcmVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbigpLnVuZGVjbGFyZWQ7XG59KTtcblxuQVNUX0xhYmVsUmVmLkRFRk1FVEhPRChcInVuZGVjbGFyZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZmFsc2U7XG59KTtcblxuQVNUX0xhYmVsLkRFRk1FVEhPRChcInVuZGVjbGFyZWRcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJkZWZpbml0aW9uXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMudGhlZGVmO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwiZ2xvYmFsXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbigpLmdsb2JhbDtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiX2RlZmF1bHRfbWFuZ2xlcl9vcHRpb25zXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHJldHVybiBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGV4Y2VwdCAgIDogW10sXG4gICAgICAgIGV2YWwgICAgIDogZmFsc2UsXG4gICAgICAgIHNvcnQgICAgIDogZmFsc2UsXG4gICAgICAgIHRvcGxldmVsIDogZmFsc2UsXG4gICAgICAgIHNjcmV3X2llOCA6IGZhbHNlXG4gICAgfSk7XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcIm1hbmdsZV9uYW1lc1wiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIG1hbmdsZSBkZWNsYXJhdGlvbiBub2Rlcy4gIFNwZWNpYWwgbG9naWMgd2lyZWRcbiAgICAvLyBpbnRvIHRoZSBjb2RlIGdlbmVyYXRvciB3aWxsIGRpc3BsYXkgdGhlIG1hbmdsZWQgbmFtZSBpZiBpdCdzXG4gICAgLy8gcHJlc2VudCAoYW5kIGZvciBBU1RfU3ltYm9sUmVmLXMgaXQnbGwgdXNlIHRoZSBtYW5nbGVkIG5hbWUgb2ZcbiAgICAvLyB0aGUgQVNUX1N5bWJvbERlY2xhcmF0aW9uIHRoYXQgaXQgcG9pbnRzIHRvKS5cbiAgICB2YXIgbG5hbWUgPSAtMTtcbiAgICB2YXIgdG9fbWFuZ2xlID0gW107XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCl7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGxuYW1lIGlzIGluY3JlbWVudGVkIHdoZW4gd2UgZ2V0IHRvIHRoZSBBU1RfTGFiZWxcbiAgICAgICAgICAgIHZhciBzYXZlX25lc3RpbmcgPSBsbmFtZTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIGxuYW1lID0gc2F2ZV9uZXN0aW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAvLyBkb24ndCBkZXNjZW5kIGFnYWluIGluIFRyZWVXYWxrZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0dy5wYXJlbnQoKSwgYSA9IFtdO1xuICAgICAgICAgICAgbm9kZS52YXJpYWJsZXMuZWFjaChmdW5jdGlvbihzeW1ib2wpe1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmV4Y2VwdC5pbmRleE9mKHN5bWJvbC5uYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3J0KSBhLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIucmVmZXJlbmNlcy5sZW5ndGggLSBhLnJlZmVyZW5jZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b19tYW5nbGUucHVzaC5hcHBseSh0b19tYW5nbGUsIGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIGRvIG5hbWUgPSBiYXNlNTQoKytsbmFtZSk7IHdoaWxlICghaXNfaWRlbnRpZmllcihuYW1lKSk7XG4gICAgICAgICAgICBub2RlLm1hbmdsZWRfbmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG4gICAgdG9fbWFuZ2xlLmZvckVhY2goZnVuY3Rpb24oZGVmKXsgZGVmLm1hbmdsZShvcHRpb25zKSB9KTtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeVwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUucHJpbnRfdG9fc3RyaW5nKCkpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1JldHVybilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInJldHVyblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaHJvdylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInRocm93XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiY29udGludWVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQnJlYWspXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJicmVha1wiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWJ1Z2dlcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImRlYnVnZ2VyXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLnZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaGlsZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcIndoaWxlXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZG8gd2hpbGVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImlmXCIpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRpdmUpIGJhc2U1NC5jb25zaWRlcihcImVsc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXIpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJ2YXJcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3QpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjb25zdFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3IpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmb3JcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9ySW4pXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmb3IgaW5cIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwic3dpdGNoXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Nhc2UpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjYXNlXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmF1bHQpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJkZWZhdWx0XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1dpdGgpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJ3aXRoXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdFNldHRlcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInNldFwiICsgbm9kZS5rZXkpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEdldHRlcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImdldFwiICsgbm9kZS5rZXkpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLmtleSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTmV3KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwibmV3XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1RoaXMpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJ0aGlzXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1RyeSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInRyeVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYXRjaClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImNhdGNoXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZpbmFsbHkpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmaW5hbGx5XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJiBub2RlLnVubWFuZ2xlYWJsZShvcHRpb25zKSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLm5hbWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1VuYXJ5IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUub3BlcmF0b3IpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLnByb3BlcnR5KTtcbiAgICB9KTtcbiAgICB0aGlzLndhbGsodHcpO1xuICAgIGJhc2U1NC5zb3J0KCk7XG59KTtcblxudmFyIGJhc2U1NCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8wMTIzNDU2Nzg5XCI7XG4gICAgdmFyIGNoYXJzLCBmcmVxdWVuY3k7XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIGZyZXF1ZW5jeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNoYXJzID0gc3RyaW5nLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjaCl7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApIH0pO1xuICAgICAgICBjaGFycy5mb3JFYWNoKGZ1bmN0aW9uKGNoKXsgZnJlcXVlbmN5W2NoXSA9IDAgfSk7XG4gICAgfVxuICAgIGJhc2U1NC5jb25zaWRlciA9IGZ1bmN0aW9uKHN0cil7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdHIubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSBpbiBmcmVxdWVuY3kpICsrZnJlcXVlbmN5W2NvZGVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBiYXNlNTQuc29ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjaGFycyA9IG1lcmdlU29ydChjaGFycywgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICBpZiAoaXNfZGlnaXQoYSkgJiYgIWlzX2RpZ2l0KGIpKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChpc19kaWdpdChiKSAmJiAhaXNfZGlnaXQoYSkpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiBmcmVxdWVuY3lbYl0gLSBmcmVxdWVuY3lbYV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYmFzZTU0LnJlc2V0ID0gcmVzZXQ7XG4gICAgcmVzZXQoKTtcbiAgICBiYXNlNTQuZ2V0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIGNoYXJzIH07XG4gICAgYmFzZTU0LmZyZXEgPSBmdW5jdGlvbigpeyByZXR1cm4gZnJlcXVlbmN5IH07XG4gICAgZnVuY3Rpb24gYmFzZTU0KG51bSkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIiwgYmFzZSA9IDU0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyc1tudW0gJSBiYXNlXSk7XG4gICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGJhc2UpO1xuICAgICAgICAgICAgYmFzZSA9IDY0O1xuICAgICAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHJldHVybiBiYXNlNTQ7XG59KSgpO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwic2NvcGVfd2FybmluZ3NcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgdW5kZWNsYXJlZCAgICAgICA6IGZhbHNlLCAvLyB0aGlzIG1ha2VzIGEgbG90IG9mIG5vaXNlXG4gICAgICAgIHVucmVmZXJlbmNlZCAgICAgOiB0cnVlLFxuICAgICAgICBhc3NpZ25fdG9fZ2xvYmFsIDogdHJ1ZSxcbiAgICAgICAgZnVuY19hcmd1bWVudHMgICA6IHRydWUsXG4gICAgICAgIG5lc3RlZF9kZWZ1bnMgICAgOiB0cnVlLFxuICAgICAgICBldmFsICAgICAgICAgICAgIDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICBpZiAob3B0aW9ucy51bmRlY2xhcmVkXG4gICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgbm9kZS51bmRlY2xhcmVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFhYWDogdGhpcyBhbHNvIHdhcm5zIGFib3V0IEpTIHN0YW5kYXJkIG5hbWVzLFxuICAgICAgICAgICAgLy8gaS5lLiBPYmplY3QsIEFycmF5LCBwYXJzZUludCBldGMuICBTaG91bGQgYWRkIGEgbGlzdCBvZlxuICAgICAgICAgICAgLy8gZXhjZXB0aW9ucy5cbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJVbmRlY2xhcmVkIHN5bWJvbDoge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIGZpbGU6IG5vZGUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lOiBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBub2RlLnN0YXJ0LmNvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduX3RvX2dsb2JhbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN5bSA9IG51bGw7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24gJiYgbm9kZS5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICBzeW0gPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvckluICYmIG5vZGUuaW5pdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpXG4gICAgICAgICAgICAgICAgc3ltID0gbm9kZS5pbml0O1xuICAgICAgICAgICAgaWYgKHN5bVxuICAgICAgICAgICAgICAgICYmIChzeW0udW5kZWNsYXJlZCgpXG4gICAgICAgICAgICAgICAgICAgIHx8IChzeW0uZ2xvYmFsKCkgJiYgc3ltLnNjb3BlICE9PSBzeW0uZGVmaW5pdGlvbigpLnNjb3BlKSkpIHtcbiAgICAgICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwie21zZ306IHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgICAgICBtc2c6IHN5bS51bmRlY2xhcmVkKCkgPyBcIkFjY2lkZW50YWwgZ2xvYmFsP1wiIDogXCJBc3NpZ25tZW50IHRvIGdsb2JhbFwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzeW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogc3ltLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN5bS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6IHN5bS5zdGFydC5jb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5ldmFsXG4gICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgbm9kZS51bmRlY2xhcmVkKClcbiAgICAgICAgICAgICYmIG5vZGUubmFtZSA9PSBcImV2YWxcIikge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIkV2YWwgaXMgdXNlZCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgbm9kZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudW5yZWZlcmVuY2VkXG4gICAgICAgICAgICAmJiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsKVxuICAgICAgICAgICAgJiYgbm9kZS51bnJlZmVyZW5jZWQoKSkge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcInt0eXBlfSB7bmFtZX0gaXMgZGVjbGFyZWQgYnV0IG5vdCByZWZlcmVuY2VkIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbCA/IFwiTGFiZWxcIiA6IFwiU3ltYm9sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIGZpbGU6IG5vZGUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lOiBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBub2RlLnN0YXJ0LmNvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnVuY19hcmd1bWVudHNcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICAmJiBub2RlLnVzZXNfYXJndW1lbnRzKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiYXJndW1lbnRzIHVzZWQgaW4gZnVuY3Rpb24ge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lID8gbm9kZS5uYW1lLm5hbWUgOiBcImFub255bW91c1wiLFxuICAgICAgICAgICAgICAgIGZpbGU6IG5vZGUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lOiBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBub2RlLnN0YXJ0LmNvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubmVzdGVkX2RlZnVuc1xuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1blxuICAgICAgICAgICAgJiYgISh0dy5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9TY29wZSkpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJGdW5jdGlvbiB7bmFtZX0gZGVjbGFyZWQgaW4gbmVzdGVkIHN0YXRlbWVudCBcXFwie3R5cGV9XFxcIiBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZS5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR3LnBhcmVudCgpLlRZUEUsXG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gT3V0cHV0U3RyZWFtKG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGluZGVudF9zdGFydCAgOiAwLFxuICAgICAgICBpbmRlbnRfbGV2ZWwgIDogNCxcbiAgICAgICAgcXVvdGVfa2V5cyAgICA6IGZhbHNlLFxuICAgICAgICBzcGFjZV9jb2xvbiAgIDogdHJ1ZSxcbiAgICAgICAgYXNjaWlfb25seSAgICA6IGZhbHNlLFxuICAgICAgICBpbmxpbmVfc2NyaXB0IDogZmFsc2UsXG4gICAgICAgIHdpZHRoICAgICAgICAgOiA4MCxcbiAgICAgICAgbWF4X2xpbmVfbGVuICA6IDMyMDAwLFxuICAgICAgICBiZWF1dGlmeSAgICAgIDogZmFsc2UsXG4gICAgICAgIHNvdXJjZV9tYXAgICAgOiBudWxsLFxuICAgICAgICBicmFja2V0aXplICAgIDogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnMgICAgOiB0cnVlLFxuICAgICAgICBjb21tZW50cyAgICAgIDogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlX2xpbmUgOiBmYWxzZSxcbiAgICAgICAgc2NyZXdfaWU4ICAgICA6IGZhbHNlLFxuICAgICAgICBwcmVhbWJsZSAgICAgIDogbnVsbCxcbiAgICB9LCB0cnVlKTtcblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gICAgdmFyIGN1cnJlbnRfY29sID0gMDtcbiAgICB2YXIgY3VycmVudF9saW5lID0gMTtcbiAgICB2YXIgY3VycmVudF9wb3MgPSAwO1xuICAgIHZhciBPVVRQVVQgPSBcIlwiO1xuXG4gICAgZnVuY3Rpb24gdG9fYXNjaWkoc3RyLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTAwODAtXFx1ZmZmZl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPD0gMiAmJiAhaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8IDIpIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGNvZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8IDQpIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX3N0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGRxID0gMCwgc3EgPSAwO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcXFxcXGJcXGZcXG5cXHJcXHRcXHgyMlxceDI3XFx1MjAyOFxcdTIwMjlcXDBdL2csIGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXGJcIjogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcZlwiOiByZXR1cm4gXCJcXFxcZlwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6IHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjogcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6IHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICBjYXNlICdcIic6ICsrZHE7IHJldHVybiAnXCInO1xuICAgICAgICAgICAgICBjYXNlIFwiJ1wiOiArK3NxOyByZXR1cm4gXCInXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXDBcIjogcmV0dXJuIFwiXFxcXHgwMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5hc2NpaV9vbmx5KSBzdHIgPSB0b19hc2NpaShzdHIpO1xuICAgICAgICBpZiAoZHEgPiBzcSkgcmV0dXJuIFwiJ1wiICsgc3RyLnJlcGxhY2UoL1xceDI3L2csIFwiXFxcXCdcIikgKyBcIidcIjtcbiAgICAgICAgZWxzZSByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXHgyMi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVfc3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgcmV0ID0gbWFrZV9zdHJpbmcoc3RyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5saW5lX3NjcmlwdClcbiAgICAgICAgICAgIHJldCA9IHJldC5yZXBsYWNlKC88XFx4MmZzY3JpcHQoWz5cXC9cXHRcXG5cXGZcXHIgXSkvZ2ksIFwiPFxcXFwvc2NyaXB0JDFcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfbmFtZShuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpXG4gICAgICAgICAgICBuYW1lID0gdG9fYXNjaWkobmFtZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX2luZGVudChiYWNrKSB7XG4gICAgICAgIHJldHVybiByZXBlYXRfc3RyaW5nKFwiIFwiLCBvcHRpb25zLmluZGVudF9zdGFydCArIGluZGVudGF0aW9uIC0gYmFjayAqIG9wdGlvbnMuaW5kZW50X2xldmVsKTtcbiAgICB9O1xuXG4gICAgLyogLS0tLS1bIGJlYXV0aWZpY2F0aW9uL21pbmlmaWNhdGlvbiBdLS0tLS0gKi9cblxuICAgIHZhciBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdmFyIGxhc3QgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gbGFzdF9jaGFyKCkge1xuICAgICAgICByZXR1cm4gbGFzdC5jaGFyQXQobGFzdC5sZW5ndGggLSAxKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVfbmV3bGluZSgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4X2xpbmVfbGVuICYmIGN1cnJlbnRfY29sID4gb3B0aW9ucy5tYXhfbGluZV9sZW4pXG4gICAgICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVpcmVTZW1pY29sb25DaGFycyA9IG1ha2VQcmVkaWNhdGUoXCIoIFsgKyAqIC8gLSAsIC5cIik7XG5cbiAgICBmdW5jdGlvbiBwcmludChzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChtaWdodF9uZWVkX3NlbWljb2xvbikge1xuICAgICAgICAgICAgaWYgKCghY2ggfHwgXCI7fVwiLmluZGV4T2YoY2gpIDwgMCkgJiYgIS9bO10kLy50ZXN0KGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VtaWNvbG9ucyB8fCByZXF1aXJlU2VtaWNvbG9uQ2hhcnMoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jb2wrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmJlYXV0aWZ5KVxuICAgICAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbWF5YmVfbmV3bGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmJlYXV0aWZ5ICYmIG9wdGlvbnMucHJlc2VydmVfbGluZSAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldF9saW5lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uc3RhcnQubGluZTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50X2xpbmUgPCB0YXJnZXRfbGluZSkge1xuICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSAwO1xuICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaWdodF9uZWVkX3NwYWNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGxhc3RfY2hhcigpO1xuICAgICAgICAgICAgaWYgKChpc19pZGVudGlmaWVyX2NoYXIocHJldilcbiAgICAgICAgICAgICAgICAgJiYgKGlzX2lkZW50aWZpZXJfY2hhcihjaCkgfHwgY2ggPT0gXCJcXFxcXCIpKVxuICAgICAgICAgICAgICAgIHx8ICgvXltcXCtcXC1cXC9dJC8udGVzdChjaCkgJiYgY2ggPT0gcHJldikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pLCBuID0gYS5sZW5ndGggLSAxO1xuICAgICAgICBjdXJyZW50X2xpbmUgKz0gbjtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgY3VycmVudF9jb2wgKz0gYVtuXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50X2NvbCA9IGFbbl0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRfcG9zICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIGxhc3QgPSBzdHI7XG4gICAgICAgIE9VVFBVVCArPSBzdHI7XG4gICAgfTtcblxuICAgIHZhciBzcGFjZSA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCIgXCIpO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBpbmRlbnQgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oaGFsZikge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWF1dGlmeSkge1xuICAgICAgICAgICAgcHJpbnQobWFrZV9pbmRlbnQoaGFsZiA/IDAuNSA6IDApKTtcbiAgICAgICAgfVxuICAgIH0gOiBub29wO1xuXG4gICAgdmFyIHdpdGhfaW5kZW50ID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKGNvbCwgY29udCkge1xuICAgICAgICBpZiAoY29sID09PSB0cnVlKSBjb2wgPSBuZXh0X2luZGVudCgpO1xuICAgICAgICB2YXIgc2F2ZV9pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICBpbmRlbnRhdGlvbiA9IGNvbDtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgaW5kZW50YXRpb24gPSBzYXZlX2luZGVudGF0aW9uO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0gOiBmdW5jdGlvbihjb2wsIGNvbnQpIHsgcmV0dXJuIGNvbnQoKSB9O1xuXG4gICAgdmFyIG5ld2xpbmUgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgIH0gOiBub29wO1xuXG4gICAgdmFyIHNlbWljb2xvbiA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCI7XCIpO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSB0cnVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JjZV9zZW1pY29sb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHByaW50KFwiO1wiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dF9pbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50X2xldmVsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX2Jsb2NrKGNvbnQpIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcHJpbnQoXCJ7XCIpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIHdpdGhfaW5kZW50KG5leHRfaW5kZW50KCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgcHJpbnQoXCJ9XCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX3BhcmVucyhjb250KSB7XG4gICAgICAgIHByaW50KFwiKFwiKTtcbiAgICAgICAgLy9YWFg6IHN0aWxsIG5pY2UgdG8gaGF2ZSB0aGF0IGZvciBhcmd1bWVudCBsaXN0c1xuICAgICAgICAvL3ZhciByZXQgPSB3aXRoX2luZGVudChjdXJyZW50X2NvbCwgY29udCk7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIHByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2l0aF9zcXVhcmUoY29udCkge1xuICAgICAgICBwcmludChcIltcIik7XG4gICAgICAgIC8vdmFyIHJldCA9IHdpdGhfaW5kZW50KGN1cnJlbnRfY29sLCBjb250KTtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgcHJpbnQoXCJdXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21tYSgpIHtcbiAgICAgICAgcHJpbnQoXCIsXCIpO1xuICAgICAgICBzcGFjZSgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb2xvbigpIHtcbiAgICAgICAgcHJpbnQoXCI6XCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5zcGFjZV9jb2xvbikgc3BhY2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZF9tYXBwaW5nID0gb3B0aW9ucy5zb3VyY2VfbWFwID8gZnVuY3Rpb24odG9rZW4sIG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0b2tlbikgb3B0aW9ucy5zb3VyY2VfbWFwLmFkZChcbiAgICAgICAgICAgICAgICB0b2tlbi5maWxlIHx8IFwiP1wiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSwgY3VycmVudF9jb2wsXG4gICAgICAgICAgICAgICAgdG9rZW4ubGluZSwgdG9rZW4uY29sLFxuICAgICAgICAgICAgICAgICghbmFtZSAmJiB0b2tlbi50eXBlID09IFwibmFtZVwiKSA/IHRva2VuLnZhbHVlIDogbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIkNvdWxkbid0IGZpZ3VyZSBvdXQgbWFwcGluZyBmb3Ige2ZpbGV9OntsaW5lfSx7Y29sfSDihpIge2NsaW5lfSx7Y2NvbH0gW3tuYW1lfV1cIiwge1xuICAgICAgICAgICAgICAgIGZpbGU6IHRva2VuLmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IHRva2VuLmNvbCxcbiAgICAgICAgICAgICAgICBjbGluZTogY3VycmVudF9saW5lLFxuICAgICAgICAgICAgICAgIGNjb2w6IGN1cnJlbnRfY29sLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwgXCJcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0gOiBub29wO1xuXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gT1VUUFVUO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wcmVhbWJsZSkge1xuICAgICAgICBwcmludChvcHRpb25zLnByZWFtYmxlLnJlcGxhY2UoL1xcclxcbj98W1xcblxcdTIwMjhcXHUyMDI5XXxcXHMqJC9nLCBcIlxcblwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0ICAgICAgICAgICAgIDogZ2V0LFxuICAgICAgICB0b1N0cmluZyAgICAgICAgOiBnZXQsXG4gICAgICAgIGluZGVudCAgICAgICAgICA6IGluZGVudCxcbiAgICAgICAgaW5kZW50YXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBpbmRlbnRhdGlvbiB9LFxuICAgICAgICBjdXJyZW50X3dpZHRoICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfY29sIC0gaW5kZW50YXRpb24gfSxcbiAgICAgICAgc2hvdWxkX2JyZWFrICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBvcHRpb25zLndpZHRoICYmIHRoaXMuY3VycmVudF93aWR0aCgpID49IG9wdGlvbnMud2lkdGggfSxcbiAgICAgICAgbmV3bGluZSAgICAgICAgIDogbmV3bGluZSxcbiAgICAgICAgcHJpbnQgICAgICAgICAgIDogcHJpbnQsXG4gICAgICAgIHNwYWNlICAgICAgICAgICA6IHNwYWNlLFxuICAgICAgICBjb21tYSAgICAgICAgICAgOiBjb21tYSxcbiAgICAgICAgY29sb24gICAgICAgICAgIDogY29sb24sXG4gICAgICAgIGxhc3QgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdCB9LFxuICAgICAgICBzZW1pY29sb24gICAgICAgOiBzZW1pY29sb24sXG4gICAgICAgIGZvcmNlX3NlbWljb2xvbiA6IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgdG9fYXNjaWkgICAgICAgIDogdG9fYXNjaWksXG4gICAgICAgIHByaW50X25hbWUgICAgICA6IGZ1bmN0aW9uKG5hbWUpIHsgcHJpbnQobWFrZV9uYW1lKG5hbWUpKSB9LFxuICAgICAgICBwcmludF9zdHJpbmcgICAgOiBmdW5jdGlvbihzdHIpIHsgcHJpbnQoZW5jb2RlX3N0cmluZyhzdHIpKSB9LFxuICAgICAgICBuZXh0X2luZGVudCAgICAgOiBuZXh0X2luZGVudCxcbiAgICAgICAgd2l0aF9pbmRlbnQgICAgIDogd2l0aF9pbmRlbnQsXG4gICAgICAgIHdpdGhfYmxvY2sgICAgICA6IHdpdGhfYmxvY2ssXG4gICAgICAgIHdpdGhfcGFyZW5zICAgICA6IHdpdGhfcGFyZW5zLFxuICAgICAgICB3aXRoX3NxdWFyZSAgICAgOiB3aXRoX3NxdWFyZSxcbiAgICAgICAgYWRkX21hcHBpbmcgICAgIDogYWRkX21hcHBpbmcsXG4gICAgICAgIG9wdGlvbiAgICAgICAgICA6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gb3B0aW9uc1tvcHRdIH0sXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9saW5lIH0sXG4gICAgICAgIGNvbCAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9jb2wgfSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X3BvcyB9LFxuICAgICAgICBwdXNoX25vZGUgICAgICAgOiBmdW5jdGlvbihub2RlKSB7IHN0YWNrLnB1c2gobm9kZSkgfSxcbiAgICAgICAgcG9wX25vZGUgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzdGFjay5wb3AoKSB9LFxuICAgICAgICBzdGFjayAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrIH0sXG4gICAgICAgIHBhcmVudCAgICAgICAgICA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgICAgICB9XG4gICAgfTtcblxufTtcblxuLyogLS0tLS1bIGNvZGUgZ2VuZXJhdG9ycyBdLS0tLS0gKi9cblxuKGZ1bmN0aW9uKCl7XG5cbiAgICAvKiAtLS0tLVsgdXRpbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZQUklOVChub2RldHlwZSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIl9jb2RlZ2VuXCIsIGdlbmVyYXRvcik7XG4gICAgfTtcblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcInByaW50XCIsIGZ1bmN0aW9uKHN0cmVhbSwgZm9yY2VfcGFyZW5zKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBnZW5lcmF0b3IgPSBzZWxmLl9jb2RlZ2VuO1xuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgc2VsZi5hZGRfY29tbWVudHMoc3RyZWFtKTtcbiAgICAgICAgICAgIHNlbGYuYWRkX3NvdXJjZV9tYXAoc3RyZWFtKTtcbiAgICAgICAgICAgIGdlbmVyYXRvcihzZWxmLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wdXNoX25vZGUoc2VsZik7XG4gICAgICAgIGlmIChmb3JjZV9wYXJlbnMgfHwgc2VsZi5uZWVkc19wYXJlbnMoc3RyZWFtKSkge1xuICAgICAgICAgICAgc3RyZWFtLndpdGhfcGFyZW5zKGRvaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3Bfbm9kZSgpO1xuICAgIH0pO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRfdG9fc3RyaW5nXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICB2YXIgcyA9IE91dHB1dFN0cmVhbShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wcmludChzKTtcbiAgICAgICAgcmV0dXJuIHMuZ2V0KCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgY29tbWVudHMgXS0tLS0tICovXG5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJhZGRfY29tbWVudHNcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIGMgPSBvdXRwdXQub3B0aW9uKFwiY29tbWVudHNcIiksIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2VsZi5zdGFydDtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiAhc3RhcnQuX2NvbW1lbnRzX2R1bXBlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Ll9jb21tZW50c19kdW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFhYWDogdWdseSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8xMTJcbiAgICAgICAgICAgICAgICAvLyAgICAgIGlmIHRoaXMgbm9kZSBpcyBgcmV0dXJuYCBvciBgdGhyb3dgLCB3ZSBjYW5ub3QgYWxsb3cgY29tbWVudHMgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gICAgICB0aGUgcmV0dXJuZWQgb3IgdGhyb3duIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX0V4aXQgJiYgc2VsZi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnZhbHVlLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KHNlbGYudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52YWx1ZS5zdGFydC5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGNvbW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMudGVzdChjb21tZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5maWx0ZXIoZnVuY3Rpb24oY29tbWVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyhzZWxmLCBjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1lbnRzLmZvckVhY2goZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvY29tbWVudFsxMzRdLy50ZXN0KGMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi8vXCIgKyBjLnZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYy50eXBlID09IFwiY29tbWVudDJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLypcIiArIGMudmFsdWUgKyBcIiovXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Lm5sYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBQQVJFTlRIRVNFUyBdLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIFBBUkVOUyhub2RldHlwZSwgZnVuYykge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJuZWVkc19wYXJlbnNcIiwgZnVuYyk7XG4gICAgfTtcblxuICAgIFBBUkVOUyhBU1RfTm9kZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gYSBmdW5jdGlvbiBleHByZXNzaW9uIG5lZWRzIHBhcmVucyBhcm91bmQgaXQgd2hlbiBpdCdzIHByb3ZhYmx5XG4gICAgLy8gdGhlIGZpcnN0IHRva2VuIHRvIGFwcGVhciBpbiBhIHN0YXRlbWVudC5cbiAgICBQQVJFTlMoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICByZXR1cm4gZmlyc3RfaW5fc3RhdGVtZW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBzYW1lIGdvZXMgZm9yIGFuIG9iamVjdCBsaXRlcmFsLCBiZWNhdXNlIG90aGVyd2lzZSBpdCB3b3VsZCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIGEgYmxvY2sgb2YgY29kZS5cbiAgICBQQVJFTlMoQVNUX09iamVjdCwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgcmV0dXJuIGZpcnN0X2luX3N0YXRlbWVudChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9VbmFyeSwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9TZXEsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9DYWxsICAgICAgICAgICAgIC8vIChmb28sIGJhcikoKSBvciBmb28oMSwgKDIsIDMpLCA0KVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeSAgICAgICAgICAgIC8vICEoZm9vLCBiYXIsIGJheilcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAgICAvLyAxICsgKDIsIDMpICsgNCA9PT4gOFxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9WYXJEZWYgICAgICAgICAgIC8vIHZhciBhID0gKDEsIDIpLCBiID0gYSArIGE7ID09PiBiID09IDRcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRG90ICAgICAgICAgICAgICAvLyAoMSwge2ZvbzoyfSkuZm9vID09PiAyXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0FycmF5ICAgICAgICAgICAgLy8gWyAxLCAoMiwgMyksIDQgXSA9PT4gWyAxLCAzLCA0IF1cbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkgICAvLyB7IGZvbzogKDEsIDIpIH0uZm9vID09PiAyXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICAgICAgLyogKGZhbHNlLCB0cnVlKSA/IChhID0gMTAsIGIgPSAyMCkgOiAoYyA9IDMwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqID09PiAyMCAoc2lkZSBlZmZlY3QsIHNldCBhIDo9IDEwIGFuZCBiIDo9IDIwKSAqL1xuICAgICAgICA7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0JpbmFyeSwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vIChmb28gJiYgYmFyKSgpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHR5cGVvZiAoZm9vICYmIGJhcilcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGZvbyAmJiBiYXIpW1wicHJvcFwiXSwgKGZvbyAmJiBiYXIpLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcyBkZWFscyB3aXRoIHByZWNlZGVuY2U6IDMgKiAoMiArIDEpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSkge1xuICAgICAgICAgICAgdmFyIHBvID0gcC5vcGVyYXRvciwgcHAgPSBQUkVDRURFTkNFW3BvXTtcbiAgICAgICAgICAgIHZhciBzbyA9IHRoaXMub3BlcmF0b3IsIHNwID0gUFJFQ0VERU5DRVtzb107XG4gICAgICAgICAgICBpZiAocHAgPiBzcFxuICAgICAgICAgICAgICAgIHx8IChwcCA9PSBzcFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzID09PSBwLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1Byb3BBY2Nlc3MsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9OZXcgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBpLmUuIG5ldyAoZm9vLmJhcigpLmJheilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG9uZSBjYWxsIGludG8gdGhpcyBzdWJ0cmVlLCB0aGVuIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHBhcmVucyBhcm91bmQgaXQgdG9vLCBvdGhlcndpc2UgdGhlIGNhbGwgd2lsbCBiZVxuICAgICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgcGFzc2luZyB0aGUgYXJndW1lbnRzIHRvIHRoZSB1cHBlciBOZXdcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCkgdGhyb3cgcDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4ICE9PSBwKSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9DYWxsLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKSwgcDE7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX05ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBTYWZhcmkgYnVnLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzNTA2XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICYmIHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzc1xuICAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICAmJiAocDEgPSBvdXRwdXQucGFyZW50KDEpKSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmIHAxLmxlZnQgPT09IHA7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX05ldywgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChub19jb25zdHJ1Y3Rvcl9wYXJlbnModGhpcywgb3V0cHV0KVxuICAgICAgICAgICAgJiYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAvLyAobmV3IERhdGUpLmdldFRpbWUoKSwgKG5ldyBEYXRlKVtcImdldFRpbWVcIl0oKVxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpKSAvLyAobmV3IGZvbykoYmFyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX051bWJlciwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPCAwICYmIHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTmFOLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyAhKGEgPSBmYWxzZSkg4oaSIHRydWVcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gMSArIChhID0gMikgKyAzIOKGkiA2LCBzaWRlIGVmZmVjdCBzZXR0aW5nIGEgPSAyXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiAhKHAgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoYSA9IGZ1bmMpKCkg4oCUb3LigJQgbmV3IChhID0gT2JqZWN0KSgpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZm9vKSA/IGJhciA6IGJhelxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoYSA9IGZvbylbXCJwcm9wXCJdIOKAlG9y4oCUIChhID0gZm9vKS5wcm9wXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFBBUkVOUyhBU1RfQXNzaWduLCBhc3NpZ25fYW5kX2NvbmRpdGlvbmFsX3BhcmVuX3J1bGVzKTtcbiAgICBQQVJFTlMoQVNUX0NvbmRpdGlvbmFsLCBhc3NpZ25fYW5kX2NvbmRpdGlvbmFsX3BhcmVuX3J1bGVzKTtcblxuICAgIC8qIC0tLS0tWyBQUklOVEVSUyBdLS0tLS0gKi9cblxuICAgIERFRlBSSU5UKEFTVF9EaXJlY3RpdmUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi52YWx1ZSk7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRGVidWdnZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImRlYnVnZ2VyXCIpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgc3RhdGVtZW50cyBdLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIGRpc3BsYXlfYm9keShib2R5LCBpc190b3BsZXZlbCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBsYXN0ID0gYm9keS5sZW5ndGggLSAxO1xuICAgICAgICBib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCwgaSl7XG4gICAgICAgICAgICBpZiAoIShzdG10IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA9PSBsYXN0ICYmIGlzX3RvcGxldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfdG9wbGV2ZWwpIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgQVNUX1N0YXRlbWVudFdpdGhCb2R5LkRFRk1FVEhPRChcIl9kb19wcmludF9ib2R5XCIsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIGZvcmNlX3N0YXRlbWVudCh0aGlzLmJvZHksIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ub3BsZXZlbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgZGlzcGxheV9ib2R5KHNlbGYuYm9keSwgdHJ1ZSwgb3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmxhYmVsLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByaW50X2JyYWNrZXRlZChib2R5LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGRpc3BsYXlfYm9keShib2R5LCBmYWxzZSwgb3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LnByaW50KFwie31cIik7XG4gICAgfTtcbiAgICBERUZQUklOVChBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHByaW50X2JyYWNrZXRlZChzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0VtcHR5U3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJkb1wiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIndoaWxlXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9XaGlsZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImZvclwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplX2Zvcl9ub2luKHNlbGYuaW5pdCwgb3V0cHV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN0ZXAucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZvckluLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmb3JcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJpblwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5vYmplY3QucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1dpdGgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcIndpdGhcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBmdW5jdGlvbnMgXS0tLS0tICovXG4gICAgQVNUX0xhbWJkYS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0LCBub2tleXdvcmQpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghbm9rZXl3b3JkKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZywgaSl7XG4gICAgICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIGFyZy5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTGFtYmRhLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGV4aXRzIF0tLS0tLSAqL1xuICAgIEFTVF9FeGl0LkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1JldHVybiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInJldHVyblwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVGhyb3csIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJ0aHJvd1wiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBsb29wIGNvbnRyb2wgXS0tLS0tICovXG4gICAgQVNUX0xvb3BDb250cm9sLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0JyZWFrLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiYnJlYWtcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnRpbnVlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiY29udGludWVcIik7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgaWYgXS0tLS0tICovXG4gICAgZnVuY3Rpb24gbWFrZV90aGVuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImJyYWNrZXRpemVcIikpIHtcbiAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzcXVlZXplciByZXBsYWNlcyBcImJsb2NrXCItcyB0aGF0IGNvbnRhaW4gb25seSBhIHNpbmdsZVxuICAgICAgICAvLyBzdGF0ZW1lbnQgd2l0aCB0aGUgc3RhdGVtZW50IGl0c2VsZjsgdGVjaG5pY2FsbHksIHRoZSBBU1RcbiAgICAgICAgLy8gaXMgY29ycmVjdCwgYnV0IHRoaXMgY2FuIGNyZWF0ZSBwcm9ibGVtcyB3aGVuIHdlIG91dHB1dCBhblxuICAgICAgICAvLyBJRiBoYXZpbmcgYW4gRUxTRSBjbGF1c2Ugd2hlcmUgdGhlIFRIRU4gY2xhdXNlIGVuZHMgaW4gYW5cbiAgICAgICAgLy8gSUYgKndpdGhvdXQqIGFuIEVMU0UgYmxvY2sgKHRoZW4gdGhlIG91dGVyIEVMU0Ugd291bGQgcmVmZXJcbiAgICAgICAgLy8gdG8gdGhlIGlubmVyIElGKS4gIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGZvciB0aGlzIGNhc2UgYW5kXG4gICAgICAgIC8vIGFkZHMgdGhlIGJsb2NrIGJyYWNrZXRzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCFzZWxmLmJvZHkpXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0RvXG4gICAgICAgICAgICAmJiAhb3V0cHV0Lm9wdGlvbihcInNjcmV3X2llOFwiKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvI2lzc3VlLzU3IElFXG4gICAgICAgICAgICAvLyBjcm9ha3Mgd2l0aCBcInN5bnRheCBlcnJvclwiIG9uIGNvZGUgbGlrZSB0aGlzOiBpZiAoZm9vKVxuICAgICAgICAgICAgLy8gZG8gLi4uIHdoaWxlKGNvbmQpOyBlbHNlIC4uLiAgd2UgbmVlZCBibG9jayBicmFja2V0c1xuICAgICAgICAgICAgLy8gYXJvdW5kIGRvL3doaWxlXG4gICAgICAgICAgICBtYWtlX2Jsb2NrKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IHNlbGYuYm9keTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChiIGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSBiLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSkge1xuICAgICAgICAgICAgICAgIGIgPSBiLmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlX3N0YXRlbWVudChzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgfTtcbiAgICBERUZQUklOVChBU1RfSWYsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImlmXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZWxzZVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHNlbGYuYWx0ZXJuYXRpdmUsIG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBzd2l0Y2ggXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic3dpdGNoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBpZiAoc2VsZi5ib2R5Lmxlbmd0aCA+IDApIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KHRydWUpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9KTtcbiAgICBBU1RfU3dpdGNoQnJhbmNoLkRFRk1FVEhPRChcIl9kb19wcmludF9ib2R5XCIsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQpe1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RlZmF1bHQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImRlZmF1bHQ6XCIpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhc2VcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiOlwiKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGV4Y2VwdGlvbnMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwidHJ5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYuYmNhdGNoKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYuYmNhdGNoLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYmZpbmFsbHkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5iZmluYWxseS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NhdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJjYXRjaFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5hcmduYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRmluYWxseSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZmluYWxseVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHByaW50X2JyYWNrZXRlZChzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgdmFyL2NvbnN0IF0tLS0tLSAqL1xuICAgIEFTVF9EZWZpbml0aW9ucy5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0LCBraW5kKXtcbiAgICAgICAgb3V0cHV0LnByaW50KGtpbmQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaSl7XG4gICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICBkZWYucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICB2YXIgaW5fZm9yID0gcCBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgcCBpbnN0YW5jZW9mIEFTVF9Gb3JJbjtcbiAgICAgICAgdmFyIGF2b2lkX3NlbWljb2xvbiA9IGluX2ZvciAmJiBwLmluaXQgPT09IHRoaXM7XG4gICAgICAgIGlmICghYXZvaWRfc2VtaWNvbG9uKVxuICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9WYXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJ2YXJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiY29uc3RcIik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemVfZm9yX25vaW4obm9kZSwgb3V0cHV0LCBub2luKSB7XG4gICAgICAgIGlmICghbm9pbikgbm9kZS5wcmludChvdXRwdXQpO1xuICAgICAgICBlbHNlIHRyeSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHRha2Ugc29tZSBwcmVjYXV0aW9ucyBoZXJlOlxuICAgICAgICAgICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzYwXG4gICAgICAgICAgICBub2RlLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBvdXRwdXQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIGlmIChleCAhPT0gb3V0cHV0KSB0aHJvdyBleDtcbiAgICAgICAgICAgIG5vZGUucHJpbnQob3V0cHV0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBERUZQUklOVChBU1RfVmFyRGVmLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLm5hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KDEpO1xuICAgICAgICAgICAgdmFyIG5vaW4gPSBwIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBwIGluc3RhbmNlb2YgQVNUX0ZvckluO1xuICAgICAgICAgICAgcGFyZW50aGVzaXplX2Zvcl9ub2luKHNlbGYudmFsdWUsIG91dHB1dCwgbm9pbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBvdGhlciBleHByZXNzaW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfQ2FsbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX05ldyAmJiBub19jb25zdHJ1Y3Rvcl9wYXJlbnMoc2VsZiwgb3V0cHV0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihleHByLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgZXhwci5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9OZXcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcIm5ld1wiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIEFTVF9DYWxsLnByb3RvdHlwZS5fY29kZWdlbihzZWxmLCBvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgQVNUX1NlcS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdGhpcy5jYXIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHRoaXMuY2RyKSB7XG4gICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuc2hvdWxkX2JyZWFrKCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2RyLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU2VxLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gaWYgKHAgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSB7XG4gICAgICAgIC8vICAgICBvdXRwdXQud2l0aF9pbmRlbnQob3V0cHV0Lm5leHRfaW5kZW50KCksIGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vICAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0KTtcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0KTtcbiAgICAgICAgLy8gfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Eb3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBleHByID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX051bWJlciAmJiBleHByLmdldFZhbHVlKCkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKCEvW3hhLWYuXS9pLnRlc3Qob3V0cHV0Lmxhc3QoKSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgIC8vIHRoZSBuYW1lIGFmdGVyIGRvdCB3b3VsZCBiZSBtYXBwZWQgYWJvdXQgaGVyZS5cbiAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHNlbGYuZW5kKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUoc2VsZi5wcm9wZXJ0eSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIltcIik7XG4gICAgICAgIHNlbGYucHJvcGVydHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiXVwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBvcCA9IHNlbGYub3BlcmF0b3I7XG4gICAgICAgIG91dHB1dC5wcmludChvcCk7XG4gICAgICAgIGlmICgvXlthLXpdL2kudGVzdChvcCkpXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VuYXJ5UG9zdGZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5wcmludChzZWxmLm9wZXJhdG9yKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmxlZnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChzZWxmLm9wZXJhdG9yKTtcbiAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCI8XCJcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCIhXCJcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5leHByZXNzaW9uLm9wZXJhdG9yID09IFwiLS1cIikge1xuICAgICAgICAgICAgLy8gc3BhY2UgaXMgbWFuZGF0b3J5IHRvIGF2b2lkIG91dHB1dHRpbmcgPCEtLVxuICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQuc3BlYy53aGF0d2cub3JnLyNjb21tZW50LXN5bnRheFxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZSBzcGFjZSBpcyBvcHRpb25hbCBkZXBlbmRpbmcgb24gXCJiZWF1dGlmeVwiXG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJpZ2h0LnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiP1wiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudC5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBsaXRlcmFscyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfQXJyYXksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGEgPSBzZWxmLmVsZW1lbnRzLCBsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPiAwKSBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihleHAsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBleHAucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmluYWwgZWxlbWVudCBpcyBhIGhvbGUsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBsb29rIGxpa2UgYSB0cmFpbGluZyBjb21tYSwgYnkgaW5zZXJ0aW5nIGFuIGFjdHVhbFxuICAgICAgICAgICAgICAgIC8vIHRyYWlsaW5nIGNvbW1hLlxuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW4gLSAxICYmIGV4cCBpbnN0YW5jZW9mIEFTVF9Ib2xlKVxuICAgICAgICAgICAgICAgICAgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsZW4gPiAwKSBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSl7XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHByb3AucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LnByaW50KFwie31cIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYua2V5O1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcInF1b3RlX2tleXNcIikpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoa2V5ICsgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBrZXkgPT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICB8fCAhb3V0cHV0Lm9wdGlvbihcImJlYXV0aWZ5XCIpXG4gICAgICAgICAgICAgICAgICAgICYmICtrZXkgKyBcIlwiID09IGtleSlcbiAgICAgICAgICAgICAgICAgICAmJiBwYXJzZUZsb2F0KGtleSkgPj0gMCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KG1ha2VfbnVtKGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKFJFU0VSVkVEX1dPUkRTKGtleSkgPyBvdXRwdXQub3B0aW9uKFwic2NyZXdfaWU4XCIpIDogaXNfaWRlbnRpZmllcl9zdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50X25hbWUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuY29sb24oKTtcbiAgICAgICAgc2VsZi52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3RTZXR0ZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcInNldFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYua2V5LnByaW50KG91dHB1dCk7XG4gICAgICAgIHNlbGYudmFsdWUuX2RvX3ByaW50KG91dHB1dCwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdEdldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZ2V0XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5rZXkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgc2VsZi52YWx1ZS5fZG9fcHJpbnQob3V0cHV0LCB0cnVlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3ltYm9sLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICB2YXIgZGVmID0gc2VsZi5kZWZpbml0aW9uKCk7XG4gICAgICAgIG91dHB1dC5wcmludF9uYW1lKGRlZiA/IGRlZi5tYW5nbGVkX25hbWUgfHwgZGVmLm5hbWUgOiBzZWxmLm5hbWUpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9VbmRlZmluZWQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcInZvaWQgMFwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfSG9sZSwgbm9vcCk7XG4gICAgREVGUFJJTlQoQVNUX0luZmluaXR5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCIxLzBcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX05hTiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiMC8wXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UaGlzLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ0aGlzXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N0cmluZywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLmdldFZhbHVlKCkpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9OdW1iZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShzZWxmLmdldFZhbHVlKCkpKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUmVnRXhwLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICB2YXIgc3RyID0gc2VsZi5nZXRWYWx1ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYXNjaWlfb25seVwiKSlcbiAgICAgICAgICAgIHN0ciA9IG91dHB1dC50b19hc2NpaShzdHIpO1xuICAgICAgICBvdXRwdXQucHJpbnQoc3RyKTtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiAvXmluLy50ZXN0KHAub3BlcmF0b3IpICYmIHAubGVmdCA9PT0gc2VsZilcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmb3JjZV9zdGF0ZW1lbnQoc3RhdCwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYnJhY2tldGl6ZVwiKSkge1xuICAgICAgICAgICAgaWYgKCFzdGF0IHx8IHN0YXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwie31cIik7XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIHN0YXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIGVsc2Ugb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RhdCB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIG91dHB1dC5mb3JjZV9zZW1pY29sb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdGF0LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgKHRoYXQgbWVhbnMgdGhlXG4gICAgLy8gaW5uZXJtb3N0IG5vZGUgaW4gdGhlIGN1cnJlbnQgb3V0cHV0KSBpcyBsZXhpY2FsbHkgdGhlIGZpcnN0IGluXG4gICAgLy8gYSBzdGF0ZW1lbnQuXG4gICAgZnVuY3Rpb24gZmlyc3RfaW5fc3RhdGVtZW50KG91dHB1dCkge1xuICAgICAgICB2YXIgYSA9IG91dHB1dC5zdGFjaygpLCBpID0gYS5sZW5ndGgsIG5vZGUgPSBhWy0taV0sIHAgPSBhWy0taV07XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50ICYmIHAuYm9keSA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgocCBpbnN0YW5jZW9mIEFTVF9TZXEgICAgICAgICAgICYmIHAuY2FyID09PSBub2RlICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUgJiYgIShwIGluc3RhbmNlb2YgQVNUX05ldykgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0RvdCAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9TdWIgICAgICAgICAgICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgICAmJiBwLmNvbmRpdGlvbiA9PT0gbm9kZSAgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAgICAgICAgJiYgcC5sZWZ0ID09PSBub2RlICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXggICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwO1xuICAgICAgICAgICAgICAgIHAgPSBhWy0taV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzZWxmIHNob3VsZCBiZSBBU1RfTmV3LiAgZGVjaWRlIGlmIHdlIHdhbnQgdG8gc2hvdyBwYXJlbnMgb3Igbm90LlxuICAgIGZ1bmN0aW9uIG5vX2NvbnN0cnVjdG9yX3BhcmVucyhzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYXJncy5sZW5ndGggPT0gMCAmJiAhb3V0cHV0Lm9wdGlvbihcImJlYXV0aWZ5XCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBiZXN0X29mKGEpIHtcbiAgICAgICAgdmFyIGJlc3QgPSBhWzBdLCBsZW4gPSBiZXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYVtpXS5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBiZXN0ID0gYVtpXTtcbiAgICAgICAgICAgICAgICBsZW4gPSBiZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9udW0obnVtKSB7XG4gICAgICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTApLCBhID0gWyBzdHIucmVwbGFjZSgvXjBcXC4vLCBcIi5cIikucmVwbGFjZSgnZSsnLCAnZScpIF0sIG07XG4gICAgICAgIGlmIChNYXRoLmZsb29yKG51bSkgPT09IG51bSkge1xuICAgICAgICAgICAgaWYgKG51bSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKFwiMHhcIiArIG51bS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgIFwiMFwiICsgbnVtLnRvU3RyaW5nKDgpKTsgLy8gc2FtZS5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKFwiLTB4XCIgKyAoLW51bSkudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCksIC8vIHByb2JhYmx5IHBvaW50bGVzc1xuICAgICAgICAgICAgICAgICAgICAgICBcIi0wXCIgKyAoLW51bSkudG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtID0gL14oLio/KSgwKykkLy5leGVjKG51bSkpKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG1bMV0gKyBcImVcIiArIG1bMl0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobSA9IC9eMD9cXC4oMCspKC4qKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgIGEucHVzaChtWzJdICsgXCJlLVwiICsgKG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgIHN0ci5zdWJzdHIoc3RyLmluZGV4T2YoXCIuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfYmxvY2soc3RtdCwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChzdG10IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiAtLS0tLVsgc291cmNlIG1hcCBnZW5lcmF0b3JzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gREVGTUFQKG5vZGV0eXBlLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgbm9kZXR5cGUuREVGTUVUSE9EKFwiYWRkX3NvdXJjZV9tYXBcIiwgZnVuY3Rpb24oc3RyZWFtKXtcbiAgICAgICAgICAgIGdlbmVyYXRvcih0aGlzLCBzdHJlYW0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gV2UgY291bGQgZWFzaWx5IGFkZCBpbmZvIGZvciBBTEwgbm9kZXMsIGJ1dCBpdCBzZWVtcyB0byBtZSB0aGF0XG4gICAgLy8gd291bGQgYmUgcXVpdGUgd2FzdGVmdWwsIGhlbmNlIHRoaXMgbm9vcCBpbiB0aGUgYmFzZSBjbGFzcy5cbiAgICBERUZNQVAoQVNUX05vZGUsIG5vb3ApO1xuXG4gICAgZnVuY3Rpb24gYmFzaWNfc291cmNlbWFwX2dlbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHNlbGYuc3RhcnQpO1xuICAgIH07XG5cbiAgICAvLyBYWFg6IEknbSBub3QgZXhhY3RseSBzdXJlIGlmIHdlIG5lZWQgaXQgZm9yIGFsbCBvZiB0aGVzZSBub2RlcyxcbiAgICAvLyBvciBpZiB3ZSBzaG91bGQgYWRkIGV2ZW4gbW9yZS5cblxuICAgIERFRk1BUChBU1RfRGlyZWN0aXZlLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0RlYnVnZ2VyLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N5bWJvbCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9KdW1wLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N0YXRlbWVudFdpdGhCb2R5LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIG5vb3ApOyAvLyBzaW5jZSB0aGUgbGFiZWwgc3ltYm9sIHdpbGwgbWFyayBpdFxuICAgIERFRk1BUChBU1RfTGFtYmRhLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N3aXRjaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9Td2l0Y2hCcmFuY2gsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfQmxvY2tTdGF0ZW1lbnQsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfVG9wbGV2ZWwsIG5vb3ApO1xuICAgIERFRk1BUChBU1RfTmV3LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1RyeSwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9DYXRjaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9GaW5hbGx5LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0RlZmluaXRpb25zLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0NvbnN0YW50LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX09iamVjdFByb3BlcnR5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5zdGFydCwgc2VsZi5rZXkpO1xuICAgIH0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBDb21wcmVzc29yKG9wdGlvbnMsIGZhbHNlX2J5X2RlZmF1bHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcHJlc3NvcikpXG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3NvcihvcHRpb25zLCBmYWxzZV9ieV9kZWZhdWx0KTtcbiAgICBUcmVlVHJhbnNmb3JtZXIuY2FsbCh0aGlzLCB0aGlzLmJlZm9yZSwgdGhpcy5hZnRlcik7XG4gICAgdGhpcy5vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzZXF1ZW5jZXMgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIHByb3BlcnRpZXMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgZGVhZF9jb2RlICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBkcm9wX2RlYnVnZ2VyIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIHVuc2FmZSAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW5zYWZlX2NvbXBzICA6IGZhbHNlLFxuICAgICAgICBjb25kaXRpb25hbHMgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGNvbXBhcmlzb25zICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgZXZhbHVhdGUgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBib29sZWFucyAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGxvb3BzICAgICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgdW51c2VkICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBob2lzdF9mdW5zICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGhvaXN0X3ZhcnMgICAgOiBmYWxzZSxcbiAgICAgICAgaWZfcmV0dXJuICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBqb2luX3ZhcnMgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGNhc2NhZGUgICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgc2lkZV9lZmZlY3RzICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBwdXJlX2dldHRlcnMgIDogZmFsc2UsXG4gICAgICAgIHB1cmVfZnVuY3MgICAgOiBudWxsLFxuICAgICAgICBuZWdhdGVfaWlmZSAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIHNjcmV3X2llOCAgICAgOiBmYWxzZSxcblxuICAgICAgICB3YXJuaW5ncyAgICAgIDogdHJ1ZSxcbiAgICAgICAgZ2xvYmFsX2RlZnMgICA6IHt9XG4gICAgfSwgdHJ1ZSk7XG59O1xuXG5Db21wcmVzc29yLnByb3RvdHlwZSA9IG5ldyBUcmVlVHJhbnNmb3JtZXI7XG5tZXJnZShDb21wcmVzc29yLnByb3RvdHlwZSwge1xuICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5KSB7IHJldHVybiB0aGlzLm9wdGlvbnNba2V5XSB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndhcm5pbmdzKVxuICAgICAgICAgICAgQVNUX05vZGUud2Fybi5hcHBseShBU1RfTm9kZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGJlZm9yZTogZnVuY3Rpb24obm9kZSwgZGVzY2VuZCwgaW5fbGlzdCkge1xuICAgICAgICBpZiAobm9kZS5fc3F1ZWV6ZWQpIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgLy9ub2RlLmRyb3BfdW51c2VkKHRoaXMpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaG9pc3RfZGVjbGFyYXRpb25zKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIG5vZGUgPSBub2RlLm9wdGltaXplKHRoaXMpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS5kcm9wX3VudXNlZCh0aGlzKTtcbiAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5fc3F1ZWV6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59KTtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICBmdW5jdGlvbiBPUFQobm9kZSwgb3B0aW1pemVyKSB7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwib3B0aW1pemVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZi5fb3B0aW1pemVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpbWl6ZXIoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBvcHQuX29wdGltaXplZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAob3B0ID09PSBzZWxmKSByZXR1cm4gb3B0O1xuICAgICAgICAgICAgcmV0dXJuIG9wdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBPUFQoQVNUX05vZGUsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImVxdWl2YWxlbnRfdG9cIiwgZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIC8vIFhYWDogdGhpcyBpcyBhIHJhdGhlciBleHBlbnNpdmUgd2F5IHRvIHRlc3QgdHdvIG5vZGUncyBlcXVpdmFsZW5jZTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbnRfdG9fc3RyaW5nKCkgPT0gbm9kZS5wcmludF90b19zdHJpbmcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1ha2Vfbm9kZShjdG9yLCBvcmlnLCBwcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzKSBwcm9wcyA9IHt9O1xuICAgICAgICBpZiAob3JpZykge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5zdGFydCkgcHJvcHMuc3RhcnQgPSBvcmlnLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5lbmQpIHByb3BzLmVuZCA9IG9yaWcuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcihwcm9wcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIHZhbCwgb3JpZykge1xuICAgICAgICAvLyBYWFg6IFdJUC5cbiAgICAgICAgLy8gaWYgKHZhbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm4gdmFsLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKG51bGwsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAvLyAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIHNjb3BlID0gY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfU2NvcGUpO1xuICAgICAgICAvLyAgICAgICAgIHZhciBkZWYgPSBzY29wZS5maW5kX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICAvLyAgICAgICAgIG5vZGUudGhlZGVmID0gZGVmO1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9KSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcmV0dXJuIHZhbC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgb3JpZywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoaXNOYU4odmFsKSA/IEFTVF9OYU4gOiBBU1RfTnVtYmVyLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUodmFsID8gQVNUX1RydWUgOiBBU1RfRmFsc2UsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdWxsLCBvcmlnKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9SZWdFeHAsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIkNhbid0IGhhbmRsZSBjb25zdGFudCBvZiB0eXBlOiB7dHlwZX1cIiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVvZiB2YWxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19zdGF0ZW1lbnRfYXJyYXkodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gW107XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkgcmV0dXJuIHRoaW5nLmJvZHk7XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSByZXR1cm4gWyB0aGluZyBdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRoaW5nIHRvIHN0YXRlbWVudCBhcnJheVwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfZW1wdHkodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keS5sZW5ndGggPT0gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb29wX2JvZHkoeCkge1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHJldHVybiB4O1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgeCBpbnN0YW5jZW9mIEFTVF9Gb3JJbiB8fCB4IGluc3RhbmNlb2YgQVNUX0RXTG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuICh4LmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgPyB4LmJvZHkgOiB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdGlnaHRlbl9ib2R5KHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIENIQU5HRUQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIENIQU5HRUQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJpZl9yZXR1cm5cIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzZXF1ZW5jZXNpemUoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJqb2luX3ZhcnNcIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChDSEFOR0VEKTtcblxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJuZWdhdGVfaWlmZVwiKSkge1xuICAgICAgICAgICAgbmVnYXRlX2lpZmVzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG5cbiAgICAgICAgZnVuY3Rpb24gZWxpbWluYXRlX3NwdXJpb3VzX2Jsb2NrcyhzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgc2Vlbl9kaXJzID0gW107XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXQuYm9keSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuX2RpcnMuaW5kZXhPZihzdGF0LnZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5fZGlycy5wdXNoKHN0YXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZV9pZl9yZXR1cm4oc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICAgICAgICAgIHZhciBpbl9sYW1iZGEgPSBzZWxmIGluc3RhbmNlb2YgQVNUX0xhbWJkYTtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIGxvb3A6IGZvciAodmFyIGkgPSBzdGF0ZW1lbnRzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAoaW5fbGFtYmRhICYmIHN0YXQgaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmICFzdGF0LnZhbHVlICYmIHJldC5sZW5ndGggPT0gMCk6XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlLCByZXQubGVuZ3RoIGlzIHByb2JhYmx5IGFsd2F5cyB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZHJvcCB1bnJlYWNoYWJsZSBjb2RlIGJlZm9yZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ZXAuICBuZXZlcnRoZWxlc3MsIGl0J3MgZ29vZCB0byBjaGVjay5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgIGNhc2Ugc3RhdCBpbnN0YW5jZW9mIEFTVF9JZjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuYm9keSBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV0dHkgc2lsbHkgY2FzZSwgYnV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm47IHJldHVybjsgPT0+IGZvbygpOyByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChpbl9sYW1iZGEgJiYgcmV0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAocmV0WzBdIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhcmV0WzBdLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhc3RhdC5ib2R5LnZhbHVlICYmICFzdGF0LmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc3RhdC5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc3RhdC5jb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuIHg7IHJldHVybiB5OyA9PT4gcmV0dXJuIGZvbygpID8geCA6IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0WzBdIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiBzdGF0LmJvZHkudmFsdWUgJiYgcmV0WzBdLnZhbHVlICYmICFzdGF0LmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gcmV0WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFswXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgWyByZXR1cm4gOyBdID09PiByZXR1cm4gZm9vKCkgPyB4IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXQubGVuZ3RoID09IDAgfHwgcmV0WzBdIGluc3RhbmNlb2YgQVNUX1JldHVybikgJiYgc3RhdC5ib2R5LnZhbHVlICYmICFzdGF0LmFsdGVybmF0aXZlICYmIGluX2xhbWJkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5hbHRlcm5hdGl2ZSA9IHJldFswXSB8fCBtYWtlX25vZGUoQVNUX1JldHVybiwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHN0YXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0WzBdID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybjsgWyBlbHNlIHguLi4gXTsgeS4uLiA9PT4gaWYgKCFmb28oKSkgeyB4Li4uOyB5Li4uIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdC5ib2R5LnZhbHVlICYmIGluX2xhbWJkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5jb25kaXRpb24gPSBzdGF0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5hbHRlcm5hdGl2ZSkuY29uY2F0KHJldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbIHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0Lmxlbmd0aCA9PSAxICYmIGluX2xhbWJkYSAmJiByZXRbMF0gaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCFzdGF0LmFsdGVybmF0aXZlIHx8IHN0YXQuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKG1ha2Vfbm9kZShBU1RfUmV0dXJuLCByZXRbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCByZXRbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5hbHRlcm5hdGl2ZSkuY29uY2F0KHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnVuc2hpZnQoc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYiA9IGFib3J0cyhzdGF0LmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gYWIgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgPyBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChhYi5sYWJlbCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWIgJiYgKChhYiBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIWFiLnZhbHVlICYmIGluX2xhbWJkYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQ29udGludWUgJiYgc2VsZiA9PT0gbG9vcF9ib2R5KGxjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGFiIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxjdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCAmJiBzZWxmID09PSBsY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGFiLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBhYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYXNfc3RhdGVtZW50X2FycmF5KHN0YXQuYm9keSkuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gc3RhdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHJldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gWyBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYiA9IGFib3J0cyhzdGF0LmFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxjdCA9IGFiIGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sID8gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoYWIubGFiZWwpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFiICYmICgoYWIgaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmICFhYi52YWx1ZSAmJiBpbl9sYW1iZGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGFiIGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlICYmIHNlbGYgPT09IGxvb3BfYm9keShsY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChhYiBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiBsY3QgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgJiYgc2VsZiA9PT0gbGN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShhYi5sYWJlbC50aGVkZWYucmVmZXJlbmNlcywgYWIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5ib2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYXNfc3RhdGVtZW50X2FycmF5KHN0YXQuYm9keSkuY29uY2F0KHJldClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5hbHRlcm5hdGl2ZSA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHN0YXQuYWx0ZXJuYXRpdmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5hbHRlcm5hdGl2ZSkuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFsgc3RhdC50cmFuc2Zvcm0oY29tcHJlc3NvcikgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBlbGltaW5hdGVfZGVhZF9jb2RlKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBoYXNfcXVpdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG9yaWcgPSBzdGF0ZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gY29tcHJlc3Nvci5zZWxmKCk7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzID0gc3RhdGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKGhhc19xdWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzdGF0LCBhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Mb29wQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxjdCA9IGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHN0YXQubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzdGF0IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxjdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBsb29wX2JvZHkobGN0KSA9PT0gc2VsZikgfHwgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQ29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBsb29wX2JvZHkobGN0KSA9PT0gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoc3RhdC5sYWJlbC50aGVkZWYucmVmZXJlbmNlcywgc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0cyhzdGF0KSkgaGFzX3F1aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIENIQU5HRUQgPSBzdGF0ZW1lbnRzLmxlbmd0aCAhPSBvcmlnO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2VxdWVuY2VzaXplKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICAgICAgdmFyIHNlcSA9IFtdLCByZXQgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1c2hfc2VxKCkge1xuICAgICAgICAgICAgICAgIHNlcSA9IEFTVF9TZXEuZnJvbV9hcnJheShzZXEpO1xuICAgICAgICAgICAgICAgIGlmIChzZXEpIHJldC5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZXEsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogc2VxXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHNlcSA9IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHNlcS5wdXNoKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgZWxzZSBwdXNoX3NlcSgpLCByZXQucHVzaChzdGF0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHVzaF9zZXEoKTtcbiAgICAgICAgICAgIHJldCA9IHNlcXVlbmNlc2l6ZV8yKHJldCwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBDSEFOR0VEID0gcmV0Lmxlbmd0aCAhPSBzdGF0ZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc2VxdWVuY2VzaXplXzIoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgZnVuY3Rpb24gY29uc19zZXEocmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBwcmV2LmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQuYWRkKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gQVNUX1NlcS5jb25zKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5ib2R5LndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBub2RlLm9wZXJhdG9yID09IFwiaW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG9wZXJhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5pbml0ICYmICEoc3RhdC5pbml0IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmluaXQgPSBjb25zX3NlcShzdGF0LmluaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc3RhdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IHByZXYuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggIT09IG9wZXJhKSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmNvbmRpdGlvbiA9IGNvbnNfc2VxKHN0YXQuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1dpdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGNvbnNfc2VxKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9FeGl0ICYmIHN0YXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQudmFsdWUgPSBjb25zX3NlcShzdGF0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQudmFsdWUgPSBjb25zX3NlcShtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc3RhdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmV4cHJlc3Npb24gPSBjb25zX3NlcShzdGF0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCA/IHN0YXQgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGpvaW5fY29uc2VjdXRpdmVfdmFycyhzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgcHJldiAmJiBwcmV2LlRZUEUgPT0gc3RhdC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYuZGVmaW5pdGlvbnMgPSBwcmV2LmRlZmluaXRpb25zLmNvbmNhdChzdGF0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgcHJldiBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICYmICghc3RhdC5pbml0IHx8IHN0YXQuaW5pdC5UWVBFID09IHByZXYuVFlQRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdC5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuaW5pdC5kZWZpbml0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmluaXQgPSBwcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBuZWdhdGVfaWlmZXMoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSAoZnVuY3Rpb24gdHJhbnNmb3JtKHRoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpbmcudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBub2RlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0cmFuc2Zvcm0obm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jYXIgPSB0cmFuc2Zvcm0obm9kZS5jYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByID0gdHJhbnNmb3JtKG5vZGUuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgIT09IG5vZGUuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBoYXMgYmVlbiBuZWdhdGVkLCByZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbmRpdGlvbiA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gbm9kZS5jb25zZXF1ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gbm9kZS5hbHRlcm5hdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHN0YXQsIHRhcmdldCkge1xuICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnJlYWNoYWJsZSBjb2RlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzdGF0LnN0YXJ0KTtcbiAgICAgICAgc3RhdC53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEZWNsYXJhdGlvbnMgaW4gdW5yZWFjaGFibGUgY29kZSEgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlX2luaXRpYWxpemVycygpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgLyogLS0tLS1bIGJvb2xlYW4vbmVnYXRpb24gaGVscGVycyBdLS0tLS0gKi9cblxuICAgIC8vIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gZXhwcmVzc2lvbiBoYXMgYSBib29sZWFuIHJlc3VsdCB0eXBlXG4gICAgKGZ1bmN0aW9uIChkZWYpe1xuICAgICAgICB2YXIgdW5hcnlfYm9vbCA9IFsgXCIhXCIsIFwiZGVsZXRlXCIgXTtcbiAgICAgICAgdmFyIGJpbmFyeV9ib29sID0gWyBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcIj09XCIsIFwiIT1cIiwgXCI9PT1cIiwgXCIhPT1cIiwgXCI8XCIsIFwiPD1cIiwgXCI+PVwiLCBcIj5cIiBdO1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXIodGhpcy5vcGVyYXRvciwgdW5hcnlfYm9vbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0JpbmFyeSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXIodGhpcy5vcGVyYXRvciwgYmluYXJ5X2Jvb2wpIHx8XG4gICAgICAgICAgICAgICAgKCAodGhpcy5vcGVyYXRvciA9PSBcIiYmXCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcInx8XCIpICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaXNfYm9vbGVhbigpICYmIHRoaXMucmlnaHQuaXNfYm9vbGVhbigpICk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19ib29sZWFuKCkgJiYgdGhpcy5hbHRlcm5hdGl2ZS5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09IFwiPVwiICYmIHRoaXMucmlnaHQuaXNfYm9vbGVhbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TZXEsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZHIuaXNfYm9vbGVhbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9UcnVlLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9GYWxzZSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiaXNfYm9vbGVhblwiLCBmdW5jKTtcbiAgICB9KTtcblxuICAgIC8vIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIGlmIGFuIGV4cHJlc3Npb24gaGFzIGEgc3RyaW5nIHJlc3VsdCB0eXBlXG4gICAgKGZ1bmN0aW9uIChkZWYpe1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9TdHJpbmcsIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09IFwiK1wiICYmXG4gICAgICAgICAgICAgICAgKHRoaXMubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikgfHwgdGhpcy5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9wZXJhdG9yID09IFwiPVwiIHx8IHRoaXMub3BlcmF0b3IgPT0gXCIrPVwiKSAmJiB0aGlzLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU2VxLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNkci5pc19zdHJpbmcoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpICYmIHRoaXMuYWx0ZXJuYXRpdmUuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmV4cHJlc3Npb24ubmFtZSA9PSBcIlN0cmluZ1wiXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5leHByZXNzaW9uLnVuZGVjbGFyZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiaXNfc3RyaW5nXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYmVzdF9vZihhc3QxLCBhc3QyKSB7XG4gICAgICAgIHJldHVybiBhc3QxLnByaW50X3RvX3N0cmluZygpLmxlbmd0aCA+XG4gICAgICAgICAgICBhc3QyLnByaW50X3RvX3N0cmluZygpLmxlbmd0aFxuICAgICAgICAgICAgPyBhc3QyIDogYXN0MTtcbiAgICB9O1xuXG4gICAgLy8gbWV0aG9kcyB0byBldmFsdWF0ZSBhIGNvbnN0YW50IGV4cHJlc3Npb25cbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIC8vIFRoZSBldmFsdWF0ZSBtZXRob2QgcmV0dXJucyBhbiBhcnJheSB3aXRoIG9uZSBvciB0d29cbiAgICAgICAgLy8gZWxlbWVudHMuICBJZiB0aGUgbm9kZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgcmVkdWNlZCB0byBhXG4gICAgICAgIC8vIGNvbnN0YW50LCB0aGVuIHRoZSBzZWNvbmQgZWxlbWVudCB0ZWxscyB1cyB0aGUgdmFsdWU7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgbWlzc2luZy4gIFRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgIC8vIG9mIHRoZSBhcnJheSBpcyBhbHdheXMgYW4gQVNUX05vZGUgZGVzY2VuZGFudDsgaWZcbiAgICAgICAgLy8gZXZhbHVhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBpdCdzIGEgbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gICAgICAgIC8vIGNvbnN0YW50OyBvdGhlcndpc2UgaXQncyB0aGUgb3JpZ2luYWwgb3IgYSByZXBsYWNlbWVudCBub2RlLlxuICAgICAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJldmFsdWF0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKSkgcmV0dXJuIFsgdGhpcyBdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5fZXZhbChjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBiZXN0X29mKG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIHZhbCwgdGhpcyksIHRoaXMpLCB2YWwgXTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggIT09IGRlZikgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgdGhpcyBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiQ2Fubm90IGV2YWx1YXRlIGEgc3RhdGVtZW50IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB0aGlzLnN0YXJ0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gWFhYOiBBU1RfRnVuY3Rpb24gaW5oZXJpdHMgZnJvbSBBU1RfU2NvcGUsIHdoaWNoIGl0c2VsZlxuICAgICAgICAgICAgLy8gaW5oZXJpdHMgZnJvbSBBU1RfU3RhdGVtZW50OyBob3dldmVyLCBhbiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGlzbid0IHJlYWxseSBhIHN0YXRlbWVudC4gIFRoaXMgY291bGQgYnl0ZSBpbiBvdGhlclxuICAgICAgICAgICAgLy8gcGxhY2VzIHRvby4gOi0oIFdpc2ggSlMgaGFkIG11bHRpcGxlIGluaGVyaXRhbmNlLlxuICAgICAgICAgICAgdGhyb3cgZGVmO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXYobm9kZSwgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21wcmVzc29yIG11c3QgYmUgcGFzc2VkXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5fZXZhbChjb21wcmVzc29yKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmKEFTVF9Ob2RlLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhyb3cgZGVmOyAgICAgICAgICAvLyBub3QgY29uc3RhbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uc3RhbnQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiIVwiOiByZXR1cm4gIWV2KGUsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gd291bGQgYmUgZXZhbHVhdGVkIHRvIGFuIGFycmF5IGFuZCBzbyB0eXBlb2Ygd291bGRcbiAgICAgICAgICAgICAgICAvLyBpbmNvcnJlY3RseSByZXR1cm4gJ29iamVjdCcuIEhlbmNlIG1ha2luZyBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikgcmV0dXJuIHR5cGVvZiBmdW5jdGlvbigpe307XG5cbiAgICAgICAgICAgICAgICBlID0gZXYoZSwgY29tcHJlc3Nvcik7XG5cbiAgICAgICAgICAgICAgICAvLyB0eXBlb2YgPFJlZ0V4cD4gcmV0dXJucyBcIm9iamVjdFwiIG9yIFwiZnVuY3Rpb25cIiBvbiBkaWZmZXJlbnQgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLy8gc28gY2Fubm90IGV2YWx1YXRlIHJlbGlhYmx5XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZWdFeHApIHRocm93IGRlZjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgY2FzZSBcInZvaWRcIjogcmV0dXJuIHZvaWQgZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgIGNhc2UgXCJ+XCI6IHJldHVybiB+ZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgZSA9IGV2KGUsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmIChlID09PSAwKSB0aHJvdyBkZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1lO1xuICAgICAgICAgICAgICBjYXNlIFwiK1wiOiByZXR1cm4gK2V2KGUsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZGVmO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGMpe1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQsIHJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiJiZcIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICYmICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwifHxcIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIHx8ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwifFwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIHwgICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiJlwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICYgICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiXlwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIF4gICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiK1wiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICsgICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiKlwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICogICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiL1wiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIC8gICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiJVwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICUgICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiLVwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIC0gICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPDxcIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIDw8ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPj5cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID4+ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPj4+XCIgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID4+PiAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID09ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPT09XCIgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID09PSAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiIT1cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICE9ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiIT09XCIgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpICE9PSAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIDwgICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPD1cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIDw9ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPlwiICAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID4gICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiPj1cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpID49ICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiaW5cIiAgICAgICAgIDogcmV0dXJuIGV2KGxlZnQsIGMpIGluICAgICAgICAgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgICBjYXNlIFwiaW5zdGFuY2VvZlwiIDogcmV0dXJuIGV2KGxlZnQsIGMpIGluc3RhbmNlb2YgZXYocmlnaHQsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZGVmO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gZXYodGhpcy5jb25kaXRpb24sIGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgPyBldih0aGlzLmNvbnNlcXVlbnQsIGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgOiBldih0aGlzLmFsdGVybmF0aXZlLCBjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZCAmJiBkLmNvbnN0YW50ICYmIGQuaW5pdCkgcmV0dXJuIGV2KGQuaW5pdCwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcIl9ldmFsXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLy8gbWV0aG9kIHRvIG5lZ2F0ZSBhbiBleHByZXNzaW9uXG4gICAgKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgIGZ1bmN0aW9uIGJhc2ljX25lZ2F0aW9uKGV4cCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIGV4cCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBuZWdhdGUgYSBzdGF0ZW1lbnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGJhc2ljX25lZ2F0aW9uKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09IFwiIVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIHNlbGYuY2RyID0gc2VsZi5jZHIubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgc2VsZi5jb25zZXF1ZW50ID0gc2VsZi5jb25zZXF1ZW50Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGJhc2ljX25lZ2F0aW9uKHRoaXMpLCBzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5jbG9uZSgpLCBvcCA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfY29tcHNcIikpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIj5cIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPj1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIj49XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI8XCIgIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiPlwiICA6IHNlbGYub3BlcmF0b3IgPSBcIjw9XCIgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiIT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPVwiIDogc2VsZi5vcGVyYXRvciA9IFwiPT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PT1cIjogc2VsZi5vcGVyYXRvciA9IFwiIT09XCI7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiIT09XCI6IHNlbGYub3BlcmF0b3IgPSBcIj09PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwifHxcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihiYXNpY19uZWdhdGlvbih0aGlzKSwgc2VsZik7XG4gICAgICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBcIiYmXCI7XG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5sZWZ0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYmFzaWNfbmVnYXRpb24odGhpcyksIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2ljX25lZ2F0aW9uKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJuZWdhdGVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGRldGVybWluZSBpZiBleHByZXNzaW9uIGhhcyBzaWRlIGVmZmVjdHNcbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZGVmKEFTVF9Ob2RlLCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIHRydWUgfSk7XG5cbiAgICAgICAgZGVmKEFTVF9FbXB0eVN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9UaGlzLCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuXG4gICAgICAgIGRlZihBU1RfQ2FsbCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICB2YXIgcHVyZSA9IGNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9mdW5jc1wiKTtcbiAgICAgICAgICAgIGlmICghcHVyZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcHVyZS5pbmRleE9mKHRoaXMuZXhwcmVzc2lvbi5wcmludF90b19zdHJpbmcoKSkgPCAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWYoQVNUX0Jsb2NrLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmJvZHkubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5W2ldLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWYoQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0RlZnVuLCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gZmFsc2UgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMucmlnaHQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXNzaWduLCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmNvbnNlcXVlbnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuYWx0ZXJuYXRpdmUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfVW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMub3BlcmF0b3IgPT0gXCIrK1wiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PSBcIi0tXCJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX09iamVjdCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX09iamVjdFByb3BlcnR5LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0FycmF5LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Eb3QsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcInB1cmVfZ2V0dGVyc1wiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1N1YiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMucHJvcGVydHkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gIWNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TZXEsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FyLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmNkci5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJoYXNfc2lkZV9lZmZlY3RzXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLy8gdGVsbCBtZSBpZiBhIHN0YXRlbWVudCBhYm9ydHNcbiAgICBmdW5jdGlvbiBhYm9ydHModGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHRoaW5nLmFib3J0cygpO1xuICAgIH07XG4gICAgKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgIGRlZihBU1RfU3RhdGVtZW50LCBmdW5jdGlvbigpeyByZXR1cm4gbnVsbCB9KTtcbiAgICAgICAgZGVmKEFTVF9KdW1wLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpcyB9KTtcbiAgICAgICAgZnVuY3Rpb24gYmxvY2tfYWJvcnRzKCl7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuYm9keS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbiA+IDAgJiYgYWJvcnRzKHRoaXMuYm9keVtuIC0gMV0pO1xuICAgICAgICB9O1xuICAgICAgICBkZWYoQVNUX0Jsb2NrU3RhdGVtZW50LCBibG9ja19hYm9ydHMpO1xuICAgICAgICBkZWYoQVNUX1N3aXRjaEJyYW5jaCwgYmxvY2tfYWJvcnRzKTtcbiAgICAgICAgZGVmKEFTVF9JZiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsdGVybmF0aXZlICYmIGFib3J0cyh0aGlzLmJvZHkpICYmIGFib3J0cyh0aGlzLmFsdGVybmF0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiYWJvcnRzXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIG9wdGltaXplcnMgXS0tLS0tICovXG5cbiAgICBPUFQoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLnNjb3BlLmhhc19kaXJlY3RpdmUoc2VsZi52YWx1ZSkgIT09IHNlbGYuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRGVidWdnZXIsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkcm9wX2RlYnVnZ2VyXCIpKVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHNlbGYuYm9keS5sYWJlbCkgPT09IHNlbGYuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmxhYmVsLnJlZmVyZW5jZXMubGVuZ3RoID09IDAgPyBzZWxmLmJvZHkgOiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9CbG9jaywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmLmJvZHkgPSB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICAgICAgc3dpdGNoIChzZWxmLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gc2VsZi5ib2R5WzBdO1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX1Njb3BlLkRFRk1FVEhPRChcImRyb3BfdW51c2VkXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKVxuICAgICAgICAgICAgJiYgIShzZWxmIGluc3RhbmNlb2YgQVNUX1RvcGxldmVsKVxuICAgICAgICAgICAgJiYgIXNlbGYudXNlc19ldmFsXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGluX3VzZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxpemF0aW9ucyA9IG5ldyBEaWN0aW9uYXJ5KCk7XG4gICAgICAgICAgICAvLyBwYXNzIDE6IGZpbmQgb3V0IHdoaWNoIHN5bWJvbHMgYXJlIGRpcmVjdGx5IHVzZWQgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgc2NvcGUgKG5vdCBpbiBuZXN0ZWQgc2NvcGVzKS5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25zLmFkZChub2RlLm5hbWUubmFtZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uJ3QgZ28gaW4gbmVzdGVkIHNjb3Blc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zICYmIHNjb3BlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9ucy5hZGQoZGVmLm5hbWUubmFtZSwgZGVmLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF91bmlxKGluX3VzZSwgbm9kZS5kZWZpbml0aW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi53YWxrKHR3KTtcbiAgICAgICAgICAgIC8vIHBhc3MgMjogZm9yIGV2ZXJ5IHVzZWQgc3ltYm9sIHdlIG5lZWQgdG8gd2FsayBpdHNcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uIGNvZGUgdG8gZmlndXJlIG91dCBpZiBpdCB1c2VzIG90aGVyXG4gICAgICAgICAgICAvLyBzeW1ib2xzICh0aGF0IG1heSBub3QgYmUgaW5fdXNlKS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5fdXNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5fdXNlW2ldLm9yaWcuZm9yRWFjaChmdW5jdGlvbihkZWNsKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWNsYXJlZCBnbG9iYWxzIHdpbGwgYmUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gaW5pdGlhbGl6YXRpb25zLmdldChkZWNsLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdCkgaW5pdC5mb3JFYWNoKGZ1bmN0aW9uKGluaXQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfdW5pcShpbl91c2UsIG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGFzcyAzOiB3ZSBzaG91bGQgZHJvcCBkZWNsYXJhdGlvbnMgbm90IGluX3VzZVxuICAgICAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiZWZvcmUobm9kZSwgZGVzY2VuZCwgaW5fbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgIShub2RlIGluc3RhbmNlb2YgQVNUX0FjY2Vzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5vZGUuYXJnbmFtZXMsIGkgPSBhLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bS51bnJlZmVyZW5jZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyB1bnVzZWQgZnVuY3Rpb24gYXJndW1lbnQge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogc3ltLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIDogc3ltLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIDogc3ltLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogc3ltLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biAmJiBub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lbWJlcihub2RlLm5hbWUuZGVmaW5pdGlvbigpLCBpbl91c2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiRHJvcHBpbmcgdW51c2VkIGZ1bmN0aW9uIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogbm9kZS5uYW1lLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgOiBub2RlLm5hbWUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA6IG5vZGUubmFtZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogbm9kZS5uYW1lLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zICYmICEodHQucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfRm9ySW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gbm9kZS5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyKGRlZi5uYW1lLmRlZmluaXRpb24oKSwgaW5fdXNlKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgOiBkZWYubmFtZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIDogZGVmLm5hbWUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA6IGRlZi5uYW1lLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCAgOiBkZWYubmFtZS5zdGFydC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUgJiYgZGVmLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLl91bnVzZWRfc2lkZV9lZmZlY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiU2lkZSBlZmZlY3RzIGluIGluaXRpYWxpemF0aW9uIG9mIHVudXNlZCB2YXJpYWJsZSB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiRHJvcHBpbmcgdW51c2VkIHZhcmlhYmxlIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSB1bmluaXRpYWxpemVkIG5hbWVzIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gbWVyZ2VTb3J0KGRlZiwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhLnZhbHVlICYmIGIudmFsdWUpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIudmFsdWUgJiYgYS52YWx1ZSkgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB1bnVzZWQgbmFtZXMgd2hvc2UgaW5pdGlhbGl6YXRpb24gaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaWRlIGVmZmVjdHMsIHdlIGNhbiBjYXNjYWRlIHRoZSBpbml0LiBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBuZXh0IG9uZSwgb3IgbmV4dCBzdGF0ZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZV9lZmZlY3RzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBkZWZbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguX3VudXNlZF9zaWRlX2VmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgudmFsdWUgPSBBU1RfU2VxLmZyb21fYXJyYXkoc2lkZV9lZmZlY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZV9lZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFsgbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEFTVF9TZXEuZnJvbV9hcnJheShzaWRlX2VmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYubGVuZ3RoID09IDAgJiYgIXNpZGVfZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZV9lZmZlY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucyA9IGRlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMuYm9keS51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBzaWRlX2VmZmVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluaXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbWJpbmF0aW9uIG9mIHVudXNlZCBuYW1lICsgc2lkZSBlZmZlY3QgbGVhZHMgdG86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzQ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCdzIGFuIGludmFsaWQgQVNULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZpeCBpdCBhdCB0aGlzIHN0YWdlIGJ5IG1vdmluZyB0aGUgYHZhcmAgb3V0c2lkZSB0aGUgYGZvcmAuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG5vZGUuaW5pdC5ib2R5LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluaXQgPSBub2RlLmluaXQuYm9keS5zbGljZSgtMSlbMF0uYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5fbGlzdCA/IE1BUC5zcGxpY2UoYm9keSkgOiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiBub2RlICE9PSBzZWxmKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgQVNUX1Njb3BlLkRFRk1FVEhPRChcImhvaXN0X2RlY2xhcmF0aW9uc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIGhvaXN0X2Z1bnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X2Z1bnNcIik7XG4gICAgICAgIHZhciBob2lzdF92YXJzID0gY29tcHJlc3Nvci5vcHRpb24oXCJob2lzdF92YXJzXCIpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChob2lzdF9mdW5zIHx8IGhvaXN0X3ZhcnMpIHtcbiAgICAgICAgICAgIHZhciBkaXJzID0gW107XG4gICAgICAgICAgICB2YXIgaG9pc3RlZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhcnMgPSBuZXcgRGljdGlvbmFyeSgpLCB2YXJzX2ZvdW5kID0gMCwgdmFyX2RlY2wgPSAwO1xuICAgICAgICAgICAgLy8gbGV0J3MgY291bnQgdmFyX2RlY2wgZmlyc3QsIHdlIHNlZW0gdG8gd2FzdGUgYSBsb3Qgb2ZcbiAgICAgICAgICAgIC8vIHNwYWNlIGlmIHdlIGhvaXN0IGB2YXJgIHdoZW4gdGhlcmUncyBvbmx5IG9uZS5cbiAgICAgICAgICAgIHNlbGYud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiBub2RlICE9PSBzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgKyt2YXJfZGVjbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaG9pc3RfdmFycyA9IGhvaXN0X3ZhcnMgJiYgdmFyX2RlY2wgPiAxO1xuICAgICAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiZWZvcmUobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuICYmIGhvaXN0X2Z1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGhvaXN0X3ZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQoZGVmLm5hbWUubmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt2YXJzX2ZvdW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXEgPSBub2RlLnRvX2Fzc2lnbm1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0dC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Gb3JJbiAmJiBwLmluaXQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSA9PSBudWxsKSByZXR1cm4gbm9kZS5kZWZpbml0aW9uc1swXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Gb3IgJiYgcC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VxKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7IC8vIHRvIGF2b2lkIGRlc2NlbmRpbmcgaW4gbmVzdGVkIHNjb3Blc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlbGYgPSBzZWxmLnRyYW5zZm9ybSh0dCk7XG4gICAgICAgICAgICBpZiAodmFyc19mb3VuZCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IG9ubHkgdmFycyB3aGljaCBkb24ndCBzaG93IHVwIGluIHNlbGYncyBhcmd1bWVudHMgbGlzdFxuICAgICAgICAgICAgICAgIHZhciBkZWZzID0gW107XG4gICAgICAgICAgICAgICAgdmFycy5lYWNoKGZ1bmN0aW9uKGRlZiwgbmFtZSl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZmluZF9pZihmdW5jdGlvbih4KXsgcmV0dXJuIHgubmFtZSA9PSBkZWYubmFtZS5uYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnbmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJzLmRlbChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IGRlZi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQobmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIG1lcmdlIGluIGFzc2lnbm1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5ib2R5Lmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmJvZHlbaV0uYm9keSwgc3ltLCBhc3NpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGV4cHIub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSA9IGV4cHIubGVmdCkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHZhcnMuaGFzKHN5bS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBleHByLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoZGVmcywgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGFzc2lnbiA9IGV4cHIuY2FyKSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXNzaWduLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChzeW0gPSBhc3NpZ24ubGVmdCkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHZhcnMuaGFzKHN5bS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBhc3NpZ24ucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShkZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5W2ldLmJvZHkgPSBleHByLmNkcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFsgaSwgMSBdLmNvbmNhdChzZWxmLmJvZHlbaV0uYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZS5hcHBseShzZWxmLmJvZHksIHRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZzID0gbWFrZV9ub2RlKEFTVF9WYXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBkZWZzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBob2lzdGVkLnB1c2goZGVmcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuYm9keSA9IGRpcnMuY29uY2F0KGhvaXN0ZWQsIHNlbGYuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmJvZHkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHNpZGUtZWZmZWN0LWZyZWUgc3RhdGVtZW50IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0RXTG9vcCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBjb25kID0gc2VsZi5jb25kaXRpb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gY29uZFswXTtcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKGNvbmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvbmRbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5ib2R5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfV2hpbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaWZfYnJlYWtfaW5fbG9vcChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRyb3BfaXQocmVzdCkge1xuICAgICAgICAgICAgcmVzdCA9IGFzX3N0YXRlbWVudF9hcnJheShyZXN0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmJvZHkuYm9keSA9IHJlc3QuY29uY2F0KHNlbGYuYm9keS5ib2R5LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcmVzdFxuICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ID8gc2VsZi5ib2R5LmJvZHlbMF0gOiBzZWxmLmJvZHk7XG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgaWYgKGZpcnN0LmJvZHkgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAmJiBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChmaXJzdC5ib2R5LmxhYmVsKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZpcnN0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3NvciksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gZmlyc3QuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJvcF9pdChmaXJzdC5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaXJzdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9CcmVha1xuICAgICAgICAgICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoZmlyc3QuYWx0ZXJuYXRpdmUubGFiZWwpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmlyc3QuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGZpcnN0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJvcF9pdChmaXJzdC5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBPUFQoQVNUX1doaWxlLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIHNlbGYgPSBBU1RfRFdMb29wLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9XaGlsZSkge1xuICAgICAgICAgICAgaWZfYnJlYWtfaW5fbG9vcChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0Zvciwgc2VsZiwgc2VsZikudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCkge1xuICAgICAgICAgICAgY29uZCA9IGNvbmQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGNvbmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKGNvbmQpIHtcbiAgICAgICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEgJiYgIWNvbmRbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzZWxmLmluaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmluaXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmluaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWZfYnJlYWtfaW5fbG9vcChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0lmLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIC8vIGlmIGNvbmRpdGlvbiBjYW4gYmUgc3RhdGljYWxseSBkZXRlcm1pbmVkLCB3YXJuIGFuZCBkcm9wXG4gICAgICAgIC8vIG9uZSBvZiB0aGUgYmxvY2tzLiAgbm90ZSwgc3RhdGljYWxseSBkZXRlcm1pbmVkIGltcGxpZXNcbiAgICAgICAgLy8g4oCcaGFzIG5vIHNpZGUgZWZmZWN0c+KAnTsgYWxzbyBpdCBkb2Vzbid0IHdvcmsgZm9yIGNhc2VzIGxpa2VcbiAgICAgICAgLy8gYHggJiYgdHJ1ZWAsIHRob3VnaCBpdCBwcm9iYWJseSBzaG91bGQuXG4gICAgICAgIHZhciBjb25kID0gc2VsZi5jb25kaXRpb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gY29uZFswXTtcbiAgICAgICAgaWYgKGNvbmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvbmRbMV0pIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuY29uZGl0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmFsdGVybmF0aXZlLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc2VsZi5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYSB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLmNvbmRpdGlvbi5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmJvZHksIGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgYS5wdXNoKHNlbGYuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBhIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2VtcHR5KHNlbGYuYWx0ZXJuYXRpdmUpKSBzZWxmLmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgdmFyIG5lZ2F0ZWQgPSBzZWxmLmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHZhciBuZWdhdGVkX2lzX2Jlc3QgPSBiZXN0X29mKHNlbGYuY29uZGl0aW9uLCBuZWdhdGVkKSA9PT0gbmVnYXRlZDtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUgJiYgbmVnYXRlZF9pc19iZXN0KSB7XG4gICAgICAgICAgICBuZWdhdGVkX2lzX2Jlc3QgPSBmYWxzZTsgLy8gYmVjYXVzZSB3ZSBhbHJlYWR5IGRvIHRoZSBzd2l0Y2ggaGVyZS5cbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbmVnYXRlZDtcbiAgICAgICAgICAgIHZhciB0bXAgPSBzZWxmLmJvZHk7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmFsdGVybmF0aXZlIHx8IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZW1wdHkoc2VsZi5ib2R5KSAmJiBpc19lbXB0eShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuY29uZGl0aW9uXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogc2VsZi5ib2R5LmJvZHksXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogc2VsZi5hbHRlcm5hdGl2ZS5ib2R5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkgJiYgc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgaWYgKG5lZ2F0ZWRfaXNfYmVzdCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmVnYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmJvZHkuYm9keVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmJvZHkuYm9keVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudFxuICAgICAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYWx0ZXJuYXRpdmUuYm9keVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9FeGl0XG4gICAgICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0V4aXRcbiAgICAgICAgICAgICYmIHNlbGYuYm9keS5UWVBFID09IHNlbGYuYWx0ZXJuYXRpdmUuVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShzZWxmLmJvZHkuQ1RPUiwgc2VsZiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogc2VsZi5ib2R5LnZhbHVlIHx8IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmLmJvZHkpLm9wdGltaXplKGNvbXByZXNzb3IpLFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IHNlbGYuYWx0ZXJuYXRpdmUudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYuYWx0ZXJuYXRpdmUpLm9wdGltaXplKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0lmXG4gICAgICAgICAgICAmJiAhc2VsZi5ib2R5LmFsdGVybmF0aXZlXG4gICAgICAgICAgICAmJiAhc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmJvZHkuY29uZGl0aW9uXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRzKHNlbGYuYm9keSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsdCA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogWyBzZWxmLCBhbHQgXVxuICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRzKHNlbGYuYWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHNlbGYuYm9keTtcbiAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG5lZ2F0ZWRfaXNfYmVzdCA/IG5lZ2F0ZWQgOiBzZWxmLmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogWyBzZWxmLCBib2R5IF1cbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuYm9keS5sZW5ndGggPT0gMCAmJiBjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5leHByZXNzaW9uXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICB2YXIgbGFzdF9icmFuY2ggPSBzZWxmLmJvZHlbc2VsZi5ib2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3RfYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBsYXN0X2JyYW5jaC5ib2R5W2xhc3RfYnJhbmNoLmJvZHkubGVuZ3RoIC0gMV07IC8vIGxhc3Qgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgbG9vcF9ib2R5KGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHN0YXQubGFiZWwpKSA9PT0gc2VsZilcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9icmFuY2guYm9keS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdF9icmFuY2ggaW5zdGFuY2VvZiBBU1RfRGVmYXVsdCAmJiBsYXN0X2JyYW5jaC5ib2R5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cCA9IHNlbGYuZXhwcmVzc2lvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgb3V0OiBpZiAoZXhwLmxlbmd0aCA9PSAyKSB0cnkge1xuICAgICAgICAgICAgLy8gY29uc3RhbnQgZXhwcmVzc2lvblxuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uID0gZXhwWzBdO1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkgYnJlYWsgb3V0O1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZXhwWzFdO1xuICAgICAgICAgICAgdmFyIGluX2lmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaW5fYmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJ1aW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlLCBkZXNjZW5kLCBpbl9saXN0KXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBkZXNjZW5kIHRoZXNlIG5vZGUgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3dpdGNoICYmIG5vZGUgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1aW5lZCA/IG5vZGUgOiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBub2RlLmJvZHkucmVkdWNlKGZ1bmN0aW9uKGEsIGJyYW5jaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGJyYW5jaC5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfSWYgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9UcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhdmUgPSBpbl9pZjtcbiAgICAgICAgICAgICAgICAgICAgaW5faWYgPSAhaW5fYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGluX2lmID0gc2F2ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50V2l0aEJvZHkgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhdmUgPSBpbl9ibG9jaztcbiAgICAgICAgICAgICAgICAgICAgaW5fYmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpbl9ibG9jayA9IHNhdmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIHRoaXMubG9vcGNvbnRyb2xfdGFyZ2V0KG5vZGUubGFiZWwpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbl9pZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbl9ibG9jaykgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5fbGlzdCA/IE1BUC5za2lwIDogbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3dpdGNoQnJhbmNoICYmIHRoaXMucGFyZW50KCkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IG5vZGUuZXhwcmVzc2lvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHAubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvdCBhIGNhc2Ugd2l0aCBub24tY29uc3RhbnQgZXhwcmVzc2lvbiwgYmFsaW5nIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHNlbGY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwWzFdID09PSB2YWx1ZSB8fCBzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0cyhub2RlKSkgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHR0LnN0YWNrID0gY29tcHJlc3Nvci5zdGFjay5zbGljZSgpOyAvLyBzbyB0aGF0J3MgYWJsZSB0byBzZWUgcGFyZW50IG5vZGVzXG4gICAgICAgICAgICBzZWxmID0gc2VsZi50cmFuc2Zvcm0odHQpO1xuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXggIT09IHNlbGYpIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9DYXNlLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9UcnksIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmLmJvZHkgPSB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwicmVtb3ZlX2luaXRpYWxpemVyc1wiLCBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKXsgZGVmLnZhbHVlID0gbnVsbCB9KTtcbiAgICB9KTtcblxuICAgIEFTVF9EZWZpbml0aW9ucy5ERUZNRVRIT0QoXCJ0b19hc3NpZ25tZW50c1wiLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYXNzaWdubWVudHMgPSB0aGlzLmRlZmluaXRpb25zLnJlZHVjZShmdW5jdGlvbihhLCBkZWYpe1xuICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIGRlZi5uYW1lLCBkZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG1ha2Vfbm9kZShBU1RfQXNzaWduLCBkZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IGRlZi52YWx1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBBU1RfU2VxLmZyb21fYXJyYXkoYXNzaWdubWVudHMpO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLmRlZmluaXRpb25zLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmID0gQVNUX0xhbWJkYS5wcm90b3R5cGUub3B0aW1pemUuY2FsbChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5uYW1lICYmIHNlbGYubmFtZS51bnJlZmVyZW5jZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0NhbGwsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiBleHAudW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChleHAubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0FycmF5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHNlbGYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9PYmplY3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoIDw9IDEpIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDEpIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBzZWxmLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIkJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRmFsc2UsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAxKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiXG4gICAgICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbChzZWxmLmFyZ3MsIGZ1bmN0aW9uKHgpeyByZXR1cm4geCBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1aXRlIGEgY29ybmVyLWNhc2UsIGJ1dCB3ZSBjYW4gaGFuZGxlIGl0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMjAzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29kZSBhcmd1bWVudCBpcyBhIGNvbnN0YW50LCB0aGVuIHdlIGNhbiBtaW5pZnkgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gXCIoZnVuY3Rpb24oXCIgKyBzZWxmLmFyZ3Muc2xpY2UoMCwgLTEpLm1hcChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIpe1wiICsgc2VsZi5hcmdzW3NlbGYuYXJncy5sZW5ndGggLSAxXS52YWx1ZSArIFwifSkoKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wID0gbmV3IENvbXByZXNzb3IoY29tcHJlc3Nvci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QgPSBhc3QudHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5maWd1cmVfb3V0X3Njb3BlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0Lm1hbmdsZV9uYW1lcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW4gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4ICE9PSBhc3QpIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBmdW4uYXJnbmFtZXMubWFwKGZ1bmN0aW9uKGFyZywgaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZi5hcmdzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLnByaW50X3RvX3N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gT3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQVNUX0Jsb2NrU3RhdGVtZW50LnByb3RvdHlwZS5fY29kZWdlbi5jYWxsKGZ1biwgZnVuLCBjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZS50b1N0cmluZygpLnJlcGxhY2UoL15cXHt8XFx9JC9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcmdzID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBKU19QYXJzZV9FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJFcnJvciBwYXJzaW5nIGNvZGUgcGFzc2VkIHRvIG5ldyBGdW5jdGlvbiBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5hcmdzW3NlbGYuYXJncy5sZW5ndGggLSAxXS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihleC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfRG90ICYmIGV4cC5wcm9wZXJ0eSA9PSBcInRvU3RyaW5nXCIgJiYgc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHAuZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3QgJiYgZXhwLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQXJyYXkgJiYgZXhwLnByb3BlcnR5ID09IFwiam9pblwiKSBFWElUOiB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHNlbGYuYXJncy5sZW5ndGggPT0gMCA/IFwiLFwiIDogc2VsZi5hcmdzWzBdLmV2YWx1YXRlKGNvbXByZXNzb3IpWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkgYnJlYWsgRVhJVDsgLy8gbm90IGEgY29uc3RhbnRcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBleHAuZXhwcmVzc2lvbi5lbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgZWwpe1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPT0gMCB8fCBlbC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gYVthLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgY29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gXCJcIiArIGxhc3RbMV0gKyBzZXBhcmF0b3IgKyBlbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBbIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIHZhbCwgbGFzdFswXSksIHZhbCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDEpIHJldHVybiBlbGVtZW50c1swXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbMF1bMF0gaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBlbGVtZW50c1sxXVswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZWxlbWVudHMuc2hpZnQoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIGVsWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHByZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBlbFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmaXJzdCkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgYXdrd2FyZCBjbG9uaW5nIHRvIG5vdCBhZmZlY3Qgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGJlc3Rfb2Ygd2lsbCBkZWNpZGUgd2hpY2ggb25lIHRvIGdldCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IG5vZGUuZXhwcmVzc2lvbi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5lbGVtZW50cyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbihlbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFswXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihzZWxmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAmJiBzZWxmLmFyZ3MubGVuZ3RoID09IDBcbiAgICAgICAgICAgICAgICAmJiAhQVNUX0Jsb2NrLnByb3RvdHlwZS5oYXNfc2lkZV9lZmZlY3RzLmNhbGwoc2VsZi5leHByZXNzaW9uLCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZikudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpWzBdO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9OZXcsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiBleHAudW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChleHAubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIlJlZ0V4cFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9DYWxsLCBzZWxmLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9TZXEsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmICghc2VsZi5jYXIuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IGNvbXByZXNzICgxLGV2YWwpKHNvbWV0aGluZykgdG9cbiAgICAgICAgICAgIC8vIGV2YWwoc29tZXRoaW5nKSBiZWNhdXNlIHRoYXQgY2hhbmdlcyB0aGUgbWVhbmluZyBvZlxuICAgICAgICAgICAgLy8gZXZhbCAoYmVjb21lcyBsZXhpY2FsIGluc3RlYWQgb2YgZ2xvYmFsKS5cbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgaWYgKCEoc2VsZi5jZHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAmJiBzZWxmLmNkci5uYW1lID09IFwiZXZhbFwiXG4gICAgICAgICAgICAgICAgICAmJiBzZWxmLmNkci51bmRlY2xhcmVkKClcbiAgICAgICAgICAgICAgICAgICYmIChwID0gY29tcHJlc3Nvci5wYXJlbnQoKSkgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBzZWxmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjYXNjYWRlXCIpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jYXIgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgJiYgIXNlbGYuY2FyLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmIHNlbGYuY2FyLmxlZnQuZXF1aXZhbGVudF90byhzZWxmLmNkcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuY2FyLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5jZHIuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmIHNlbGYuY2FyLmVxdWl2YWxlbnRfdG8oc2VsZi5jZHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX1VuYXJ5LkRFRk1FVEhPRChcImxpZnRfc2VxdWVuY2VzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzZXF1ZW5jZXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNlcS50b19hcnJheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHgucG9wKCk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNlcSA9IEFTVF9TZXEuZnJvbV9hcnJheSh4KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgcmV0dXJuIHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZiA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgICAgIHZhciBlID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJib29sZWFuc1wiKSAmJiBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBlLm9wZXJhdG9yID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICEhZm9vID09PiBmb28sIGlmIHdlJ3JlIGluIGJvb2xlYW4gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInR5cGVvZlwiOlxuICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBhbHdheXMgcmV0dXJucyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRodXMgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyB0cnVlIGluIGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQm9vbGVhbiBleHByZXNzaW9uIGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBzZWxmLm9wZXJhdG9yID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2Yoc2VsZiwgZS5uZWdhdGUoY29tcHJlc3NvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpWzBdO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaGFzX3NpZGVfZWZmZWN0c19vcl9wcm9wX2FjY2Vzcyhub2RlLCBjb21wcmVzc29yKSB7XG4gICAgICAgIHZhciBzYXZlX3B1cmVfZ2V0dGVycyA9IGNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpO1xuICAgICAgICBjb21wcmVzc29yLm9wdGlvbnMucHVyZV9nZXR0ZXJzID0gZmFsc2U7XG4gICAgICAgIHZhciByZXQgPSBub2RlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIGNvbXByZXNzb3Iub3B0aW9ucy5wdXJlX2dldHRlcnMgPSBzYXZlX3B1cmVfZ2V0dGVycztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBBU1RfQmluYXJ5LkRFRk1FVEhPRChcImxpZnRfc2VxdWVuY2VzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzZXF1ZW5jZXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgaW5zdGFuY2VvZiBBU1RfU2VxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHNlcS50b19hcnJheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IHgucG9wKCk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNlcSA9IEFTVF9TZXEuZnJvbV9hcnJheSh4KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1NlcVxuICAgICAgICAgICAgICAgICYmIHRoaXMgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgJiYgIWhhc19zaWRlX2VmZmVjdHNfb3JfcHJvcF9hY2Nlc3ModGhpcy5sZWZ0LCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXEgPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IHgucG9wKCk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNlcSA9IEFTVF9TZXEuZnJvbV9hcnJheSh4KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIHZhciBjb21tdXRhdGl2ZU9wZXJhdG9ycyA9IG1ha2VQcmVkaWNhdGUoXCI9PSA9PT0gIT0gIT09ICogJiB8IF5cIik7XG5cbiAgICBPUFQoQVNUX0JpbmFyeSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciByZXZlcnNlID0gY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSA/IG5vb3BcbiAgICAgICAgICAgIDogZnVuY3Rpb24ob3AsIGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlIHx8ICEoc2VsZi5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikgfHwgc2VsZi5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ApIHNlbGYub3BlcmF0b3IgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHNlbGYubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAoY29tbXV0YXRpdmVPcGVyYXRvcnMoc2VsZi5vcGVyYXRvcikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgIShzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgYSBjb25zdGFudCwgd2hhdGV2ZXIgc2lkZSBlZmZlY3RzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlZnQgc2lkZSBtaWdodCBoYXZlIGNvdWxkIG5vdCBpbmZsdWVuY2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0LiAgaGVuY2UsIGZvcmNlIHN3aXRjaC5cblxuICAgICAgICAgICAgICAgIGlmICghKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAmJiBQUkVDRURFTkNFW3NlbGYubGVmdC5vcGVyYXRvcl0gPj0gUFJFQ0VERU5DRVtzZWxmLm9wZXJhdG9yXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL15bIT1dPT0/JC8udGVzdChzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQuY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQuY29uc2VxdWVudC5kZWZpbml0aW9uKCkgPT09IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXj09Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL14hPS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYucmlnaHQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQuYWx0ZXJuYXRpdmUuZGVmaW5pdGlvbigpID09PSBzZWxmLmxlZnQuZGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL149PS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYucmlnaHQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sZWZ0LmNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuY29uc2VxdWVudC5kZWZpbml0aW9uKCkgPT09IHNlbGYucmlnaHQuZGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL149PS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYubGVmdC5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL14hPS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYubGVmdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuYWx0ZXJuYXRpdmUuZGVmaW5pdGlvbigpID09PSBzZWxmLnJpZ2h0LmRlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9ePT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLmxlZnQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5sZWZ0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29tcGFyaXNvbnNcIikpIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgIGNhc2UgXCI9PT1cIjpcbiAgICAgICAgICBjYXNlIFwiIT09XCI6XG4gICAgICAgICAgICBpZiAoKHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYubGVmdC5pc19ib29sZWFuKCkgJiYgc2VsZi5yaWdodC5pc19ib29sZWFuKCkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IHNlbGYub3BlcmF0b3Iuc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWFhYOiBpbnRlbnRpb25hbGx5IGZhbGxpbmcgZG93biB0byB0aGUgbmV4dCBjYXNlXG4gICAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC52YWx1ZSA9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIlxuICAgICAgICAgICAgICAgICYmIGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5yaWdodC5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICAgICAgfHwgIXNlbGYucmlnaHQuZXhwcmVzc2lvbi51bmRlY2xhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0ID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYubGVmdCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wZXJhdG9yLmxlbmd0aCA9PSAyKSBzZWxmLm9wZXJhdG9yICs9IFwiPVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgdmFyIGxsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgdmFyIHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICgobGwubGVuZ3RoID4gMSAmJiAhbGxbMV0pIHx8IChyci5sZW5ndGggPiAxICYmICFyclsxXSkpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuICYmIGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRmFsc2UsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxsLmxlbmd0aCA+IDEgJiYgbGxbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnIubGVuZ3RoID4gMSAmJiByclsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgdmFyIGxsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgdmFyIHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICgobGwubGVuZ3RoID4gMSAmJiBsbFsxXSkgfHwgKHJyLmxlbmd0aCA+IDEgJiYgcnJbMV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQm9vbGVhbiB8fCBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGwubGVuZ3RoID4gMSAmJiAhbGxbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnIubGVuZ3RoID4gMSAmJiAhcnJbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGxbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgdmFyIGxsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgdmFyIHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICgobGwubGVuZ3RoID4gMSAmJiBsbFswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgJiYgbGxbMV0pIHx8XG4gICAgICAgICAgICAgICAgKHJyLmxlbmd0aCA+IDEgJiYgcnJbMF0gaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIHJyWzFdKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIisgaW4gYm9vbGVhbiBjb250ZXh0IGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNvbXBhcmlzb25zXCIpKSB7XG4gICAgICAgICAgICBpZiAoIShjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0JpbmFyeSlcbiAgICAgICAgICAgICAgICB8fCBjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgIHZhciBuZWdhdGVkID0gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHNlbGYubmVnYXRlKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2Yoc2VsZiwgbmVnYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIjxcIjogcmV2ZXJzZShcIj5cIik7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiPD1cIjogcmV2ZXJzZShcIj49XCIpOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIitcIiAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5nZXRWYWx1ZSgpID09PSBcIlwiICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIiAmJiBzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5sZWZ0O1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCIgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmdldFZhbHVlKCkgPT09IFwiXCIgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIiAmJiBzZWxmLmxlZnQucmlnaHQgaW5zdGFuY2VvZiBBU1RfTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLnJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcoc2VsZi5sZWZ0LnJpZ2h0LnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIHNlbGYubGVmdC5nZXRWYWx1ZSgpICsgc2VsZi5yaWdodC5sZWZ0LmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGYucmlnaHQubGVmdC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIHNlbGYubGVmdC5yaWdodC5nZXRWYWx1ZSgpICsgc2VsZi5yaWdodC5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLmxlZnQucmlnaHQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiICsgc2VsZi5sZWZ0LnJpZ2h0LmdldFZhbHVlKCkgKyBzZWxmLnJpZ2h0LmxlZnQuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5yaWdodC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmxlZnQuZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHggKiAoeSAqIHopICA9PT4gIHggKiB5ICogelxuICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gc2VsZi5vcGVyYXRvclxuICAgICAgICAgICAgJiYgKHNlbGYub3BlcmF0b3IgPT0gXCIqXCIgfHwgc2VsZi5vcGVyYXRvciA9PSBcIiYmXCIgfHwgc2VsZi5vcGVyYXRvciA9PSBcInx8XCIpKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5yaWdodC5sZWZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpWzBdO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi51bmRlY2xhcmVkKCkpIHtcbiAgICAgICAgICAgIHZhciBkZWZpbmVzID0gY29tcHJlc3Nvci5vcHRpb24oXCJnbG9iYWxfZGVmc1wiKTtcbiAgICAgICAgICAgIGlmIChkZWZpbmVzICYmIGRlZmluZXMuaGFzT3duUHJvcGVydHkoc2VsZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGVfZnJvbV9jb25zdGFudChjb21wcmVzc29yLCBkZWZpbmVzW3NlbGYubmFtZV0sIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZik7XG4gICAgICAgICAgICAgIGNhc2UgXCJOYU5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OYU4sIHNlbGYpO1xuICAgICAgICAgICAgICBjYXNlIFwiSW5maW5pdHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9JbmZpbml0eSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1VuZGVmaW5lZCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfU2NvcGUpO1xuICAgICAgICAgICAgdmFyIHVuZGVmID0gc2NvcGUuZmluZF92YXJpYWJsZShcInVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIGlmICh1bmRlZikge1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICAgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgOiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgdGhlZGVmIDogdW5kZWZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWYucmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIHZhciBBU1NJR05fT1BTID0gWyAnKycsICctJywgJy8nLCAnKicsICclJywgJz4+JywgJzw8JywgJz4+PicsICd8JywgJ14nLCAnJicgXTtcbiAgICBPUFQoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYgPSBzZWxmLmxpZnRfc2VxdWVuY2VzKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIj1cIlxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQubGVmdC5uYW1lID09IHNlbGYubGVmdC5uYW1lXG4gICAgICAgICAgICAmJiBtZW1iZXIoc2VsZi5yaWdodC5vcGVyYXRvciwgQVNTSUdOX09QUykpIHtcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBzZWxmLnJpZ2h0Lm9wZXJhdG9yICsgXCI9XCI7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiY29uZGl0aW9uYWxzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uIGluc3RhbmNlb2YgQVNUX1NlcSkge1xuICAgICAgICAgICAgdmFyIGNhciA9IHNlbGYuY29uZGl0aW9uLmNhcjtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24uY2RyO1xuICAgICAgICAgICAgcmV0dXJuIEFTVF9TZXEuY29ucyhjYXIsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25kID0gc2VsZi5jb25kaXRpb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb25zZXF1ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJDb25kaXRpb24gYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5hbHRlcm5hdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVnYXRlZCA9IGNvbmRbMF0ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoYmVzdF9vZihjb25kWzBdLCBuZWdhdGVkKSA9PT0gbmVnYXRlZCkge1xuICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IG5lZ2F0ZWQsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogc2VsZi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogc2VsZi5jb25zZXF1ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudDtcbiAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZTtcbiAgICAgICAgaWYgKGNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAmJiBhbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmIGNvbnNlcXVlbnQub3BlcmF0b3IgPT0gYWx0ZXJuYXRpdmUub3BlcmF0b3JcbiAgICAgICAgICAgICYmIGNvbnNlcXVlbnQubGVmdC5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlLmxlZnQpXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFN0dWZmIGxpa2UgdGhpczpcbiAgICAgICAgICAgICAqIGlmIChmb28pIGV4cCA9IHNvbWV0aGluZzsgZWxzZSBleHAgPSBzb21ldGhpbmdfZWxzZTtcbiAgICAgICAgICAgICAqID09PlxuICAgICAgICAgICAgICogZXhwID0gZm9vID8gc29tZXRoaW5nIDogc29tZXRoaW5nX2Vsc2U7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0Fzc2lnbiwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBjb25zZXF1ZW50Lm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGNvbnNlcXVlbnQubGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmUucmlnaHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Jvb2xlYW4sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJib29sZWFuc1wiKSkge1xuICAgICAgICAgICAgdmFyIHAgPSBjb21wcmVzc29yLnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiPT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBwLm9wZXJhdG9yID09IFwiIT1cIikpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJOb24tc3RyaWN0IGVxdWFsaXR5IGFnYWluc3QgYm9vbGVhbjoge29wZXJhdG9yfSB7dmFsdWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogcC5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBzZWxmLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBmaWxlICAgICA6IHAuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSAgICAgOiBwLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbCAgICAgIDogcC5zdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiArc2VsZi52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDEgLSBzZWxmLnZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9TdWIsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydHk7XG4gICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBjb21wcmVzc29yLm9wdGlvbihcInByb3BlcnRpZXNcIikpIHtcbiAgICAgICAgICAgIHByb3AgPSBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoUkVTRVJWRURfV09SRFMocHJvcCkgPyBjb21wcmVzc29yLm9wdGlvbihcInNjcmV3X2llOFwiKSA6IGlzX2lkZW50aWZpZXJfc3RyaW5nKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRG90LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBzZWxmLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgOiBwcm9wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsaXRlcmFsc19pbl9ib29sZWFuX2NvbnRleHQoc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJib29sZWFuc1wiKSAmJiBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIE9QVChBU1RfQXJyYXksIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG4gICAgT1BUKEFTVF9PYmplY3QsIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG4gICAgT1BUKEFTVF9SZWdFeHAsIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGEgc21hbGwgd3JhcHBlciBhcm91bmQgZml0emdlbidzIHNvdXJjZS1tYXAgbGlicmFyeVxuZnVuY3Rpb24gU291cmNlTWFwKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBmaWxlIDogbnVsbCxcbiAgICAgICAgcm9vdCA6IG51bGwsXG4gICAgICAgIG9yaWcgOiBudWxsLFxuICAgIH0pO1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgTU9aX1NvdXJjZU1hcC5Tb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlICAgICAgIDogb3B0aW9ucy5maWxlLFxuICAgICAgICBzb3VyY2VSb290IDogb3B0aW9ucy5yb290XG4gICAgfSk7XG4gICAgdmFyIG9yaWdfbWFwID0gb3B0aW9ucy5vcmlnICYmIG5ldyBNT1pfU291cmNlTWFwLlNvdXJjZU1hcENvbnN1bWVyKG9wdGlvbnMub3JpZyk7XG4gICAgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZ2VuX2xpbmUsIGdlbl9jb2wsIG9yaWdfbGluZSwgb3JpZ19jb2wsIG5hbWUpIHtcbiAgICAgICAgaWYgKG9yaWdfbWFwKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IG9yaWdfbWFwLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdfbGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdfY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvdXJjZSA9IGluZm8uc291cmNlO1xuICAgICAgICAgICAgb3JpZ19saW5lID0gaW5mby5saW5lO1xuICAgICAgICAgICAgb3JpZ19jb2wgPSBpbmZvLmNvbHVtbjtcbiAgICAgICAgICAgIG5hbWUgPSBpbmZvLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgZ2VuZXJhdGVkIDogeyBsaW5lOiBnZW5fbGluZSwgY29sdW1uOiBnZW5fY29sIH0sXG4gICAgICAgICAgICBvcmlnaW5hbCAgOiB7IGxpbmU6IG9yaWdfbGluZSwgY29sdW1uOiBvcmlnX2NvbCB9LFxuICAgICAgICAgICAgc291cmNlICAgIDogc291cmNlLFxuICAgICAgICAgICAgbmFtZSAgICAgIDogbmFtZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZCAgICAgICAgOiBhZGQsXG4gICAgICAgIGdldCAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdlbmVyYXRvciB9LFxuICAgICAgICB0b1N0cmluZyAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBnZW5lcmF0b3IudG9TdHJpbmcoKSB9XG4gICAgfTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpe1xuXG4gICAgdmFyIE1PWl9UT19NRSA9IHtcbiAgICAgICAgVHJ5U3RhdGVtZW50IDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVHJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgIDogZnJvbV9tb3ooTS5ibG9jaykuYm9keSxcbiAgICAgICAgICAgICAgICBiY2F0Y2ggICA6IGZyb21fbW96KE0uaGFuZGxlcnNbMF0pLFxuICAgICAgICAgICAgICAgIGJmaW5hbGx5IDogTS5maW5hbGl6ZXIgPyBuZXcgQVNUX0ZpbmFsbHkoZnJvbV9tb3ooTS5maW5hbGl6ZXIpKSA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBDYXRjaENsYXVzZSA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NhdGNoKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBhcmduYW1lIDogZnJvbV9tb3ooTS5wYXJhbSksXG4gICAgICAgICAgICAgICAgYm9keSAgICA6IGZyb21fbW96KE0uYm9keSkuYm9keVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgOiBNLnByb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHByb3Ape1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0ga2V5LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgICAgICA6IG15X2VuZF90b2tlbihwcm9wLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSAgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3oocHJvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0S2V5VmFsKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUubmFtZSA9IGZyb21fbW96KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RTZXR0ZXIoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy52YWx1ZS5uYW1lID0gZnJvbV9tb3ooa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdEdldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTVF9TZXEuZnJvbV9hcnJheShNLmV4cHJlc3Npb25zLm1hcChmcm9tX21veikpO1xuICAgICAgICB9LFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS5jb21wdXRlZCA/IEFTVF9TdWIgOiBBU1RfRG90KSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IE0uY29tcHV0ZWQgPyBmcm9tX21veihNLnByb3BlcnR5KSA6IE0ucHJvcGVydHkubmFtZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS5vYmplY3QpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgU3dpdGNoQ2FzZSA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE0udGVzdCA/IEFTVF9DYXNlIDogQVNUX0RlZmF1bHQpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS50ZXN0KSxcbiAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogTS5jb25zZXF1ZW50Lm1hcChmcm9tX21veilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBMaXRlcmFsIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IE0udmFsdWUsIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgIDogbXlfZW5kX3Rva2VuKE0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIG5ldyBBU1RfTnVsbChhcmdzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9TdHJpbmcoYXJncyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX051bWJlcihhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSkoYXJncyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZWdFeHAoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogRnJvbV9Nb3pfVW5hcnksXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IEZyb21fTW96X1VuYXJ5LFxuICAgICAgICBJZGVudGlmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgcCA9IEZST01fTU9aX1NUQUNLW0ZST01fTU9aX1NUQUNLLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS5uYW1lID09IFwidGhpc1wiID8gQVNUX1RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiTGFiZWxlZFN0YXRlbWVudFwiID8gQVNUX0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiICYmIHAuaWQgPT09IE0gPyAocC5raW5kID09IFwiY29uc3RcIiA/IEFTVF9TeW1ib2xDb25zdCA6IEFTVF9TeW1ib2xWYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID8gKHAuaWQgPT09IE0gPyBBU1RfU3ltYm9sTGFtYmRhIDogQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID8gKHAuaWQgPT09IE0gPyBBU1RfU3ltYm9sRGVmdW4gOiBBU1RfU3ltYm9sRnVuYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJDYXRjaENsYXVzZVwiID8gQVNUX1N5bWJvbENhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkJyZWFrU3RhdGVtZW50XCIgfHwgcC50eXBlID09IFwiQ29udGludWVTdGF0ZW1lbnRcIiA/IEFTVF9MYWJlbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBBU1RfU3ltYm9sUmVmKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICA6IE0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnJvbV9Nb3pfVW5hcnkoTSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJwcmVmaXhcIiBpbiBNID8gTS5wcmVmaXhcbiAgICAgICAgICAgIDogTS50eXBlID09IFwiVW5hcnlFeHByZXNzaW9uXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgKHByZWZpeCA/IEFTVF9VbmFyeVByZWZpeCA6IEFTVF9VbmFyeVBvc3RmaXgpKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICBvcGVyYXRvciAgIDogTS5vcGVyYXRvcixcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIE1FX1RPX01PWiA9IHt9O1xuXG4gICAgbWFwKFwiTm9kZVwiLCBBU1RfTm9kZSk7XG4gICAgbWFwKFwiUHJvZ3JhbVwiLCBBU1RfVG9wbGV2ZWwsIFwiYm9keUBib2R5XCIpO1xuICAgIG1hcChcIkZ1bmN0aW9uXCIsIEFTVF9GdW5jdGlvbiwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJFbXB0eVN0YXRlbWVudFwiLCBBU1RfRW1wdHlTdGF0ZW1lbnQpO1xuICAgIG1hcChcIkJsb2NrU3RhdGVtZW50XCIsIEFTVF9CbG9ja1N0YXRlbWVudCwgXCJib2R5QGJvZHlcIik7XG4gICAgbWFwKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBBU1RfU2ltcGxlU3RhdGVtZW50LCBcImV4cHJlc3Npb24+Ym9keVwiKTtcbiAgICBtYXAoXCJJZlN0YXRlbWVudFwiLCBBU1RfSWYsIFwidGVzdD5jb25kaXRpb24sIGNvbnNlcXVlbnQ+Ym9keSwgYWx0ZXJuYXRlPmFsdGVybmF0aXZlXCIpO1xuICAgIG1hcChcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIFwibGFiZWw+bGFiZWwsIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJCcmVha1N0YXRlbWVudFwiLCBBU1RfQnJlYWssIFwibGFiZWw+bGFiZWxcIik7XG4gICAgbWFwKFwiQ29udGludWVTdGF0ZW1lbnRcIiwgQVNUX0NvbnRpbnVlLCBcImxhYmVsPmxhYmVsXCIpO1xuICAgIG1hcChcIldpdGhTdGF0ZW1lbnRcIiwgQVNUX1dpdGgsIFwib2JqZWN0PmV4cHJlc3Npb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgQVNUX1N3aXRjaCwgXCJkaXNjcmltaW5hbnQ+ZXhwcmVzc2lvbiwgY2FzZXNAYm9keVwiKTtcbiAgICBtYXAoXCJSZXR1cm5TdGF0ZW1lbnRcIiwgQVNUX1JldHVybiwgXCJhcmd1bWVudD52YWx1ZVwiKTtcbiAgICBtYXAoXCJUaHJvd1N0YXRlbWVudFwiLCBBU1RfVGhyb3csIFwiYXJndW1lbnQ+dmFsdWVcIik7XG4gICAgbWFwKFwiV2hpbGVTdGF0ZW1lbnRcIiwgQVNUX1doaWxlLCBcInRlc3Q+Y29uZGl0aW9uLCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRG9XaGlsZVN0YXRlbWVudFwiLCBBU1RfRG8sIFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJGb3JTdGF0ZW1lbnRcIiwgQVNUX0ZvciwgXCJpbml0PmluaXQsIHRlc3Q+Y29uZGl0aW9uLCB1cGRhdGU+c3RlcCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkZvckluU3RhdGVtZW50XCIsIEFTVF9Gb3JJbiwgXCJsZWZ0PmluaXQsIHJpZ2h0Pm9iamVjdCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIEFTVF9EZWJ1Z2dlcik7XG4gICAgbWFwKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBBU1RfRGVmdW4sIFwiaWQ+bmFtZSwgcGFyYW1zQGFyZ25hbWVzLCBib2R5JWJvZHlcIik7XG4gICAgbWFwKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBBU1RfVmFyLCBcImRlY2xhcmF0aW9uc0BkZWZpbml0aW9uc1wiKTtcbiAgICBtYXAoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgQVNUX1ZhckRlZiwgXCJpZD5uYW1lLCBpbml0PnZhbHVlXCIpO1xuXG4gICAgbWFwKFwiVGhpc0V4cHJlc3Npb25cIiwgQVNUX1RoaXMpO1xuICAgIG1hcChcIkFycmF5RXhwcmVzc2lvblwiLCBBU1RfQXJyYXksIFwiZWxlbWVudHNAZWxlbWVudHNcIik7XG4gICAgbWFwKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIEFTVF9GdW5jdGlvbiwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJCaW5hcnlFeHByZXNzaW9uXCIsIEFTVF9CaW5hcnksIFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIik7XG4gICAgbWFwKFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgQVNUX0Fzc2lnbiwgXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKTtcbiAgICBtYXAoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCBBU1RfQmluYXJ5LCBcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpO1xuICAgIG1hcChcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBBU1RfQ29uZGl0aW9uYWwsIFwidGVzdD5jb25kaXRpb24sIGNvbnNlcXVlbnQ+Y29uc2VxdWVudCwgYWx0ZXJuYXRlPmFsdGVybmF0aXZlXCIpO1xuICAgIG1hcChcIk5ld0V4cHJlc3Npb25cIiwgQVNUX05ldywgXCJjYWxsZWU+ZXhwcmVzc2lvbiwgYXJndW1lbnRzQGFyZ3NcIik7XG4gICAgbWFwKFwiQ2FsbEV4cHJlc3Npb25cIiwgQVNUX0NhbGwsIFwiY2FsbGVlPmV4cHJlc3Npb24sIGFyZ3VtZW50c0BhcmdzXCIpO1xuXG4gICAgLyogLS0tLS1bIHRvb2xzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gbXlfc3RhcnRfdG9rZW4obW96bm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub2tlbih7XG4gICAgICAgICAgICBmaWxlICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zb3VyY2UsXG4gICAgICAgICAgICBsaW5lICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgY29sICAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2Muc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgcG9zICAgIDogbW96bm9kZS5zdGFydCxcbiAgICAgICAgICAgIGVuZHBvcyA6IG1vem5vZGUuc3RhcnRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG15X2VuZF90b2tlbihtb3pub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHtcbiAgICAgICAgICAgIGZpbGUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnNvdXJjZSxcbiAgICAgICAgICAgIGxpbmUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLmVuZC5saW5lLFxuICAgICAgICAgICAgY29sICAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2MuZW5kLmNvbHVtbixcbiAgICAgICAgICAgIHBvcyAgICA6IG1vem5vZGUuZW5kLFxuICAgICAgICAgICAgZW5kcG9zIDogbW96bm9kZS5lbmRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1hcChtb3p0eXBlLCBteXR5cGUsIHByb3BtYXApIHtcbiAgICAgICAgdmFyIG1vel90b19tZSA9IFwiZnVuY3Rpb24gRnJvbV9Nb3pfXCIgKyBtb3p0eXBlICsgXCIoTSl7XFxuXCI7XG4gICAgICAgIG1vel90b19tZSArPSBcInJldHVybiBuZXcgbXl0eXBlKHtcXG5cIiArXG4gICAgICAgICAgICBcInN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcXG5cIiArXG4gICAgICAgICAgICBcImVuZDogbXlfZW5kX3Rva2VuKE0pXCI7XG5cbiAgICAgICAgaWYgKHByb3BtYXApIHByb3BtYXAuc3BsaXQoL1xccyosXFxzKi8pLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICB2YXIgbSA9IC8oW2EtejAtOSRfXSspKD18QHw+fCUpKFthLXowLTkkX10rKS9pLmV4ZWMocHJvcCk7XG4gICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVuZGVyc3RhbmQgcHJvcGVydHkgbWFwOiBcIiArIHByb3ApO1xuICAgICAgICAgICAgdmFyIG1veiA9IFwiTS5cIiArIG1bMV0sIGhvdyA9IG1bMl0sIG15ID0gbVszXTtcbiAgICAgICAgICAgIG1vel90b19tZSArPSBcIixcXG5cIiArIG15ICsgXCI6IFwiO1xuICAgICAgICAgICAgaWYgKGhvdyA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBtb3ogKyBcIi5tYXAoZnJvbV9tb3opXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBcImZyb21fbW96KFwiICsgbW96ICsgXCIpXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBtb3o7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIiVcIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBcImZyb21fbW96KFwiICsgbW96ICsgXCIpLmJvZHlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1bmRlcnN0YW5kIG9wZXJhdG9yIGluIHByb3BtYXA6IFwiICsgcHJvcCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb3pfdG9fbWUgKz0gXCJcXG59KX1cIjtcblxuICAgICAgICAvLyBtb3pfdG9fbWUgPSBwYXJzZShtb3pfdG9fbWUpLnByaW50X3RvX3N0cmluZyh7IGJlYXV0aWZ5OiB0cnVlIH0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhtb3pfdG9fbWUpO1xuXG4gICAgICAgIG1vel90b19tZSA9IG5ldyBGdW5jdGlvbihcIm15dHlwZVwiLCBcIm15X3N0YXJ0X3Rva2VuXCIsIFwibXlfZW5kX3Rva2VuXCIsIFwiZnJvbV9tb3pcIiwgXCJyZXR1cm4oXCIgKyBtb3pfdG9fbWUgKyBcIilcIikoXG4gICAgICAgICAgICBteXR5cGUsIG15X3N0YXJ0X3Rva2VuLCBteV9lbmRfdG9rZW4sIGZyb21fbW96XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNT1pfVE9fTUVbbW96dHlwZV0gPSBtb3pfdG9fbWU7XG4gICAgfTtcblxuICAgIHZhciBGUk9NX01PWl9TVEFDSyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBmcm9tX21veihub2RlKSB7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSBub2RlICE9IG51bGwgPyBNT1pfVE9fTUVbbm9kZS50eXBlXShub2RlKSA6IG51bGw7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBBU1RfTm9kZS5mcm9tX21vemlsbGFfYXN0ID0gZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciBzYXZlX3N0YWNrID0gRlJPTV9NT1pfU1RBQ0s7XG4gICAgICAgIEZST01fTU9aX1NUQUNLID0gW107XG4gICAgICAgIHZhciBhc3QgPSBmcm9tX21veihub2RlKTtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sgPSBzYXZlX3N0YWNrO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG5cbn0pKCk7XG5cblxuZXhwb3J0cy5zeXMgPSBzeXM7XG5leHBvcnRzLk1PWl9Tb3VyY2VNYXAgPSBNT1pfU291cmNlTWFwO1xuZXhwb3J0cy5VZ2xpZnlKUyA9IFVnbGlmeUpTO1xuZXhwb3J0cy5hcnJheV90b19oYXNoID0gYXJyYXlfdG9faGFzaDtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuY2hhcmFjdGVycyA9IGNoYXJhY3RlcnM7XG5leHBvcnRzLm1lbWJlciA9IG1lbWJlcjtcbmV4cG9ydHMuZmluZF9pZiA9IGZpbmRfaWY7XG5leHBvcnRzLnJlcGVhdF9zdHJpbmcgPSByZXBlYXRfc3RyaW5nO1xuZXhwb3J0cy5EZWZhdWx0c0Vycm9yID0gRGVmYXVsdHNFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLk1BUCA9IE1BUDtcbmV4cG9ydHMucHVzaF91bmlxID0gcHVzaF91bmlxO1xuZXhwb3J0cy5zdHJpbmdfdGVtcGxhdGUgPSBzdHJpbmdfdGVtcGxhdGU7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbmV4cG9ydHMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xuZXhwb3J0cy5zZXRfZGlmZmVyZW5jZSA9IHNldF9kaWZmZXJlbmNlO1xuZXhwb3J0cy5zZXRfaW50ZXJzZWN0aW9uID0gc2V0X2ludGVyc2VjdGlvbjtcbmV4cG9ydHMubWFrZVByZWRpY2F0ZSA9IG1ha2VQcmVkaWNhdGU7XG5leHBvcnRzLmFsbCA9IGFsbDtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG5leHBvcnRzLkRFRk5PREUgPSBERUZOT0RFO1xuZXhwb3J0cy5BU1RfVG9rZW4gPSBBU1RfVG9rZW47XG5leHBvcnRzLkFTVF9Ob2RlID0gQVNUX05vZGU7XG5leHBvcnRzLkFTVF9TdGF0ZW1lbnQgPSBBU1RfU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRGVidWdnZXIgPSBBU1RfRGVidWdnZXI7XG5leHBvcnRzLkFTVF9EaXJlY3RpdmUgPSBBU1RfRGlyZWN0aXZlO1xuZXhwb3J0cy5BU1RfU2ltcGxlU3RhdGVtZW50ID0gQVNUX1NpbXBsZVN0YXRlbWVudDtcbmV4cG9ydHMud2Fsa19ib2R5ID0gd2Fsa19ib2R5O1xuZXhwb3J0cy5BU1RfQmxvY2sgPSBBU1RfQmxvY2s7XG5leHBvcnRzLkFTVF9CbG9ja1N0YXRlbWVudCA9IEFTVF9CbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuQVNUX0VtcHR5U3RhdGVtZW50ID0gQVNUX0VtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfU3RhdGVtZW50V2l0aEJvZHkgPSBBU1RfU3RhdGVtZW50V2l0aEJvZHk7XG5leHBvcnRzLkFTVF9MYWJlbGVkU3RhdGVtZW50ID0gQVNUX0xhYmVsZWRTdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9JdGVyYXRpb25TdGF0ZW1lbnQgPSBBU1RfSXRlcmF0aW9uU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRFdMb29wID0gQVNUX0RXTG9vcDtcbmV4cG9ydHMuQVNUX0RvID0gQVNUX0RvO1xuZXhwb3J0cy5BU1RfV2hpbGUgPSBBU1RfV2hpbGU7XG5leHBvcnRzLkFTVF9Gb3IgPSBBU1RfRm9yO1xuZXhwb3J0cy5BU1RfRm9ySW4gPSBBU1RfRm9ySW47XG5leHBvcnRzLkFTVF9XaXRoID0gQVNUX1dpdGg7XG5leHBvcnRzLkFTVF9TY29wZSA9IEFTVF9TY29wZTtcbmV4cG9ydHMuQVNUX1RvcGxldmVsID0gQVNUX1RvcGxldmVsO1xuZXhwb3J0cy5BU1RfTGFtYmRhID0gQVNUX0xhbWJkYTtcbmV4cG9ydHMuQVNUX0FjY2Vzc29yID0gQVNUX0FjY2Vzc29yO1xuZXhwb3J0cy5BU1RfRnVuY3Rpb24gPSBBU1RfRnVuY3Rpb247XG5leHBvcnRzLkFTVF9EZWZ1biA9IEFTVF9EZWZ1bjtcbmV4cG9ydHMuQVNUX0p1bXAgPSBBU1RfSnVtcDtcbmV4cG9ydHMuQVNUX0V4aXQgPSBBU1RfRXhpdDtcbmV4cG9ydHMuQVNUX1JldHVybiA9IEFTVF9SZXR1cm47XG5leHBvcnRzLkFTVF9UaHJvdyA9IEFTVF9UaHJvdztcbmV4cG9ydHMuQVNUX0xvb3BDb250cm9sID0gQVNUX0xvb3BDb250cm9sO1xuZXhwb3J0cy5BU1RfQnJlYWsgPSBBU1RfQnJlYWs7XG5leHBvcnRzLkFTVF9Db250aW51ZSA9IEFTVF9Db250aW51ZTtcbmV4cG9ydHMuQVNUX0lmID0gQVNUX0lmO1xuZXhwb3J0cy5BU1RfU3dpdGNoID0gQVNUX1N3aXRjaDtcbmV4cG9ydHMuQVNUX1N3aXRjaEJyYW5jaCA9IEFTVF9Td2l0Y2hCcmFuY2g7XG5leHBvcnRzLkFTVF9EZWZhdWx0ID0gQVNUX0RlZmF1bHQ7XG5leHBvcnRzLkFTVF9DYXNlID0gQVNUX0Nhc2U7XG5leHBvcnRzLkFTVF9UcnkgPSBBU1RfVHJ5O1xuZXhwb3J0cy5BU1RfQ2F0Y2ggPSBBU1RfQ2F0Y2g7XG5leHBvcnRzLkFTVF9GaW5hbGx5ID0gQVNUX0ZpbmFsbHk7XG5leHBvcnRzLkFTVF9EZWZpbml0aW9ucyA9IEFTVF9EZWZpbml0aW9ucztcbmV4cG9ydHMuQVNUX1ZhciA9IEFTVF9WYXI7XG5leHBvcnRzLkFTVF9Db25zdCA9IEFTVF9Db25zdDtcbmV4cG9ydHMuQVNUX1ZhckRlZiA9IEFTVF9WYXJEZWY7XG5leHBvcnRzLkFTVF9DYWxsID0gQVNUX0NhbGw7XG5leHBvcnRzLkFTVF9OZXcgPSBBU1RfTmV3O1xuZXhwb3J0cy5BU1RfU2VxID0gQVNUX1NlcTtcbmV4cG9ydHMuQVNUX1Byb3BBY2Nlc3MgPSBBU1RfUHJvcEFjY2VzcztcbmV4cG9ydHMuQVNUX0RvdCA9IEFTVF9Eb3Q7XG5leHBvcnRzLkFTVF9TdWIgPSBBU1RfU3ViO1xuZXhwb3J0cy5BU1RfVW5hcnkgPSBBU1RfVW5hcnk7XG5leHBvcnRzLkFTVF9VbmFyeVByZWZpeCA9IEFTVF9VbmFyeVByZWZpeDtcbmV4cG9ydHMuQVNUX1VuYXJ5UG9zdGZpeCA9IEFTVF9VbmFyeVBvc3RmaXg7XG5leHBvcnRzLkFTVF9CaW5hcnkgPSBBU1RfQmluYXJ5O1xuZXhwb3J0cy5BU1RfQ29uZGl0aW9uYWwgPSBBU1RfQ29uZGl0aW9uYWw7XG5leHBvcnRzLkFTVF9Bc3NpZ24gPSBBU1RfQXNzaWduO1xuZXhwb3J0cy5BU1RfQXJyYXkgPSBBU1RfQXJyYXk7XG5leHBvcnRzLkFTVF9PYmplY3QgPSBBU1RfT2JqZWN0O1xuZXhwb3J0cy5BU1RfT2JqZWN0UHJvcGVydHkgPSBBU1RfT2JqZWN0UHJvcGVydHk7XG5leHBvcnRzLkFTVF9PYmplY3RLZXlWYWwgPSBBU1RfT2JqZWN0S2V5VmFsO1xuZXhwb3J0cy5BU1RfT2JqZWN0U2V0dGVyID0gQVNUX09iamVjdFNldHRlcjtcbmV4cG9ydHMuQVNUX09iamVjdEdldHRlciA9IEFTVF9PYmplY3RHZXR0ZXI7XG5leHBvcnRzLkFTVF9TeW1ib2wgPSBBU1RfU3ltYm9sO1xuZXhwb3J0cy5BU1RfU3ltYm9sQWNjZXNzb3IgPSBBU1RfU3ltYm9sQWNjZXNzb3I7XG5leHBvcnRzLkFTVF9TeW1ib2xEZWNsYXJhdGlvbiA9IEFTVF9TeW1ib2xEZWNsYXJhdGlvbjtcbmV4cG9ydHMuQVNUX1N5bWJvbFZhciA9IEFTVF9TeW1ib2xWYXI7XG5leHBvcnRzLkFTVF9TeW1ib2xDb25zdCA9IEFTVF9TeW1ib2xDb25zdDtcbmV4cG9ydHMuQVNUX1N5bWJvbEZ1bmFyZyA9IEFTVF9TeW1ib2xGdW5hcmc7XG5leHBvcnRzLkFTVF9TeW1ib2xEZWZ1biA9IEFTVF9TeW1ib2xEZWZ1bjtcbmV4cG9ydHMuQVNUX1N5bWJvbExhbWJkYSA9IEFTVF9TeW1ib2xMYW1iZGE7XG5leHBvcnRzLkFTVF9TeW1ib2xDYXRjaCA9IEFTVF9TeW1ib2xDYXRjaDtcbmV4cG9ydHMuQVNUX0xhYmVsID0gQVNUX0xhYmVsO1xuZXhwb3J0cy5BU1RfU3ltYm9sUmVmID0gQVNUX1N5bWJvbFJlZjtcbmV4cG9ydHMuQVNUX0xhYmVsUmVmID0gQVNUX0xhYmVsUmVmO1xuZXhwb3J0cy5BU1RfVGhpcyA9IEFTVF9UaGlzO1xuZXhwb3J0cy5BU1RfQ29uc3RhbnQgPSBBU1RfQ29uc3RhbnQ7XG5leHBvcnRzLkFTVF9TdHJpbmcgPSBBU1RfU3RyaW5nO1xuZXhwb3J0cy5BU1RfTnVtYmVyID0gQVNUX051bWJlcjtcbmV4cG9ydHMuQVNUX1JlZ0V4cCA9IEFTVF9SZWdFeHA7XG5leHBvcnRzLkFTVF9BdG9tID0gQVNUX0F0b207XG5leHBvcnRzLkFTVF9OdWxsID0gQVNUX051bGw7XG5leHBvcnRzLkFTVF9OYU4gPSBBU1RfTmFOO1xuZXhwb3J0cy5BU1RfVW5kZWZpbmVkID0gQVNUX1VuZGVmaW5lZDtcbmV4cG9ydHMuQVNUX0hvbGUgPSBBU1RfSG9sZTtcbmV4cG9ydHMuQVNUX0luZmluaXR5ID0gQVNUX0luZmluaXR5O1xuZXhwb3J0cy5BU1RfQm9vbGVhbiA9IEFTVF9Cb29sZWFuO1xuZXhwb3J0cy5BU1RfRmFsc2UgPSBBU1RfRmFsc2U7XG5leHBvcnRzLkFTVF9UcnVlID0gQVNUX1RydWU7XG5leHBvcnRzLlRyZWVXYWxrZXIgPSBUcmVlV2Fsa2VyO1xuZXhwb3J0cy5LRVlXT1JEUyA9IEtFWVdPUkRTO1xuZXhwb3J0cy5LRVlXT1JEU19BVE9NID0gS0VZV09SRFNfQVRPTTtcbmV4cG9ydHMuUkVTRVJWRURfV09SRFMgPSBSRVNFUlZFRF9XT1JEUztcbmV4cG9ydHMuS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTjtcbmV4cG9ydHMuT1BFUkFUT1JfQ0hBUlMgPSBPUEVSQVRPUl9DSEFSUztcbmV4cG9ydHMuUkVfSEVYX05VTUJFUiA9IFJFX0hFWF9OVU1CRVI7XG5leHBvcnRzLlJFX09DVF9OVU1CRVIgPSBSRV9PQ1RfTlVNQkVSO1xuZXhwb3J0cy5SRV9ERUNfTlVNQkVSID0gUkVfREVDX05VTUJFUjtcbmV4cG9ydHMuT1BFUkFUT1JTID0gT1BFUkFUT1JTO1xuZXhwb3J0cy5XSElURVNQQUNFX0NIQVJTID0gV0hJVEVTUEFDRV9DSEFSUztcbmV4cG9ydHMuUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiA9IFBVTkNfQkVGT1JFX0VYUFJFU1NJT047XG5leHBvcnRzLlBVTkNfQ0hBUlMgPSBQVU5DX0NIQVJTO1xuZXhwb3J0cy5SRUdFWFBfTU9ESUZJRVJTID0gUkVHRVhQX01PRElGSUVSUztcbmV4cG9ydHMuVU5JQ09ERSA9IFVOSUNPREU7XG5leHBvcnRzLmlzX2xldHRlciA9IGlzX2xldHRlcjtcbmV4cG9ydHMuaXNfZGlnaXQgPSBpc19kaWdpdDtcbmV4cG9ydHMuaXNfYWxwaGFudW1lcmljX2NoYXIgPSBpc19hbHBoYW51bWVyaWNfY2hhcjtcbmV4cG9ydHMuaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayA9IGlzX3VuaWNvZGVfY29tYmluaW5nX21hcms7XG5leHBvcnRzLmlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uID0gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb247XG5leHBvcnRzLmlzX2lkZW50aWZpZXIgPSBpc19pZGVudGlmaWVyO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX3N0YXJ0ID0gaXNfaWRlbnRpZmllcl9zdGFydDtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9jaGFyID0gaXNfaWRlbnRpZmllcl9jaGFyO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX3N0cmluZyA9IGlzX2lkZW50aWZpZXJfc3RyaW5nO1xuZXhwb3J0cy5wYXJzZV9qc19udW1iZXIgPSBwYXJzZV9qc19udW1iZXI7XG5leHBvcnRzLkpTX1BhcnNlX0Vycm9yID0gSlNfUGFyc2VfRXJyb3I7XG5leHBvcnRzLmpzX2Vycm9yID0ganNfZXJyb3I7XG5leHBvcnRzLmlzX3Rva2VuID0gaXNfdG9rZW47XG5leHBvcnRzLkVYX0VPRiA9IEVYX0VPRjtcbmV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuZXhwb3J0cy5VTkFSWV9QUkVGSVggPSBVTkFSWV9QUkVGSVg7XG5leHBvcnRzLlVOQVJZX1BPU1RGSVggPSBVTkFSWV9QT1NURklYO1xuZXhwb3J0cy5BU1NJR05NRU5UID0gQVNTSUdOTUVOVDtcbmV4cG9ydHMuUFJFQ0VERU5DRSA9IFBSRUNFREVOQ0U7XG5leHBvcnRzLlNUQVRFTUVOVFNfV0lUSF9MQUJFTFMgPSBTVEFURU1FTlRTX1dJVEhfTEFCRUxTO1xuZXhwb3J0cy5BVE9NSUNfU1RBUlRfVE9LRU4gPSBBVE9NSUNfU1RBUlRfVE9LRU47XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLlRyZWVUcmFuc2Zvcm1lciA9IFRyZWVUcmFuc2Zvcm1lcjtcbmV4cG9ydHMuU3ltYm9sRGVmID0gU3ltYm9sRGVmO1xuZXhwb3J0cy5iYXNlNTQgPSBiYXNlNTQ7XG5leHBvcnRzLk91dHB1dFN0cmVhbSA9IE91dHB1dFN0cmVhbTtcbmV4cG9ydHMuQ29tcHJlc3NvciA9IENvbXByZXNzb3I7XG5leHBvcnRzLlNvdXJjZU1hcCA9IFNvdXJjZU1hcDtcblxuZXhwb3J0cy5BU1RfTm9kZS53YXJuX2Z1bmN0aW9uID0gZnVuY3Rpb24gKHR4dCkgeyBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIGNvbnNvbGUud2Fybih0eHQpIH1cblxuZXhwb3J0cy5taW5pZnkgPSBmdW5jdGlvbiAoZmlsZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVWdsaWZ5SlMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBvdXRTb3VyY2VNYXAgOiBudWxsLFxuICAgICAgICBzb3VyY2VSb290ICAgOiBudWxsLFxuICAgICAgICBpblNvdXJjZU1hcCAgOiBudWxsLFxuICAgICAgICBmcm9tU3RyaW5nICAgOiBmYWxzZSxcbiAgICAgICAgd2FybmluZ3MgICAgIDogZmFsc2UsXG4gICAgICAgIG1hbmdsZSAgICAgICA6IHt9LFxuICAgICAgICBvdXRwdXQgICAgICAgOiBudWxsLFxuICAgICAgICBjb21wcmVzcyAgICAgOiB7fVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgZmlsZXMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgZmlsZXMgPSBbIGZpbGVzIF07XG5cbiAgICBVZ2xpZnlKUy5iYXNlNTQucmVzZXQoKTtcblxuICAgIC8vIDEuIHBhcnNlXG4gICAgdmFyIHRvcGxldmVsID0gbnVsbDtcbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICB2YXIgY29kZSA9IG9wdGlvbnMuZnJvbVN0cmluZ1xuICAgICAgICAgICAgPyBmaWxlXG4gICAgICAgICAgICA6IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBcInV0ZjhcIik7XG4gICAgICAgIHRvcGxldmVsID0gVWdsaWZ5SlMucGFyc2UoY29kZSwge1xuICAgICAgICAgICAgZmlsZW5hbWU6IG9wdGlvbnMuZnJvbVN0cmluZyA/IFwiP1wiIDogZmlsZSxcbiAgICAgICAgICAgIHRvcGxldmVsOiB0b3BsZXZlbFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIDIuIGNvbXByZXNzXG4gICAgaWYgKG9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzID0geyB3YXJuaW5nczogb3B0aW9ucy53YXJuaW5ncyB9O1xuICAgICAgICBVZ2xpZnlKUy5tZXJnZShjb21wcmVzcywgb3B0aW9ucy5jb21wcmVzcyk7XG4gICAgICAgIHRvcGxldmVsLmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgdmFyIHNxID0gVWdsaWZ5SlMuQ29tcHJlc3Nvcihjb21wcmVzcyk7XG4gICAgICAgIHRvcGxldmVsID0gdG9wbGV2ZWwudHJhbnNmb3JtKHNxKTtcbiAgICB9XG5cbiAgICAvLyAzLiBtYW5nbGVcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgdG9wbGV2ZWwuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICB0b3BsZXZlbC5jb21wdXRlX2NoYXJfZnJlcXVlbmN5KCk7XG4gICAgICAgIHRvcGxldmVsLm1hbmdsZV9uYW1lcyhvcHRpb25zLm1hbmdsZSk7XG4gICAgfVxuXG4gICAgLy8gNC4gb3V0cHV0XG4gICAgdmFyIGluTWFwID0gb3B0aW9ucy5pblNvdXJjZU1hcDtcbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluU291cmNlTWFwID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaW5NYXAgPSBmcy5yZWFkRmlsZVN5bmMob3B0aW9ucy5pblNvdXJjZU1hcCwgXCJ1dGY4XCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vdXRTb3VyY2VNYXApIHtcbiAgICAgICAgb3V0cHV0LnNvdXJjZV9tYXAgPSBVZ2xpZnlKUy5Tb3VyY2VNYXAoe1xuICAgICAgICAgICAgZmlsZTogb3B0aW9ucy5vdXRTb3VyY2VNYXAsXG4gICAgICAgICAgICBvcmlnOiBpbk1hcCxcbiAgICAgICAgICAgIHJvb3Q6IG9wdGlvbnMuc291cmNlUm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgICAgIFVnbGlmeUpTLm1lcmdlKG91dHB1dCwgb3B0aW9ucy5vdXRwdXQpO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtID0gVWdsaWZ5SlMuT3V0cHV0U3RyZWFtKG91dHB1dCk7XG4gICAgdG9wbGV2ZWwucHJpbnQoc3RyZWFtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlIDogc3RyZWFtICsgXCJcIixcbiAgICAgICAgbWFwICA6IG91dHB1dC5zb3VyY2VfbWFwICsgXCJcIlxuICAgIH07XG59O1xuXG5leHBvcnRzLmRlc2NyaWJlX2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gVWdsaWZ5SlMuT3V0cHV0U3RyZWFtKHsgYmVhdXRpZnk6IHRydWUgfSk7XG4gICAgZnVuY3Rpb24gZG9pdGVtKGN0b3IpIHtcbiAgICAgICAgb3V0LnByaW50KFwiQVNUX1wiICsgY3Rvci5UWVBFKTtcbiAgICAgICAgdmFyIHByb3BzID0gY3Rvci5TRUxGX1BST1BTLmZpbHRlcihmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHJldHVybiAhL15cXCQvLnRlc3QocHJvcCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSkgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wcmludChwcm9wKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG9yLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LnByaW50X3N0cmluZyhjdG9yLmRvY3VtZW50YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG9yLlNVQkNMQVNTRVMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGN0b3IuU1VCQ0xBU1NFUy5mb3JFYWNoKGZ1bmN0aW9uKGN0b3IsIGkpe1xuICAgICAgICAgICAgICAgICAgICBvdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGRvaXRlbShjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkb2l0ZW0oVWdsaWZ5SlMuQVNUX05vZGUpO1xuICAgIHJldHVybiBvdXQgKyBcIlwiO1xufTsiLCJ2YXIgdWdsaWZ5ID0gcmVxdWlyZSgndWdsaWZ5LWpzJylcbnZhciBqYWRlID0gcmVxdWlyZSgnamFkZS9saWIvamFkZS5qcycpXG52YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpXG52YXIgaGxqYWRlID0gcmVxdWlyZSgnLi4vaGlnaGxpZ2h0LWphZGUuanMnKVxudmFyIGhpZ2hsaWdodGVycyA9IHtcbiAgamF2YXNjcmlwdDogZnVuY3Rpb24gKHNyYykge1xuICAgIHJldHVybiBobGpzLmhpZ2hsaWdodCgnamF2YXNjcmlwdCcsIHNyYykudmFsdWU7XG4gIH0sXG4gIGh0bWw6IGZ1bmN0aW9uIChzcmMpIHtcbiAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQoJ3htbCcsIHNyYykudmFsdWU7XG4gIH0sXG4gIGphZGU6IGhsamFkZVxufVxuXG5mdW5jdGlvbiAkKHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgcmV0dXJuIChwYXJlbnQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG59XG5mdW5jdGlvbiBfKHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgcmV0dXJuIChwYXJlbnQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG59XG5mdW5jdGlvbiBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICBpZiAoZWxlbWVudClcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKVxufVxuXG5cbmZ1bmN0aW9uIGVuYWJsZVRhYihlbCkge1xuICBlbC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gOSkgey8vIHRhYiB3YXMgcHJlc3NlZFxuXG4gICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb24vc2VsZWN0aW9uXG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZVxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydFxuICAgICAgdmFyIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kXG5cbiAgICAgIC8vIHNldCB0ZXh0YXJlYSB2YWx1ZSB0bzogdGV4dCBiZWZvcmUgY2FyZXQgKyAnICAnICsgdGV4dCBhZnRlciBjYXJldFxuICAgICAgdGhpcy52YWx1ZSA9IHZhbC5zdWJzdHJpbmcoMCwgc3RhcnQpICsgJyAgJyArIHZhbC5zdWJzdHJpbmcoZW5kKTtcblxuICAgICAgLy8gcHV0IGNhcmV0IGF0IHJpZ2h0IHBvc2l0aW9uIGFnYWluXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydCArIDI7XG5cbiAgICAgIC8vIHByZXZlbnQgdGhlIGZvY3VzIGxvc2VcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWxcbn1cbmZ1bmN0aW9uIG1ha2VFZGl0YWJsZShwcmUsIGxhbmd1YWdlLCBvblVwZGF0ZSkge1xuICBpZiAoIXByZSkgcmV0dXJuXG4gIHZhciBzcmMgPSBwcmUudGV4dENvbnRlbnRcbiAgdmFyIGVkaXRNb2RlID0gZmFsc2VcbiAgb24ocHJlLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlZGl0TW9kZSkge1xuICAgICAgZWRpdE1vZGUgPSB0cnVlXG4gICAgICBwcmUuaW5uZXJIVE1MID0gJydcbiAgICAgIHZhciB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICAgIGVuYWJsZVRhYih0ZXh0YXJlYSlcbiAgICAgIHRleHRhcmVhLnRleHRDb250ZW50ID0gc3JjXG4gICAgICBwcmUuYXBwZW5kQ2hpbGQodGV4dGFyZWEpXG4gICAgICB0ZXh0YXJlYS5mb2N1cygpXG4gICAgICBvbih0ZXh0YXJlYSwgJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVkaXRNb2RlID0gZmFsc2VcbiAgICAgICAgc3JjID0gdGV4dGFyZWEudmFsdWVcbiAgICAgICAgcHJlLmlubmVySFRNTCA9ICcnXG4gICAgICAgIHZhciBjb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29kZS5pbm5lckhUTUwgPSBoaWdobGlnaHRlcnNbbGFuZ3VhZ2VdKHNyYylcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gc3JjXG4gICAgICAgIH1cbiAgICAgICAgcHJlLmFwcGVuZENoaWxkKGNvZGUpXG4gICAgICAgIG9uVXBkYXRlKHNyYylcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuZnVuY3Rpb24gbWFrZUludGVyYWN0aXZlKGNvbnRyb2wpIHtcbiAgdmFyIGphZGUgPSBfKCdbZGF0YS1jb250cm9sPVwiaW5wdXQtamFkZVwiXScsIGNvbnRyb2wpXG4gIHZhciBqYWRlU1JDID0gamFkZS50ZXh0Q29udGVudFxuICB2YXIganMgPSBfKCdbZGF0YS1jb250cm9sPVwiaW5wdXQtanNcIl0nLCBjb250cm9sKVxuICB2YXIganNTUkMgPSBqcyA/IGpzLnRleHRDb250ZW50IDogJ3sgcGFnZVRpdGxlOiBcIkphZGVcIiwgeW91QXJlVXNpbmdKYWRlOiB0cnVlIH0nXG4gIG1ha2VFZGl0YWJsZShqYWRlLCAnamFkZScsIGZ1bmN0aW9uIChqYWRlKSB7XG4gICAgamFkZVNSQyA9IGphZGVcbiAgICB1cGRhdGUoY29udHJvbCwgamFkZVNSQywganNTUkMpXG4gIH0pXG4gIG1ha2VFZGl0YWJsZShqcywgJ2phdmFzY3JpcHQnLCBmdW5jdGlvbiAoanMpIHtcbiAgICBqc1NSQyA9IGpzXG4gICAgdXBkYXRlKGNvbnRyb2wsIGphZGVTUkMsIGpzU1JDKVxuICB9KVxuICBpZiAoXygnW2RhdGEtY29udHJvbD1cIm91dHB1dC1odG1sXCJdJywgY29udHJvbCkgJiYgXygnW2RhdGEtY29udHJvbD1cIm91dHB1dC1odG1sXCJdJywgY29udHJvbCkudGV4dENvbnRlbnQudHJpbSgpID09PSAnJylcbiAgICB1cGRhdGUoY29udHJvbCwgamFkZVNSQywganNTUkMpXG59XG5mdW5jdGlvbiB1cGRhdGUoY29udHJvbCwgamFkZVNSQywganMpIHtcbiAgdmFyIGpzT3V0ID0gXygnW2RhdGEtY29udHJvbD1cIm91dHB1dC1qc1wiXScsIGNvbnRyb2wpXG4gIHZhciBodG1sT3V0ID0gXygnW2RhdGEtY29udHJvbD1cIm91dHB1dC1odG1sXCJdJywgY29udHJvbClcbiAgdmFyIGpzT2JqQSA9IHt9XG4gIHZhciBqc09iakIgPSB7fVxuICB0cnkge1xuICAgIGpzT2JqQSA9IEZ1bmN0aW9uKCcnLCAncmV0dXJuICcgKyBqcykoKVxuICAgIGpzT2JqQiA9IEZ1bmN0aW9uKCcnLCAncmV0dXJuICcgKyBqcykoKVxuICB9IGNhdGNoIChleCkge1xuXG4gIH1cbiAgaWYgKGpzT3V0KSB7XG4gICAganNPYmpBLmNsaWVudCA9IHRydWVcbiAgICBpZiAoanNPYmpBLmNvbXBpbGVEZWJ1ZyA9PT0gdW5kZWZpbmVkKSBqc09iakEuY29tcGlsZURlYnVnID0gZmFsc2VcbiAgICB2YXIganNPdXRTcmMgPSBqYWRlLmNvbXBpbGUoamFkZVNSQywganNPYmpBKS50b1N0cmluZygpXG4gICAgdHJ5IHtcbiAgICAgIGpzT3V0U3JjID0gdWdsaWZ5Lm1pbmlmeShqc091dFNyYywge1xuICAgICAgICBmcm9tU3RyaW5nOiB0cnVlLFxuICAgICAgICBtYW5nbGU6IGZhbHNlLFxuICAgICAgICBvdXRwdXQ6IHtiZWF1dGlmeTogdHJ1ZX0sXG4gICAgICAgIGNvbXByZXNzOiBmYWxzZVxuICAgICAgfSkuY29kZVxuICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIGpzT3V0LmlubmVySFRNTCA9ICcnXG4gICAgdmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJylcbiAgICB0cnkge1xuICAgICAgY29kZS5pbm5lckhUTUwgPSBoaWdobGlnaHRlcnMuamF2YXNjcmlwdChqc091dFNyYylcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29kZS50ZXh0Q29udGVudCA9IGpzT3V0U3JjXG4gICAgfVxuICAgIGpzT3V0LmFwcGVuZENoaWxkKGNvZGUpXG4gIH1cbiAgaWYgKGh0bWxPdXQpIHtcbiAgICBpZiAoanNPYmpCLmNvbXBpbGVEZWJ1ZyA9PT0gdW5kZWZpbmVkKSBqc09iakIuY29tcGlsZURlYnVnID0gdHJ1ZVxuICAgIGlmIChqc09iakIucHJldHR5ID09PSB1bmRlZmluZWQpIGpzT2JqQi5wcmV0dHkgPSB0cnVlXG4gICAgdmFyIGh0bWxPdXRTcmMgPSBqYWRlLmNvbXBpbGUoamFkZVNSQywganNPYmpCKShqc09iakIpXG4gICAgaHRtbE91dC5pbm5lckhUTUwgPSAnJ1xuICAgIHZhciBjb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpXG4gICAgdHJ5IHtcbiAgICAgIGNvZGUuaW5uZXJIVE1MID0gaGlnaGxpZ2h0ZXJzLmh0bWwoaHRtbE91dFNyYylcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29kZS50ZXh0Q29udGVudCA9IGh0bWxPdXRTcmNcbiAgICB9XG4gICAgaHRtbE91dC5hcHBlbmRDaGlsZChjb2RlKVxuICB9XG59XG52YXIgaW50ZXJhY3RpdmVzID0gJCgnW2RhdGEtY29udHJvbD1cImludGVyYWN0aXZlXCJdJylcbmZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJhY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gIG1ha2VJbnRlcmFjdGl2ZShpbnRlcmFjdGl2ZXNbaV0pXG59IiwidmFyIExleGVyID0gcmVxdWlyZSgnamFkZS9saWIvbGV4ZXInKTtcbnZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJyk7XG4gXG5mdW5jdGlvbiBoaWdobGlnaHRKYXZhU2NyaXB0KGpzKSB7XG4gIHJldHVybiBobGpzLmhpZ2hsaWdodCgnamF2YXNjcmlwdCcsIGpzKS52YWx1ZTtcbn1cbiBcbmZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufVxuIFxubW9kdWxlLmV4cG9ydHMgPSBoaWdobGlnaHRKYWRlO1xuZnVuY3Rpb24gaGlnaGxpZ2h0SmFkZShqYWRlKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihqYWRlKTtcbiBcbiAgdmFyIGZvcm1hdCA9ICcnXG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgdmFyIHRvayA9IHt9O1xuICB2YXIgYnVmID0gW107XG4gIHZhciB0ZXh0TW9kZSA9IGZhbHNlO1xuICB2YXIgdGV4dEluZGVudCA9IDA7XG4gIHZhciB0ZXh0QnVmID0gJyc7XG4gIGZ1bmN0aW9uIGVudGVyVGV4dE1vZGUoKSB7XG4gICAgdGV4dE1vZGUgPSB0cnVlO1xuICAgIHRleHRJbmRlbnQgPSAwO1xuICAgIHRleHRCdWYgPSAnJztcbiAgfVxuICBmdW5jdGlvbiBleGl0VGV4dE1vZGUoKSB7XG4gICAgaWYgKHRleHRNb2RlKSB7XG4gICAgICB0ZXh0TW9kZSA9IGZhbHNlO1xuICAgICAgdGV4dEluZGVudCA9IDA7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnamF2YXNjcmlwdCcpIHtcbiAgICAgICAgYnVmLnB1c2goaGlnaGxpZ2h0SmF2YVNjcmlwdCh0ZXh0QnVmKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5wdXNoKGVzY2FwZSh0ZXh0QnVmKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdoaWxlICh0b2sudHlwZSAhPT0gJ2VvcycpIHtcbiAgICBsYXN0ID0gdG9rO1xuICAgIHZhciBiZWZvcmUgPSBsZXhlci5pbnB1dDtcbiAgICB0b2sgPSBsZXhlci5uZXh0KCk7XG4gICAgdmFyIGFmdGVyID0gbGV4ZXIuaW5wdXQ7XG4gICAgdmFyIHNyYyA9IGJlZm9yZS5zdWJzdHIoMCwgYmVmb3JlLmxlbmd0aCAtIGFmdGVyLmxlbmd0aCk7XG4gICAgaWYgKHRleHRNb2RlKSB7XG4gICAgICB0ZXh0QnVmICs9IGVzY2FwZShzcmMpO1xuICAgICAgaWYgKHRvay50eXBlID09PSAnaW5kZW50JykgdGV4dEluZGVudCsrO1xuICAgICAgaWYgKHRvay50eXBlID09PSAnb3V0ZGVudCcpIHRleHRJbmRlbnQtLTtcbiAgICAgIGlmICh0ZXh0SW5kZW50IDw9IDApIGV4aXRUZXh0TW9kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgIHN3aXRjaCAodG9rLnZhbCkge1xuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBmb3JtYXQgPSAnamF2YXNjcmlwdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICBmb3JtYXQgPSAnY3NzJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBmb3JtYXQgPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRvay50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIGlmICh0b2sudmFsID09PSAnLicpIHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGVzY2FwZShzcmMpKTtcbiAgICAgICAgICAgIGVudGVyVGV4dE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmLnB1c2goZXNjYXBlKHNyYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgYnVmLnB1c2goZXNjYXBlKHNyYykpO1xuICAgICAgICAgIGlmICh0ZXh0SW5kZW50IDw9IDApIGV4aXRUZXh0TW9kZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvdXRkZW50JzpcbiAgICAgICAgICBidWYucHVzaChlc2NhcGUoc3JjKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luZGVudCc6XG4gICAgICAgICAgYnVmLnB1c2goZXNjYXBlKHNyYykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgIGJ1Zi5wdXNoKCc8c3BhbiBjbGFzcz1cImtleXdvcmRcIj4nICsgZXNjYXBlKHNyYykgKyAnPC9zcGFuPicpO1xuICAgICAgICAgIGVudGVyVGV4dE1vZGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgYnVmLnB1c2goaGlnaGxpZ2h0SmF2YVNjcmlwdChzcmMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXR0cnMnOlxuICAgICAgICAgIGJ1Zi5wdXNoKGhpZ2hsaWdodEphdmFTY3JpcHQoc3JjKS5yZXBsYWNlKC8oPHNwYW5bXjxdKzxcXC8pfCheXFwoW149XSs9KXwoLFtePV0rPSkvZywgZnVuY3Rpb24gKF8sIHNwYW4sIGJlZ2luLCBtaWQpIHtcbiAgICAgICAgICAgIGlmIChzcGFuKSByZXR1cm4gXztcbiAgICAgICAgICAgIGlmIChiZWdpbikge1xuICAgICAgICAgICAgICByZXR1cm4gJyg8c3BhbiBjbGFzcz1cImF0dHJpYnV0ZVwiPicgKyBiZWdpbi5zdWJzdHIoMSwgYmVnaW4ubGVuZ3RoIC0gMikgKyAnPC9zcGFuPj0nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnLDxzcGFuIGNsYXNzPVwiYXR0cmlidXRlXCI+JyArIG1pZC5zdWJzdHIoMSwgbWlkLmxlbmd0aCAtIDIpICsgJzwvc3Bhbj49J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5jbHVkZSc6XG4gICAgICAgICAgYnVmLnB1c2goJzxzcGFuIGNsYXNzPVwia2V5d29yZFwiPmluY2x1ZGU8L3NwYW4+IDxzcGFuIGNsYXNzPVwic3RyaW5nXCI+JyArIGVzY2FwZShzcmMucmVwbGFjZSgvXmluY2x1ZGUgLywgJycpKSArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICAgIGJ1Zi5wdXNoKCc8c3BhbiBjbGFzcz1cImtleXdvcmRcIj5leHRlbmRzPC9zcGFuPiA8c3BhbiBjbGFzcz1cInN0cmluZ1wiPicgKyBlc2NhcGUoc3JjLnJlcGxhY2UoL15leHRlbmRzIC8sICcnKSkgKyAnPC9zcGFuPicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgYnVmLnB1c2goJzxzcGFuIGNsYXNzPVwia2V5d29yZFwiPmJsb2NrPC9zcGFuPicgKyBlc2NhcGUoc3JjLnJlcGxhY2UoL15ibG9jay8sICcnKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaXhpbic6XG4gICAgICAgICAgYnVmLnB1c2goJzxzcGFuIGNsYXNzPVwia2V5d29yZFwiPm1peGluPC9zcGFuPicgKyBoaWdobGlnaHRKYXZhU2NyaXB0KHNyYy5yZXBsYWNlKC9ebWl4aW4vLCAnJykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2FsbCc6XG4gICAgICAgICAgYnVmLnB1c2goJzxzcGFuIGNsYXNzPVwia2V5d29yZFwiPis8L3NwYW4+JyArIGhpZ2hsaWdodEphdmFTY3JpcHQoc3JjLnJlcGxhY2UoL15cXCsvLCAnJykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICAgIGJ1Zi5wdXNoKCc8c3BhbiBjbGFzcz1cImtleXdvcmRcIj4nICsgZXNjYXBlKHNyYykgKyAnPC9zcGFuPicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlb3MnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJ1Zi5wdXNoKCc8c3BhbiBjbGFzcz1cIicgKyB0b2sudHlwZSArICdcIj4nICsgZXNjYXBlKHNyYykgKyAnPC9zcGFuPicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmLmpvaW4oJycpO1xufTsiXX0=
;